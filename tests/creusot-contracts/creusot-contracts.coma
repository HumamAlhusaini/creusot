module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl [#"../../creusot-contracts/src/std/array.rs" 75 4 75 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 74 14 74 45
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 72 4 72 10
  let%span sarray2 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  use creusot.int.UInt64
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray2] view'0 self = Seq.(++) visited (view'0 o)
  
  use seq.Seq
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/array.rs" 75 4 75 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#sarray0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans [#"../../creusot-contracts/src/std/array.rs" 82 4 82 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 79 15 79 32
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 80 15 80 32
  let%span sarray2 = "../../creusot-contracts/src/std/array.rs" 81 14 81 42
  let%span sarray3 = "../../creusot-contracts/src/std/array.rs" 77 4 77 10
  let%span sarray4 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  use creusot.int.UInt64
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray4] view'0 self = Seq.(++) visited (view'0 o)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/array.rs" 82 4 82 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sarray1] produces'0 b bc c)
   -> ([%#sarray0] produces'0 a ab b)  -> ([%#sarray2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 78 14 78 45
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 76 4 76 10
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap3] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap5] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_IntoIter'0)
  
   =
    [%#shash_map2] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26] (self : t_IntoIter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_map0] produces'0 self (Seq.empty : Seq.seq (t_K'0, t_V'0)) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 83 15 83 32
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 84 15 84 32
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 85 14 85 42
  let%span shash_map3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 87 24 87 102
  let%span shash_map4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 87 8 87 104
  let%span shash_map5 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap6] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq7] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap10] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap9] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_IntoIter'0)
  
   =
    [%#shash_map5] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq (t_K'0, t_V'0)
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq (t_K'0, t_V'0)
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90] (a : t_IntoIter'0) (ab : Seq.seq (t_K'0, t_V'0)) (b : t_IntoIter'0) (bc : Seq.seq (t_K'0, t_V'0)) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_map1] produces'0 b bc c)
   -> ([%#shash_map0] produces'0 a ab b)
   -> ([%#shash_map3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 130 14 130 45
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 128 4 128 10
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap3] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap7] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap5] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_Iter'0)
  
   =
    [%#shash_map2] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26] (self : t_Iter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_map0] produces'0 self (Seq.empty : Seq.seq (t_K'0, t_V'0)) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 135 15 135 32
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 136 15 136 32
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 137 14 137 42
  let%span shash_map3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 139 24 139 102
  let%span shash_map4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 139 8 139 104
  let%span shash_map5 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap6] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq7] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap11] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap10] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel9] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_Iter'0)
  
   =
    [%#shash_map5] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq (t_K'0, t_V'0)
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq (t_K'0, t_V'0)
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90] (a : t_Iter'0) (ab : Seq.seq (t_K'0, t_V'0)) (b : t_Iter'0) (bc : Seq.seq (t_K'0, t_V'0)) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_map1] produces'0 b bc c)
   -> ([%#shash_map0] produces'0 a ab b)
   -> ([%#shash_map3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 182 14 182 45
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 180 4 180 10
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  use creusot.prelude.MutBorrow
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap3] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (x : (t_K'0, MutBorrow.t t_V'0))
  
   =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap7] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap5] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (o : t_IterMut'0)
  
   =
    [%#shash_map2] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'1 (let (a, _) = Seq.get visited i1 in a) = deep_model'1 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26] (self : t_IterMut'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_map0] produces'0 self (Seq.empty : Seq.seq (t_K'0, MutBorrow.t t_V'0)) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 187 15 187 32
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 188 15 188 32
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 189 14 189 42
  let%span shash_map3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 191 24 191 102
  let%span shash_map4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 191 8 191 104
  let%span shash_map5 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  use creusot.prelude.MutBorrow
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap6] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (x : (t_K'0, MutBorrow.t t_V'0))
  
   =
    [%#sseq7] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap11] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap10] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel9] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (o : t_IterMut'0)
  
   =
    [%#shash_map5] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'1 (let (a, _) = Seq.get visited i1 in a) = deep_model'1 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (t_K'0, MutBorrow.t t_V'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (t_K'0, MutBorrow.t t_V'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90] (a : t_IterMut'0) (ab : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (b : t_IterMut'0) (bc : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (c : t_IterMut'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_map1] produces'0 b bc c)
   -> ([%#shash_map0] produces'0 a ab b)
   -> ([%#shash_map3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 80 0 86 1]
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 11 77 33
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 78 11 78 33
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 79 10 79 43
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 88 20 88 108
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 89 20 89 98
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 87 4 87 31
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sseq8 = "../../creusot-contracts/src/logic/seq.rs" 377 4 377 12
  let%span sseq9 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 80 4 80 12
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  type t_I'0
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 15 4 15 34] (self : t_I'0) : Fset.fset t_DeepModelTy'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset11] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq9] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_I'0) (visited : Seq.seq t_T'0) (end' : t_I'0)
  
   =
    [%#shash_set7] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'1 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains'1 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'0 visited x
     -> contains'1 (view'0 start) (deep_model'0 x) /\ not contains'1 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'1 (view'0 end') x
     -> contains'1 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  use seq.Seq
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (_1 : ()) : () =
    [%#sseq8] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq3] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function get'0 [#"../../creusot-contracts/src/logic/seq.rs" 82 4 84 17] (self : Seq.seq t_T'0) (ix : int) : t_Option'0
   =
    [%#sseq10] if 0 <= ix /\ ix < Seq.length self then C_Some'0 (Seq.get self ix) else C_None'0
  
  constant a  : t_I'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_I'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_I'0
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 80 0 86 1] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  goal vc_set_produces_trans'0 : ([%#shash_set1] set_produces'0 b bc c)
   -> ([%#shash_set0] set_produces'0 a ab b)
   -> ([%#sseq3] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'0 (Seq.(++) a b) x = contains'0 a x
  \/ contains'0 b x)
   -> (let _ = concat_contains'0 () in ([%#shash_set4] forall i : int, x : t_T'0 . Seq.length ab <= i
  /\ get'0 (Seq.(++) ab bc) i = C_Some'0 x  -> contains'0 bc x)
  && (let _ = () in let _ = () in ([%#shash_set5] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in let _ = () in [%#shash_set2] set_produces'0 a (Seq.(++) ab bc) c)))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 107 14 107 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 105 4 105 10
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 96 8 96 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 52 4 52 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 95 4 95 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  use seq.Seq
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 26] (self : t_IntoIter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 115 4 115 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 112 15 112 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 113 15 113 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 114 14 114 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 11 77 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 78 11 78 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 79 10 79 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 116 8 116 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 96 8 96 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 87 4 87 31
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 377 4 377 12
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 52 4 52 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq13] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set9] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 95 4 95 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  use seq.Seq
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (_1 : ()) : () =
    [%#sseq11] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq10] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 80 0 86 1] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_set8] let _ = concat_contains'0 () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq t_T'0, b : t_IntoIter'0, bc : Seq.seq t_T'0, c : t_IntoIter'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 115 4 115 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set1] produces'0 b bc c)
   -> ([%#shash_set0] produces'0 a ab b)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 146 14 146 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 144 4 144 10
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 135 8 135 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 126 4 126 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq6] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 134 4 134 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  use seq.Seq
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 26] (self : t_Iter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 154 4 154 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 151 15 151 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 152 15 152 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 153 14 153 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 11 77 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 78 11 78 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 79 10 79 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 155 8 155 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 135 8 135 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 87 4 87 31
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 377 4 377 12
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel13 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 126 4 126 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel13] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq14] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set9] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 134 4 134 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  use seq.Seq
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (_1 : ()) : () =
    [%#sseq11] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq10] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 80 0 86 1] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
   =
    [%#shash_set8] let _ = concat_contains'0 () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 154 4 154 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set1] produces'0 b bc c)
   -> ([%#shash_set0] produces'0 a ab b)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 222 4 222 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 221 14 221 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 219 4 219 10
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 210 8 210 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 201 4 201 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq6] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 209 4 209 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  use seq.Seq
  
  constant self  : t_Intersection'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 222 4 222 26] (self : t_Intersection'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 229 4 229 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 226 15 226 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 227 15 227 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 228 14 228 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 77 11 77 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 78 11 78 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 79 10 79 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 230 8 230 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 210 8 210 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 87 4 87 31
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 377 4 377 12
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel13 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 201 4 201 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel13] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq14] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set9] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 209 4 209 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  use seq.Seq
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (_1 : ()) : () =
    [%#sseq11] ()
  
  axiom concat_contains'0_spec : forall _1 : () . [%#sseq10] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 80 0 86 1] (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
   =
    [%#shash_set8] let _ = concat_contains'0 () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Intersection'0, ab : Seq.seq t_T'0, b : t_Intersection'0, bc : Seq.seq t_T'0, c : t_Intersection'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_Intersection'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Intersection'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Intersection'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 229 4 229 90] (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set1] produces'0 b bc c)
   -> ([%#shash_set0] produces'0 a ab b)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body [#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 18 29 18 32
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 17 26 17 75
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant5] inv'4 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant5] inv'0 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Self_'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  type t_Rhs'0
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant5] inv'5 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Rhs'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  type t_DeepModelTy'0
  
  function deep_model'4 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'4 self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'0 self
  
  function deep_model'5 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'5 self
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  let rec eq'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:eq 'self' type invariant] inv'2 self}
    {[@expl:eq 'other' type invariant] inv'3 other}
    any [ return' (result:bool)-> {[%#scmp3] result = (deep_model'2 self = deep_model'3 other)} (! return' {result}) ] 
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body'0[#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18] (self_:t_Self_'0) (rhs:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] [%#scmp1] inv'1 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {self_} {rhs} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : bool = Any.any_l () | & self_ : t_Self_'0 = self_ | & rhs : t_Rhs'0 = rhs | & _4 : bool = Any.any_l () ] 
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] [%#scmp2] result
      = (deep_model'0 self_ <> deep_model'1 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 39 29 39 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 38 48 38 52
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 36 29 36 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Rhs'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.Any
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0 } (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0 } (! bb4)
          | br1 -> {r0'0 = C_Equal'0 } (! bb2)
          | br2 -> {r0'0 = C_Greater'0 } (! bb2) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] [%#scmp4] result
      = lt_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 47 29 47 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 46 66 46 70
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 44 29 44 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Rhs'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.Any
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0 } (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0 } (! bb4)
          | br1 -> {r0'0 = C_Equal'0 } (! bb4)
          | br2 -> {r0'0 = C_Greater'0 } (! bb2) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] [%#scmp4] result
      = le_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 55 29 55 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 54 51 54 55
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 52 29 52 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Rhs'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.Any
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0 } (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0 } (! bb2)
          | br1 -> {r0'0 = C_Equal'0 } (! bb2)
          | br2 -> {r0'0 = C_Greater'0 } (! bb4) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] [%#scmp4] result
      = gt_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 63 29 63 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 62 69 62 73
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 60 29 60 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 59 26 59 77
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Rhs'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.Any
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0 } (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0 } (! bb2)
          | br1 -> {r0'0 = C_Equal'0 } (! bb4)
          | br2 -> {r0'0 = C_Greater'0 } (! bb4) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] [%#scmp4] result
      = ge_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_max_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 80 29 80 30
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 80 41 80 45
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'0 self
  
  let rec le'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:le 'self' type invariant] inv'1 self}
    {[@expl:le 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp5] result = le_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Self_'0)
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_max_body'0[#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18] (self_:t_Self_'0) (o:t_Self_'0) (return'  (ret:t_Self_'0))= {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] [%#scmp1] inv'0 o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = le'0 {self_} {o} (fun (_ret':bool) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 =  [ &_0 <- o ] s3 | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'0 o} s1 | s1 = -{resolve'0 o}- s2 | s2 =  [ &_0 <- self_ ] s3 | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_Self_'0 = Any.any_l () | & self_ : t_Self_'0 = self_ | & o : t_Self_'0 = o | & _8 : bool = Any.any_l () ]
    
    [ return' (result:t_Self_'0)-> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] [%#scmp3] ge_log'0 (deep_model'0 result) (deep_model'0 self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] [%#scmp4] ge_log'0 (deep_model'0 result) (deep_model'0 o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] [%#scmp0] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] [%#scmp0] le_log'0 (deep_model'0 self_) (deep_model'0 o)
       -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] [%#scmp0] lt_log'0 (deep_model'0 o) (deep_model'0 self_)
       -> result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_min_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 89 29 89 30
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 89 41 89 45
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant21 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant21] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord18] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord19] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord16] cmp_log'0 x y = C_Less'0)
   -> ([%#sord17] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord13] cmp_log'0 x y
  = o)  -> ([%#sord14] cmp_log'0 y z = o)  -> ([%#sord15] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord12] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel7] deep_model'0 self
  
  let rec lt'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:lt 'self' type invariant] inv'1 self}
    {[@expl:lt 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp6] result = lt_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Self_'0)
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_min_body'0[#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18] (self_:t_Self_'0) (o:t_Self_'0) (return'  (ret:t_Self_'0))= {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] [%#scmp1] inv'0 o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = lt'0 {self_} {o} (fun (_ret':bool) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'0 o} s1 | s1 = -{resolve'0 o}- s2 | s2 =  [ &_0 <- self_ ] s3 | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 =  [ &_0 <- o ] s3 | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_Self_'0 = Any.any_l () | & self_ : t_Self_'0 = self_ | & o : t_Self_'0 = o | & _8 : bool = Any.any_l () ]
    
    [ return' (result:t_Self_'0)-> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] [%#scmp3] le_log'0 (deep_model'0 result) (deep_model'0 self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] [%#scmp4] le_log'0 (deep_model'0 result) (deep_model'0 o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] [%#scmp0] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] [%#scmp0] lt_log'0 (deep_model'0 self_) (deep_model'0 o)
       -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] [%#scmp5] le_log'0 (deep_model'0 o) (deep_model'0 self_)
       -> result = o}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_clamp_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 102 31 102 34
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 102 42 102 45
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 93 27 93 63
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 102 56 102 60
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 94 26 94 65
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 95 26 95 65
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 97 16 101 43
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span scmp9 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span smodel10 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant24 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_Self_'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant24] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord23] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord21] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord22] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord19] cmp_log'0 x y = C_Less'0)
   -> ([%#sord20] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord16] cmp_log'0 x y
  = o)  -> ([%#sord17] cmp_log'0 y z = o)  -> ([%#sord18] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord15] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel10] deep_model'0 self
  
  let rec gt'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:gt 'self' type invariant] inv'1 self}
    {[@expl:gt 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp8] result = gt_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Self_'0)
  
  let rec lt'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:lt 'self' type invariant] inv'1 self}
    {[@expl:lt 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp9] result = lt_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_clamp_body'0[#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18] (self_:t_Self_'0) (min:t_Self_'0) (max:t_Self_'0) (return'  (ret:t_Self_'0))= {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] [%#scmp1] inv'0 min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] [%#scmp2] inv'0 max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] [%#scmp3] le_log'0 (deep_model'0 min) (deep_model'0 max)}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = gt'0 {self_} {max} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_9 = false} (! bb8) | br1 -> {_9} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'0 min} s1
      | s1 = -{resolve'0 min}- s2
      | s2 = {[@expl:type invariant] inv'0 self_} s3
      | s3 = -{resolve'0 self_}- s4
      | s4 =  [ &_0 <- max ] s5
      | s5 = bb13 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'0 max} s1
      | s1 = -{resolve'0 max}- s2
      | s2 = lt'0 {self_} {min} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s3)
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1
      | s1 = -{resolve'0 self_}- s2
      | s2 =  [ &_0 <- min ] s3
      | s3 = bb12 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'0 min} s1 | s1 = -{resolve'0 min}- s2 | s2 =  [ &_0 <- self_ ] s3 | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Self_'0 = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & min : t_Self_'0 = min
    | & max : t_Self_'0 = max
    | & _9 : bool = Any.any_l ()
    | & _12 : bool = Any.any_l () ]
    
    [ return' (result:t_Self_'0)-> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] [%#scmp4] inv'0 result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] [%#scmp5] ge_log'0 (deep_model'0 result) (deep_model'0 min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] [%#scmp6] le_log'0 (deep_model'0 result) (deep_model'0 max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] [%#scmp0] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] [%#scmp7] if gt_log'0 (deep_model'0 self_) (deep_model'0 max) then
        result = max
      else
        if lt_log'0 (deep_model'0 self_) (deep_model'0 min) then result = min else result = self_
      }
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_max_body [#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 112 22 112 24
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 112 29 112 31
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 112 39 112 40
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 107 22 107 60
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 108 22 108 60
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 109 22 109 50
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 110 22 110 73
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 111 22 111 72
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp9 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp10 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord23] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord21] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord22] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord19] cmp_log'0 x y = C_Less'0)
   -> ([%#sord20] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord16] cmp_log'0 x y
  = o)  -> ([%#sord17] cmp_log'0 y z = o)  -> ([%#sord18] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord15] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  let rec max'0 (self:t_T'0) (other:t_T'0) (return'  (ret:t_T'0))= {[@expl:max 'self' type invariant] inv'0 self}
    {[@expl:max 'other' type invariant] inv'0 other}
    any
    [ return' (result:t_T'0)-> {inv'0 result}
      {[%#scmp8] ge_log'0 (deep_model'0 result) (deep_model'0 self)}
      {[%#scmp9] ge_log'0 (deep_model'0 result) (deep_model'0 other)}
      {[%#scmp10] result = self \/ result = other}
      {[%#scmp10] le_log'0 (deep_model'0 self) (deep_model'0 other)  -> result = other}
      {[%#scmp10] lt_log'0 (deep_model'0 other) (deep_model'0 self)  -> result = self}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_max_body'0[#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66] (v1:t_T'0) (v2:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] [%#scmp0] inv'0 v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] [%#scmp1] inv'0 v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = max'0 {v1} {v2} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_T'0 = Any.any_l () | & v1 : t_T'0 = v1 | & v2 : t_T'0 = v2 ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_cmp_max_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] [%#scmp3] ge_log'0 (deep_model'0 result) (deep_model'0 v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] [%#scmp4] ge_log'0 (deep_model'0 result) (deep_model'0 v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] [%#scmp5] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] [%#scmp6] le_log'0 (deep_model'0 v1) (deep_model'0 v2)
       -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] [%#scmp7] lt_log'0 (deep_model'0 v2) (deep_model'0 v1)
       -> result = v1}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_min_body [#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 123 22 123 24
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 123 29 123 31
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 123 39 123 40
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 118 22 118 60
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 119 22 119 60
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 120 22 120 50
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 121 22 121 72
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 122 22 122 73
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp9 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp10 = "../../creusot-contracts/src/std/cmp.rs" 7 0 130 1
  let%span scmp11 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord24] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord22] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord23] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord20] cmp_log'0 x y = C_Less'0)
   -> ([%#sord21] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord17] cmp_log'0 x y
  = o)  -> ([%#sord18] cmp_log'0 y z = o)  -> ([%#sord19] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord16] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord15] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  let rec min'0 (self:t_T'0) (other:t_T'0) (return'  (ret:t_T'0))= {[@expl:min 'self' type invariant] inv'0 self}
    {[@expl:min 'other' type invariant] inv'0 other}
    any
    [ return' (result:t_T'0)-> {inv'0 result}
      {[%#scmp8] le_log'0 (deep_model'0 result) (deep_model'0 self)}
      {[%#scmp9] le_log'0 (deep_model'0 result) (deep_model'0 other)}
      {[%#scmp10] result = self \/ result = other}
      {[%#scmp10] lt_log'0 (deep_model'0 self) (deep_model'0 other)  -> result = self}
      {[%#scmp11] le_log'0 (deep_model'0 other) (deep_model'0 self)  -> result = other}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_min_body'0[#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66] (v1:t_T'0) (v2:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] [%#scmp0] inv'0 v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] [%#scmp1] inv'0 v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = min'0 {v1} {v2} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_T'0 = Any.any_l () | & v1 : t_T'0 = v1 | & v2 : t_T'0 = v2 ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_cmp_min_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] [%#scmp3] le_log'0 (deep_model'0 result) (deep_model'0 v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] [%#scmp4] le_log'0 (deep_model'0 result) (deep_model'0 v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] [%#scmp5] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] [%#scmp6] lt_log'0 (deep_model'0 v1) (deep_model'0 v2)
       -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] [%#scmp7] le_log'0 (deep_model'0 v2) (deep_model'0 v1)
       -> result = v2}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 155 14 155 64
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 153 4 153 10
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_le_log'0 : [%#scmp0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 160 14 160 61
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 158 4 158 10
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_lt_log'0 : [%#scmp0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 165 14 165 61
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 163 4 163 10
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_ge_log'0 : [%#scmp0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 170 14 170 64
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 168 4 168 10
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_gt_log'0 : [%#scmp0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 175 14 175 45
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 173 4 173 10
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  function refl'0 [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (x : t_Reverse'0) : ()
  
  goal vc_refl'0 : [%#scmp0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 180 15 180 32
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 181 15 181 32
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 182 14 182 31
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 178 4 178 10
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp4] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  constant z  : t_Reverse'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (x : t_Reverse'0) (y : t_Reverse'0) (z : t_Reverse'0) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#scmp1] cmp_log'0 y z = o)  -> ([%#scmp0] cmp_log'0 x y = o)  -> ([%#scmp2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 187 15 187 45
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 188 14 188 47
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 185 4 185 10
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function antisym1'0 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_antisym1'0 : ([%#scmp0] cmp_log'0 x y = C_Less'0)  -> ([%#scmp1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 193 15 193 48
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 194 14 194 44
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 191 4 191 10
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function antisym2'0 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_antisym2'0 : ([%#scmp0] cmp_log'0 x y = C_Greater'0)  -> ([%#scmp1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 199 14 199 59
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 197 4 197 10
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_eq_cmp'0 : [%#scmp0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl [#"../../creusot-contracts/src/std/deque.rs" 185 4 185 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 184 14 184 45
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 182 4 182 10
  let%span sdeque2 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice3] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  use seq.Seq
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/deque.rs" 185 4 185 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#sdeque0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans [#"../../creusot-contracts/src/std/deque.rs" 192 4 192 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 189 15 189 32
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 190 15 190 32
  let%span sdeque2 = "../../creusot-contracts/src/std/deque.rs" 191 14 191 42
  let%span sdeque3 = "../../creusot-contracts/src/std/deque.rs" 187 4 187 10
  let%span sdeque4 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex8 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice10 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice9] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice10] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel7] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex8] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice5] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque4] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/deque.rs" 192 4 192 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sdeque1] produces'0 b bc c)
   -> ([%#sdeque0] produces'0 a ab b)  -> ([%#sdeque2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl [#"../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 57 14 57 45
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 55 4 55 10
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned3 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned3] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned2] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant self  : t_Cloned'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26] (self : t_Cloned'0) : ()
  
  goal vc_produces_refl'0 : [%#scloned0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 62 15 62 32
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 63 15 63 32
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 64 14 64 42
  let%span scloned3 = "../../creusot-contracts/src/std/iter/cloned.rs" 60 4 60 10
  let%span scloned4 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned5 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter7] produces'1 a ab b)
   -> ([%#siter8] produces'1 b bc c)  -> ([%#siter9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter6] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned5] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned4] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant a  : t_Cloned'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Cloned'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Cloned'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90] (a : t_Cloned'0) (ab : Seq.seq t_T'0) (b : t_Cloned'0) (bc : Seq.seq t_T'0) (c : t_Cloned'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#scloned1] produces'0 b bc c)
   -> ([%#scloned0] produces'0 a ab b)  -> ([%#scloned2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl [#"../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 55 4 55 10
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied3 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied3] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied2] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant self  : t_Copied'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26] (self : t_Copied'0) : ()
  
  goal vc_produces_refl'0 : [%#scopied0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span scopied3 = "../../creusot-contracts/src/std/iter/copied.rs" 60 4 60 10
  let%span scopied4 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied5 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter7] produces'1 a ab b)
   -> ([%#siter8] produces'1 b bc c)  -> ([%#siter9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter6] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied5] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied4] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  constant a  : t_Copied'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Copied'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Copied'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (a : t_Copied'0) (ab : Seq.seq t_T'0) (b : t_Copied'0) (bc : Seq.seq t_T'0) (c : t_Copied'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#scopied1] produces'0 b bc c)
   -> ([%#scopied0] produces'0 a ab b)  -> ([%#scopied2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 18 14 18 45
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 16 4 16 10
  let%span sempty2 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  constant self  : t_Empty'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26] (self : t_Empty'0) : ()
  
  goal vc_produces_refl'0 : [%#sempty0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 23 15 23 32
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 24 15 24 32
  let%span sempty2 = "../../creusot-contracts/src/std/iter/empty.rs" 25 14 25 42
  let%span sempty3 = "../../creusot-contracts/src/std/iter/empty.rs" 21 4 21 10
  let%span sempty4 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  use seq.Seq
  
  constant a  : t_Empty'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Empty'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Empty'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90] (a : t_Empty'0) (ab : Seq.seq t_T'0) (b : t_Empty'0) (bc : Seq.seq t_T'0) (c : t_Empty'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sempty1] produces'0 b bc c)
   -> ([%#sempty0] produces'0 a ab b)  -> ([%#sempty2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 82 14 82 45
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 80 4 80 10
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate8 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.prelude.MutBorrow
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate8] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
  
   =
    [%#senumerate2] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  constant self  : t_Enumerate'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (self : t_Enumerate'0) : ()
  
  goal vc_produces_refl'0 : [%#senumerate0] produces'0 self (Seq.empty : Seq.seq (UInt64.t, t_Item'0)) self
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans [#"../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 32
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 88 15 88 32
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 89 14 89 42
  let%span senumerate3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 85 4 85 10
  let%span senumerate4 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate5 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate10 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter7] produces'1 a ab b)
   -> ([%#siter8] produces'1 b bc c)  -> ([%#siter9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter6] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.prelude.MutBorrow
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate5] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate10] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
  
   =
    [%#senumerate4] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  constant a  : t_Enumerate'0
  
  constant ab  : Seq.seq (UInt64.t, t_Item'0)
  
  constant b  : t_Enumerate'0
  
  constant bc  : Seq.seq (UInt64.t, t_Item'0)
  
  constant c  : t_Enumerate'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90] (a : t_Enumerate'0) (ab : Seq.seq (UInt64.t, t_Item'0)) (b : t_Enumerate'0) (bc : Seq.seq (UInt64.t, t_Item'0)) (c : t_Enumerate'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#senumerate1] produces'0 b bc c)
   -> ([%#senumerate0] produces'0 a ab b)  -> ([%#senumerate2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl [#"../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 104 14 104 45
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 102 4 102 10
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter5 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops12] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops9] unnest'0 self b)
   -> ([%#sops10] unnest'0 b c)  -> ([%#sops11] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops8] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops6] postcondition_mut'0 self args res_state res)
   -> ([%#sops7] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter3] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'1 (func'0 self)
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter13] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter5] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter2] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  constant self  : t_Filter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26] (self : t_Filter'0) : ()
  
  goal vc_produces_refl'0 : [%#sfilter0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans [#"../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 109 15 109 32
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 32
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 111 14 111 42
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 107 4 107 10
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter5 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter6 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter7 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter5] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter6] inv'0 self  -> inv'1 (func'0 self)
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter7] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter4] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  constant a  : t_Filter'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Filter'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Filter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90] (a : t_Filter'0) (ab : Seq.seq t_Item'0) (b : t_Filter'0) (bc : Seq.seq t_Item'0) (c : t_Filter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sfilter1] produces'0 b bc c)
   -> ([%#sfilter0] produces'0 a ab b)  -> ([%#sfilter2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl [#"../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 104 14 104 45
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 102 4 102 10
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops15 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter19 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map6] forall i : t_Item'0 . precondition'0 f (i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops15] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops12] unnest'0 self b)
   -> ([%#sops13] unnest'0 b c)  -> ([%#sops14] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops11] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops9] postcondition_mut'0 self args res_state res)
   -> ([%#sops10] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map7] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map8] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 (i) f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 (i) f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map4] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map3] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter17] produces'1 a ab b)
   -> ([%#siter18] produces'1 b bc c)  -> ([%#siter19] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter16] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map5] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map2] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  use seq.Seq
  
  constant self  : t_FilterMap'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26] (self : t_FilterMap'0) : ()
  
  
  goal vc_produces_refl'0 : [%#sfilter_map0] produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans [#"../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 15 109 32
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 110 15 110 32
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 111 14 111 42
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 107 4 107 10
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map9 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map10 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops15 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops16 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops17 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter19 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter20 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter21 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map8] forall i : t_Item'0 . precondition'0 f (i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops17] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops14] unnest'0 self b)
   -> ([%#sops15] unnest'0 b c)  -> ([%#sops16] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops13] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops11] postcondition_mut'0 self args res_state res)
   -> ([%#sops12] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map9] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map10] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 (i) f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 (i) f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map6] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map5] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter19] produces'1 a ab b)
   -> ([%#siter20] produces'1 b bc c)  -> ([%#siter21] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter18] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map7] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map4] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  use seq.Seq
  
  constant a  : t_FilterMap'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_FilterMap'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_FilterMap'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90] (a : t_FilterMap'0) (ab : Seq.seq t_B'0) (b : t_FilterMap'0) (bc : Seq.seq t_B'0) (c : t_FilterMap'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sfilter_map1] produces'0 b bc c)
   -> ([%#sfilter_map0] produces'0 a ab b)  -> ([%#sfilter_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 39 4 39 10
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse3] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse4] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse2] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  constant self  : t_Fuse'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse'0) : ()
  
  goal vc_produces_refl'0 : [%#sfuse0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 44 4 44 10
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse5 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse6 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse5] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse6] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse4] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  constant a  : t_Fuse'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Fuse'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Fuse'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sfuse1] produces'0 b bc c)
   -> ([%#sfuse0] produces'0 a ab b)  -> ([%#sfuse2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 63 15 63 31
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 64 15 64 44
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 65 14 65 50
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 61 4 61 10
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse5 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse6 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse7 = "../../creusot-contracts/src/std/iter/fuse.rs" 39 4 39 10
  let%span sfuse8 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse9 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse10 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse11 = "../../creusot-contracts/src/std/iter/fuse.rs" 44 4 44 10
  let%span smodel12 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfuse13 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse14 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'1 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'1_spec : forall self : t_Fuse'0 . ([%#sfuse13] inv'0 self  -> inv'1 (view'1 self))
  && ([%#sfuse14] forall other : t_Fuse'0 . view'1 self = view'1 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse5] match view'1 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'1 other = view'1 self
      | C_Some'0 i -> match view'1 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
  
   =
    [%#sfuse11] ()
  
  axiom produces_trans'0_spec : forall a : t_Fuse'0, ab : Seq.seq t_Item'0, b : t_Fuse'0, bc : Seq.seq t_Item'0, c : t_Fuse'0 . ([%#sfuse8] produces'0 a ab b)
   -> ([%#sfuse9] produces'0 b bc c)  -> ([%#sfuse10] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse'0) : () =
    [%#sfuse7] ()
  
  axiom produces_refl'0_spec : forall self : t_Fuse'0 . [%#sfuse6] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  use creusot.prelude.MutBorrow
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t t_Fuse'0) : t_Option'0 =
    [%#smodel12] view'1 self.current
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : MutBorrow.t t_Fuse'0) =
    [%#sfuse4] (view'0 self = C_None'0
    \/ (exists it : MutBorrow.t t_I'0 . completed'1 it /\ view'0 self = C_Some'0 (it.current)))
    /\ view'1 self.final = C_None'0
  
  constant self  : MutBorrow.t t_Fuse'0
  
  constant steps  : Seq.seq t_Item'0
  
  constant next  : t_Fuse'0
  
  function is_fused'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (self : MutBorrow.t t_Fuse'0) (steps : Seq.seq t_Item'0) (next : t_Fuse'0) : ()
  
  
  goal vc_is_fused'0 : ([%#sfuse1] produces'0 self.final steps next)
   -> ([%#sfuse0] completed'0 self)  -> ([%#sfuse2] steps = (Seq.empty : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_refl [#"../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 80 14 80 45
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 78 4 78 10
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap4 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'1 (func'0 self)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap4] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap2] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  constant self  : t_Map'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26] (self : t_Map'0) : ()
  
  goal vc_produces_refl'0 : [%#smap0] produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_trans [#"../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 85 15 85 32
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 86 15 86 32
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 87 14 87 42
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 83 4 83 10
  let%span smap4 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap5 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap6 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap5] inv'0 self  -> inv'1 (func'0 self)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter14] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap6] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap4] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  constant a  : t_Map'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_Map'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_Map'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90] (a : t_Map'0) (ab : Seq.seq t_B'0) (b : t_Map'0) (bc : Seq.seq t_B'0) (c : t_Map'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#smap1] produces'0 b bc c)
   -> ([%#smap0] produces'0 a ab b)  -> ([%#smap2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  use seq.Seq
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops9] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops6] unnest'0 self b)
   -> ([%#sops7] unnest'0 b c)  -> ([%#sops8] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops5] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops3] postcondition_mut'0 self args res_state res)
   -> ([%#sops4] unnest'0 self res_state)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter10] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv2] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  constant self  : t_MapInv'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : ()
  
  goal vc_produces_refl'0 : [%#smap_inv0] produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 4 26 10
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  use seq.Seq
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv4] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  constant a  : t_MapInv'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_MapInv'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_MapInv'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#smap_inv1] produces'0 b bc c)
   -> ([%#smap_inv0] produces'0 a ab b)  -> ([%#smap_inv2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 62 15 62 39
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 63 14 63 31
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 60 4 60 23
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  
  type t_I'0
  
  type t_F'0
  
  type t_B'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_B'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Seq.seq t_B'0) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_MapInv'0) =
    match _1 with
      | {t_MapInv__iter'0 = x0 ; t_MapInv__func'0 = x1 ; t_MapInv__produced'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self : t_MapInv'0) =
    [%#smap_inv3] resolve'3 self.t_MapInv__iter'0 /\ resolve'2 self.t_MapInv__func'0
  
  constant self  : t_MapInv'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31] (self : t_MapInv'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#smap_inv0] structural_resolve'0 self)  -> ([%#smap_inv1] resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next [#"../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 91 39 91 58
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 94 16 94 76
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 95 31 95 71
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 99 38 99 88
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 100 32 100 63
  let%span smap_inv5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 105 32 105 56
  let%span smap_inv6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 17 90 21
  let%span smap_inv7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 26 90 44
  let%span smap_inv8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 86 14 89 5
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 169 27 169 52
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 170 26 170 71
  let%span smap_inv12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 163 15 163 31
  let%span smap_inv13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 164 4 164 60
  let%span smap_inv14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 165 15 165 30
  let%span smap_inv15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 166 15 166 64
  let%span smap_inv16 = "../../creusot-contracts/src/std/iter/map_inv.rs" 167 14 167 74
  let%span smap_inv17 = "../../creusot-contracts/src/std/iter/map_inv.rs" 168 14 168 75
  let%span smap_inv18 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 68
  let%span smap_inv19 = "../../creusot-contracts/src/std/iter/map_inv.rs" 182 12 187 74
  let%span smap_inv20 = "../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv21 = "../../creusot-contracts/src/std/iter/map_inv.rs" 74 12 76 73
  let%span smap_inv22 = "../../creusot-contracts/src/std/iter/map_inv.rs" 124 14 124 81
  let%span smap_inv23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 127 12 132 88
  let%span smap_inv24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 117 12 119 63
  let%span smap_inv25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sresolve26 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smap_inv27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv29 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv30 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv31 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv32 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 4 26 10
  let%span siter33 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter34 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter35 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter36 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops37 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops38 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops39 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops40 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops41 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops42 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops43 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span smap_inv44 = "../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 156 47
  let%span smap_inv45 = "../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  let%span sinvariant46 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_I'0) =
    [%#sinvariant46] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_I'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_I'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate inv'9 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Item'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'5 x] . inv'5 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'9 a_0
    end
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter34] produces'0 a ab b)
   -> ([%#siter35] produces'0 b bc c)  -> ([%#siter36] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter33] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  use seq.Seq
  
  let rec next'1 (self:MutBorrow.t t_I'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'0)-> {inv'5 result}
      {[%#siter9] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Item'0))= any
    [ good (field_0:t_Item'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  use seq.Seq
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_F'0) =
    [%#sinvariant46] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_F'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : (t_Item'0, Seq.seq t_Item'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : (t_Item'0, Seq.seq t_Item'0) [inv'7 x] . inv'7 x
  = (let (x0, x1) = x in inv'9 x0)
  
  type t_B'0
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops43] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'2 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops40] unnest'0 self b)
   -> ([%#sops41] unnest'0 b c)  -> ([%#sops42] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops39] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops37] postcondition_mut'0 self args res_state res)
   -> ([%#sops38] unnest'0 self res_state)
  
  let rec call_mut'0 (self:MutBorrow.t t_F'0) (args:(t_Item'0, Seq.seq t_Item'0)) (return'  (ret:t_B'0))= {[@expl:call_mut 'self' type invariant] inv'6 self}
    {[@expl:call_mut 'args' type invariant] inv'7 args}
    {[@expl:call_mut requires] [%#sops10] precondition'0 self.current args}
    any
    [ return' (result:t_B'0)-> {inv'8 result}
      {[%#sops11] postcondition_mut'0 self.current args self.final result}
      (! return' {result}) ]
  
  
  predicate next_precondition'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 115 4 115 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv24] forall e : t_Item'0, i : t_I'0 . produces'0 iter (Seq.singleton e) i
     -> precondition'0 func (e, produced)
  
  predicate preservation'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 49] (iter : t_I'0) (func : t_F'0)
  
   =
    [%#smap_inv45] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, s)
     -> postcondition_mut'0 f.current (e1, s) f.final b  -> precondition'0 f.final (e2, Seq.snoc s e1)
  
  predicate reinitialize'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 33] (_1 : ()) =
    [%#smap_inv44] forall iter : MutBorrow.t t_I'0, func : t_F'0 . completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  predicate preservation_inv'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv23] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Seq.(++) produced s)
     -> postcondition_mut'0 f.current (e1, Seq.(++) produced s) f.final b
     -> precondition'0 f.final (e2, Seq.snoc (Seq.(++) produced s) e1)
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv22] produced
  = (Seq.empty : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 72 4 72 30] (self : t_MapInv'0) =
    [%#smap_inv21] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
  
  function produces_one_invariant'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 169 4 169 73] (self : t_MapInv'0) (e : t_Item'0) (r : t_B'0) (f : MutBorrow.t t_F'0) (iter : t_I'0) : ()
  
  
  axiom produces_one_invariant'0_spec : forall self : t_MapInv'0, e : t_Item'0, r : t_B'0, f : MutBorrow.t t_F'0, iter : t_I'0 . ([%#smap_inv12] invariant'0 self)
   -> ([%#smap_inv13] produces'0 self.t_MapInv__iter'0 (Seq.singleton e) iter)
   -> ([%#smap_inv14] f.current = self.t_MapInv__func'0)
   -> ([%#smap_inv15] postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final r)
   -> ([%#smap_inv16] preservation_inv'0 iter f.final (Seq.snoc self.t_MapInv__produced'0 e))
  && ([%#smap_inv17] next_precondition'0 iter f.final (Seq.snoc self.t_MapInv__produced'0 e))
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv25] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'0 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
   =
    [%#smap_inv32] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv29] produces'1 a ab b)
   -> ([%#smap_inv30] produces'1 b bc c)  -> ([%#smap_inv31] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : () =
    [%#smap_inv28] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . [%#smap_inv27] produces'1 self (Seq.empty : Seq.seq t_B'0) self
  
  use seq.Seq
  
  predicate produces_one'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv19] exists f : MutBorrow.t t_F'0, e : t_Item'0 . f.current = self.t_MapInv__func'0
    /\ f.final = succ.t_MapInv__func'0
    /\ produces'0 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.snoc self.t_MapInv__produced'0 e
    /\ precondition'0 f.current (e, self.t_MapInv__produced'0)
    /\ postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final visited
  
  axiom produces_one'0_spec : forall self : t_MapInv'0, visited : t_B'0, succ : t_MapInv'0 . [%#smap_inv18] produces_one'0 self visited succ
  = produces'1 self (Seq.singleton visited) succ
  
  predicate inv'10 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_MapInv'0 [inv'10 x] . inv'10 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'0 iter /\ inv'1 func
    end)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_MapInv'0) =
    [%#sinvariant46] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_MapInv'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_MapInv'0) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_MapInv'0) =
    resolve'1 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_B'0
  
  use creusot.prelude.Any
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'8 a_0
    end
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : MutBorrow.t t_MapInv'0)
   =
    [%#smap_inv20] (self.final).t_MapInv__produced'0 = (Seq.empty : Seq.seq t_Item'0)
    /\ completed'1 (MutBorrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  meta "compute_max_steps" 1000000
  
  let rec next'0[#"../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44] (self:MutBorrow.t t_MapInv'0) (return'  (ret:t_Option'1))= {[@expl:next 'self' type invariant] [%#smap_inv6] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv0] self.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 (self.current).t_MapInv__iter'0}
        MutBorrow.borrow_final
          <t_I'0>
          {(self.current).t_MapInv__iter'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_I'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_MapInv__iter'0 = _ret'.final } } ] 
            s1)
      | s1 = next'1 {_6} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_5 = C_None'0 } (! bb5) | br1 (x0:t_Item'0)-> {_5 = C_Some'0 x0} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = v_Some'0 {_5} (fun (r0'0:t_Item'0) ->  [ &v <- r0'0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv1] precondition'0 (self.current).t_MapInv__func'0 (v, (self.current).t_MapInv__produced'0)}
        s2
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &produced <- [%#smap_inv2] Seq.snoc (self.current).t_MapInv__produced'0 v ] s1 | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = {inv'1 (self.current).t_MapInv__func'0}
        MutBorrow.borrow_final
          <t_F'0>
          {(self.current).t_MapInv__func'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_F'0) ->
             [ &_14 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { self.current with t_MapInv__func'0 = _ret'.final } } ] 
            s1)
      | s1 =  [ &_15 <- (v, (self.current).t_MapInv__produced'0) ] s2
      | s2 = call_mut'0 {_14} {_15} (fun (_ret':t_B'0) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_MapInv__produced'0 = produced } } ] s1
      | s1 =  [ &_19 <- [%#smap_inv3] let _ = () in () ] s2
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = {[@expl:assertion] [%#smap_inv4] produces_one'0 old_self r self.current} s1 | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'2 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- C_Some'1 r ] s3
      | s3 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb17
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv5] Seq.empty : Seq.seq t_Item'0 ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_MapInv__produced'0 = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'2 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- C_None'1 ] s4
      | s4 = bb17 ]
    
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : t_Option'1 = Any.any_l ()
    | & self : MutBorrow.t t_MapInv'0 = self
    | & old_self : t_MapInv'0 = Any.any_l ()
    | & _5 : t_Option'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_I'0 = Any.any_l ()
    | & v : t_Item'0 = Any.any_l ()
    | & produced : Seq.seq t_Item'0 = Any.any_l ()
    | & r : t_B'0 = Any.any_l ()
    | & _14 : MutBorrow.t t_F'0 = Any.any_l ()
    | & _15 : (t_Item'0, Seq.seq t_Item'0) = Any.any_l ()
    | & _19 : () = Any.any_l ()
    | & _24 : Seq.seq t_Item'0 = Any.any_l () ]
    
    [ return' (result:t_Option'1)-> {[@expl:next result type invariant] [%#smap_inv7] inv'3 result}
      {[@expl:next ensures] [%#smap_inv8] match result with
        | C_None'1 -> completed'0 self
        | C_Some'1 v -> produces_one'0 self.current v self.final
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 124 14 124 81
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 127 12 132 88
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  type t_I'0
  
  type t_F'0
  
  use creusot.prelude.MutBorrow
  
  type t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops9] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops6] unnest'0 self b)
   -> ([%#sops7] unnest'0 b c)  -> ([%#sops8] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops5] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops3] postcondition_mut'0 self args res_state res)
   -> ([%#sops4] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter11] produces'0 a ab b)
   -> ([%#siter12] produces'0 b bc c)  -> ([%#siter13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter10] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  predicate preservation'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 49] (iter : t_I'0) (func : t_F'0)
  
   =
    [%#smap_inv2] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, s)
     -> postcondition_mut'0 f.current (e1, s) f.final b  -> precondition'0 f.final (e2, Seq.snoc s e1)
  
  constant iter  : t_I'0
  
  constant func  : t_F'0
  
  constant produced  : Seq.seq t_Item'0
  
  predicate preservation_inv'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
  
  goal vc_preservation_inv'0 : [%#smap_inv0] produced = (Seq.empty : Seq.seq t_Item'0)
   -> ([%#smap_inv1] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
   -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> precondition'0 f.current (e1, Seq.(++) produced s)
   -> postcondition_mut'0 f.current (e1, Seq.(++) produced s) f.final b
   -> precondition'0 f.final (e2, Seq.snoc (Seq.(++) produced s) e1))
  = preservation'0 iter func
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 68
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 182 12 187 74
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 4 26 10
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops15 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops16 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops17 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops18 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops19 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  use seq.Seq
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops19] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops16] unnest'0 self b)
   -> ([%#sops17] unnest'0 b c)  -> ([%#sops18] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops15] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops13] postcondition_mut'0 self args res_state res)
   -> ([%#sops14] unnest'0 self res_state)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter9] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv2] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
   =
    [%#smap_inv8] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv5] produces'0 a ab b)
   -> ([%#smap_inv6] produces'0 b bc c)  -> ([%#smap_inv7] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : () =
    [%#smap_inv4] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . [%#smap_inv3] produces'0 self (Seq.empty : Seq.seq t_B'0) self
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  constant self  : t_MapInv'0
  
  constant visited  : t_B'0
  
  constant succ  : t_MapInv'0
  
  predicate produces_one'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
  
  
  goal vc_produces_one'0 : [%#smap_inv0] ([%#smap_inv1] exists f : MutBorrow.t t_F'0, e : t_Item'0 . f.current
  = self.t_MapInv__func'0
  /\ f.final = succ.t_MapInv__func'0
  /\ produces'1 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
  /\ succ.t_MapInv__produced'0 = Seq.snoc self.t_MapInv__produced'0 e
  /\ precondition'0 f.current (e, self.t_MapInv__produced'0)
  /\ postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final visited)
  = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 31 14 31 45
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 29 4 29 10
  let%span sonce2 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_Once'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26] (self : t_Once'0) : ()
  
  goal vc_produces_refl'0 : [%#sonce0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 36 15 36 32
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 37 15 37 32
  let%span sonce2 = "../../creusot-contracts/src/std/iter/once.rs" 38 14 38 42
  let%span sonce3 = "../../creusot-contracts/src/std/iter/once.rs" 34 4 34 10
  let%span sonce4 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_Once'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Once'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Once'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90] (a : t_Once'0) (ab : Seq.seq t_T'0) (b : t_Once'0) (bc : Seq.seq t_T'0) (c : t_Once'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sonce1] produces'0 b bc c)
   -> ([%#sonce0] produces'0 a ab b)  -> ([%#sonce2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 35 14 35 45
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 33 4 33 10
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange2] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  use seq.Seq
  
  constant self  : t_Range'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26] (self : t_Range'0) : ()
  
  goal vc_produces_refl'0 : [%#srange0] produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 40 15 40 32
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 41 15 41 32
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 42 14 42 42
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 38 4 38 10
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange4] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  use seq.Seq
  
  constant a  : t_Range'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_Range'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_Range'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90] (a : t_Range'0) (ab : Seq.seq t_Idx'0) (b : t_Range'0) (bc : Seq.seq t_Idx'0) (c : t_Range'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srange1] produces'0 b bc c)
   -> ([%#srange0] produces'0 a ab b)  -> ([%#srange2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 62 14 62 50
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 60 4 60 10
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange2] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  use seq.Seq
  
  constant self  : t_Range'0
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31] (self : t_Range'0) : ()
  
  goal vc_produces_back_refl'0 : [%#srange0] produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 67 15 67 37
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 68 15 68 37
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 69 14 69 47
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 65 4 65 10
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange4] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  use seq.Seq
  
  constant a  : t_Range'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_Range'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_Range'0
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95] (a : t_Range'0) (ab : Seq.seq t_Idx'0) (b : t_Range'0) (bc : Seq.seq t_Idx'0) (c : t_Range'0) : ()
  
  
  goal vc_produces_back_trans'0 : ([%#srange1] produces_back'0 b bc c)
   -> ([%#srange0] produces_back'0 a ab b)  -> ([%#srange2] produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92]
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span sops1 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  
  type t_Idx'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops1] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  constant r  : t_RangeInclusive'0
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
  
  goal vc_range_inclusive_len'0 : ([%#sops1] not is_empty_log'0 r
   -> deep_model'0 (start_log'0 r) <= deep_model'0 (end_log'0 r))
   -> (if is_empty_log'0 r then
    [%#srange0] is_empty_log'0 r = (0 = 0)
  else
    [%#srange0] is_empty_log'0 r = (deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 107 14 107 45
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 105 4 105 10
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops5] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange4] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange3] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange2] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  use seq.Seq
  
  constant self  : t_RangeInclusive'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26] (self : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_refl'0 : [%#srange0] produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 112 15 112 32
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 113 15 113 32
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 114 14 114 42
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 110 4 110 10
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange5 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange6 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops7] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange6] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange5] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange4] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  use seq.Seq
  
  constant a  : t_RangeInclusive'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_RangeInclusive'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_RangeInclusive'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90] (a : t_RangeInclusive'0) (ab : Seq.seq t_Idx'0) (b : t_RangeInclusive'0) (bc : Seq.seq t_Idx'0) (c : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srange1] produces'0 b bc c)
   -> ([%#srange0] produces'0 a ab b)  -> ([%#srange2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 134 14 134 50
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 132 4 132 10
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops5] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange4] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange3] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange2] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  use seq.Seq
  
  constant self  : t_RangeInclusive'0
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31] (self : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_back_refl'0 : [%#srange0] produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 139 15 139 37
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 140 15 140 37
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 141 14 141 47
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 137 4 137 10
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange5 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange6 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops7] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange6] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange5] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange4] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  use seq.Seq
  
  constant a  : t_RangeInclusive'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_RangeInclusive'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_RangeInclusive'0
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95] (a : t_RangeInclusive'0) (ab : Seq.seq t_Idx'0) (b : t_RangeInclusive'0) (bc : Seq.seq t_Idx'0) (c : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_back_trans'0 : ([%#srange1] produces_back'0 b bc c)
   -> ([%#srange0] produces_back'0 a ab b)  -> ([%#srange2] produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 31 14 31 45
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 29 4 29 10
  let%span srepeat2 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat2] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  constant self  : t_Repeat'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26] (self : t_Repeat'0) : ()
  
  goal vc_produces_refl'0 : [%#srepeat0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 36 15 36 32
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 37 15 37 32
  let%span srepeat2 = "../../creusot-contracts/src/std/iter/repeat.rs" 38 14 38 42
  let%span srepeat3 = "../../creusot-contracts/src/std/iter/repeat.rs" 34 4 34 10
  let%span srepeat4 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat4] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  constant a  : t_Repeat'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Repeat'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Repeat'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90] (a : t_Repeat'0) (ab : Seq.seq t_T'0) (b : t_Repeat'0) (bc : Seq.seq t_T'0) (c : t_Repeat'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srepeat1] produces'0 b bc c)
   -> ([%#srepeat0] produces'0 a ab b)  -> ([%#srepeat2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 47 14 47 45
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 45 4 45 10
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev3 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces_back'0 a ab b)
   -> ([%#siter6] produces_back'0 b bc c)  -> ([%#siter7] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter4] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev2] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  constant self  : t_Rev'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26] (self : t_Rev'0) : ()
  
  goal vc_produces_refl'0 : [%#srev0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 52 15 52 32
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 53 15 53 32
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 54 14 54 42
  let%span srev3 = "../../creusot-contracts/src/std/iter/rev.rs" 50 4 50 10
  let%span srev4 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev5 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter7] produces_back'0 a ab b)
   -> ([%#siter8] produces_back'0 b bc c)  -> ([%#siter9] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter6] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev5] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev4] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  constant a  : t_Rev'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Rev'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Rev'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90] (a : t_Rev'0) (ab : Seq.seq t_Item'0) (b : t_Rev'0) (bc : Seq.seq t_Item'0) (c : t_Rev'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srev1] produces'0 b bc c)
   -> ([%#srev0] produces'0 a ab b)  -> ([%#srev2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl [#"../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 73 14 73 45
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 71 4 71 10
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip4 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip3] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip4] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip2] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant self  : t_Skip'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26] (self : t_Skip'0) : ()
  
  goal vc_produces_refl'0 : [%#sskip0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 78 15 78 32
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 32
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 80 14 80 42
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 76 4 76 10
  let%span sskip4 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip5 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip6 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip5] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip6] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip4] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant a  : t_Skip'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Skip'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Skip'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (a : t_Skip'0) (ab : Seq.seq t_Item'0) (b : t_Skip'0) (bc : Seq.seq t_Item'0) (c : t_Skip'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sskip1] produces'0 b bc c)
   -> ([%#sskip0] produces'0 a ab b)  -> ([%#sskip2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl [#"../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 71 14 71 45
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 69 4 69 10
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake4 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake3] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake4] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake2] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant self  : t_Take'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26] (self : t_Take'0) : ()
  
  goal vc_produces_refl'0 : [%#stake0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 76 15 76 32
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 77 15 77 32
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 78 14 78 42
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 74 4 74 10
  let%span stake4 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake5 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake6 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake5] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake6] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake4] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant a  : t_Take'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Take'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Take'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (a : t_Take'0) (ab : Seq.seq t_Item'0) (b : t_Take'0) (bc : Seq.seq t_Item'0) (c : t_Take'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#stake1] produces'0 b bc c)
   -> ([%#stake0] produces'0 a ab b)  -> ([%#stake2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl [#"../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 55 14 55 45
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 53 4 53 10
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip4 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_A'0
  
  type t_B'0
  
  use creusot.int.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_A'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'1 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter6] produces'2 a ab b)
   -> ([%#siter7] produces'2 b bc c)  -> ([%#siter8] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_B'0 . [%#siter5] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip4] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
  
   =
    [%#szip2] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  constant self  : t_Zip'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26] (self : t_Zip'0) : ()
  
  goal vc_produces_refl'0 : [%#szip0] produces'0 self (Seq.empty : Seq.seq (t_Item'0, t_Item'1)) self
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans [#"../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 60 15 60 32
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 61 15 61 32
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 62 14 62 42
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 58 4 58 10
  let%span szip4 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip5 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip6 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_A'0
  
  type t_B'0
  
  use creusot.int.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_A'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip5] inv'0 self  -> inv'1 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'2 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'2_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter8] produces'2 a ab b)
   -> ([%#siter9] produces'2 b bc c)  -> ([%#siter10] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_B'0 . [%#siter7] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip6] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
  
   =
    [%#szip4] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  constant a  : t_Zip'0
  
  constant ab  : Seq.seq (t_Item'0, t_Item'1)
  
  constant b  : t_Zip'0
  
  constant bc  : Seq.seq (t_Item'0, t_Item'1)
  
  constant c  : t_Zip'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90] (a : t_Zip'0) (ab : Seq.seq (t_Item'0, t_Item'1)) (b : t_Zip'0) (bc : Seq.seq (t_Item'0, t_Item'1)) (c : t_Zip'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#szip1] produces'0 b bc c)
   -> ([%#szip0] produces'0 a ab b)  -> ([%#szip2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl [#"../../creusot-contracts/src/std/iter.rs" 263 4 263 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 262 14 262 45
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 260 4 260 10
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter2] produces'1 self.current visited o.current /\ self.final = o.final
  
  constant self  : MutBorrow.t t_I'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 263 4 263 26] (self : MutBorrow.t t_I'0) : ()
  
  goal vc_produces_refl'0 : [%#siter0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans [#"../../creusot-contracts/src/std/iter.rs" 270 4 270 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 267 15 267 32
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 268 15 268 32
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 269 14 269 42
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 265 4 265 10
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter4] produces'1 self.current visited o.current /\ self.final = o.final
  
  constant a  : MutBorrow.t t_I'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : MutBorrow.t t_I'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : MutBorrow.t t_I'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 270 4 270 90] (a : MutBorrow.t t_I'0) (ab : Seq.seq t_Item'0) (b : MutBorrow.t t_I'0) (bc : Seq.seq t_Item'0) (c : MutBorrow.t t_I'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#siter1] produces'0 b bc c)
   -> ([%#siter0] produces'0 a ab b)  -> ([%#siter2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../creusot-contracts/src/std/option.rs" 103 16 105 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 103 43 103 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 103 52 103 53
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 99 26 102 17
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_T'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_T'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops4] precondition'0 self args}
    any
    [ return' (result:t_T'0)-> {inv'2 result} {[%#sops4] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 103 16 105 36] (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] [%#soption0] self_ = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & _7 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] [%#soption3] match self_ with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../creusot-contracts/src/std/option.rs" 131 16 133 37]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 131 35 131 36
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 123 27 126 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 131 44 131 53
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 127 26 130 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'5 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  type t_U'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'4 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use creusot.prelude.Any
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_body'0[#"../../creusot-contracts/src/std/option.rs" 131 16 133 37] (self_:t_Option'1) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_9 <- (t) ] s2
      | s2 = call_once'0 {f} {_9} (fun (_ret':t_U'0) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'1 _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _7 : t_U'0 = Any.any_l ()
    | & _9 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> exists r : t_U'0 . result = C_Some'1 r /\ postcondition_once'0 f (t) r
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../creusot-contracts/src/std/option.rs" 149 16 151 33]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 149 36 149 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 140 27 143 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 149 45 149 54
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 145 26 148 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant6] inv'4 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'0 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = (let (x0) = x in inv'5 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : ())
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:()))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'2 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any [ return' (result:())-> {inv'3 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use creusot.prelude.Any
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_inspect_body'0[#"../../creusot-contracts/src/std/option.rs" 149 16 151 33] (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = any [ br0 -> {self_ = C_None'0 } (! bb5) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- (_12) ] s3
      | s3 = call_once'0 {f} {_10} (fun (_ret':()) ->  [ &_8 <- _ret' ] s4)
      | s4 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _10 : t_T'0 = Any.any_l ()
    | & _12 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] [%#soption3] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] [%#soption0] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] [%#soption4] match self_ with
        | C_None'0 -> true
        | C_Some'0 t -> postcondition_once'0 f (t) ()
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../creusot-contracts/src/std/option.rs" 166 16 168 37]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 166 38 166 45
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 166 50 166 51
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 158 27 161 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 166 59 166 60
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 162 26 165 17
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_U'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_U'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'4 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'0 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use creusot.prelude.Any
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_body'0[#"../../creusot-contracts/src/std/option.rs" 166 16 168 37] (self_:t_Option'0) (default:t_U'0) (f:t_F'0) (return'  (ret:t_U'0))= {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] [%#soption1] inv'0 default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] [%#soption2] inv'1 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] [%#soption3] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_9 <- (t) ] s4
      | s4 = call_once'0 {f} {_9} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- default ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_U'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_U'0 = default
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _9 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_U'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] [%#soption4] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] [%#soption5] match self_ with
        | C_None'0 -> result = default
        | C_Some'0 t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../creusot-contracts/src/std/option.rs" 183 16 186 37]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 183 46 183 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 183 58 183 59
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 175 27 178 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 183 67 183 68
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 179 26 182 17
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_D'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_D'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_D'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = (let (x0) = x in inv'6 x0)
  
  predicate precondition'1 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  type t_U'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate postcondition_once'1 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'4 args}
    {[@expl:call_once requires] [%#sops6] precondition'1 self args}
    any
    [ return' (result:t_U'0)-> {inv'3 result} {[%#sops6] postcondition_once'1 self args result} (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'5 x] . inv'5 x = true
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_D'0) (args : ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_D'0) (args : ()) (result : t_U'0)
  
  
  let rec call_once'1 (self:t_D'0) (args:()) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'3 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 183 16 186 37] (self_:t_Option'0) (default:t_D'0) (f:t_F'0) (return'  (ret:t_U'0))= {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] [%#soption1] inv'0 default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] [%#soption2] inv'1 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] [%#soption3] match self_ with
      | C_None'0 -> precondition'0 default ()
      | C_Some'0 t -> precondition'1 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_11 <- (t) ] s4
      | s4 = call_once'0 {f} {_11} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = call_once'1 {default} {_8} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_U'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_D'0 = default
    | & f : t_F'0 = f
    | & _8 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l ()
    | & _11 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_U'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] [%#soption4] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] [%#soption5] match self_ with
        | C_None'0 -> postcondition_once'0 default () result
        | C_Some'0 t -> postcondition_once'1 f (t) result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../creusot-contracts/src/std/option.rs" 204 16 206 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 204 42 204 45
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 204 53 204 65
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 200 26 203 17
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_E'0
  
  type t_Result'0  =
    | C_Ok'0 t_T'0
    | C_Err'0 t_E'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'2 [@rewrite] : forall x : () [inv'3 x] . inv'3 x = true
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_E'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_E'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_E'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops4] precondition'0 self args}
    any
    [ return' (result:t_E'0)-> {inv'4 result} {[%#sops4] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Result'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'0 [inv'2 x] . inv'2 x
  = match x with
    | C_Ok'0 a_0 -> inv'5 a_0
    | C_Err'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 204 16 206 36] (self_:t_Option'0) (err:t_F'0) (return'  (ret:t_Result'0))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] [%#soption1] inv'0 err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] [%#soption0] self_ = C_None'0
     -> precondition'0 err ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 err} s1
      | s1 = -{resolve'0 err}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Ok'0 t ] s4
      | s4 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {err} {_8} (fun (_ret':t_E'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_Err'0 _6 ] s1 | s1 = bb8 ] 
    | bb8 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Result'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & err : t_F'0 = err
    | & _6 : t_E'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] [%#soption3] match self_ with
        | C_None'0 -> exists r : t_E'0 . result = C_Err'0 r /\ postcondition_once'0 err () r
        | C_Some'0 t -> result = C_Ok'0 t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../creusot-contracts/src/std/option.rs" 234 16 236 45]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 234 40 234 41
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 226 27 229 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 234 49 234 58
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 230 26 233 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'4 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  type t_U'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_Option'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_Option'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#sops5] postcondition_once'0 self args result}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use creusot.prelude.Any
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_then_body'0[#"../../creusot-contracts/src/std/option.rs" 234 16 236 45] (self_:t_Option'1) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_8 <- (t) ] s2
      | s2 = call_once'0 {f} {_8} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _8 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> postcondition_once'0 f (t) result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../creusot-contracts/src/std/option.rs" 254 16 256 41]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 254 35 254 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 243 27 246 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 254 52 254 61
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 247 26 253 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_P'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_P'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant6] inv'0 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let (x0) = x in inv'5 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_P'0) (args : t_T'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : bool)
  
  axiom inv_axiom'2 [@rewrite] : forall x : bool [inv'4 x] . inv'4 x = true
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_P'0) (args : t_T'0) (result : bool)
  
  
  let rec call_once'0 (self:t_P'0) (args:t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:bool)-> {inv'4 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_P'0)
  
  use creusot.prelude.Any
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_filter_body'0[#"../../creusot-contracts/src/std/option.rs" 254 16 256 41] (self_:t_Option'0) (predicate':t_P'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] [%#soption1] inv'1 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 predicate' (t)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- (_11) ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
    
    | bb7 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb9 ] 
    | bb9 = bb12
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve'0 t}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 predicate'} s1 | s1 = -{resolve'1 predicate'}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb14 ] 
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & predicate' : t_P'0 = predicate'
    | & t : t_T'0 = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : t_T'0 = Any.any_l ()
    | & _11 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> match result with
          | C_None'0 -> postcondition_once'0 predicate' (t) false /\ resolve'0 t
          | C_Some'0 r -> postcondition_once'0 predicate' (t) true /\ r = t
          end
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../creusot-contracts/src/std/option.rs" 273 16 275 44]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 273 36 273 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 273 45 273 54
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 269 26 272 17
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'2 x] . inv'2 x = true
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_Option'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_Option'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'2 args}
    {[@expl:call_once requires] [%#sops4] precondition'0 self args}
    any
    [ return' (result:t_Option'0)-> {inv'1 result}
      {[%#sops4] postcondition_once'0 self args result}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 273 16 275 44] (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] [%#soption0] self_ = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Some'0 t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb10
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & _7 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] [%#soption2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] [%#soption3] match self_ with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = C_Some'0 t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../creusot-contracts/src/std/option.rs" 311 16 313 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 311 52 311 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 306 27 306 63
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 311 61 311 67
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 307 26 310 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span sresolve8 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sresolve9 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant10 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  use creusot.prelude.MutBorrow
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant10] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve8] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'4 _1
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'3 [@rewrite] : forall x : () [inv'5 x] . inv'5 x = true
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_T'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_T'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_T'0)-> {inv'1 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'7 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve9] match self with
      | C_Some'0 x -> resolve'7 x
      | C_None'0 -> true
      end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'5 _1
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant10] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'4 x] . inv'4 x = invariant'1 x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_T'0)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'1 [inv'6 x] . inv'6 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'1)-> {inv'6 result}
      {[%#soption6] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption7] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_T'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:unwrap 'self' type invariant] inv'6 self}
    {[@expl:unwrap requires] [%#soption0] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_T'0)-> {inv'2 result} {[%#soption0] C_Some'1 result = self} (! return' {result}) ]
  
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve8] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body'0[#"../../creusot-contracts/src/std/option.rs" 311 16 313 36] (self_:MutBorrow.t t_Option'0) (f:t_F'0) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] [%#soption0] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] [%#soption2] self_.current = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_.current = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'1 r0'0}
            MutBorrow.borrow_final <t_T'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s3))
      | s3 = {inv'1 t.current}
        MutBorrow.borrow_final <t_T'0> {t.current} {MutBorrow.get_id t}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'2 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb14 ]
    
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_12} (fun (_ret':t_T'0) ->  [ &_10 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_9 <- C_Some'0 _10 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self_ with
          | {current = x'0} -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self_ with
          | {current = x'1} -> resolve'2 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_ <- { self_ with current = _9 } ] s3
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'3 self_.current}
        MutBorrow.borrow_final <t_Option'0> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':t_Option'1) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':MutBorrow.t t_T'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {inv'1 _13.current}
        MutBorrow.borrow_final <t_T'0> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_8 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _8.current}
        MutBorrow.borrow_final <t_T'0> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_8 <- { _8 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'2 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'1 _6.current}
        MutBorrow.borrow_final <t_T'0> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_6 <- { _6 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _3.current}
        MutBorrow.borrow_final <t_T'0> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'2 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb15 ]
    
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : MutBorrow.t t_T'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & f : t_F'0 = f
    | & _3 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _8 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _9 : t_Option'0 = Any.any_l ()
    | & _10 : t_T'0 = Any.any_l ()
    | & _12 : () = Any.any_l ()
    | & _13 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _14 : t_Option'1 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & t : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] [%#soption4] match self_.current with
        | C_None'0 -> postcondition_once'0 f () result.current /\ self_.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self_.current = C_Some'0 (result.current) /\ self_.final = C_Some'0 (result.final)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../creusot-contracts/src/std/option.rs" 338 16 340 45]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 338 41 338 50
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 324 27 327 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 338 58 338 67
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 328 26 337 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 159 0 181 1
  let%span sresolve6 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant7 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  use creusot.prelude.MutBorrow
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_P'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_P'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant7] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'5 x] . inv'5 x = (let (x0) = x in inv'1 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_P'0) (args : MutBorrow.t t_T'0)
  
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : bool)
  
  axiom inv_axiom'4 [@rewrite] : forall x : bool [inv'6 x] . inv'6 x = true
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_P'0) (args : MutBorrow.t t_T'0) (result : bool)
  
  
  let rec call_once'0 (self:t_P'0) (args:MutBorrow.t t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'4 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:bool)-> {inv'6 result} {[%#sops5] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve6] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'3 _1
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant7] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  let rec take'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#soption0] result = self.current /\ self.final = C_None'0}
      (! return' {result}) ]
  
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve6] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'4 _1
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_P'0)
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_if_body'0[#"../../creusot-contracts/src/std/option.rs" 338 16 340 45] (self_:MutBorrow.t t_Option'0) (predicate':t_P'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] [%#soption0] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] [%#soption1] inv'4 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] [%#soption2] match self_.current with
      | C_None'0 -> true
      | C_Some'0 t -> forall b : MutBorrow.t t_T'0 . inv'1 b /\ b.current = t  -> precondition'0 predicate' (b)
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_.current = C_None'0 } (! bb4) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'0 r0'0}
            MutBorrow.borrow_mut <t_T'0> {r0'0}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T'0> {t.current} {MutBorrow.get_id t}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_9 <- (_10) ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 = {inv'2 self_.current}
        MutBorrow.borrow_final <t_Option'0> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_11 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 = take'0 {_11} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb12 ] 
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'4 predicate'} s1
      | s1 = -{resolve'2 predicate'}- s2
      | s2 = {[@expl:type invariant] inv'3 self_} s3
      | s3 = -{resolve'1 self_}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb13 ] 
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & predicate' : t_P'0 = predicate'
    | & t : MutBorrow.t t_T'0 = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _10 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _11 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] [%#soption4] match self_.current with
        | C_None'0 -> result = C_None'0 /\ self_.final = C_None'0
        | C_Some'0 cur -> exists b : MutBorrow.t t_T'0, res : bool . inv'1 b
        /\ cur = b.current
        /\ postcondition_once'0 predicate' (b) res
        /\ (if res then
          self_.final = C_None'0 /\ result = C_Some'0 (b.final)
        else
          self_.final = C_Some'0 (b.final) /\ result = C_None'0
        )
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : t_Option'0) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption4] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  constant z  : t_Option'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : t_Option'0) (y : t_Option'0) (z : t_Option'0) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl [#"../../creusot-contracts/src/std/option.rs" 477 4 477 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 476 14 476 45
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 474 4 474 10
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/option.rs" 477 4 477 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans [#"../../creusot-contracts/src/std/option.rs" 484 4 484 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 481 15 481 32
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 482 15 482 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 483 14 483 42
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 479 4 479 10
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/option.rs" 484 4 484 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi11122593048316696412__produces_refl [#"../../creusot-contracts/src/std/option.rs" 530 4 530 26] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 529 14 529 45
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 527 4 527 10
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 522 12 523 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/option.rs" 530 4 530 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi11122593048316696412__produces_trans [#"../../creusot-contracts/src/std/option.rs" 537 4 537 90] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 534 15 534 32
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 535 15 535 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 536 14 536 42
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 532 4 532 10
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 522 12 523 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/option.rs" 537 4 537 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi13775167061943888590__produces_refl [#"../../creusot-contracts/src/std/option.rs" 586 4 586 26] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 585 14 585 45
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 583 4 583 10
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 578 12 579 96
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption2] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/option.rs" 586 4 586 26] (self : t_IterMut'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi13775167061943888590__produces_trans [#"../../creusot-contracts/src/std/option.rs" 593 4 593 90] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 590 15 590 32
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 591 15 591 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 592 14 592 42
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 588 4 588 10
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 578 12 579 96
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption4] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (MutBorrow.t t_T'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (MutBorrow.t t_T'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/option.rs" 593 4 593 90] (a : t_IterMut'0) (ab : Seq.seq (MutBorrow.t t_T'0)) (b : t_IterMut'0) (bc : Seq.seq (MutBorrow.t t_T'0)) (c : t_IterMut'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#soption1] produces'0 b bc c)
   -> ([%#soption0] produces'0 a ab b)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  constant self  : Opaque.ptr
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (self : Opaque.ptr) : bool
  
  goal vc_is_null_logic'0 : [%#sptr0] (addr_logic'0 self = 0) = (addr_logic'0 self = 0)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 97 4 97 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 96 14 96 48
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 98 8 98 30
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 90 4 90 30] (self : Opaque.ptr) : int
  
  constant self  : Opaque.ptr
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 97 4 97 34] (self : Opaque.ptr) : bool
  
  goal vc_is_null_logic'0 : [%#sptr0] (addr_logic'0 self = 0) = (addr_logic'0 self = 0)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 425 14 425 45
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 423 4 423 10
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice3] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  use seq.Seq
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#sslice0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 430 15 430 32
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 431 15 431 32
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 432 14 432 42
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 428 4 428 10
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex8 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice10 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice9] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice10] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel7] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex8] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice5] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice4] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sslice1] produces'0 b bc c)
   -> ([%#sslice0] produces'0 a ab b)  -> ([%#sslice2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 479 14 479 45
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 477 4 477 10
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 473 12 473 66
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex7 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice8] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice9] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel6] view'2 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex7] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice3] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice5] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice2] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  use seq.Seq
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 26] (self : t_IterMut'0) : ()
  
  goal vc_produces_refl'0 : [%#sslice0] produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 484 15 484 32
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 485 15 485 32
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 486 14 486 42
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 482 4 482 10
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 473 12 473 66
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span smodel8 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex9 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice10 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice11 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice10] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice11] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel8] view'2 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex9] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice5] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice7] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice4] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (MutBorrow.t t_T'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (MutBorrow.t t_T'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 90] (a : t_IterMut'0) (ab : Seq.seq (MutBorrow.t t_T'0)) (b : t_IterMut'0) (bc : Seq.seq (MutBorrow.t t_T'0)) (c : t_IterMut'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sslice1] produces'0 b bc c)
   -> ([%#sslice0] produces'0 a ab b)  -> ([%#sslice2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl [#"../../creusot-contracts/src/std/vec.rs" 283 4 283 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 282 14 282 45
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 280 4 280 10
  let%span svec2 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec2] view'0 self = Seq.(++) visited (view'0 rhs)
  
  use seq.Seq
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/vec.rs" 283 4 283 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#svec0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans [#"../../creusot-contracts/src/std/vec.rs" 290 4 290 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 287 15 287 32
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 288 15 288 32
  let%span svec2 = "../../creusot-contracts/src/std/vec.rs" 289 14 289 42
  let%span svec3 = "../../creusot-contracts/src/std/vec.rs" 285 4 285 10
  let%span svec4 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec4] view'0 self = Seq.(++) visited (view'0 rhs)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/vec.rs" 290 4 290 72] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#svec1] produces'0 b bc c)
   -> ([%#svec0] produces'0 a ab b)  -> ([%#svec2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Real.(<=) x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Real.(<) x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Real.(>=) x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Real.(>) x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Real.real) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span snum_rational4 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational4] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Real.real) (y : Real.real) (z : Real.real) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span snum_rational3 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational3] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span snum_rational3 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational3] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Real.real) (y : Real.real) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__ghost__qyi4711228197303399097__clone [#"../../creusot-contracts/src/ghost.rs" 50 4 50 27] (* <ghost::GhostBox<T> as std::clone::Clone> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 50 14 50 18
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 50 23 50 27
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 49 14 49 29
  let%span sclone3 = "../../creusot-contracts/src/std/clone.rs" 7 0 20 1
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed5 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed5] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  let rec clone'1 (self:t_T'0) (return'  (ret:t_T'0))= {[@expl:clone 'self' type invariant] inv'2 self}
    any [ return' (result:t_T'0)-> {inv'3 result} {[%#sclone3] result = self} (! return' {result}) ] 
  
  use creusot.prelude.Any
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/ghost.rs" 50 4 50 27] (self:t_GhostBox'0) (return'  (ret:t_GhostBox'0))= {[@expl:clone 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone'1 {self.t_GhostBox__0'0} (fun (_ret':t_T'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'0 = _3 } ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_GhostBox'0 = Any.any_l () | & self : t_GhostBox'0 = self | & _3 : t_T'0 = Any.any_l () ] 
    [ return' (result:t_GhostBox'0)-> {[@expl:clone result type invariant] [%#sghost1] inv'1 result}
      {[@expl:clone ensures] [%#sghost2] result = self}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi11746049757730684686__deref [#"../../creusot-contracts/src/ghost.rs" 69 4 69 36] (* <ghost::GhostBox<T> as std::ops::Deref> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 69 23 69 36
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed4 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use creusot.prelude.Any
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed4] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'0) =
    [%#sinvariant3] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant3] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  meta "compute_max_steps" 1000000
  
  let rec deref'0[#"../../creusot-contracts/src/ghost.rs" 69 4 69 36] (self:t_GhostBox'0) (return'  (ret:t_T'0))= {[@expl:deref 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_3 <- self.t_GhostBox__0'0 ] s1 | s1 =  [ &_0 <- _3 ] s2 | s2 = return' {_0} ]  ] )
    [ & _0 : t_T'0 = Any.any_l () | & self : t_GhostBox'0 = self | & _3 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:deref result type invariant] [%#sghost1] inv'1 result}
      {[@expl:deref ensures] [%#sghost2] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi4247034559912199455__deref_mut [#"../../creusot-contracts/src/ghost.rs" 85 4 85 48] (* <ghost::GhostBox<T> as std::ops::DerefMut> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 85 31 85 48
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed5 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'2 _1
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed5] inv'0 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_GhostBox'0) =
    [%#sinvariant4] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_GhostBox'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_GhostBox'0) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_GhostBox'0) =
    resolve'3 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec deref_mut'0[#"../../creusot-contracts/src/ghost.rs" 85 4 85 48] (self:MutBorrow.t t_GhostBox'0) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_GhostBox__0'0}
        MutBorrow.borrow_final <t_T'0> {(self.current).t_GhostBox__0'0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_5 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_GhostBox__0'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _5.current}
        MutBorrow.borrow_final <t_T'0> {_5.current} {MutBorrow.get_id _5}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'0 _4.current}
        MutBorrow.borrow_final <t_T'0> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_2 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_4 <- { _4 with current = _ret'.final } ] 
            s3)
      | s3 = {inv'0 _2.current}
        MutBorrow.borrow_final <t_T'0> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_2 <- { _2 with current = _ret'.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 _5} s5
      | s5 = -{resolve'0 _5}- s6
      | s6 = {[@expl:type invariant] inv'1 _4} s7
      | s7 = -{resolve'0 _4}- s8
      | s8 = {[@expl:type invariant] inv'1 _2} s9
      | s9 = -{resolve'0 _2}- s10
      | s10 = {[@expl:type invariant] inv'2 self} s11
      | s11 = -{resolve'1 self}- s12
      | s12 = return' {_0} ]
     ]
    )
    [ & _0 : MutBorrow.t t_T'0 = Any.any_l ()
    | & self : MutBorrow.t t_GhostBox'0 = self
    | & _2 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _4 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_T'0)-> {[@expl:deref_mut result type invariant] [%#sghost1] inv'1 result}
      {[@expl:deref_mut ensures] [%#sghost2] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi14191374204198111214__resolve_coherence [#"../../creusot-contracts/src/ghost.rs" 118 4 118 31] (* <ghost::GhostBox<T> as resolve::Resolve> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 115 15 115 24
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 116 15 116 39
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 117 14 117 31
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 73 15 73 39
  let%span sresolve4 = "../../creusot-contracts/src/resolve.rs" 74 14 74 31
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 113 4 113 23
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span sresolve7 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed9] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'0) =
    [%#sinvariant8] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve7] resolve'3 self
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_GhostBox'0) =
    match _1 with
      | {t_GhostBox__0'0 = x0} -> resolve'2 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 109 4 109 28] (self : t_GhostBox'0) =
    [%#sghost6] resolve'1 self.t_GhostBox__0'0
  
  predicate structural_resolve'1 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'3 _1
  
  function resolve_coherence'1 [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (self : t_T'0) : ()
  
  axiom resolve_coherence'1_spec : forall self : t_T'0 . ([%#sresolve3] structural_resolve'1 self)
   -> ([%#sresolve4] resolve'1 self)
  
  constant self  : t_GhostBox'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/ghost.rs" 118 4 118 31] (self : t_GhostBox'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sghost1] structural_resolve'0 self)
   -> ([%#sghost0] inv'0 self)
   -> ([@expl:resolve_coherence requires] [%#sresolve3] structural_resolve'1 self.t_GhostBox__0'0)
  /\ (([%#sresolve4] resolve'1 self.t_GhostBox__0'0)
   -> (let _ = resolve_coherence'1 self.t_GhostBox__0'0 in [%#sghost2] resolve'0 self))
end
module M_creusot_contracts__ghost__qyi15728210394389215748__borrow [#"../../creusot-contracts/src/ghost.rs" 127 4 127 40] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 127 19 127 23
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 127 28 127 40
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 126 14 126 35
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed4 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_T'0 }
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: t_T'0 }
  
  use creusot.prelude.Any
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed4] inv'6 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_GhostBox'1 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'1) =
    [%#sinvariant3] inv'3 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'1 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant3] inv'6 self
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed4] inv'5 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec borrow'0[#"../../creusot-contracts/src/ghost.rs" 127 4 127 40] (self:t_GhostBox'1) (return'  (ret:t_GhostBox'0))= {[@expl:borrow 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- self.t_GhostBox__0'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'1 = _5 } ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_GhostBox'0 = Any.any_l () | & self : t_GhostBox'1 = self | & _5 : t_T'0 = Any.any_l () ] 
    [ return' (result:t_GhostBox'0)-> {[@expl:borrow result type invariant] [%#sghost1] inv'1 result}
      {[@expl:borrow ensures] [%#sghost2] result.t_GhostBox__0'1 = self.t_GhostBox__0'0}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi15728210394389215748__borrow_mut [#"../../creusot-contracts/src/ghost.rs" 141 4 141 52] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 141 27 141 31
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 141 36 141 52
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 140 14 140 39
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed5 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_T'0 }
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: MutBorrow.t t_T'0 }
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant4] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'2 _1
  
  predicate invariant'3 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed5] inv'0 self
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_GhostBox'1 [inv'5 x] . inv'5 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'6 a_0
    end
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_GhostBox'1) =
    [%#sinvariant4] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_GhostBox'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_GhostBox'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_GhostBox'1) =
    [%#sresolve3] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_GhostBox'1) =
    resolve'3 _1
  
  use creusot.prelude.Any
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : MutBorrow.t t_T'0) =
    [%#sboxed5] inv'1 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec borrow_mut'0[#"../../creusot-contracts/src/ghost.rs" 141 4 141 52] (self:MutBorrow.t t_GhostBox'1) (return'  (ret:t_GhostBox'0))= {[@expl:borrow_mut 'self' type invariant] [%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_GhostBox__0'0}
        MutBorrow.borrow_final <t_T'0> {(self.current).t_GhostBox__0'0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_5 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_GhostBox__0'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _5.current}
        MutBorrow.borrow_final <t_T'0> {_5.current} {MutBorrow.get_id _5}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final } ] 
            s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'1 = _4 } ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _5} s1
      | s1 = -{resolve'0 _5}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = return' {_0} ]
     ]
    )
    [ & _0 : t_GhostBox'0 = Any.any_l ()
    | & self : MutBorrow.t t_GhostBox'1 = self
    | & _4 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:t_GhostBox'0)-> {[@expl:borrow_mut result type invariant] [%#sghost1] inv'3 result}
      {[@expl:borrow_mut ensures] [%#sghost2] result.t_GhostBox__0'1
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi15728210394389215748__conjure [#"../../creusot-contracts/src/ghost.rs" 159 4 159 28] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 158 15 158 20
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 159 24 159 28
  let%span sboxed2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed2] inv'2 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec conjure'0[#"../../creusot-contracts/src/ghost.rs" 159 4 159 28] (_1:()) (return'  (ret:t_GhostBox'0))= {[@expl:conjure requires] [%#sghost0] false}
    (! bb0 [ bb0 = {false} any ] )
    [ return' (result:t_GhostBox'0)-> {[@expl:conjure result type invariant] [%#sghost1] inv'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi15728210394389215748__new [#"../../creusot-contracts/src/ghost.rs" 185 4 185 28] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 185 24 185 28
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sboxed3 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use creusot.prelude.Any
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed3] inv'0 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"../../creusot-contracts/src/ghost.rs" 185 4 185 28] (x:t_T'0) (return'  (ret:t_GhostBox'0))= {[@expl:new 'x' type invariant] [%#sghost0] inv'0 x}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 =  [ &_0 <- { t_GhostBox__0'0 = x } ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : t_GhostBox'0 = Any.any_l () | & x : t_T'0 = x ] 
    [ return' (result:t_GhostBox'0)-> {[@expl:new result type invariant] [%#sghost1] inv'1 result}
      {[@expl:new ensures] [%#sghost2] result.t_GhostBox__0'0 = x}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi15728210394389215748__new_logic [#"../../creusot-contracts/src/ghost.rs" 200 4 200 34] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 199 14 199 28
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 201 8 201 25
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  constant x  : t_T'0
  
  function new_logic'0 [#"../../creusot-contracts/src/ghost.rs" 200 4 200 34] (x : t_T'0) : t_GhostBox'0
  
  goal vc_new_logic'0 : [%#sghost0] { t_GhostBox__0'0 = x }.t_GhostBox__0'0 = x
end
module M_creusot_contracts__ghost__qyi15728210394389215748__into_inner [#"../../creusot-contracts/src/ghost.rs" 210 4 210 32] (* ghost::GhostBox<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 210 22 210 26
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 210 31 210 32
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 208 14 208 31
  let%span sboxed3 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  use creusot.prelude.Any
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed3] inv'1 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec into_inner'0[#"../../creusot-contracts/src/ghost.rs" 210 4 210 32] (self:t_GhostBox'0) (return'  (ret:t_T'0))= {[@expl:into_inner 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- self.t_GhostBox__0'0 ] s1 | s1 = bb2 ]  | bb2 = return' {_0} ] )
    [ & _0 : t_T'0 = Any.any_l () | & self : t_GhostBox'0 = self ]
    
    [ return' (result:t_T'0)-> {[@expl:into_inner result type invariant] [%#sghost1] inv'1 result}
      {[@expl:into_inner ensures] [%#sghost2] result = self.t_GhostBox__0'0}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__subtract [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 196 15 196 33
  let%span sfmap1 = "../../creusot-contracts/src/logic/fmap.rs" 197 14 197 36
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 198 14 198 46
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 199 14 203 5
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 181 14 185 5
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 205 8 205 33
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 155 12 155 89
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 147 19 147 71
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 164 15 164 35
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 165 14 171 5
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 172 14 172 54
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap16] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
  
   =
    [%#sfmap14] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap'0) (k : t_K'0) : bool
  
   =
    [%#sfmap15] get_unsized'0 self k <> C_None'0
  
  function subset'0 [#"../../creusot-contracts/src/logic/fmap.rs" 153 4 153 44] (self : t_FMap'0) (other : t_FMap'0) : bool
  
   =
    [%#sfmap6] forall k : t_K'0 . contains'0 self k  -> get_unsized'0 other k = get_unsized'0 self k
  
  function disjoint'0 [#"../../creusot-contracts/src/logic/fmap.rs" 146 4 146 46] (self : t_FMap'0) (other : t_FMap'0) : bool
  
   =
    [%#sfmap7] forall k : t_K'0 . not contains'0 self k \/ not contains'0 other k
  
  function ext_eq'0 [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self : t_FMap'0) (other : t_FMap'0) : bool
  
   =
    [%#sfmap10] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap8] ext_eq'0 self other  -> self = other)
  && ([%#sfmap9] (forall k : t_K'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  use mach.int.Int
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap17] len'0 self >= 0
  
  function union'0 [#"../../creusot-contracts/src/logic/fmap.rs" 173 4 173 43] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
  
  
  axiom union'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap11] disjoint'0 self other)
   -> ([%#sfmap12] forall k : t_K'0 . get_unsized'0 (union'0 self other) k
  = (if contains'0 self k then
    get_unsized'0 self k
  else
    if contains'0 other k then get_unsized'0 other k else C_None'0
  ))
  && ([%#sfmap13] len'0 (union'0 self other) = len'0 self + len'0 other)
  
  function subtract_keys'0 [#"../../creusot-contracts/src/logic/fmap.rs" 186 4 186 51] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
  
  
  axiom subtract_keys'0_spec : forall self : t_FMap'0, other : t_FMap'0 . [%#sfmap4] forall k : t_K'0 . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k)
  
  constant self  : t_FMap'0
  
  constant other  : t_FMap'0
  
  function subtract'0 [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
  
  
  goal vc_subtract'0 : ([%#sfmap0] subset'0 other self)
   -> ([%#sfmap4] forall k : t_K'0 . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k))
   -> (let result = subtract_keys'0 self other in ([%#sfmap1] disjoint'0 result other)
  && ([%#sfmap2] ext_eq'0 (union'0 other result) self)
  && ([%#sfmap3] forall k : t_K'0 . get_unsized'0 result k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k)))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap1 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  
  type t_K'0
  
  type t_FMap'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap2] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
  
   =
    [%#sfmap4] Map.get (view'0 self) k
  
  constant self  : t_FMap'0
  
  constant other  : t_FMap'0
  
  function ext_eq'0 [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self : t_FMap'0) (other : t_FMap'0) : bool
  
  
  goal vc_ext_eq'0 : ([%#sfmap2] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2  -> view'0 m1 <> view'0 m2)
   -> ([%#sfmap2] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2  -> view'0 m1 <> view'0 m2)
   -> (let result = view'0 self = view'0 other in ([%#sfmap0] result  -> self = other)
  && ([%#sfmap1] (forall k : t_K'0 . get_unsized'0 self k = get_unsized'0 other k)  -> result))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__contains_ghost [#"../../creusot-contracts/src/logic/fmap.rs" 286 4 286 49] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 286 27 286 31
  let%span sfmap1 = "../../creusot-contracts/src/logic/fmap.rs" 286 33 286 36
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 285 14 285 43
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 315 40 315 50
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 307 4 314 11
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 36 26 36 51
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil11 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil12 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sinvariant13 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sboxed16 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'1
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap14] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'1
  
   =
    [%#sfmap10] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap'0) (k : t_K'0) : bool
  
   =
    [%#sfmap8] get_unsized'0 self k <> C_None'1
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_K'0)
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  predicate invariant'5 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_V'0) =
    [%#sboxed16] inv'7 self
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_V'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  function unwrap'0 [#"../../creusot-contracts/src/util.rs" 57 0 57 36] (op : t_Option'1) : t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'1 . ([%#sutil11] op <> C_None'1)
   -> ([%#sutil12] C_Some'1 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self : t_FMap'0) (k : t_K'0) : t_V'0
  
   =
    [%#sfmap9] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'4 [#"../../creusot-contracts/src/logic/fmap.rs" 489 4 489 30] (self : t_FMap'0) =
    [%#sfmap15] forall k : t_K'0 . contains'0 self k  -> inv'6 k /\ inv'8 (lookup_unsized'0 self k)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_FMap'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_FMap'0) =
    [%#sinvariant13] inv'5 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FMap'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_K'0) =
    [%#sinvariant13] inv'6 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_K'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_K'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_V'0) =
    [%#sinvariant13] inv'7 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_V'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:t_K'0) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap3] inv'0 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap4] inv'1 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap5] inv'2 result}
      {[%#sfmap6] if contains'0 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant13] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  let rec is_some'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_some 'self' type invariant] inv'3 self}
    any [ return' (result:bool)-> {[%#soption7] result = (self <> C_None'0)} (! return' {result}) ] 
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec contains_ghost'0[#"../../creusot-contracts/src/logic/fmap.rs" 286 4 286 49] (self:t_FMap'0) (key:t_K'0) (return'  (ret:bool))= {[@expl:contains_ghost 'self' type invariant] [%#sfmap0] inv'0 self}
    {[@expl:contains_ghost 'key' type invariant] [%#sfmap1] inv'1 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost'0 {self} {key} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some'0 {_5} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l () | & self : t_FMap'0 = self | & key : t_K'0 = key | & _5 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:contains_ghost ensures] [%#sfmap2] result = contains'0 self key}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 187 4 189 17] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 186 14 186 38
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 192 12 192 63
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  type t_T'0
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset2] Fset.mem e self
  
  constant self  : Fset.fset t_T'0
  
  constant other  : Fset.fset t_T'0
  
  predicate ext_eq'0 [#"../../creusot-contracts/src/logic/fset.rs" 187 4 189 17] (self : Fset.fset t_T'0) (other : Fset.fset t_T'0)
  
  
  goal vc_ext_eq'0 : [%#sfset0] ([%#sfset1] forall e : t_T'0 . contains'0 self e = contains'0 other e)  -> self = other
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__singleton [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 201 14 201 57
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 203 8 203 29
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  type t_T'0
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset2] Fset.mem e self
  
  use set.Fset
  
  use set.Fset
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset t_T'0) (e : t_T'0) : Fset.fset t_T'0
  
   =
    [%#sfset3] Fset.add e self
  
  constant x  : t_T'0
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (x : t_T'0) : Fset.fset t_T'0
  
  goal vc_singleton'0 : [%#sfset0] forall y : t_T'0 . contains'0 (insert'0 (Fset.empty : Fset.fset t_T'0) x) y = (x = y)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__unions [#"../../creusot-contracts/src/logic/fset.rs" 211 4 211 61] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 209 14 209 102
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 210 14 210 24
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 207 4 207 12
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  type t_U'0
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_U'0) (e : t_U'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  type t_T'0
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  use map.Map
  
  use set.Fset
  
  use map.Map
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self : Fset.fset t_T'0) (e : t_T'0) : Fset.fset t_T'0
  
   =
    [%#sfset4] Fset.remove e self
  
  use mach.int.Int
  
  use set.Fset
  
  constant self  : Fset.fset t_T'0
  
  constant f  : Map.map t_T'0 (Fset.fset t_U'0)
  
  function unions'0 [#"../../creusot-contracts/src/logic/fset.rs" 211 4 211 61] (self : Fset.fset t_T'0) (f : Map.map t_T'0 (Fset.fset t_U'0)) : Fset.fset t_U'0
  
  
  goal vc_unions'0 : if Fset.cardinal self = 0 then
    [%#sfset0] forall y : t_U'0 . contains'0 (Fset.empty : Fset.fset t_U'0) y
    = (exists x : t_T'0 . contains'1 self x /\ contains'0 (Map.get f x) y)
  else
    let x = Fset.pick self in (0 <= ([%#sfset1] Fset.cardinal self)
    /\ ([%#sfset1] Fset.cardinal (remove'0 self x)) < ([%#sfset1] Fset.cardinal self))
    /\ (([%#sfset0] forall y : t_U'0 . contains'0 (unions'0 (remove'0 self x) f) y
    = (exists x' : t_T'0 . contains'1 (remove'0 self x) x' /\ contains'0 (Map.get f x') y))
     -> ([%#sfset0] forall y : t_U'0 . contains'0 (Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)) y
    = (exists x : t_T'0 . contains'1 self x /\ contains'0 (Map.get f x) y)))

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate [#"../../creusot-contracts/src/logic/fset.rs" 268 4 268 50] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 265 15 265 21
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 266 14 266 123
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 267 14 267 15
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 271 32 271 85
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 201 14 201 57
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 274 32 274 108
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 248 14 248 117
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 269 8 277 9
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq9 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 203 8 203 29
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use mach.int.Int
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset8] Fset.mem e self
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq9] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset8] Fset.mem e self
  
  use seq.Seq
  
  use set.Fset
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset12] Fset.add e self
  
  use set.Fset
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset10] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  use seq.Seq
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq11] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 249 4 249 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  constant self  : Fset.fset t_T'0
  
  constant n  : int
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 268 4 268 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  goal vc_replicate'0 : ([%#sfset0] n >= 0)
   -> (if n = 0 then
    ([%#sfset3] forall xs : Seq.seq t_T'0 . Seq.length xs = 0  -> xs = (Seq.empty : Seq.seq t_T'0))
    && (let _ = () in let _ = () in ([%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) y
    = ((Seq.empty : Seq.seq t_T'0) = y))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) xs
    = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x))))
  else
    ([%#sfset5] forall xs : Seq.seq t_T'0, i : int . 0 < i /\ i < Seq.length xs
     -> Seq.get xs i = Seq.get (tail'0 xs) (i - 1))
    && (let _ = () in let _ = () in (([@expl:replicate requires] [%#sfset0] n - 1 >= 0)
    /\ 0 <= ([%#sfset2] n) /\ ([%#sfset2] n - 1) < ([%#sfset2] n))
    /\ (([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self (n - 1)) xs
    = (Seq.length xs = n - 1 /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
     -> ([%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 self (replicate'0 self (n - 1))) xs
    = (0 < Seq.length xs /\ contains'2 self (Seq.get xs 0) /\ contains'0 (replicate'0 self (n - 1)) (tail'0 xs)))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 self (replicate'0 self (n - 1))) xs
    = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))))
  )
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 286 4 286 56] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 283 15 283 21
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 284 14 284 123
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 285 14 285 15
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 289 32 289 85
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 201 14 201 57
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 265 15 265 21
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 266 14 266 123
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 267 14 267 15
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 287 8 294 9
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 203 8 203 29
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 269 8 277 9
  let%span sfset13 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 248 14 248 117
  let%span sseq15 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use mach.int.Int
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq10] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  use seq.Seq
  
  use set.Fset
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset13] Fset.add e self
  
  use set.Fset
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset11] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  use seq.Seq
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq15] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 249 4 249 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset14] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 268 4 268 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset5] n >= 0)
   -> replicate'0 self n
  = ([%#sfset12] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    let _ = let _ = () in () in cons'0 self (replicate'0 self (n - 1))
  )
  
  axiom replicate'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset5] n >= 0)
   -> ([%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
  = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  use set.Fset
  
  constant self  : Fset.fset t_T'0
  
  constant n  : int
  
  function replicate_up_to'0 [#"../../creusot-contracts/src/logic/fset.rs" 286 4 286 56] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  goal vc_replicate_up_to'0 : ([%#sfset0] n >= 0)
   -> (if n = 0 then
    ([%#sfset3] forall xs : Seq.seq t_T'0 . Seq.length xs = 0  -> xs = (Seq.empty : Seq.seq t_T'0))
    && (let _ = () in let _ = () in ([%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) y
    = ((Seq.empty : Seq.seq t_T'0) = y))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) xs
    = (Seq.length xs <= n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x))))
  else
    (([@expl:replicate_up_to requires] [%#sfset0] n - 1 >= 0)
    /\ 0 <= ([%#sfset2] n) /\ ([%#sfset2] n - 1) < ([%#sfset2] n))
    /\ (([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (replicate_up_to'0 self (n - 1)) xs
    = (Seq.length xs <= n - 1 /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
     -> ([@expl:replicate requires] [%#sfset5] n >= 0)
    /\ (([%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
    = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (Fset.union (replicate_up_to'0 self (n
    - 1)) (replicate'0 self n)) xs
    = (Seq.length xs <= n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))))
  )
end
module M_creusot_contracts__logic__fset__unions_union [#"../../creusot-contracts/src/logic/fset.rs" 470 0 470 27]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 467 10 467 125
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 468 10 469 76
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 465 0 465 8
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 209 14 209 102
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 210 14 210 24
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 207 4 207 12
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  type t_T'0
  
  use set.Fset
  
  type t_U'0
  
  use set.Fset
  
  use map.Map
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_U'0) (e : t_U'0)
  
   =
    [%#sfset6] Fset.mem e self
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset6] Fset.mem e self
  
  use map.Map
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self : Fset.fset t_T'0) (e : t_T'0) : Fset.fset t_T'0
  
   =
    [%#sfset7] Fset.remove e self
  
  function unions'0 [#"../../creusot-contracts/src/logic/fset.rs" 211 4 211 61] (self : Fset.fset t_T'0) (f : Map.map t_T'0 (Fset.fset t_U'0)) : Fset.fset t_U'0
  
  
  axiom unions'0_def : forall self : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0) . unions'0 self f
  = ([%#sfset5] if Fset.cardinal self = 0 then
    Fset.empty : Fset.fset t_U'0
  else
    let x = Fset.pick self in Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)
  )
  
  axiom unions'0_spec : forall self : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0) . [%#sfset3] forall y : t_U'0 . contains'0 (unions'0 self f) y
  = (exists x : t_T'0 . contains'1 self x /\ contains'0 (Map.get f x) y)
  
  use set.Fset
  
  constant _1  : ()
  
  function unions_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 470 0 470 27] (_1 : ()) : ()
  
  goal vc_unions_union'0 : ([%#sfset0] forall s1 : Fset.fset t_T'0, s2 : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0) . unions'0 (Fset.union s1 s2) f
  = Fset.union (unions'0 s1 f) (unions'0 s2 f))
  && ([%#sfset1] forall s : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0), g : Map.map t_T'0 (Fset.fset t_U'0) . unions'0 s (fun (x : t_T'0) -> Fset.union (Map.get f x) (Map.get g x))
  = Fset.union (unions'0 s f) (unions'0 s g))
end
module M_creusot_contracts__logic__fset__map_union [#"../../creusot-contracts/src/logic/fset.rs" 476 0 476 24]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 475 10 475 104
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 473 0 473 8
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 232 8 232 27
  
  type t_T'0
  
  use set.Fset
  
  type t_U'0
  
  use map.Map
  
  use set.Fset
  
  use set.Fset
  
  function map'0 [#"../../creusot-contracts/src/logic/fset.rs" 231 4 231 52] (self : Fset.fset t_T'0) (f : Map.map t_T'0 t_U'0) : Fset.fset t_U'0
  
   =
    [%#sfset2] Fset.map f self
  
  use set.Fset
  
  use set.Fset
  
  constant _1  : ()
  
  function map_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 476 0 476 24] (_1 : ()) : ()
  
  goal vc_map_union'0 : [%#sfset0] forall s : Fset.fset t_T'0, t : Fset.fset t_T'0, f : Map.map t_T'0 t_U'0 . map'0 (Fset.union s t) f
  = Fset.union (map'0 s f) (map'0 t f)
end
module M_creusot_contracts__logic__fset__concat_union [#"../../creusot-contracts/src/logic/fset.rs" 485 0 485 24]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 481 10 482 83
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 483 10 484 83
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 479 0 479 8
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 257 14 257 144
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  use seq.Seq
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 258 4 258 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset3] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  use set.Fset
  
  constant _1  : ()
  
  function concat_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 485 0 485 24] (_1 : ()) : ()
  
  goal vc_concat_union'0 : ([%#sfset0] forall s1 : Fset.fset (Seq.seq t_T'0), s2 : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . concat'0 (Fset.union s1 s2) t
  = Fset.union (concat'0 s1 t) (concat'0 s2 t))
  && ([%#sfset1] forall s : Fset.fset (Seq.seq t_T'0), t1 : Fset.fset (Seq.seq t_T'0), t2 : Fset.fset (Seq.seq t_T'0) . concat'0 s (Fset.union t1 t2)
  = Fset.union (concat'0 s t1) (concat'0 s t2))
end
module M_creusot_contracts__logic__fset__cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 491 0 491 23]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 490 10 490 133
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 492 20 492 115
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 493 20 493 74
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 494 20 494 89
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 492 4 492 117
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 257 14 257 144
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 248 14 248 117
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 247 8 247 27
  let%span sseq8 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  type t_T'0
  
  use set.Fset
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  use seq.Seq
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 258 4 258 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset5] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  use seq.Seq
  
  use seq.Seq
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq8] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 249 4 249 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  use seq.Seq
  
  function push_front'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/seq.rs" 246 4 246 41] (self : Seq.seq t_T'0) (x : t_T'0) : Seq.seq t_T'0
  
   =
    [%#sseq7] Seq.cons x self
  
  constant _1  : ()
  
  function cons_concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 491 0 491 23] (_1 : ()) : ()
  
  goal vc_cons_concat'0 : ([%#sfset1] forall x : t_T'0, xs : Seq.seq t_T'0, ys : Seq.seq t_T'0 . Seq.(++) (push_front'0 xs x) ys
  = push_front'0 (Seq.(++) xs ys) x)
  && (let _ = () in let _ = () in ([%#sfset2] forall x : t_T'0, ys : Seq.seq t_T'0 . tail'0 (push_front'0 ys x) = ys)
  && (let _ = () in let _ = () in ([%#sfset3] forall ys : Seq.seq t_T'0 . 0 < Seq.length ys
   -> ys = push_front'0 (tail'0 ys) (Seq.get ys 0))
  && (let _ = () in let _ = () in [%#sfset0] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
  = cons'0 s (concat'0 t u))))
end
module M_creusot_contracts__logic__fset__concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 503 0 503 54]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 500 11 500 27
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 501 10 501 76
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 502 10 502 11
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 265 15 265 21
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 266 14 266 123
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 267 14 267 15
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 517 10 517 59
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 518 10 518 59
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 490 10 490 133
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 504 4 511 5
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 269 8 277 9
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 257 14 257 144
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 520 4 520 68
  let%span sfset15 = "../../creusot-contracts/src/logic/fset.rs" 201 14 201 57
  let%span sfset16 = "../../creusot-contracts/src/logic/fset.rs" 203 8 203 29
  let%span sfset17 = "../../creusot-contracts/src/logic/fset.rs" 492 4 492 117
  let%span sfset18 = "../../creusot-contracts/src/logic/fset.rs" 248 14 248 117
  let%span sfset19 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sseq20 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use mach.int.Int
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq13] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  use set.Fset
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset19] Fset.add e self
  
  use set.Fset
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset16] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset15] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  use seq.Seq
  
  use seq.Seq
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq20] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 249 4 249 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset18] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 268 4 268 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> replicate'0 self n
  = ([%#sfset10] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    let _ = let _ = () in () in cons'0 self (replicate'0 self (n - 1))
  )
  
  axiom replicate'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> ([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
  = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  use seq.Seq
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 258 4 258 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset11] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty'0 [#"../../creusot-contracts/src/logic/fset.rs" 519 0 519 39] (s : Fset.fset (Seq.seq t_T'0)) : ()
  
   =
    [%#sfset14] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty'0_spec : forall s : Fset.fset (Seq.seq t_T'0) . ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) s
  = s)
  && ([%#sfset7] concat'0 s (singleton'0 (Seq.empty : Seq.seq t_T'0)) = s)
  
  function cons_concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 491 0 491 23] (_1 : ()) : () =
    [%#sfset17] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat'0_spec : forall _1 : () . [%#sfset8] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
  = cons'0 s (concat'0 t u)
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T'0
  
  function concat_replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 503 0 503 54] (n : int) (m : int) (s : Fset.fset t_T'0) : ()
  
  
  goal vc_concat_replicate'0 : ([%#sfset0] 0 <= n /\ 0 <= m)
   -> (if n = 0 then
    ([@expl:replicate requires] [%#sfset3] m >= 0)
    /\ (([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 s m) xs
    = (Seq.length xs = m /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 s x)))
     -> ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) (replicate'0 s m) = replicate'0 s m)
    && ([%#sfset7] concat'0 (replicate'0 s m) (singleton'0 (Seq.empty : Seq.seq t_T'0)) = replicate'0 s m)
     -> (let _ = concat_empty'0 (replicate'0 s m) in [%#sfset1] replicate'0 s (n + m)
    = concat'0 (replicate'0 s n) (replicate'0 s m)))
  else
    ([%#sfset8] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
    = cons'0 s (concat'0 t u))
     -> (let _ = cons_concat'0 () in (([@expl:concat_replicate requires] [%#sfset0] 0 <= n - 1 /\ 0 <= m)
    /\ 0 <= ([%#sfset2] n) /\ ([%#sfset2] n - 1) < ([%#sfset2] n))
    /\ (([%#sfset1] replicate'0 s (n - 1 + m) = concat'0 (replicate'0 s (n - 1)) (replicate'0 s m))
     -> (let _ = concat_replicate'0 (n - 1) m s in [%#sfset1] replicate'0 s (n + m)
    = concat'0 (replicate'0 s n) (replicate'0 s m))))
  )
end
module M_creusot_contracts__logic__fset__concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 519 0 519 39]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 517 10 517 59
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 518 10 518 59
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 520 20 520 66
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 521 20 521 66
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 520 4 520 68
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 257 14 257 144
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 201 14 201 57
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 203 8 203 29
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset8] Fset.mem e self
  
  use seq.Seq
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 258 4 258 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset5] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  use set.Fset
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset9] Fset.add e self
  
  use set.Fset
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset7] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset6] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  use seq.Seq
  
  constant s  : Fset.fset (Seq.seq t_T'0)
  
  function concat_empty'0 [#"../../creusot-contracts/src/logic/fset.rs" 519 0 519 39] (s : Fset.fset (Seq.seq t_T'0)) : ()
  
  
  goal vc_concat_empty'0 : ([%#sfset2] forall xs : Seq.seq t_T'0 . Seq.(++) xs (Seq.empty : Seq.seq t_T'0) = xs)
  && (let _ = () in let _ = () in ([%#sfset3] forall xs : Seq.seq t_T'0 . Seq.(++) (Seq.empty : Seq.seq t_T'0) xs = xs)
  && (let _ = () in let _ = () in ([%#sfset0] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) s = s)
  && ([%#sfset1] concat'0 s (singleton'0 (Seq.empty : Seq.seq t_T'0)) = s)))
end
module M_creusot_contracts__logic__fset__concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 531 0 531 60]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 527 11 527 26
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 528 10 529 67
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 530 10 530 11
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 265 15 265 21
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 266 14 266 123
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 267 14 267 15
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 517 10 517 59
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 518 10 518 59
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 481 10 482 83
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 483 10 484 83
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 500 11 500 27
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 501 10 501 76
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 502 10 502 11
  let%span sfset13 = "../../creusot-contracts/src/logic/fset.rs" 532 4 540 5
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 283 15 283 21
  let%span sfset15 = "../../creusot-contracts/src/logic/fset.rs" 284 14 284 123
  let%span sfset16 = "../../creusot-contracts/src/logic/fset.rs" 285 14 285 15
  let%span sfset17 = "../../creusot-contracts/src/logic/fset.rs" 287 8 294 9
  let%span sfset18 = "../../creusot-contracts/src/logic/fset.rs" 257 14 257 144
  let%span sfset19 = "../../creusot-contracts/src/logic/fset.rs" 269 8 277 9
  let%span sfset20 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq21 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset22 = "../../creusot-contracts/src/logic/fset.rs" 520 4 520 68
  let%span sfset23 = "../../creusot-contracts/src/logic/fset.rs" 201 14 201 57
  let%span sfset24 = "../../creusot-contracts/src/logic/fset.rs" 203 8 203 29
  let%span sfset25 = "../../creusot-contracts/src/logic/fset.rs" 479 0 479 8
  let%span sfset26 = "../../creusot-contracts/src/logic/fset.rs" 504 4 511 5
  let%span sfset27 = "../../creusot-contracts/src/logic/fset.rs" 248 14 248 117
  let%span sfset28 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset29 = "../../creusot-contracts/src/logic/fset.rs" 490 10 490 133
  let%span sfset30 = "../../creusot-contracts/src/logic/fset.rs" 492 4 492 117
  let%span sseq31 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use mach.int.Int
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset20] Fset.mem e self
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq21] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset20] Fset.mem e self
  
  use set.Fset
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset28] Fset.add e self
  
  use set.Fset
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 202 4 202 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset24] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset23] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  use seq.Seq
  
  use set.Fset
  
  use seq.Seq
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq31] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 249 4 249 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset27] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 268 4 268 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> replicate'0 self n
  = ([%#sfset19] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    let _ = let _ = () in () in cons'0 self (replicate'0 self (n - 1))
  )
  
  axiom replicate'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> ([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
  = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  function replicate_up_to'0 [#"../../creusot-contracts/src/logic/fset.rs" 286 4 286 56] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate_up_to'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset14] n >= 0)
   -> replicate_up_to'0 self n
  = ([%#sfset17] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    Fset.union (replicate_up_to'0 self (n - 1)) (replicate'0 self n)
  )
  
  axiom replicate_up_to'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset14] n >= 0)
   -> ([%#sfset15] forall xs : Seq.seq t_T'0 . contains'0 (replicate_up_to'0 self n) xs
  = (Seq.length xs <= n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  use seq.Seq
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 258 4 258 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset18] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty'0 [#"../../creusot-contracts/src/logic/fset.rs" 519 0 519 39] (s : Fset.fset (Seq.seq t_T'0)) : ()
  
   =
    [%#sfset22] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty'0_spec : forall s : Fset.fset (Seq.seq t_T'0) . ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) s
  = s)
  && ([%#sfset7] concat'0 s (singleton'0 (Seq.empty : Seq.seq t_T'0)) = s)
  
  function concat_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 485 0 485 24] (_1 : ()) : () =
    [%#sfset25] ()
  
  axiom concat_union'0_spec : forall _1 : () . ([%#sfset8] forall s1 : Fset.fset (Seq.seq t_T'0), s2 : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . concat'0 (Fset.union s1 s2) t
  = Fset.union (concat'0 s1 t) (concat'0 s2 t))
  && ([%#sfset9] forall s : Fset.fset (Seq.seq t_T'0), t1 : Fset.fset (Seq.seq t_T'0), t2 : Fset.fset (Seq.seq t_T'0) . concat'0 s (Fset.union t1 t2)
  = Fset.union (concat'0 s t1) (concat'0 s t2))
  
  function cons_concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 491 0 491 23] (_1 : ()) : () =
    [%#sfset30] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat'0_spec : forall _1 : () . [%#sfset29] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
  = cons'0 s (concat'0 t u)
  
  function concat_replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 503 0 503 54] (n : int) (m : int) (s : Fset.fset t_T'0) : ()
  
  
  axiom concat_replicate'0_def : forall n : int, m : int, s : Fset.fset t_T'0 . ([%#sfset10] 0 <= n /\ 0 <= m)
   -> concat_replicate'0 n m s
  = ([%#sfset26] if n = 0 then
    let _ = concat_empty'0 (replicate'0 s m) in ()
  else
    let _ = cons_concat'0 () in let _ = concat_replicate'0 (n - 1) m s in ()
  )
  
  axiom concat_replicate'0_spec : forall n : int, m : int, s : Fset.fset t_T'0 . ([%#sfset10] 0 <= n /\ 0 <= m)
   -> ([%#sfset11] replicate'0 s (n + m) = concat'0 (replicate'0 s n) (replicate'0 s m))
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T'0
  
  function concat_replicate_up_to'0 [#"../../creusot-contracts/src/logic/fset.rs" 531 0 531 60] (n : int) (m : int) (s : Fset.fset t_T'0) : ()
  
  
  goal vc_concat_replicate_up_to'0 : ([%#sfset0] 0 <= n /\ n < m)
   -> (if n + 1 = m then
    ([@expl:replicate requires] [%#sfset3] n + 1 >= 0)
    /\ (([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 s (n + 1)) xs
    = (Seq.length xs = n + 1 /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 s x)))
     -> ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) (replicate'0 s (n + 1)) = replicate'0 s (n + 1))
    && ([%#sfset7] concat'0 (replicate'0 s (n + 1)) (singleton'0 (Seq.empty : Seq.seq t_T'0)) = replicate'0 s (n + 1))
     -> (let _ = concat_empty'0 (replicate'0 s (n + 1)) in [%#sfset1] replicate_up_to'0 s m
    = Fset.union (replicate_up_to'0 s n) (concat'0 (replicate'0 s (n + 1)) (replicate_up_to'0 s (m - n - 1)))))
  else
    ([%#sfset8] forall s1 : Fset.fset (Seq.seq t_T'0), s2 : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . concat'0 (Fset.union s1 s2) t
    = Fset.union (concat'0 s1 t) (concat'0 s2 t))
    && ([%#sfset9] forall s : Fset.fset (Seq.seq t_T'0), t1 : Fset.fset (Seq.seq t_T'0), t2 : Fset.fset (Seq.seq t_T'0) . concat'0 s (Fset.union t1 t2)
    = Fset.union (concat'0 s t1) (concat'0 s t2))
     -> (let _ = concat_union'0 () in ([@expl:concat_replicate requires] [%#sfset10] 0 <= n /\ 0 <= m - n - 1)
    /\ (([%#sfset11] replicate'0 s (n + (m - n - 1)) = concat'0 (replicate'0 s n) (replicate'0 s (m - n - 1)))
     -> (let _ = concat_replicate'0 n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] [%#sfset0] 0 <= n
    /\ n < m - 1)
    /\ 0 <= ([%#sfset2] m) /\ ([%#sfset2] m - 1) < ([%#sfset2] m))
    /\ (([%#sfset1] replicate_up_to'0 s (m - 1)
    = Fset.union (replicate_up_to'0 s n) (concat'0 (replicate'0 s (n + 1)) (replicate_up_to'0 s (m - 1 - n - 1))))
     -> (let _ = concat_replicate_up_to'0 n (m - 1) s in [%#sfset1] replicate_up_to'0 s m
    = Fset.union (replicate_up_to'0 s n) (concat'0 (replicate'0 s (n + 1)) (replicate_up_to'0 s (m - n - 1))))))))
  )
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : int) (y : int) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] (x <= y) = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : int) (y : int) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] (x < y) = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : int) (y : int) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] (x >= y) = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : int) (y : int) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] (x > y) = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : int) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord4] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : int) (y : int) (z : int) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord3] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : int) (y : int) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord3] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : int) (y : int) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : int) (y : int) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt8.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  constant z  : UInt8.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt8.t) (y : UInt8.t) (z : UInt8.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt16.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  constant z  : UInt16.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt16.t) (y : UInt16.t) (z : UInt16.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt32.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  constant z  : UInt32.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt32.t) (y : UInt32.t) (z : UInt32.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt128.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  constant z  : UInt128.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt128.t) (y : UInt128.t) (z : UInt128.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int8.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord4] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  constant z  : Int8.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int8.t) (y : Int8.t) (z : Int8.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord3] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord3] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int16.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord4] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  constant z  : Int16.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int16.t) (y : Int16.t) (z : Int16.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord3] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord3] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int32.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord4] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  constant z  : Int32.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int32.t) (y : Int32.t) (z : Int32.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord3] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord3] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord4] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int128.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord4] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  constant z  : Int128.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int128.t) (y : Int128.t) (z : Int128.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord3] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord3] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord4] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Char.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Char.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Char.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Char.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Char.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord4] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  constant z  : Char.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Char.t) (y : Char.t) (z : Char.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord3] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Char.t) (y : Char.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord3] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Char.t) (y : Char.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Char.t) (y : Char.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Bool.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Bool.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Bool.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Bool.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : bool) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord4] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : bool) (y : bool) (z : bool) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord3] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord3] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : bool) (y : bool) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 127 8 127 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'2 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ le_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 132 8 132 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'2 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ lt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 137 8 137 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'2 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ ge_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 142 8 142 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'2 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord2] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ gt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 147 8 147 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'2 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'2_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : (t_A'0, t_B'0)) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 152 8 152 35
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord17] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord15] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Less'0)
   -> ([%#sord14] cmp_log'2 y x = C_Greater'0)
  
  function trans'2 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'2_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord10] cmp_log'2 x y = o)
   -> ([%#sord11] cmp_log'2 y z = o)  -> ([%#sord12] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord9] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord8] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord4] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  constant z  : (t_A'0, t_B'0)
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) (z : (t_A'0, t_B'0)) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 159 8 159 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'2 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 165 8 165 35
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 171 8 171 35
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'2 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'2_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  constant x  : (t_A'0, t_B'0)
  
  constant y  : (t_A'0, t_B'0)
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : (t_A'0, t_B'0)) (y : (t_A'0, t_B'0)) : ()
  
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (* logic::seq::Seq<T> *)
  let%span sseq0 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq1 = "../../creusot-contracts/src/logic/seq.rs" 377 4 377 12
  let%span sseq2 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  type t_T'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq2] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  use seq.Seq
  
  constant _1  : ()
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (_1 : ()) : ()
  
  goal vc_concat_contains'0 : [%#sseq0] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
end
module M_creusot_contracts__pcell__qyi11656593191764906533__clone [#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (* <pcell::Id as std::clone::Clone> *)
  let%span spcell0 = "../../creusot-contracts/src/pcell.rs" 33 14 33 29
  
  type t_Id'0
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (self:t_Id'0) (return'  (ret:t_Id'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_Id'0 = Any.any_l () | & self : t_Id'0 = self ] 
    [ return' (result:t_Id'0)-> {[@expl:clone ensures] [%#spcell0] result = self} (! return' {result}) ]

end
module M_creusot_contracts__pcell__qyi14846468513926953542__take [#"../../creusot-contracts/src/pcell.rs" 263 4 263 68] (* pcell::PCell<T> *)
  let%span spcell0 = "../../creusot-contracts/src/pcell.rs" 264 36 264 48
  let%span spcell1 = "../../creusot-contracts/src/pcell.rs" 263 24 263 28
  let%span spcell2 = "../../creusot-contracts/src/pcell.rs" 263 30 263 34
  let%span spcell3 = "../../creusot-contracts/src/pcell.rs" 259 15 259 37
  let%span spcell4 = "../../creusot-contracts/src/pcell.rs" 263 67 263 68
  let%span spcell5 = "../../creusot-contracts/src/pcell.rs" 260 14 260 53
  let%span spcell6 = "../../creusot-contracts/src/pcell.rs" 261 14 261 46
  let%span spcell7 = "../../creusot-contracts/src/pcell.rs" 262 14 262 49
  let%span sdefault8 = "../../creusot-contracts/src/std/default.rs" 31 26 31 45
  let%span spcell9 = "../../creusot-contracts/src/pcell.rs" 136 27 136 31
  let%span spcell10 = "../../creusot-contracts/src/pcell.rs" 136 33 136 37
  let%span spcell11 = "../../creusot-contracts/src/pcell.rs" 136 67 136 70
  let%span spcell12 = "../../creusot-contracts/src/pcell.rs" 132 15 132 37
  let%span spcell13 = "../../creusot-contracts/src/pcell.rs" 136 78 136 79
  let%span spcell14 = "../../creusot-contracts/src/pcell.rs" 133 14 133 43
  let%span spcell15 = "../../creusot-contracts/src/pcell.rs" 134 14 134 46
  let%span spcell16 = "../../creusot-contracts/src/pcell.rs" 135 14 135 53
  let%span spcell17 = "../../creusot-contracts/src/pcell.rs" 71 8 71 15
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span spcell19 = "../../creusot-contracts/src/pcell.rs" 54 4 54 12
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed21 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant22 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  type t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate is_default'0 [#"../../creusot-contracts/src/std/default.rs" 24 4 24 32] (self : t_T'0)
  
  let rec default'0 (_1:()) (return'  (ret:t_T'0))= any
    [ return' (result:t_T'0)-> {inv'2 result} {[%#sdefault8] is_default'0 result} (! return' {result}) ]
  
  
  type t_UnsafeCell'0  =
    { t_UnsafeCell__value'0: t_T'0 }
  
  type t_PCell'0  =
    { t_PCell__0'0: t_UnsafeCell'0 }
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_UnsafeCell'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_UnsafeCell'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_UnsafeCell__value'0 = value} -> inv'2 value
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PCell'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PCell'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_PCell__0'0 = a_0} -> inv'5 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_PCell'0) =
    [%#sinvariant20] inv'4 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PCell'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_PCell'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use creusot.prelude.MutBorrow
  
  type t_Id'0
  
  type t_PCellOwn'0  =
    { t_PCellOwn__qy95zprivate'0: (); t_PCellOwn__id'0: t_Id'0; t_PCellOwn__val'0: t_T'0 }
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: MutBorrow.t t_PCellOwn'0 }
  
  predicate invariant'3 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed21] inv'2 self
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_T'0 [inv'8 x] . inv'8 x = invariant'3 x
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PCellOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PCellOwn'0 [inv'7 x] . inv'7 x
  = match x with
    | {t_PCellOwn__qy95zprivate'0 = _private ; t_PCellOwn__id'0 = id ; t_PCellOwn__val'0 = val'} -> inv'8 val'
    end
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_PCellOwn'0) =
    [%#sinvariant22] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_PCellOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_PCellOwn'0 [inv'6 x] . inv'6 x = invariant'2 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : MutBorrow.t t_PCellOwn'0) =
    [%#sboxed21] inv'6 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_PCellOwn'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_PCellOwn'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  function id'0 [#"../../creusot-contracts/src/pcell.rs" 221 4 221 25] (self : t_PCell'0) : t_Id'0
  
  function id'1 [#"../../creusot-contracts/src/pcell.rs" 70 4 70 25] (self : t_PCellOwn'0) : t_Id'0 =
    [%#spcell17] self.t_PCellOwn__id'0
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 227 4 227 33] (self : t_GhostBox'0) : MutBorrow.t t_PCellOwn'0
  
   =
    [%#sghost18] self.t_GhostBox__0'0
  
  function view'0 [#"../../creusot-contracts/src/pcell.rs" 56 4 56 33] (self : t_PCellOwn'0) : t_T'0 =
    [%#spcell19] self.t_PCellOwn__val'0
  
  let rec replace'0 (self:t_PCell'0) (perm:t_GhostBox'0) (val':t_T'0) (return'  (ret:t_T'0))= {[@expl:replace 'self' type invariant] [%#spcell9] inv'0 self}
    {[@expl:replace 'perm' type invariant] [%#spcell10] inv'1 perm}
    {[@expl:replace 'val' type invariant] [%#spcell11] inv'2 val'}
    {[@expl:replace requires] [%#spcell12] id'0 self = id'1 (inner_logic'0 perm).current}
    any
    [ return' (result:t_T'0)-> {[%#spcell13] inv'2 result}
      {[%#spcell14] val' = view'0 (inner_logic'0 perm).final}
      {[%#spcell15] result = view'0 (inner_logic'0 perm).current}
      {[%#spcell16] id'0 self = id'1 (inner_logic'0 perm).final}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec take'0[#"../../creusot-contracts/src/pcell.rs" 263 4 263 68] (self:t_PCell'0) (perm:t_GhostBox'0) (return'  (ret:t_T'0))= {[@expl:take 'self' type invariant] [%#spcell1] inv'0 self}
    {[@expl:take 'perm' type invariant] [%#spcell2] inv'1 perm}
    {[@expl:take requires] [%#spcell3] id'0 self = id'1 (inner_logic'0 perm).current}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = s0 [ s0 = default'0 {[%#spcell0] ()} (fun (_ret':t_T'0) ->  [ &_9 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = replace'0 {self} {perm} {_9} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self : t_PCell'0 = self
    | & perm : t_GhostBox'0 = perm
    | & _9 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:take result type invariant] [%#spcell4] inv'2 result}
      {[@expl:take ensures #0] [%#spcell5] id'0 self = id'1 (inner_logic'0 perm).final}
      {[@expl:take ensures #1] [%#spcell6] result = view'0 (inner_logic'0 perm).current}
      {[@expl:take ensures #2] [%#spcell7] is_default'0 (view'0 (inner_logic'0 perm).final)}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__new [#"../../creusot-contracts/src/ptr_own.rs" 52 4 52 56] (* ptr_own::PtrOwn<T> *)
  let%span sptr_own0 = "../../creusot-contracts/src/ptr_own.rs" 52 15 52 16
  let%span sptr_own1 = "../../creusot-contracts/src/ptr_own.rs" 52 24 52 56
  let%span sptr_own2 = "../../creusot-contracts/src/ptr_own.rs" 51 14 51 64
  let%span sptr_own3 = "../../creusot-contracts/src/ptr_own.rs" 61 20 61 23
  let%span sptr_own4 = "../../creusot-contracts/src/ptr_own.rs" 61 36 61 68
  let%span sptr_own5 = "../../creusot-contracts/src/ptr_own.rs" 60 14 60 67
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sboxed7 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own8 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr9 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr10 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed7] inv'0 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  use creusot.prelude.Opaque
  
  type t_PtrOwn'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_PtrOwn'0 }
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (self : Opaque.ptr) : bool =
    [%#sptr10] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr9] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 [#"../../creusot-contracts/src/ptr_own.rs" 26 4 26 34] (self : t_PtrOwn'0) : Opaque.ptr
  
  function val'0 [#"../../creusot-contracts/src/ptr_own.rs" 33 4 33 34] (self : t_PtrOwn'0) : t_T'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ptr_own.rs" 43 4 43 30] (self : t_PtrOwn'0) =
    [%#sptr_own8] not is_null_logic'0 (ptr'0 self) /\ inv'2 (val'0 self)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_PtrOwn'0) =
    [%#sboxed7] inv'5 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : (Opaque.ptr, t_GhostBox'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (Opaque.ptr, t_GhostBox'0) [inv'1 x] . inv'1 x
  = (let (x0, x1) = x in inv'3 x1)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 227 4 227 33] (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost6] self.t_GhostBox__0'0
  
  let rec from_box'0 (val':t_T'0) (return'  (ret:(Opaque.ptr, t_GhostBox'0)))= {[@expl:from_box 'val' type invariant] [%#sptr_own3] inv'2 val'}
    any
    [ return' (result:(Opaque.ptr, t_GhostBox'0))-> {[%#sptr_own4] inv'1 result}
      {[%#sptr_own5] ptr'0 (inner_logic'0 (let (_, a) = result in a)) = (let (a, _) = result in a)
      /\ val'0 (inner_logic'0 (let (_, a) = result in a)) = val'}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"../../creusot-contracts/src/ptr_own.rs" 52 4 52 56] (v:t_T'0) (return'  (ret:(Opaque.ptr, t_GhostBox'0)))= {[@expl:new 'v' type invariant] [%#sptr_own0] inv'0 v}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 = from_box'0 {v} (fun (_ret':(Opaque.ptr, t_GhostBox'0)) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : (Opaque.ptr, t_GhostBox'0) = Any.any_l () | & v : t_T'0 = v ] 
    [ return' (result:(Opaque.ptr, t_GhostBox'0))-> {[@expl:new result type invariant] [%#sptr_own1] inv'1 result}
      {[@expl:new ensures] [%#sptr_own2] ptr'0 (inner_logic'0 (let (_, a) = result in a)) = (let (a, _) = result in a)
      /\ val'0 (inner_logic'0 (let (_, a) = result in a)) = v}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__drop [#"../../creusot-contracts/src/ptr_own.rs" 98 4 98 57] (* ptr_own::PtrOwn<T> *)
  let%span sptr_own0 = "../../creusot-contracts/src/ptr_own.rs" 98 32 98 35
  let%span sptr_own1 = "../../creusot-contracts/src/ptr_own.rs" 97 15 97 31
  let%span sptr_own2 = "../../creusot-contracts/src/ptr_own.rs" 92 34 92 37
  let%span sptr_own3 = "../../creusot-contracts/src/ptr_own.rs" 89 15 89 31
  let%span sptr_own4 = "../../creusot-contracts/src/ptr_own.rs" 92 63 92 69
  let%span sptr_own5 = "../../creusot-contracts/src/ptr_own.rs" 90 14 90 35
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sresolve7 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sboxed8 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own9 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr10 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr11 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  type t_PtrOwn'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_PtrOwn'0 }
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (self : Opaque.ptr) : bool =
    [%#sptr11] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr10] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 [#"../../creusot-contracts/src/ptr_own.rs" 26 4 26 34] (self : t_PtrOwn'0) : Opaque.ptr
  
  type t_T'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed8] inv'3 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function val'0 [#"../../creusot-contracts/src/ptr_own.rs" 33 4 33 34] (self : t_PtrOwn'0) : t_T'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ptr_own.rs" 43 4 43 30] (self : t_PtrOwn'0) =
    [%#sptr_own9] not is_null_logic'0 (ptr'0 self) /\ inv'0 (val'0 self)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_PtrOwn'0) =
    [%#sboxed8] inv'4 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_PtrOwn'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 227 4 227 33] (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost6] self.t_GhostBox__0'0
  
  let rec to_box'0 (ptr:Opaque.ptr) (own:t_GhostBox'0) (return'  (ret:t_T'0))= {[@expl:to_box 'own' type invariant] [%#sptr_own2] inv'1 own}
    {[@expl:to_box requires] [%#sptr_own3] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_T'0)-> {[%#sptr_own4] inv'0 result}
      {[%#sptr_own5] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve7] resolve'2 self
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec drop'0[#"../../creusot-contracts/src/ptr_own.rs" 98 4 98 57] (ptr:Opaque.ptr) (own:t_GhostBox'0) (return'  (ret:()))= {[@expl:drop 'own' type invariant] [%#sptr_own0] inv'1 own}
    {[@expl:drop requires] [%#sptr_own1] ptr = ptr'0 (inner_logic'0 own)}
    (! bb0
    [ bb0 = s0 [ s0 = to_box'0 {ptr} {own} (fun (_ret':t_T'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 _4} s1 | s1 = -{resolve'0 _4}- s2 | s2 = bb2 ] 
    | bb2 = bb3
    | bb3 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l () | & ptr : Opaque.ptr = ptr | & own : t_GhostBox'0 = own | & _4 : t_T'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 47 4 47 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 45 15 45 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 46 14 46 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 43 4 43 23
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  
  type t_T1'0
  
  type t_T2'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T2'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T1'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : (t_T1'0, t_T2'0)) =
    match _1 with
      | (x0, x1) -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : (t_T1'0, t_T2'0)) =
    [%#sresolve3] resolve'2 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  constant self  : (t_T1'0, t_T2'0)
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 47 4 47 31] (self : (t_T1'0, t_T2'0)) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 61 4 61 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 59 15 59 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 60 14 60 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 57 4 57 23
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : MutBorrow.t t_T'0) =
    _1.final = _1.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve3] self.final = self.current
  
  constant self  : MutBorrow.t t_T'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 31] (self : MutBorrow.t t_T'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 73 15 73 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 74 14 74 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 71 4 71 23
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  
  type t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve3] resolve'1 self
  
  constant self  : t_T'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (self : t_T'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 92 4 92 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 90 15 90 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 91 14 91 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 88 4 88 23
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Option'0) =
    match _1 with
      | C_None'0 -> true
      | C_Some'0 x0 -> resolve'1 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve3] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  constant self  : t_Option'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 92 4 92 31] (self : t_Option'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone [#"../../creusot-contracts/src/snapshot.rs" 58 4 58 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot0 = "../../creusot-contracts/src/snapshot.rs" 57 14 57 29
  
  type t_T'0
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/snapshot.rs" 58 4 58 27] (self:t_T'0) (return'  (ret:t_T'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_T'0 = Any.any_l () | & self : t_T'0 = self ] 
    [ return' (result:t_T'0)-> {[@expl:clone ensures] [%#ssnapshot0] result = self} (! return' {result}) ]

end
module M_creusot_contracts__util__unwrap [#"../../creusot-contracts/src/util.rs" 57 0 57 36]
  let%span sutil0 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil1 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sutil2 = "../../creusot-contracts/src/util.rs" 45 11 45 16
  let%span sutil3 = "../../creusot-contracts/src/util.rs" 46 10 46 15
  let%span sutil4 = "../../creusot-contracts/src/util.rs" 47 10 47 11
  let%span sutil5 = "../../creusot-contracts/src/util.rs" 58 4 61 5
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function unreachable'0 [#"../../creusot-contracts/src/util.rs" 48 0 48 28] (_1 : ()) : t_T'0
  
  axiom unreachable'0_spec : forall _1 : () . ([%#sutil2] false)  -> ([%#sutil3] false)
  
  constant op  : t_Option'0
  
  function unwrap'0 [#"../../creusot-contracts/src/util.rs" 57 0 57 36] (op : t_Option'0) : t_T'0
  
  goal vc_unwrap'0 : ([%#sutil0] op <> C_None'0)
   -> match op with
    | C_Some'0 t -> [%#sutil1] C_Some'0 t = op
    | C_None'0 -> ([@expl:unreachable requires] [%#sutil2] false)
    /\ (([%#sutil3] false)  -> ([%#sutil1] C_Some'0 (unreachable'0 ()) = op))
    end
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl__refines [#"../../creusot-contracts/src/std/array.rs" 75 4 75 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 75 4 75 26
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  use creusot.int.UInt64
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray1] view'0 self = Seq.(++) visited (view'0 o)
  
  use seq.Seq
  
  goal refines : [%#sarray0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans__refines [#"../../creusot-contracts/src/std/array.rs" 82 4 82 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 82 4 82 90
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  use creusot.int.UInt64
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray1] view'0 self = Seq.(++) visited (view'0 o)
  
  goal refines : [%#sarray0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap6] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap5] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_IntoIter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  goal refines : [%#shash_map0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (t_K'0, t_V'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (t_K'0, t_V'0)) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap6] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap5] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_IntoIter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  goal refines : [%#shash_map0] forall a : t_IntoIter'0 . forall ab : Seq.seq (t_K'0, t_V'0) . forall b : t_IntoIter'0 . forall bc : Seq.seq (t_K'0, t_V'0) . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_Iter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  goal refines : [%#shash_map0] forall a : t_Iter'0 . forall ab : Seq.seq (t_K'0, t_V'0) . forall b : t_Iter'0 . forall bc : Seq.seq (t_K'0, t_V'0) . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, t_V'0)) (x : (t_K'0, t_V'0))
  
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq (t_K'0, t_V'0)) (o : t_Iter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited (k2, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'0 (let (a, _) = Seq.get visited i1 in a) = deep_model'0 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  goal refines : [%#shash_map0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (t_K'0, t_V'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (t_K'0, t_V'0)) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  use creusot.prelude.MutBorrow
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (x : (t_K'0, MutBorrow.t t_V'0))
  
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (o : t_IterMut'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'1 (let (a, _) = Seq.get visited i1 in a) = deep_model'1 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  goal refines : [%#shash_map0] forall a : t_IterMut'0 . forall ab : Seq.seq (t_K'0, MutBorrow.t t_V'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (t_K'0, MutBorrow.t t_V'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  use creusot.prelude.MutBorrow
  
  type t_V'0
  
  use seq.Seq
  
  use mach.int.Int
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  use seq.Seq
  
  use seq.Seq
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (x : (t_K'0, MutBorrow.t t_V'0))
  
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  use map.Map
  
  use map.Map
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq (t_K'0, MutBorrow.t t_V'0)) (o : t_IterMut'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited (k, v)
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k /\ contains'0 visited (k2, v2)))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited (k1, v)) \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited
    /\ deep_model'1 (let (a, _) = Seq.get visited i1 in a) = deep_model'1 (let (a, _) = Seq.get visited i2 in a)
     -> i1 = i2)
  
  use seq.Seq
  
  goal refines : [%#shash_map0] forall self : t_IterMut'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (t_K'0, MutBorrow.t t_V'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (t_K'0, MutBorrow.t t_V'0)) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 108 4 108 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 96 8 96 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 52 4 52 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 95 4 95 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  use seq.Seq
  
  goal refines : [%#shash_set0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 115 4 115 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 115 4 115 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 96 8 96 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (t_NonNull'0, t_Layout'0, ())
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 52 4 52 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 95 4 95 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  use seq.Seq
  
  goal refines : [%#shash_set0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 154 4 154 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 154 4 154 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 135 8 135 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 126 4 126 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 134 4 134 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  use seq.Seq
  
  goal refines : [%#shash_set0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 147 4 147 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 135 8 135 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 126 4 126 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 134 4 134 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  use seq.Seq
  
  goal refines : [%#shash_set0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 222 4 222 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 222 4 222 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 210 8 210 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 201 4 201 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 209 4 209 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  use seq.Seq
  
  goal refines : [%#shash_set0] forall self : t_Intersection'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 229 4 229 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 229 4 229 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 210 8 210 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 64 16 71 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use set.Fset
  
  type t_DeepModelTy'0
  
  use set.Fset
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 201 4 201 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  use seq.Seq
  
  use mach.int.Int
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  use seq.Seq
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 59 0 63 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 209 4 209 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  use seq.Seq
  
  goal refines : [%#shash_set0] forall a : t_Intersection'0 . forall ab : Seq.seq t_T'0 . forall b : t_Intersection'0 . forall bc : Seq.seq t_T'0 . forall c : t_Intersection'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl__refines [#"../../creusot-contracts/src/std/deque.rs" 185 4 185 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 185 4 185 26
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  use seq.Seq
  
  goal refines : [%#sdeque0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans__refines [#"../../creusot-contracts/src/std/deque.rs" 192 4 192 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 192 4 192 90
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sdeque0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal refines : [%#scloned0] forall a : t_Cloned'0 . forall ab : Seq.seq t_T'0 . forall b : t_Cloned'0 . forall bc : Seq.seq t_T'0 . forall c : t_Cloned'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal refines : [%#scloned0] forall self : t_Cloned'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal refines : [%#scopied0] forall self : t_Copied'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'0 self  -> inv'1 (iter'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  use seq.Seq
  
  goal refines : [%#scopied0] forall a : t_Copied'0 . forall ab : Seq.seq t_T'0 . forall b : t_Copied'0 . forall bc : Seq.seq t_T'0 . forall c : t_Copied'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  goal refines : [%#sempty0] forall self : t_Empty'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  use seq.Seq
  
  goal refines : [%#sempty0] forall a : t_Empty'0 . forall ab : Seq.seq t_T'0 . forall b : t_Empty'0 . forall bc : Seq.seq t_T'0 . forall c : t_Empty'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate7 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.prelude.MutBorrow
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate7] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
  
   =
    [%#senumerate1] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  goal refines : [%#senumerate0] forall a : t_Enumerate'0 . forall ab : Seq.seq (UInt64.t, t_Item'0) . forall b : t_Enumerate'0 . forall bc : Seq.seq (UInt64.t, t_Item'0) . forall c : t_Enumerate'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate7 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.prelude.MutBorrow
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate7] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, t_Item'0)) (o : t_Enumerate'0)
  
   =
    [%#senumerate1] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  use seq.Seq
  
  goal refines : [%#senumerate0] forall self : t_Enumerate'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (UInt64.t, t_Item'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (UInt64.t, t_Item'0)) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter2] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter3] inv'0 self  -> inv'1 (func'0 self)
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  goal refines : [%#sfilter0] forall self : t_Filter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter2] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter3] inv'0 self  -> inv'1 (func'0 self)
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  goal refines : [%#sfilter0] forall a : t_Filter'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Filter'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Filter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map5] forall i : t_Item'0 . precondition'0 f (i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map6] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map7] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 (i) f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 (i) f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map2] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map4] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  use seq.Seq
  
  goal refines : [%#sfilter_map0] forall self : t_FilterMap'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map5] forall i : t_Item'0 . precondition'0 f (i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map6] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map7] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 (i) f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 (i) f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map2] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map4] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  use seq.Seq
  
  goal refines : [%#sfilter_map0] forall a : t_FilterMap'0 . forall ab : Seq.seq t_B'0 . forall b : t_FilterMap'0 . forall bc : Seq.seq t_B'0 . forall c : t_FilterMap'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse2] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse3] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  goal refines : [%#sfuse0] forall a : t_Fuse'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Fuse'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Fuse'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse2] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse3] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  goal refines : [%#sfuse0] forall self : t_Fuse'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap2] inv'0 self  -> inv'1 (func'0 self)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter11] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  goal refines : [%#smap0] forall self : t_Map'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  use seq.Seq
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap2] inv'0 self  -> inv'1 (func'0 self)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter11] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  goal refines : [%#smap0] forall a : t_Map'0 . forall ab : Seq.seq t_B'0 . forall b : t_Map'0 . forall bc : Seq.seq t_B'0 . forall c : t_Map'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops2 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  use seq.Seq
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops8] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops5] unnest'0 self b)
   -> ([%#sops6] unnest'0 b c)  -> ([%#sops7] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops4] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops2] postcondition_mut'0 self args res_state res)
   -> ([%#sops3] unnest'0 self res_state)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter9] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv1] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  goal refines : [%#smap_inv0] forall self : t_MapInv'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops2 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  use seq.Seq
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops8] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops5] unnest'0 self b)
   -> ([%#sops6] unnest'0 b c)  -> ([%#sops7] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops4] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops2] postcondition_mut'0 self args res_state res)
   -> ([%#sops3] unnest'0 self res_state)
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter9] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv1] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  use seq.Seq
  
  goal refines : [%#smap_inv0] forall a : t_MapInv'0 . forall ab : Seq.seq t_B'0 . forall b : t_MapInv'0 . forall bc : Seq.seq t_B'0 . forall c : t_MapInv'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans__refines [#"../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  goal refines : [%#sonce0] forall a : t_Once'0 . forall ab : Seq.seq t_T'0 . forall b : t_Once'0 . forall bc : Seq.seq t_T'0 . forall c : t_Once'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl__refines [#"../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#sonce0] forall self : t_Once'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall self : t_Range'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall a : t_Range'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_Range'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_Range'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall a : t_RangeInclusive'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_RangeInclusive'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_RangeInclusive'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall self : t_RangeInclusive'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  goal refines : [%#srepeat0] forall self : t_Repeat'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  use seq.Seq
  
  goal refines : [%#srepeat0] forall a : t_Repeat'0 . forall ab : Seq.seq t_T'0 . forall b : t_Repeat'0 . forall bc : Seq.seq t_T'0 . forall c : t_Repeat'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces_back'0 a ab b)
   -> ([%#siter5] produces_back'0 b bc c)  -> ([%#siter6] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter3] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev1] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#srev0] forall self : t_Rev'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces_back'0 a ab b)
   -> ([%#siter5] produces_back'0 b bc c)  -> ([%#siter6] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter3] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev1] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#srev0] forall a : t_Rev'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Rev'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Rev'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip1] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal refines : [%#sskip0] forall a : t_Skip'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Skip'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Skip'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip1] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal refines : [%#sskip0] forall self : t_Skip'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl__refines [#"../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake1] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#stake0] forall self : t_Take'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans__refines [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake1] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#stake0] forall a : t_Take'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Take'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Take'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_A'0
  
  type t_B'0
  
  use creusot.int.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_A'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip2] inv'0 self  -> inv'1 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'2 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'2_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter5] produces'2 a ab b)
   -> ([%#siter6] produces'2 b bc c)  -> ([%#siter7] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_B'0 . [%#siter4] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
  
   =
    [%#szip1] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  goal refines : [%#szip0] forall a : t_Zip'0 . forall ab : Seq.seq (t_Item'0, t_Item'1) . forall b : t_Zip'0 . forall bc : Seq.seq (t_Item'0, t_Item'1) . forall c : t_Zip'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  type t_A'0
  
  type t_B'0
  
  use creusot.int.UInt64
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_A'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip2] inv'0 self  -> inv'1 (itera'0 self)
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter5] produces'2 a ab b)
   -> ([%#siter6] produces'2 b bc c)  -> ([%#siter7] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_B'0 . [%#siter4] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq (t_Item'0, t_Item'1)) (o : t_Zip'0)
  
   =
    [%#szip1] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  use seq.Seq
  
  goal refines : [%#szip0] forall self : t_Zip'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (t_Item'0, t_Item'1)) self
   -> produces'0 self (Seq.empty : Seq.seq (t_Item'0, t_Item'1)) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl__refines [#"../../creusot-contracts/src/std/iter.rs" 263 4 263 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 263 4 263 26
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter3] produces'1 a ab b)
   -> ([%#siter4] produces'1 b bc c)  -> ([%#siter5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter2] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter1] produces'1 self.current visited o.current /\ self.final = o.final
  
  goal refines : [%#siter0] forall self : MutBorrow.t t_I'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans__refines [#"../../creusot-contracts/src/std/iter.rs" 270 4 270 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 270 4 270 90
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter3] produces'1 a ab b)
   -> ([%#siter4] produces'1 b bc c)  -> ([%#siter5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter2] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter1] produces'1 self.current visited o.current /\ self.final = o.final
  
  goal refines : [%#siter0] forall a : MutBorrow.t t_I'0 . forall ab : Seq.seq t_Item'0 . forall b : MutBorrow.t t_I'0 . forall bc : Seq.seq t_Item'0 . forall c : MutBorrow.t t_I'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 477 4 477 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 477 4 477 26
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 484 4 484 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 484 4 484 90
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 469 12 470 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 453 4 453 30] (self : t_IntoIter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 467 4 467 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  goal refines : [%#soption0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi11122593048316696412__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 530 4 530 26] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 530 4 530 26
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 522 12 523 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi11122593048316696412__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 537 4 537 90] (* <std::option::Iter<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 537 4 537 90
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 522 12 523 96
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 506 4 506 34] (self : t_Iter'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 520 4 520 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  goal refines : [%#soption0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi13775167061943888590__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 593 4 593 90] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 593 4 593 90
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 578 12 579 96
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  use seq.Seq
  
  goal refines : [%#soption0] forall a : t_IterMut'0 . forall ab : Seq.seq (MutBorrow.t t_T'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (MutBorrow.t t_T'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi13775167061943888590__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 586 4 586 26] (* <std::option::IterMut<'a, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 586 4 586 26
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 578 12 579 96
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 562 4 562 38] (self : t_IterMut'0) : t_Option'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_IterMut'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 433 4 433 90
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 426 4 426 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 426 4 426 26
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 403 4 403 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 417 4 417 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  use seq.Seq
  
  goal refines : [%#sslice0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 480 4 480 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 480 4 480 26
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 473 12 473 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel5] view'2 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice2] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice4] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice1] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  use seq.Seq
  
  goal refines : [%#sslice0] forall self : t_IterMut'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 487 4 487 90
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 473 12 473 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.slice.Slice64
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel5] view'2 self.current
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice2] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice4] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 471 4 471 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice1] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall a : t_IterMut'0 . forall ab : Seq.seq (MutBorrow.t t_T'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (MutBorrow.t t_T'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans__refines [#"../../creusot-contracts/src/std/vec.rs" 290 4 290 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 290 4 290 72
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  goal refines : [%#svec0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl__refines [#"../../creusot-contracts/src/std/vec.rs" 283 4 283 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 283 4 283 26
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  use seq.Seq
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  use seq.Seq
  
  goal refines : [%#svec0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 161 4 161 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1__refines [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 189 4 189 33
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp__refines [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 200 4 200 31
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl__refines [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 176 4 176 20
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans__refines [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 183 4 183 52
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall z : t_Reverse'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2__refines [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 195 4 195 33
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 156 4 156 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 166 4 166 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 171 4 171 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 437 8 442 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 436 4 436 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match (self, o) with
      | (C_None'0, C_None'0) -> C_Equal'0
      | (C_None'0, C_Some'0 _) -> C_Less'0
      | (C_Some'0 _, C_None'0) -> C_Greater'0
      | (C_Some'0 x, C_Some'0 y) -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall z : t_Option'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<=) x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Real.(<=) x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<) x y
  = (cmp_log'0 x y = C_Less'0)  -> Real.(<) x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>=) x y
  = (cmp_log'0 x y <> C_Less'0)  -> Real.(>=) x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>) x y
  = (cmp_log'0 x y = C_Greater'0)  -> Real.(>) x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall z : Real.real . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 29 4 29 12
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use real.Real
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x >= y) = (cmp_log'0 x y <> C_Less'0)
   -> (x >= y) = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall result : () . cmp_log'0 x x = C_Equal'0  -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x > y)
  = (cmp_log'0 x y = C_Greater'0)  -> (x > y) = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x <= y)
  = (cmp_log'0 x y <> C_Greater'0)  -> (x <= y) = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x < y) = (cmp_log'0 x y = C_Less'0)
   -> (x < y) = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x = y) = (cmp_log'0 x y = C_Equal'0)
   -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 181 4 181 12
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use mach.int.Int
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall z : int . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall z : UInt8.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall z : UInt16.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall z : UInt32.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall z : UInt128.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall z : Int8.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int8
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall z : Int16.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int16
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall z : Int32.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int32
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall z : Int128.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int128
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Char.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Char.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall z : Char.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Char.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Char
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Char.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Bool.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Bool.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Bool.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall z : bool . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.prelude.Bool
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Bool.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'2 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ gt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'2 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ ge_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ gt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'2 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'2_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'2 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ le_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'0 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'2 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'2_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'2 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'2_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall z : (t_A'0, t_B'0) . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'2 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0))
  
   =
    [%#sord1] (let (a, _) = self in a) = (let (a, _) = o in a)
    /\ lt_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    \/ lt_log'2 (let (a, _) = self in a) (let (a, _) = o in a)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 307 8 314 11
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'2 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : (t_A'0, t_B'0)) (o : (t_A'0, t_B'0)) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = C_Equal'0 then
      cmp_log'2 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
  
  
  goal refines : [%#sord0] forall x : (t_A'0, t_B'0) . forall y : (t_A'0, t_B'0) . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__deque__qyi15330951746891243504__resolve_coherence__refines [#"../../creusot-contracts/src/std/deque.rs" 71 4 71 31] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 71 4 71 31
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 64 20 64 83
  let%span sdeque2 = "../../creusot-contracts/src/std/deque.rs" 16 14 16 41
  let%span sdeque3 = "../../creusot-contracts/src/std/deque.rs" 44 8 44 31
  
  use creusot.int.UInt64
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_VecDeque'0  =
    { t_VecDeque__head'0: UInt64.t; t_VecDeque__len'0: UInt64.t; t_VecDeque__buf'0: t_RawVec'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_RawVec'0) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_VecDeque'0) =
    match _1 with
      | {t_VecDeque__head'0 = x0 ; t_VecDeque__len'0 = x1 ; t_VecDeque__buf'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'2 x0
      end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_VecDeque'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_VecDeque'0 [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 17 4 17 27] (self : t_VecDeque'0) : Seq.seq t_T'0
  
  axiom view'0_spec : forall self : t_VecDeque'0 . [%#sdeque2] Seq.length (view'0 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/std/deque.rs" 43 4 43 47] (self : t_VecDeque'0) (ix : int) : t_T'0
  
   =
    [%#sdeque3] Seq.get (view'0 self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/deque.rs" 63 4 63 28] (self : t_VecDeque'0) =
    [%#sdeque1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  goal refines : [%#sdeque0] forall self : t_VecDeque'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi7712864753404203214__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 21 8 21 29
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Cloned'0) =
    match _1 with
      | {t_Cloned__it'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Cloned'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Cloned'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 20 4 20 28] (self : t_Cloned'0) =
    [%#scloned1] resolve'1 (iter'0 self)
  
  goal refines : [%#scloned0] forall self : t_Cloned'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi10817769304312191898__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31] (* <std::iter::Copied<I> as resolve::Resolve> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Copied'0) =
    match _1 with
      | {t_Copied__it'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Copied'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Copied'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 20 4 20 28] (self : t_Copied'0) =
    [%#scopied1] resolve'1 (iter'0 self)
  
  goal refines : [%#scopied0] forall self : t_Copied'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi7229971731912667430__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 30 8 30 29
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Enumerate'0) =
    match _1 with
      | {t_Enumerate__iter'0 = x0 ; t_Enumerate__count'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  axiom inv_axiom'1 : forall x : t_Enumerate'0 [inv'1 x] . inv'1 x
   -> match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Enumerate'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 29 4 29 28] (self : t_Enumerate'0) =
    [%#senumerate1] resolve'2 (iter'0 self)
  
  goal refines : [%#senumerate0] forall self : t_Enumerate'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi7619436869179474426__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map.rs" 40 4 40 31] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 40 4 40 31
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 32 8 32 54
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Map'0) =
    match _1 with
      | {t_Map__iter'0 = x0 ; t_Map__f'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Map'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'3 f
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Map'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap2] inv'1 self  -> inv'2 (iter'0 self)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap3] inv'1 self  -> inv'3 (func'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/map.rs" 31 4 31 28] (self : t_Map'0) =
    [%#smap1] resolve'2 (iter'0 self) /\ resolve'1 (func'0 self)
  
  goal refines : [%#smap0] forall self : t_Map'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_F'0
  
  type t_B'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_B'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Seq.seq t_B'0) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_MapInv'0) =
    match _1 with
      | {t_MapInv__iter'0 = x0 ; t_MapInv__func'0 = x1 ; t_MapInv__produced'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'1 : forall x : t_MapInv'0 [inv'1 x] . inv'1 x
   -> match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'2 iter /\ inv'3 func
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_MapInv'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self : t_MapInv'0) =
    [%#smap_inv1] resolve'3 self.t_MapInv__iter'0 /\ resolve'2 self.t_MapInv__func'0
  
  goal refines : [%#smap_inv0] forall self : t_MapInv'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi1800235112549046777__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31] (* <std::iter::Skip<I> as resolve::Resolve> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 32 12 32 33
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Skip'0) =
    match _1 with
      | {t_Skip__iter'0 = x0 ; t_Skip__n'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Skip'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Skip'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 30 4 30 28] (self : t_Skip'0) =
    [%#sskip1] resolve'2 (iter'0 self)
  
  goal refines : [%#sskip0] forall self : t_Skip'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi7846602308660485643__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31] (* <std::iter::Take<I> as resolve::Resolve> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 41 8 41 29
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Take'0) =
    match _1 with
      | {t_Take__iter'0 = x0 ; t_Take__n'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Take'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Take'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/take.rs" 40 4 40 28] (self : t_Take'0) =
    [%#stake1] resolve'2 (iter'0 self)
  
  goal refines : [%#stake0] forall self : t_Take'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi6798028551487775744__resolve_coherence__refines [#"../../creusot-contracts/src/std/slice.rs" 459 4 459 31] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 459 4 459 31
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 451 20 451 36
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ()) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Opaque.ptr) =
    true
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_NonNull'0) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_IterMut'0) =
    match _1 with
      | {t_IterMut__ptr'0 = x0 ; t_IterMut__end_or_len'0 = x1 ; t_IterMut__qy95zmarker'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  use seq.Seq
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : Slice64.slice t_T'0 . ([%#sslice3] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice4] view'1 self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice2] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/slice.rs" 450 4 450 28] (self : t_IterMut'0) =
    [%#sslice1] (view'0 self).current = (view'0 self).final
  
  goal refines : [%#sslice0] forall self : t_IterMut'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi16169840827095121464__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 61 4 61 31] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 61 4 61 31
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 54 20 54 83
  let%span svec2 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex3 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span svec5 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed7 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use creusot.int.UInt64
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_A'0
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: t_A'0 }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_RawVec'0) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Vec'0) =
    match _1 with
      | {t_Vec__buf'0 = x0 ; t_Vec__len'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  type t_T'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'3 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed7] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  use seq.Seq
  
  predicate invariant'2 [#"../../creusot-contracts/src/logic/seq.rs" 628 4 628 30] (self : Seq.seq t_T'0) =
    [%#sseq6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 22 4 22 27] (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec2] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/vec.rs" 70 4 70 30] (self : t_Vec'0) =
    [%#svec5] inv'2 (view'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Vec'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 28 4 28 47] (self : t_Vec'0) (ix : int) : t_T'0
  
   =
    [%#sindex3] Seq.get (view'0 self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 53 4 53 28] (self : t_Vec'0) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  goal refines : [%#svec0] forall self : t_Vec'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9945000909994515642__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 261 4 261 31] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 261 4 261 31
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 254 20 254 83
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  use creusot.int.UInt64
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Opaque.ptr) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_NonNull'0) =
    true
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_ManuallyDrop'0) =
    true
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ()) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_IntoIter'0) =
    match _1 with
      | {t_IntoIter__buf'0 = x0 ; t_IntoIter__phantom'0 = x1 ; t_IntoIter__cap'0 = x2 ; t_IntoIter__alloc'0 = x3 ; t_IntoIter__ptr'0 = x4 ; t_IntoIter__end'0 = x5} -> resolve'1 x5
      /\ resolve'2 x4 /\ resolve'3 x3 /\ resolve'4 x2 /\ resolve'5 x1 /\ resolve'2 x0
      end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_ManuallyDrop'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_ManuallyDrop'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_ManuallyDrop__value'0 = value} -> inv'3 value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_IntoIter__buf'0 = buf ; t_IntoIter__phantom'0 = phantom ; t_IntoIter__cap'0 = cap ; t_IntoIter__alloc'0 = alloc ; t_IntoIter__ptr'0 = ptr ; t_IntoIter__end'0 = end'} -> inv'2 alloc
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_IntoIter'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use mach.int.Int
  
  use seq.Seq
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  use seq.Seq
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 253 4 253 28] (self : t_IntoIter'0) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'6 (Seq.get (view'0 self) i)
  
  goal refines : [%#svec0] forall self : t_IntoIter'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi14191374204198111214__resolve_coherence__refines [#"../../creusot-contracts/src/ghost.rs" 118 4 118 31] (* <ghost::GhostBox<T> as resolve::Resolve> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 118 4 118 31
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed4 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve2] resolve'3 self
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0) =
    resolve'2 _1
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_GhostBox'0) =
    match _1 with
      | {t_GhostBox__0'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed4] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 109 4 109 28] (self : t_GhostBox'0) =
    [%#sghost1] resolve'2 self.t_GhostBox__0'0
  
  goal refines : [%#sghost0] forall self : t_GhostBox'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ inv'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 47 4 47 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 47 4 47 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_T1'0
  
  type t_T2'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T2'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T1'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : (t_T1'0, t_T2'0)) =
    match _1 with
      | (x0, x1) -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T1'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T2'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : (t_T1'0, t_T2'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : (t_T1'0, t_T2'0) [inv'1 x] . inv'1 x
  = (let (x0, x1) = x in inv'2 x0 /\ inv'3 x1)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : (t_T1'0, t_T2'0)) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : (t_T1'0, t_T2'0))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (t_T1'0, t_T2'0) [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : (t_T1'0, t_T2'0)) =
    [%#sresolve1] resolve'2 (let (a, _) = self in a) /\ resolve'1 (let (_, a) = self in a)
  
  goal refines : [%#sresolve0] forall self : (t_T1'0, t_T2'0) . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 61 4 61 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 61 4 61 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : MutBorrow.t t_T'0) =
    _1.final = _1.current
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant3] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve1] self.final = self.current
  
  goal refines : [%#sresolve0] forall self : MutBorrow.t t_T'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 75 4 75 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed3 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed3] inv'2 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve1] resolve'1 self
  
  goal refines : [%#sresolve0] forall self : t_T'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 92 4 92 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 92 4 92 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Option'0) =
    match _1 with
      | C_None'0 -> true
      | C_Some'0 x0 -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve1] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  goal refines : [%#sresolve0] forall self : t_Option'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 39 4 39 10
  let%span sfuse5 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse6 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse7 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse8 = "../../creusot-contracts/src/std/iter/fuse.rs" 44 4 44 10
  let%span sfuse9 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse10 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse9] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse10] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
  
   =
    [%#sfuse8] ()
  
  axiom produces_trans'0_spec : forall a : t_Fuse'0, ab : Seq.seq t_Item'0, b : t_Fuse'0, bc : Seq.seq t_Item'0, c : t_Fuse'0 . ([%#sfuse5] produces'0 a ab b)
   -> ([%#sfuse6] produces'0 b bc c)  -> ([%#sfuse7] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse'0) : () =
    [%#sfuse4] ()
  
  axiom produces_refl'0_spec : forall self : t_Fuse'0 . [%#sfuse3] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t t_Fuse'0) : t_Option'0 =
    [%#smodel11] view'0 self.current
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : MutBorrow.t t_Fuse'0) =
    [%#sfuse2] (view'1 self = C_None'0
    \/ (exists it : MutBorrow.t t_I'0 . completed'1 it /\ view'1 self = C_Some'0 (it.current)))
    /\ view'0 self.final = C_None'0
  
  goal refines : [%#sfuse0] forall self : MutBorrow.t t_Fuse'0 . forall steps : Seq.seq t_Item'0 . forall next : t_Fuse'0 . produces'0 self.final steps next
  /\ completed'0 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ (forall result : () . steps = (Seq.empty : Seq.seq t_Item'0) /\ self.final = next
   -> steps = (Seq.empty : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 68
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 182 12 187 74
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 21 4 21 10
  let%span smap_inv7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 26 4 26 10
  let%span sinvariant11 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops16 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops17 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops18 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops19 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops20 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops21 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops22 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span smap_inv23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 74 12 76 73
  let%span smap_inv24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 156 47
  let%span smap_inv25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 124 14 124 81
  let%span smap_inv26 = "../../creusot-contracts/src/std/iter/map_inv.rs" 127 12 132 88
  let%span smap_inv27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 117 12 119 63
  let%span smap_inv28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  use seq.Seq
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  use seq.Seq
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0))
  
  
  predicate next_precondition'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 115 4 115 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv27] forall e : t_Item'0, i : t_I'0 . produces'1 iter (Seq.singleton e) i
     -> precondition'0 func (e, produced)
  
  type t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res : t_B'0 . [%#sops22] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops19] unnest'0 self b)
   -> ([%#sops20] unnest'0 b c)  -> ([%#sops21] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops18] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : (t_Item'0, Seq.seq t_Item'0)) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : (t_Item'0, Seq.seq t_Item'0), res_state : t_F'0, res : t_B'0 . ([%#sops16] postcondition_mut'0 self args res_state res)
   -> ([%#sops17] unnest'0 self res_state)
  
  use seq.Seq
  
  predicate preservation'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 49] (iter : t_I'0) (func : t_F'0)
  
   =
    [%#smap_inv28] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, s)
     -> postcondition_mut'0 f.current (e1, s) f.final b  -> precondition'0 f.final (e2, Seq.snoc s e1)
  
  predicate reinitialize'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 33] (_1 : ()) =
    [%#smap_inv24] forall iter : MutBorrow.t t_I'0, func : t_F'0 . completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  predicate preservation_inv'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv26] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, Seq.(++) produced s)
     -> postcondition_mut'0 f.current (e1, Seq.(++) produced s) f.final b
     -> precondition'0 f.final (e2, Seq.snoc (Seq.(++) produced s) e1)
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv25] produced
  = (Seq.empty : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 72 4 72 30] (self : t_MapInv'0) =
    [%#smap_inv23] reinitialize'0 ()
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_MapInv'0 [inv'3 x] . inv'3 x
  = (invariant'1 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'4 iter /\ inv'5 func
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_MapInv'0) =
    [%#sinvariant11] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_MapInv'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv4] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
   =
    [%#smap_inv10] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv7] produces'0 a ab b)
   -> ([%#smap_inv8] produces'0 b bc c)  -> ([%#smap_inv9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : () =
    [%#smap_inv6] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . [%#smap_inv5] produces'0 self (Seq.empty : Seq.seq t_B'0) self
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : MutBorrow.t t_MapInv'0)
   =
    [%#smap_inv1] (self.final).t_MapInv__produced'0 = (Seq.empty : Seq.seq t_Item'0)
    /\ completed'1 (MutBorrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  use seq.Seq
  
  predicate produces_one'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv3] exists f : MutBorrow.t t_F'0, e : t_Item'0 . f.current = self.t_MapInv__func'0
    /\ f.final = succ.t_MapInv__func'0
    /\ produces'1 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.snoc self.t_MapInv__produced'0 e
    /\ precondition'0 f.current (e, self.t_MapInv__produced'0)
    /\ postcondition_mut'0 f.current (e, self.t_MapInv__produced'0) f.final visited
  
  axiom produces_one'0_spec : forall self : t_MapInv'0, visited : t_B'0, succ : t_MapInv'0 . [%#smap_inv2] produces_one'0 self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  goal refines : [%#smap_inv0] forall self : MutBorrow.t t_MapInv'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : t_Option'0 . match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces_one'0 self.current v self.final
    end
  /\ inv'1 result
   -> match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall self : t_Range'0 . forall result : () . produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall a : t_Range'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_Range'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_Range'0 . produces_back'0 b bc c
  /\ produces_back'0 a ab b
   -> produces_back'0 b bc c
  /\ produces_back'0 a ab b
  /\ (forall result : () . produces_back'0 a (Seq.(++) ab bc) c  -> produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall self : t_RangeInclusive'0 . forall result : () . produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 77 4 80 5
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  use mach.int.Int
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  use seq.Seq
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  use seq.Seq
  
  goal refines : [%#srange0] forall a : t_RangeInclusive'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_RangeInclusive'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_RangeInclusive'0 . produces_back'0 b bc c
  /\ produces_back'0 a ab b
   -> produces_back'0 b bc c
  /\ produces_back'0 a ab b
  /\ (forall result : () . produces_back'0 a (Seq.(++) ab bc) c  -> produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__unnest_trans__refines [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 129 4 129 43
  
  type t_F'0
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall b : t_F'0 . forall c : t_F'0 . unnest'0 b c /\ unnest'0 self b
   -> unnest'0 b c /\ unnest'0 self b /\ (forall result : () . unnest'0 self c  -> unnest'0 self c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__unnest_refl__refines [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 122 4 122 24
  
  type t_F'0
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall result : () . unnest'0 self self  -> unnest'0 self self
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__fn_mut_once__refines [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 135 4 135 55
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
   -> postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__postcondition_mut_unnest__refines [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 117 4 117 85
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
  
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res_state : t_F'0 . forall res : t_Output'0 . postcondition_mut'0 self args res_state res
   -> postcondition_mut'0 self args res_state res
  /\ (forall result : () . unnest'0 self res_state  -> unnest'0 self res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_mut__refines [#"../../creusot-contracts/src/std/ops.rs" 151 4 151 67] (* <F as std::ops::FnExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 151 4 151 67
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
  
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 144 4 144 68] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res_state : t_F'0 . forall res : t_Output'0 . forall result : () . postcondition_mut'0 self args res_state res
  = (self = res_state /\ postcondition'0 self args res)
   -> postcondition_mut'0 self args res_state res = (self = res_state /\ postcondition'0 self args res)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_once__refines [#"../../creusot-contracts/src/std/ops.rs" 156 4 156 51] (* <F as std::ops::FnExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 156 4 156 51
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 144 4 144 68] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (resolve'0 self /\ postcondition'0 self args res)
   -> postcondition_once'0 self args res = (resolve'0 self /\ postcondition'0 self args res)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 81 4 81 34
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  goal refines : [%#sptr0] forall self : Opaque.ptr . forall result : bool . result = (addr_logic'0 self = 0)
   -> result = (addr_logic'0 self = 0)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 97 4 97 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 97 4 97 34
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 90 4 90 30] (self : Opaque.ptr) : int
  
  goal refines : [%#sptr0] forall self : Opaque.ptr . forall result : bool . result = (addr_logic'0 self = 0)
   -> result = (addr_logic'0 self = 0)
end
module M_creusot_contracts__ghost__qyi4711228197303399097__clone__refines [#"../../creusot-contracts/src/ghost.rs" 50 4 50 27] (* <ghost::GhostBox<T> as std::clone::Clone> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 50 4 50 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed2] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sghost0] forall self : t_GhostBox'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_GhostBox'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__fmap__qyi1775402764303793352__clone__refines [#"../../creusot-contracts/src/logic/fmap.rs" 476 4 476 27] (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 476 4 476 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil6 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil7 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  use map.Map
  
  use map.Map
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
  
   =
    [%#sfmap5] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap'0) (k : t_K'0) : bool
  
   =
    [%#sfmap3] get_unsized'0 self k <> C_None'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_K'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_V'0) =
    [%#sboxed9] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  function unwrap'0 [#"../../creusot-contracts/src/util.rs" 57 0 57 36] (op : t_Option'0) : t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil6] op <> C_None'0)
   -> ([%#sutil7] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self : t_FMap'0) (k : t_K'0) : t_V'0
  
   =
    [%#sfmap4] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'1 [#"../../creusot-contracts/src/logic/fmap.rs" 489 4 489 30] (self : t_FMap'0) =
    [%#sfmap2] forall k : t_K'0 . contains'0 self k  -> inv'2 k /\ inv'3 (lookup_unsized'0 self k)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FMap'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_FMap'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FMap'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sfmap0] forall self : t_FMap'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_FMap'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__fset__qyi13324666171263681189__clone__refines [#"../../creusot-contracts/src/logic/fset.rs" 444 4 444 27] (* <logic::fset::FSet<T> as std::clone::Clone> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 444 4 444 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 458 20 458 63
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  type t_T'0
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/logic/fset.rs" 457 4 457 30] (self : Fset.fset t_T'0) =
    [%#sfset2] forall x : t_T'0 . contains'0 self x  -> inv'2 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Fset.fset t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Fset.fset t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : Fset.fset t_T'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Fset.fset t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Fset.fset t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sfset0] forall self : Fset.fset t_T'0 . inv'0 self
   -> inv'0 self /\ (forall result : Fset.fset t_T'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__int__qyi3540547019284611154__clone__refines [#"../../creusot-contracts/src/logic/int.rs" 33 4 33 27] (* <logic::int::Int as std::clone::Clone> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 33 4 33 27
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'1 [@rewrite] : forall x : int [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sint0] forall self : int . inv'0 self
   -> (forall result : int . result = self  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__seq__qyi7164078029063507335__clone__refines [#"../../creusot-contracts/src/logic/seq.rs" 616 4 616 27] (* <logic::seq::Seq<T> as std::clone::Clone> *)
  let%span sseq0 = "../../creusot-contracts/src/logic/seq.rs" 616 4 616 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sseq2 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed3 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed3] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  use seq.Seq
  
  predicate invariant'1 [#"../../creusot-contracts/src/logic/seq.rs" 628 4 628 30] (self : Seq.seq t_T'0) =
    [%#sseq2] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'2 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : Seq.seq t_T'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sseq0] forall self : Seq.seq t_T'0 . inv'0 self
   -> inv'0 self /\ (forall result : Seq.seq t_T'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__pcell__qyi11656593191764906533__clone__refines [#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (* <pcell::Id as std::clone::Clone> *)
  let%span spcell0 = "../../creusot-contracts/src/pcell.rs" 34 4 34 27
  
  type t_Id'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Id'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Id'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Id'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Id'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#spcell0] forall self : t_Id'0 . inv'0 self
   -> (forall result : t_Id'0 . result = self  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone__refines [#"../../creusot-contracts/src/snapshot.rs" 58 4 58 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot0 = "../../creusot-contracts/src/snapshot.rs" 58 4 58 27
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#ssnapshot0] forall self : t_T'0 . inv'0 self
   -> (forall result : t_T'0 . result = self  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__ghost__qyi11746049757730684686__deref__refines [#"../../creusot-contracts/src/ghost.rs" 69 4 69 36] (* <ghost::GhostBox<T> as std::ops::Deref> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed2] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_GhostBox'0) =
    [%#sinvariant1] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant1] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  goal refines : [%#sghost0] forall self : t_GhostBox'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_T'0 . self.t_GhostBox__0'0 = result /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__ghost__qyi4247034559912199455__deref_mut__refines [#"../../creusot-contracts/src/ghost.rs" 85 4 85 48] (* <ghost::GhostBox<T> as std::ops::DerefMut> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed2] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_GhostBox'0) =
    [%#sinvariant1] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_GhostBox'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant1] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  goal refines : [%#sghost0] forall self : MutBorrow.t t_GhostBox'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : MutBorrow.t t_T'0 . result
  = MutBorrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)
  /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__logic__int__qyi8495612394334423323__eq__refines [#"../../creusot-contracts/src/logic/int.rs" 238 4 238 38] (* <logic::int::Int as std::cmp::PartialEq> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 238 4 238 38
  let%span smodel1 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel2 = "../../creusot-contracts/src/model.rs" 92 8 92 12
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 91 4 91 44] (self : int) : int =
    [%#smodel2] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : int) : int =
    [%#smodel1] deep_model'1 self
  
  goal refines : [%#sint0] forall self : int . forall other : int . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (self = other)  -> result = (deep_model'0 self = deep_model'0 other))
end
module M_creusot_contracts__logic__int__qyi3411234291730139970__add__refines [#"../../creusot-contracts/src/logic/int.rs" 249 4 249 36] (* <logic::int::Int as std::ops::Add> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 249 4 249 36
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . result = self + rhs  -> inv'0 result)
end
module M_creusot_contracts__logic__int__qyi14674898037351238599__sub__refines [#"../../creusot-contracts/src/logic/int.rs" 260 4 260 36] (* <logic::int::Int as std::ops::Sub> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 260 4 260 36
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . result = self - rhs  -> inv'0 result)
end
module M_creusot_contracts__logic__int__qyi92031444461445902__mul__refines [#"../../creusot-contracts/src/logic/int.rs" 271 4 271 36] (* <logic::int::Int as std::ops::Mul> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 271 4 271 36
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . result = self * rhs  -> inv'0 result)
end
module M_creusot_contracts__logic__int__qyi2704776725966497021__div__refines [#"../../creusot-contracts/src/logic/int.rs" 282 4 282 36] (* <logic::int::Int as std::ops::Div> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 282 4 282 36
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . result = Int.div self rhs  -> inv'0 result)
end
module M_creusot_contracts__logic__int__qyi13390566486180286353__rem__refines [#"../../creusot-contracts/src/logic/int.rs" 293 4 293 36] (* <logic::int::Int as std::ops::Rem> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 293 4 293 36
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  goal refines : [%#sint0] forall self : int . forall rhs : int . inv'0 rhs /\ inv'0 self
   -> (forall result : int . result = Int.mod self rhs  -> inv'0 result)
end
module M_creusot_contracts__logic__int__qyi6972377124305281595__neg__refines [#"../../creusot-contracts/src/logic/int.rs" 303 4 303 24] (* <logic::int::Int as std::ops::Neg> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 303 4 303 24
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : int)
  
  axiom inv_axiom'0 [@rewrite] : forall x : int [inv'0 x] . inv'0 x = true
  
  use mach.int.Int
  
  goal refines : [%#sint0] forall self : int . inv'0 self  -> (forall result : int . result = - self  -> inv'0 result)
end
