module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl [#"../../creusot-contracts/src/std/array.rs" 75 4 75 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 74 14 74 45
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 75 27 75 29
  let%span sarray2 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray2] view'0 self = Seq.(++) visited (view'0 o)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/array.rs" 75 4 75 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#sarray0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans [#"../../creusot-contracts/src/std/array.rs" 82 4 82 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 79 15 79 32
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 80 15 80 32
  let%span sarray2 = "../../creusot-contracts/src/std/array.rs" 81 14 81 42
  let%span sarray3 = "../../creusot-contracts/src/std/array.rs" 82 91 82 93
  let%span sarray4 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray4] view'0 self = Seq.(++) visited (view'0 o)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/array.rs" 82 4 82 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sarray0] produces'0 a ab b)
   -> ([%#sarray1] produces'0 b bc c)  -> ([%#sarray2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 78 14 78 45
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 79 27 79 29
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'1  =
    { _0'1: t_NonNull'0; _1'1: t_Layout'0; _2'0: () }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 tuple'1
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap3] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap5] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map2] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26] (self : t_IntoIter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_map0] produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 83 15 83 32
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 84 15 84 32
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 85 14 85 42
  let%span shash_map3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 87 24 87 102
  let%span shash_map4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 87 8 87 104
  let%span shash_map5 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'1  =
    { _0'1: t_NonNull'0; _1'1: t_Layout'0; _2'0: () }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 tuple'1
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap6] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq7] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap10] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap9] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map5] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90] (a : t_IntoIter'0) (ab : Seq.seq tuple'0) (b : t_IntoIter'0) (bc : Seq.seq tuple'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_map0] produces'0 a ab b)
   -> ([%#shash_map1] produces'0 b bc c)
   -> ([%#shash_map3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 130 14 130 45
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 131 27 131 29
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap3] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap7] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap5] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq tuple'0) (o : t_Iter'0)
  
   =
    [%#shash_map2] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26] (self : t_Iter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_map0] produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 135 15 135 32
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 136 15 136 32
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 137 14 137 42
  let%span shash_map3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 139 24 139 102
  let%span shash_map4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 139 8 139 104
  let%span shash_map5 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap6] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq7] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap11] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap10] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel9] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq tuple'0) (o : t_Iter'0)
  
   =
    [%#shash_map5] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90] (a : t_Iter'0) (ab : Seq.seq tuple'0) (b : t_Iter'0) (bc : Seq.seq tuple'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_map0] produces'0 a ab b)
   -> ([%#shash_map1] produces'0 b bc c)
   -> ([%#shash_map3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl [#"../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 182 14 182 45
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 183 27 183 29
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: MutBorrow.t t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap3] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap7] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap5] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq tuple'0) (o : t_IterMut'0)
  
   =
    [%#shash_map2] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k
    /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'1 (Seq.get visited i1)._0'0 = deep_model'1 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26] (self : t_IterMut'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_map0] produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans [#"../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 187 15 187 32
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 188 15 188 32
  let%span shash_map2 = "../../creusot-contracts/src/std/collections/hash_map.rs" 189 14 189 42
  let%span shash_map3 = "../../creusot-contracts/src/std/collections/hash_map.rs" 191 24 191 102
  let%span shash_map4 = "../../creusot-contracts/src/std/collections/hash_map.rs" 191 8 191 104
  let%span shash_map5 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: MutBorrow.t t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap6] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq7] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap11] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap10] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap8] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel9] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq tuple'0) (o : t_IterMut'0)
  
   =
    [%#shash_map5] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k
    /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'1 (Seq.get visited i1)._0'0 = deep_model'1 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90] (a : t_IterMut'0) (ab : Seq.seq tuple'0) (b : t_IterMut'0) (bc : Seq.seq tuple'0) (c : t_IterMut'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_map0] produces'0 a ab b)
   -> ([%#shash_map1] produces'0 b bc c)
   -> ([%#shash_map3] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in [%#shash_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__set_produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 83 0 89 1]
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 91 20 91 108
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 92 20 92 98
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sseq8 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sseq9 = "../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 86 8 86 82
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_I'0
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 15 4 15 34] (self : t_I'0) : Fset.fset t_DeepModelTy'0
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset11] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq8] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_I'0) (visited : Seq.seq t_T'0) (end' : t_I'0)
  
   =
    [%#shash_set7] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'1 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains'1 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'0 visited x
     -> contains'1 (view'0 start) (deep_model'0 x) /\ not contains'1 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'1 (view'0 end') x
     -> contains'1 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17]  : () =
    [%#sseq9] ()
  
  axiom concat_contains'0_spec : [%#sseq3] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function get'0 [#"../../creusot-contracts/src/logic/seq.rs" 82 4 84 17] (self : Seq.seq t_T'0) (ix : int) : t_Option'0
   =
    [%#sseq10] if 0 <= ix /\ ix < Seq.length self then C_Some'0 (Seq.get self ix) else C_None'0
  
  constant a  : t_I'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_I'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_I'0
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 83 0 89 1] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  goal vc_set_produces_trans'0 : ([%#shash_set0] set_produces'0 a ab b)
   -> ([%#shash_set1] set_produces'0 b bc c)
   -> ([%#sseq3] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'0 (Seq.(++) a b) x = contains'0 a x
  \/ contains'0 b x)
   -> (let _ = concat_contains'0 in ([%#shash_set4] forall i : int, x : t_T'0 . Seq.length ab <= i
  /\ get'0 (Seq.(++) ab bc) i = C_Some'0 x  -> contains'0 bc x)
  && (let _ = () in let _ = () in ([%#shash_set5] forall i : int . 0 <= i /\ i < Seq.length bc
   -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
  && (let _ = () in let _ = () in [%#shash_set2] set_produces'0 a (Seq.(++) ab bc) c)))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 111 4 111 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 110 14 110 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 111 27 111 29
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 99 8 99 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'0  =
    { _0'0: t_NonNull'0; _1'0: t_Layout'0; _2'0: () }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple'0
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 55 4 55 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 98 4 98 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 111 4 111 26] (self : t_IntoIter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 118 4 118 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 115 15 115 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 116 15 116 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 117 14 117 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 119 8 119 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 99 8 99 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sseq12 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'0  =
    { _0'0: t_NonNull'0; _1'0: t_Layout'0; _2'0: () }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple'0
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 55 4 55 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset10] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq11] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set8] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 98 4 98 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17]  : () =
    [%#sseq13] ()
  
  axiom concat_contains'0_spec : [%#sseq12] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 83 0 89 1] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_set9] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq t_T'0, b : t_IntoIter'0, bc : Seq.seq t_T'0, c : t_IntoIter'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 118 4 118 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set0] produces'0 a ab b)
   -> ([%#shash_set1] produces'0 b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 150 4 150 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 149 14 149 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 150 27 150 29
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 138 8 138 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 129 4 129 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq6] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 137 4 137 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 150 4 150 26] (self : t_Iter'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 157 4 157 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 154 15 154 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 155 15 155 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 156 14 156 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 158 8 158 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 138 8 138 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq12 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 129 4 129 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset10] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel11] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq12] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set8] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 137 4 137 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17]  : () =
    [%#sseq14] ()
  
  axiom concat_contains'0_spec : [%#sseq13] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 83 0 89 1] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
   =
    [%#shash_set9] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 157 4 157 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set0] produces'0 a ab b)
   -> ([%#shash_set1] produces'0 b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 236 4 236 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 235 14 235 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 236 27 236 29
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 204 4 204 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq6] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 223 4 223 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  constant self  : t_Intersection'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 236 4 236 26] (self : t_Intersection'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 243 4 243 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 240 15 240 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 241 15 241 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 242 14 242 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 244 8 244 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq12 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 204 4 204 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset10] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel11] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq12] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set8] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 223 4 223 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17]  : () =
    [%#sseq14] ()
  
  axiom concat_contains'0_spec : [%#sseq13] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 83 0 89 1] (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
   =
    [%#shash_set9] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Intersection'0, ab : Seq.seq t_T'0, b : t_Intersection'0, bc : Seq.seq t_T'0, c : t_Intersection'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_Intersection'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Intersection'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Intersection'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 243 4 243 90] (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set0] produces'0 a ab b)
   -> ([%#shash_set1] produces'0 b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl [#"../../creusot-contracts/src/std/collections/hash_set.rs" 264 4 264 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 263 14 263 45
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 264 27 264 29
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 8 252 38
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Difference'0  =
    { t_Difference__iter'0: t_Iter'0; t_Difference__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 215 4 215 33] (self : t_Difference'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq6] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Difference'0) (visited : Seq.seq t_T'0) (end' : t_Difference'0)
  
   =
    [%#shash_set3] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 251 4 251 64] (self : t_Difference'0) (visited : Seq.seq t_T'0) (o : t_Difference'0)
  
   =
    [%#shash_set2] set_produces'0 self visited o
  
  constant self  : t_Difference'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 264 4 264 26] (self : t_Difference'0) : ()
  
  
  goal vc_produces_refl'0 : [%#shash_set0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans [#"../../creusot-contracts/src/std/collections/hash_set.rs" 271 4 271 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 268 15 268 32
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 269 15 269 32
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 270 14 270 42
  let%span shash_set3 = "../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set4 = "../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set5 = "../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set6 = "../../creusot-contracts/src/std/collections/hash_set.rs" 272 8 272 43
  let%span shash_set7 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 8 252 38
  let%span shash_set8 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set9 = "../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq12 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Difference'0  =
    { t_Difference__iter'0: t_Iter'0; t_Difference__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 215 4 215 33] (self : t_Difference'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset10] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel11] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq12] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Difference'0) (visited : Seq.seq t_T'0) (end' : t_Difference'0)
  
   =
    [%#shash_set8] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 251 4 251 64] (self : t_Difference'0) (visited : Seq.seq t_T'0) (o : t_Difference'0)
  
   =
    [%#shash_set7] set_produces'0 self visited o
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17]  : () =
    [%#sseq14] ()
  
  axiom concat_contains'0_spec : [%#sseq13] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 83 0 89 1] (a : t_Difference'0) (ab : Seq.seq t_T'0) (b : t_Difference'0) (bc : Seq.seq t_T'0) (c : t_Difference'0) : ()
  
   =
    [%#shash_set9] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Difference'0, ab : Seq.seq t_T'0, b : t_Difference'0, bc : Seq.seq t_T'0, c : t_Difference'0 . ([%#shash_set3] set_produces'0 a ab b)
   -> ([%#shash_set4] set_produces'0 b bc c)  -> ([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
  
  constant a  : t_Difference'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Difference'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Difference'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 271 4 271 90] (a : t_Difference'0) (ab : Seq.seq t_T'0) (b : t_Difference'0) (bc : Seq.seq t_T'0) (c : t_Difference'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#shash_set0] produces'0 a ab b)
   -> ([%#shash_set1] produces'0 b bc c)
   -> (([@expl:set_produces_trans requires #0] [%#shash_set3] set_produces'0 a ab b)
  && ([@expl:set_produces_trans requires #1] [%#shash_set4] set_produces'0 b bc c))
  /\ (([%#shash_set5] set_produces'0 a (Seq.(++) ab bc) c)
   -> (let _ = set_produces_trans'0 a ab b bc c in [%#shash_set2] produces'0 a (Seq.(++) ab bc) c))
end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialEq_Rhs_ne_body [#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 17 16 17 17
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 18 29 18 32
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 17 26 17 75
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Self_'0
  
  type t_Rhs'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant5] inv'4 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant5] inv'0 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Self_'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant5] inv'5 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Rhs'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  type t_DeepModelTy'0
  
  function deep_model'4 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'4 self
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'0 self
  
  function deep_model'5 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'5 self
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  let rec eq'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:eq 'self' type invariant] inv'2 self}
    {[@expl:eq 'other' type invariant] inv'3 other}
    any [ return' (result:bool)-> {[%#scmp3] result = (deep_model'2 self = deep_model'3 other)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialEq_Rhs_ne_body'0[#"../../creusot-contracts/src/std/cmp.rs" 10 31 18 18] (self_:t_Self_'0) (rhs:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] [%#scmp1] inv'1 rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {self_} {rhs} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- not _4 ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : bool = Any.any_l () | & self_ : t_Self_'0 = self_ | & rhs : t_Rhs'0 = rhs | & _4 : bool = Any.any_l () ] 
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialEq_Rhs_ne_body ensures] [%#scmp2] result
      = (deep_model'0 self_ <> deep_model'1 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_lt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 39 29 39 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 38 48 38 52
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 35 16 35 17
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 36 29 36 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  type t_Self_'0
  
  type t_Rhs'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_lt_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 36 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0} (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0} (! bb4) | br1 -> {r0'0 = C_Equal'0} (! bb2) | br2 -> {r0'0 = C_Greater'0} (! bb2) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_lt_body ensures] [%#scmp4] result
      = lt_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_le_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 47 29 47 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 46 66 46 70
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 43 16 43 17
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 44 29 44 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  type t_Self_'0
  
  type t_Rhs'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_le_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 44 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0} (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0} (! bb4) | br1 -> {r0'0 = C_Equal'0} (! bb4) | br2 -> {r0'0 = C_Greater'0} (! bb2) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_le_body ensures] [%#scmp4] result
      = le_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_gt_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 55 29 55 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 54 51 54 55
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 51 16 51 17
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 52 29 52 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  type t_Self_'0
  
  type t_Rhs'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_gt_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 52 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0} (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0} (! bb2) | br1 -> {r0'0 = C_Equal'0} (! bb2) | br2 -> {r0'0 = C_Greater'0} (! bb4) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_gt_body ensures] [%#scmp4] result
      = gt_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_PartialOrd_Rhs_ge_body [#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 63 29 63 34
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 62 69 62 73
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 59 16 59 17
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 60 29 60 34
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 59 26 59 77
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 32 26 32 91
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Ordering'0
  
  type t_Self_'0
  
  type t_Rhs'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant20] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Rhs'0) =
    [%#sinvariant20] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rhs'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Rhs'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord18] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord15] cmp_log'0 x y = C_Less'0)
   -> ([%#sord16] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord12] cmp_log'0 x y
  = o)  -> ([%#sord13] cmp_log'0 y z = o)  -> ([%#sord14] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord11] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord8] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord7] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'2 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Rhs'0) : t_DeepModelTy'0
  
  let rec partial_cmp'0 (self:t_Self_'0) (other:t_Rhs'0) (return'  (ret:t_Option'0))= {[@expl:partial_cmp 'self' type invariant] inv'0 self}
    {[@expl:partial_cmp 'other' type invariant] inv'1 other}
    any
    [ return' (result:t_Option'0)-> {[%#scmp5] result = C_Some'0 (cmp_log'0 (deep_model'2 self) (deep_model'3 other))}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Ordering'0))= any
    [ good (field_0:t_Ordering'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Ordering'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'2 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Rhs'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_PartialOrd_Rhs_ge_body'0[#"../../creusot-contracts/src/std/cmp.rs" 27 32 60 18] (self_:t_Self_'0) (other:t_Rhs'0) (return'  (ret:bool))= {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] [%#scmp2] inv'0 self_}
    {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] [%#scmp3] inv'1 other}
    (! bb0
    [ bb0 = s0 [ s0 = partial_cmp'0 {self_} {other} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_4 = C_None'0} (! bb8) | br1 (x0:t_Ordering'0)-> {_4 = C_Some'0 x0} (! bb3) ] 
    | bb8 = bb2
    | bb3 = v_Some'0 {_4}
        (fun (r0'0:t_Ordering'0) ->
          any
          [ br0 -> {r0'0 = C_Less'0} (! bb2) | br1 -> {r0'0 = C_Equal'0} (! bb4) | br2 -> {r0'0 = C_Greater'0} (! bb4) ]
        )
    | bb2 = s0 [ s0 =  [ &_0 <- [%#scmp0] false ] s1 | s1 = bb6 ] 
    | bb4 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#scmp1] true ] s1 | s1 = bb6 ] 
    | bb6 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & other : t_Rhs'0 = other
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_cmp_PartialOrd_Rhs_ge_body ensures] [%#scmp4] result
      = ge_log'0 (deep_model'0 self_) (deep_model'1 other)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_max_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 75 16 75 17
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 80 29 80 30
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 80 41 80 45
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 77 26 77 55
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 78 26 78 77
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 79 26 79 79
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 43 26 43 77
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant23 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Self_'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant23] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord22] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord20] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord21] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord18] cmp_log'0 x y = C_Less'0)
   -> ([%#sord19] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord15] cmp_log'0 x y
  = o)  -> ([%#sord16] cmp_log'0 y z = o)  -> ([%#sord17] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord14] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel9] deep_model'0 self
  
  let rec le'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:le 'self' type invariant] inv'1 self}
    {[@expl:le 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp8] result = le_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Self_'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_max_body'0[#"../../creusot-contracts/src/std/cmp.rs" 68 18 80 18] (self_:t_Self_'0) (o:t_Self_'0) (return'  (ret:t_Self_'0))= {[@expl:extern_spec_std_cmp_Ord_max_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_Ord_max_body 'o' type invariant] [%#scmp1] inv'0 o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = le'0 {self_} {o} (fun (_ret':bool) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 =  [ &_0 <- o ] s3 | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'0 o} s1 | s1 = -{resolve'0 o}- s2 | s2 =  [ &_0 <- self_ ] s3 | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_Self_'0 = Any.any_l () | & self_ : t_Self_'0 = self_ | & o : t_Self_'0 = o | & _8 : bool = Any.any_l () ]
    
    [ return' (result:t_Self_'0)-> {[@expl:extern_spec_std_cmp_Ord_max_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #0] [%#scmp3] ge_log'0 (deep_model'0 result) (deep_model'0 self_)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #1] [%#scmp4] ge_log'0 (deep_model'0 result) (deep_model'0 o)}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #2] [%#scmp5] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #3] [%#scmp6] le_log'0 (deep_model'0 self_) (deep_model'0 o)
       -> result = o}
      {[@expl:extern_spec_std_cmp_Ord_max_body ensures #4] [%#scmp7] lt_log'0 (deep_model'0 o) (deep_model'0 self_)
       -> result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_min_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 84 16 84 17
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 89 29 89 30
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 89 41 89 45
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 86 26 86 55
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 87 26 87 79
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant23 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Self_'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant23] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord22] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord20] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord21] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord18] cmp_log'0 x y = C_Less'0)
   -> ([%#sord19] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord15] cmp_log'0 x y
  = o)  -> ([%#sord16] cmp_log'0 y z = o)  -> ([%#sord17] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord14] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel9] deep_model'0 self
  
  let rec lt'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:lt 'self' type invariant] inv'1 self}
    {[@expl:lt 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp8] result = lt_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Self_'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_min_body'0[#"../../creusot-contracts/src/std/cmp.rs" 68 18 89 18] (self_:t_Self_'0) (o:t_Self_'0) (return'  (ret:t_Self_'0))= {[@expl:extern_spec_std_cmp_Ord_min_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_Ord_min_body 'o' type invariant] [%#scmp1] inv'0 o}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = lt'0 {self_} {o} (fun (_ret':bool) ->  [ &_8 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_8 = false} (! bb8) | br1 -> {_8} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'0 o} s1 | s1 = -{resolve'0 o}- s2 | s2 =  [ &_0 <- self_ ] s3 | s3 = bb9 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 =  [ &_0 <- o ] s3 | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_Self_'0 = Any.any_l () | & self_ : t_Self_'0 = self_ | & o : t_Self_'0 = o | & _8 : bool = Any.any_l () ]
    
    [ return' (result:t_Self_'0)-> {[@expl:extern_spec_std_cmp_Ord_min_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #0] [%#scmp3] le_log'0 (deep_model'0 result) (deep_model'0 self_)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #1] [%#scmp4] le_log'0 (deep_model'0 result) (deep_model'0 o)}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #2] [%#scmp5] result = self_ \/ result = o}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #3] [%#scmp6] lt_log'0 (deep_model'0 self_) (deep_model'0 o)
       -> result = self_}
      {[@expl:extern_spec_std_cmp_Ord_min_body ensures #4] [%#scmp7] le_log'0 (deep_model'0 o) (deep_model'0 self_)
       -> result = o}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_Ord_clamp_body [#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 93 16 93 17
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 102 31 102 34
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 102 42 102 45
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 93 27 93 63
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 102 56 102 60
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 94 26 94 65
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 95 26 95 65
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 96 26 96 74
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 97 26 101 41
  let%span scmp9 = "../../creusot-contracts/src/std/cmp.rs" 51 26 51 76
  let%span scmp10 = "../../creusot-contracts/src/std/cmp.rs" 35 26 35 76
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_Self_'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Self_'0) =
    [%#sinvariant25] inv'0 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Self_'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Self_'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord24] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord22] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord23] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord20] cmp_log'0 x y = C_Less'0)
   -> ([%#sord21] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord17] cmp_log'0 x y
  = o)  -> ([%#sord18] cmp_log'0 y z = o)  -> ([%#sord19] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord16] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord15] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Self_'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Self_'0) : t_DeepModelTy'0 =
    [%#smodel11] deep_model'0 self
  
  let rec gt'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:gt 'self' type invariant] inv'1 self}
    {[@expl:gt 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp9] result = gt_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Self_'0)
  
  let rec lt'0 (self:t_Self_'0) (other:t_Self_'0) (return'  (ret:bool))= {[@expl:lt 'self' type invariant] inv'1 self}
    {[@expl:lt 'other' type invariant] inv'1 other}
    any
    [ return' (result:bool)-> {[%#scmp10] result = lt_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_Ord_clamp_body'0[#"../../creusot-contracts/src/std/cmp.rs" 68 18 102 18] (self_:t_Self_'0) (min:t_Self_'0) (max:t_Self_'0) (return'  (ret:t_Self_'0))= {[@expl:extern_spec_std_cmp_Ord_clamp_body 'self_' type invariant] [%#scmp0] inv'0 self_}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'min' type invariant] [%#scmp1] inv'0 min}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body 'max' type invariant] [%#scmp2] inv'0 max}
    {[@expl:extern_spec_std_cmp_Ord_clamp_body requires] [%#scmp3] le_log'0 (deep_model'0 min) (deep_model'0 max)}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = gt'0 {self_} {max} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_9 = false} (! bb8) | br1 -> {_9} (! bb7) ] 
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'0 min} s1
      | s1 = -{resolve'0 min}- s2
      | s2 = {[@expl:type invariant] inv'0 self_} s3
      | s3 = -{resolve'0 self_}- s4
      | s4 =  [ &_0 <- max ] s5
      | s5 = bb13 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'0 max} s1
      | s1 = -{resolve'0 max}- s2
      | s2 = lt'0 {self_} {min} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s3)
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1
      | s1 = -{resolve'0 self_}- s2
      | s2 =  [ &_0 <- min ] s3
      | s3 = bb12 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'0 min} s1 | s1 = -{resolve'0 min}- s2 | s2 =  [ &_0 <- self_ ] s3 | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Self_'0 = Any.any_l ()
    | & self_ : t_Self_'0 = self_
    | & min : t_Self_'0 = min
    | & max : t_Self_'0 = max
    | & _9 : bool = Any.any_l ()
    | & _12 : bool = Any.any_l () ]
    
    [ return' (result:t_Self_'0)-> {[@expl:extern_spec_std_cmp_Ord_clamp_body result type invariant] [%#scmp4] inv'0 result}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #0] [%#scmp5] ge_log'0 (deep_model'0 result) (deep_model'0 min)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #1] [%#scmp6] le_log'0 (deep_model'0 result) (deep_model'0 max)}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #2] [%#scmp7] result = self_ \/ result = min \/ result = max}
      {[@expl:extern_spec_std_cmp_Ord_clamp_body ensures #3] [%#scmp8] if gt_log'0 (deep_model'0 self_) (deep_model'0 max) then
        result = max
      else
        if lt_log'0 (deep_model'0 self_) (deep_model'0 min) then result = min else result = self_
      }
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_max_body [#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 112 22 112 24
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 112 29 112 31
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 112 39 112 40
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 107 22 107 60
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 108 22 108 60
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 109 22 109 50
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 110 22 110 73
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 111 22 111 72
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 75 26 75 66
  let%span scmp9 = "../../creusot-contracts/src/std/cmp.rs" 76 26 76 63
  let%span scmp10 = "../../creusot-contracts/src/std/cmp.rs" 77 26 77 55
  let%span scmp11 = "../../creusot-contracts/src/std/cmp.rs" 78 26 78 77
  let%span scmp12 = "../../creusot-contracts/src/std/cmp.rs" 79 26 79 79
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord25] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord23] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord24] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord21] cmp_log'0 x y = C_Less'0)
   -> ([%#sord22] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord18] cmp_log'0 x y
  = o)  -> ([%#sord19] cmp_log'0 y z = o)  -> ([%#sord20] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord17] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord16] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord15] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  let rec max'0 (self:t_T'0) (other:t_T'0) (return'  (ret:t_T'0))= {[@expl:max 'self' type invariant] inv'0 self}
    {[@expl:max 'other' type invariant] inv'0 other}
    any
    [ return' (result:t_T'0)-> {inv'0 result}
      {[%#scmp8] ge_log'0 (deep_model'0 result) (deep_model'0 self)}
      {[%#scmp9] ge_log'0 (deep_model'0 result) (deep_model'0 other)}
      {[%#scmp10] result = self \/ result = other}
      {[%#scmp11] le_log'0 (deep_model'0 self) (deep_model'0 other)  -> result = other}
      {[%#scmp12] lt_log'0 (deep_model'0 other) (deep_model'0 self)  -> result = self}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_max_body'0[#"../../creusot-contracts/src/std/cmp.rs" 112 12 113 66] (v1:t_T'0) (v2:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_cmp_max_body 'v1' type invariant] [%#scmp0] inv'0 v1}
    {[@expl:extern_spec_std_cmp_max_body 'v2' type invariant] [%#scmp1] inv'0 v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = max'0 {v1} {v2} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_T'0 = Any.any_l () | & v1 : t_T'0 = v1 | & v2 : t_T'0 = v2 ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_cmp_max_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_max_body ensures #0] [%#scmp3] ge_log'0 (deep_model'0 result) (deep_model'0 v1)}
      {[@expl:extern_spec_std_cmp_max_body ensures #1] [%#scmp4] ge_log'0 (deep_model'0 result) (deep_model'0 v2)}
      {[@expl:extern_spec_std_cmp_max_body ensures #2] [%#scmp5] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #3] [%#scmp6] le_log'0 (deep_model'0 v1) (deep_model'0 v2)
       -> result = v2}
      {[@expl:extern_spec_std_cmp_max_body ensures #4] [%#scmp7] lt_log'0 (deep_model'0 v2) (deep_model'0 v1)
       -> result = v1}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__extern_spec_std_cmp_min_body [#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66]
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 123 22 123 24
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 123 29 123 31
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 123 39 123 40
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 118 22 118 60
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 119 22 119 60
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 120 22 120 50
  let%span scmp6 = "../../creusot-contracts/src/std/cmp.rs" 121 22 121 72
  let%span scmp7 = "../../creusot-contracts/src/std/cmp.rs" 122 22 122 73
  let%span scmp8 = "../../creusot-contracts/src/std/cmp.rs" 84 26 84 66
  let%span scmp9 = "../../creusot-contracts/src/std/cmp.rs" 85 26 85 63
  let%span scmp10 = "../../creusot-contracts/src/std/cmp.rs" 86 26 86 55
  let%span scmp11 = "../../creusot-contracts/src/std/cmp.rs" 87 26 87 79
  let%span scmp12 = "../../creusot-contracts/src/std/cmp.rs" 88 26 88 77
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_DeepModelTy'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord25] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord23] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord24] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord21] cmp_log'0 x y = C_Less'0)
   -> ([%#sord22] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord18] cmp_log'0 x y
  = o)  -> ([%#sord19] cmp_log'0 y z = o)  -> ([%#sord20] cmp_log'0 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord17] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord16] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord15] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  let rec min'0 (self:t_T'0) (other:t_T'0) (return'  (ret:t_T'0))= {[@expl:min 'self' type invariant] inv'0 self}
    {[@expl:min 'other' type invariant] inv'0 other}
    any
    [ return' (result:t_T'0)-> {inv'0 result}
      {[%#scmp8] le_log'0 (deep_model'0 result) (deep_model'0 self)}
      {[%#scmp9] le_log'0 (deep_model'0 result) (deep_model'0 other)}
      {[%#scmp10] result = self \/ result = other}
      {[%#scmp11] lt_log'0 (deep_model'0 self) (deep_model'0 other)  -> result = self}
      {[%#scmp12] le_log'0 (deep_model'0 other) (deep_model'0 self)  -> result = other}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_cmp_min_body'0[#"../../creusot-contracts/src/std/cmp.rs" 123 12 124 66] (v1:t_T'0) (v2:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_cmp_min_body 'v1' type invariant] [%#scmp0] inv'0 v1}
    {[@expl:extern_spec_std_cmp_min_body 'v2' type invariant] [%#scmp1] inv'0 v2}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = bb5
    | bb5 = s0 [ s0 = min'0 {v1} {v2} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_T'0 = Any.any_l () | & v1 : t_T'0 = v1 | & v2 : t_T'0 = v2 ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_cmp_min_body result type invariant] [%#scmp2] inv'0 result}
      {[@expl:extern_spec_std_cmp_min_body ensures #0] [%#scmp3] le_log'0 (deep_model'0 result) (deep_model'0 v1)}
      {[@expl:extern_spec_std_cmp_min_body ensures #1] [%#scmp4] le_log'0 (deep_model'0 result) (deep_model'0 v2)}
      {[@expl:extern_spec_std_cmp_min_body ensures #2] [%#scmp5] result = v1 \/ result = v2}
      {[@expl:extern_spec_std_cmp_min_body ensures #3] [%#scmp6] lt_log'0 (deep_model'0 v1) (deep_model'0 v2)
       -> result = v1}
      {[@expl:extern_spec_std_cmp_min_body ensures #4] [%#scmp7] le_log'0 (deep_model'0 v2) (deep_model'0 v1)
       -> result = v2}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 155 14 155 64
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 156 36 156 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_le_log'0 : [%#scmp0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 160 14 160 61
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 161 36 161 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_lt_log'0 : [%#scmp0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 165 14 165 61
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 166 36 166 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_ge_log'0 : [%#scmp0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 170 14 170 64
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 171 36 171 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  
  goal vc_cmp_gt_log'0 : [%#scmp0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 175 14 175 45
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 176 21 176 23
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  function refl'0 [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (x : t_Reverse'0) : ()
  
  goal vc_refl'0 : [%#scmp0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 180 15 180 32
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 181 15 181 32
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 182 14 182 31
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 183 53 183 55
  let%span scmp4 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp4] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  constant z  : t_Reverse'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (x : t_Reverse'0) (y : t_Reverse'0) (z : t_Reverse'0) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#scmp0] cmp_log'0 x y = o)  -> ([%#scmp1] cmp_log'0 y z = o)  -> ([%#scmp2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 187 15 187 45
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 188 14 188 47
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 189 34 189 36
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function antisym1'0 [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_antisym1'0 : ([%#scmp0] cmp_log'0 x y = C_Less'0)  -> ([%#scmp1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 193 15 193 48
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 194 14 194 44
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 195 34 195 36
  let%span scmp3 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp3] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function antisym2'0 [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_antisym2'0 : ([%#scmp0] cmp_log'0 x y = C_Greater'0)  -> ([%#scmp1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 199 14 199 59
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 200 32 200 34
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  constant x  : t_Reverse'0
  
  constant y  : t_Reverse'0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (x : t_Reverse'0) (y : t_Reverse'0) : ()
  
  goal vc_eq_cmp'0 : [%#scmp0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl [#"../../creusot-contracts/src/std/deque.rs" 185 4 185 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 184 14 184 45
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 185 27 185 29
  let%span sdeque2 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice3] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/deque.rs" 185 4 185 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#sdeque0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans [#"../../creusot-contracts/src/std/deque.rs" 192 4 192 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 189 15 189 32
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 190 15 190 32
  let%span sdeque2 = "../../creusot-contracts/src/std/deque.rs" 191 14 191 42
  let%span sdeque3 = "../../creusot-contracts/src/std/deque.rs" 192 91 192 93
  let%span sdeque4 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex8 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice10 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice9] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice10] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel7] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex8] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice5] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque4] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/deque.rs" 192 4 192 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sdeque0] produces'0 a ab b)
   -> ([%#sdeque1] produces'0 b bc c)  -> ([%#sdeque2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_assert_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint0 = "../../creusot-contracts/src/std/hint.rs" 7 23 7 27
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_assert_unchecked_body'0[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (cond:bool) (return'  (ret:()))= {[@expl:extern_spec_std_hint_assert_unchecked_body requires] [%#shint0] cond}
    (! bb0 [ bb0 = return' {_0} ] ) [ & _0 : () = Any.any_l () ]  [ return' (result:())-> (! return' {result}) ] 
end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_black_box_body [#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42]
  let%span shint0 = "../../creusot-contracts/src/std/hint.rs" 12 28 12 33
  let%span shint1 = "../../creusot-contracts/src/std/hint.rs" 12 41 12 42
  let%span shint2 = "../../creusot-contracts/src/std/hint.rs" 11 22 11 37
  
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_black_box_body'0[#"../../creusot-contracts/src/std/hint.rs" 12 12 12 42] (dummy:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_hint_black_box_body 'dummy' type invariant] [%#shint0] inv'0 dummy}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- dummy ] s1 | s1 = bb2 ]  | bb2 = return' {_0} ] )
    [ & _0 : t_T'0 = Any.any_l () | & dummy : t_T'0 = dummy ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_hint_black_box_body result type invariant] [%#shint1] inv'0 result}
      {[@expl:extern_spec_std_hint_black_box_body ensures] [%#shint2] result = dummy}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_spin_loop_body [#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1]
  let%span shint0 = "../../creusot-contracts/src/std/hint.rs" 17 23 17 27
  let%span shint1 = "../../creusot-contracts/src/std/hint.rs" 18 22 18 26
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_spin_loop_body'0[#"../../creusot-contracts/src/std/hint.rs" 3 0 35 1] (return'  (ret:()))= {[@expl:extern_spec_std_hint_spin_loop_body requires] [%#shint0] true}
    (! bb0 [ bb0 = return' {_0} ] ) [ & _0 : () = Any.any_l () ] 
    [ return' (result:())-> {[@expl:extern_spec_std_hint_spin_loop_body ensures] [%#shint1] true} (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_unreachable_unchecked_body [#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50]
  let%span shint0 = "../../creusot-contracts/src/std/hint.rs" 22 23 22 28
  let%span shint1 = "../../creusot-contracts/src/std/hint.rs" 23 49 23 50
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 15 8 15 13
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 14 4 14 30] (self : ()) =
    [%#sinvariant2] false
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : ())
  
  axiom inv_axiom'0 [@rewrite] : forall x : () [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_unreachable_unchecked_body'0[#"../../creusot-contracts/src/std/hint.rs" 23 12 23 50] (return'  (ret:()))= {[@expl:extern_spec_std_hint_unreachable_unchecked_body requires] [%#shint0] false}
    (! bb0 [ bb0 = {false} any ] )
    [ return' (result:())-> {[@expl:extern_spec_std_hint_unreachable_unchecked_body result type invariant] [%#shint1] inv'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__hint__extern_spec_std_hint_must_use_body [#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41]
  let%span shint0 = "../../creusot-contracts/src/std/hint.rs" 30 27 30 32
  let%span shint1 = "../../creusot-contracts/src/std/hint.rs" 30 40 30 41
  let%span shint2 = "../../creusot-contracts/src/std/hint.rs" 29 22 29 37
  
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_hint_must_use_body'0[#"../../creusot-contracts/src/std/hint.rs" 30 12 30 41] (value:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_hint_must_use_body 'value' type invariant] [%#shint0] inv'0 value}
    (! bb0 [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- value ] s1 | s1 = bb2 ]  | bb2 = return' {_0} ] )
    [ & _0 : t_T'0 = Any.any_l () | & value : t_T'0 = value ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_hint_must_use_body result type invariant] [%#shint1] inv'0 result}
      {[@expl:extern_spec_std_hint_must_use_body ensures] [%#shint2] result = value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl [#"../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 57 14 57 45
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 58 27 58 29
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned3 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned2] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Cloned'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26] (self : t_Cloned'0) : ()
  
  goal vc_produces_refl'0 : [%#scloned0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 62 15 62 32
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 63 15 63 32
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 64 14 64 42
  let%span scloned3 = "../../creusot-contracts/src/std/iter/cloned.rs" 65 91 65 93
  let%span scloned4 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned5 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter7] produces'1 a ab b)
   -> ([%#siter8] produces'1 b bc c)  -> ([%#siter9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter6] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned5] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned4] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : t_Cloned'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Cloned'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Cloned'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90] (a : t_Cloned'0) (ab : Seq.seq t_T'0) (b : t_Cloned'0) (bc : Seq.seq t_T'0) (c : t_Cloned'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#scloned0] produces'0 a ab b)
   -> ([%#scloned1] produces'0 b bc c)  -> ([%#scloned2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl [#"../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 58 27 58 29
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied3 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied2] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant self  : t_Copied'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26] (self : t_Copied'0) : ()
  
  goal vc_produces_refl'0 : [%#scopied0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span scopied3 = "../../creusot-contracts/src/std/iter/copied.rs" 65 91 65 93
  let%span scopied4 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied5 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter7] produces'1 a ab b)
   -> ([%#siter8] produces'1 b bc c)  -> ([%#siter9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter6] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied5] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied4] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  constant a  : t_Copied'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Copied'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Copied'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (a : t_Copied'0) (ab : Seq.seq t_T'0) (b : t_Copied'0) (bc : Seq.seq t_T'0) (c : t_Copied'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#scopied0] produces'0 a ab b)
   -> ([%#scopied1] produces'0 b bc c)  -> ([%#scopied2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl [#"../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 18 14 18 45
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 19 27 19 29
  let%span sempty2 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  constant self  : t_Empty'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26] (self : t_Empty'0) : ()
  
  goal vc_produces_refl'0 : [%#sempty0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans [#"../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 23 15 23 32
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 24 15 24 32
  let%span sempty2 = "../../creusot-contracts/src/std/iter/empty.rs" 25 14 25 42
  let%span sempty3 = "../../creusot-contracts/src/std/iter/empty.rs" 26 91 26 93
  let%span sempty4 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  constant a  : t_Empty'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Empty'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Empty'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90] (a : t_Empty'0) (ab : Seq.seq t_T'0) (b : t_Empty'0) (bc : Seq.seq t_T'0) (c : t_Empty'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sempty0] produces'0 a ab b)
   -> ([%#sempty1] produces'0 b bc c)  -> ([%#sempty2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 82 14 82 45
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 27 83 29
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate8 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  type tuple'0  =
    { _0'0: UInt64.t; _1'0: t_Item'0 }
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate8] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq tuple'0) (o : t_Enumerate'0)
  
   =
    [%#senumerate2] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._0'0 = n'0 self + i /\ (Seq.get visited i)._1'0 = Seq.get s i))
  
  constant self  : t_Enumerate'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (self : t_Enumerate'0) : ()
  
  goal vc_produces_refl'0 : [%#senumerate0] produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans [#"../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 32
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 88 15 88 32
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 89 14 89 42
  let%span senumerate3 = "../../creusot-contracts/src/std/iter/enumerate.rs" 90 91 90 93
  let%span senumerate4 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate5 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate10 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  type tuple'0  =
    { _0'0: UInt64.t; _1'0: t_Item'0 }
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter7] produces'1 a ab b)
   -> ([%#siter8] produces'1 b bc c)  -> ([%#siter9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter6] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate5] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate10] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq tuple'0) (o : t_Enumerate'0)
  
   =
    [%#senumerate4] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._0'0 = n'0 self + i /\ (Seq.get visited i)._1'0 = Seq.get s i))
  
  constant a  : t_Enumerate'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_Enumerate'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_Enumerate'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90] (a : t_Enumerate'0) (ab : Seq.seq tuple'0) (b : t_Enumerate'0) (bc : Seq.seq tuple'0) (c : t_Enumerate'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#senumerate0] produces'0 a ab b)
   -> ([%#senumerate1] produces'0 b bc c)  -> ([%#senumerate2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl [#"../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 104 14 104 45
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 105 27 105 29
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter5 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops12] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops9] unnest'0 self b)
   -> ([%#sops10] unnest'0 b c)  -> ([%#sops11] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops8] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops6] postcondition_mut'0 self args res_state res)
   -> ([%#sops7] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter3] forall f : t_F'0, i : t_Item'0 . precondition'0 f i
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 i f2 true
    /\ postcondition_mut'0 f1 i f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter14] produces'1 a ab b)
   -> ([%#siter15] produces'1 b bc c)  -> ([%#siter16] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter13] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter5] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter2] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  constant self  : t_Filter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26] (self : t_Filter'0) : ()
  
  goal vc_produces_refl'0 : [%#sfilter0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans [#"../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 109 15 109 32
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 32
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 111 14 111 42
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 112 91 112 93
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter5 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter6 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter7 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter5] forall f : t_F'0, i : t_Item'0 . precondition'0 f i
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 i f2 true
    /\ postcondition_mut'0 f1 i f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter6] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter7] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter4] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  constant a  : t_Filter'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Filter'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Filter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90] (a : t_Filter'0) (ab : Seq.seq t_Item'0) (b : t_Filter'0) (bc : Seq.seq t_Item'0) (c : t_Filter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sfilter0] produces'0 a ab b)
   -> ([%#sfilter1] produces'0 b bc c)  -> ([%#sfilter2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl [#"../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 104 14 104 45
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 105 27 105 29
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops15 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter19 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map6] forall i : t_Item'0 . precondition'0 f i
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops15] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops12] unnest'0 self b)
   -> ([%#sops13] unnest'0 b c)  -> ([%#sops14] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops11] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops9] postcondition_mut'0 self args res_state res)
   -> ([%#sops10] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map7] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map8] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 i f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 i f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map4] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map3] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter17] produces'1 a ab b)
   -> ([%#siter18] produces'1 b bc c)  -> ([%#siter19] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter16] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map5] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map2] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  constant self  : t_FilterMap'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26] (self : t_FilterMap'0) : ()
  
  
  goal vc_produces_refl'0 : [%#sfilter_map0] produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans [#"../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 109 15 109 32
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 110 15 110 32
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 111 14 111 42
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 112 91 112 93
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map8 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map9 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map10 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops15 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops16 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops17 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter19 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter20 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter21 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map8] forall i : t_Item'0 . precondition'0 f i
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops17] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops14] unnest'0 self b)
   -> ([%#sops15] unnest'0 b c)  -> ([%#sops16] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops13] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops11] postcondition_mut'0 self args res_state res)
   -> ([%#sops12] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map9] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map10] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 i f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 i f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map6] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map5] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter19] produces'1 a ab b)
   -> ([%#siter20] produces'1 b bc c)  -> ([%#siter21] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter18] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map7] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map4] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  constant a  : t_FilterMap'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_FilterMap'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_FilterMap'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90] (a : t_FilterMap'0) (ab : Seq.seq t_B'0) (b : t_FilterMap'0) (bc : Seq.seq t_B'0) (c : t_FilterMap'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sfilter_map0] produces'0 a ab b)
   -> ([%#sfilter_map1] produces'0 b bc c)  -> ([%#sfilter_map2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse3] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse4] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse2] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  constant self  : t_Fuse'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse'0) : ()
  
  goal vc_produces_refl'0 : [%#sfuse0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse5 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse6 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse5] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse6] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse4] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  constant a  : t_Fuse'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Fuse'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Fuse'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sfuse0] produces'0 a ab b)
   -> ([%#sfuse1] produces'0 b bc c)  -> ([%#sfuse2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 63 15 63 31
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 64 15 64 44
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 65 14 65 50
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 66 63 66 65
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse5 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse6 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse7 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse8 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse9 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse10 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse11 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span smodel12 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfuse13 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse14 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'1 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'1_spec : forall self : t_Fuse'0 . ([%#sfuse13] inv'0 self  -> inv'1 (view'1 self))
  && ([%#sfuse14] forall other : t_Fuse'0 . view'1 self = view'1 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse5] match view'1 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'1 other = view'1 self
      | C_Some'0 i -> match view'1 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
  
   =
    [%#sfuse11] ()
  
  axiom produces_trans'0_spec : forall a : t_Fuse'0, ab : Seq.seq t_Item'0, b : t_Fuse'0, bc : Seq.seq t_Item'0, c : t_Fuse'0 . ([%#sfuse8] produces'0 a ab b)
   -> ([%#sfuse9] produces'0 b bc c)  -> ([%#sfuse10] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse'0) : () =
    [%#sfuse7] ()
  
  axiom produces_refl'0_spec : forall self : t_Fuse'0 . [%#sfuse6] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t t_Fuse'0) : t_Option'0 =
    [%#smodel12] view'1 self.current
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : MutBorrow.t t_Fuse'0) =
    [%#sfuse4] (view'0 self = C_None'0
    \/ (exists it : MutBorrow.t t_I'0 . completed'1 it /\ view'0 self = C_Some'0 (it.current)))
    /\ view'1 self.final = C_None'0
  
  constant self  : MutBorrow.t t_Fuse'0
  
  constant steps  : Seq.seq t_Item'0
  
  constant next  : t_Fuse'0
  
  function is_fused'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (self : MutBorrow.t t_Fuse'0) (steps : Seq.seq t_Item'0) (next : t_Fuse'0) : ()
  
  
  goal vc_is_fused'0 : ([%#sfuse0] completed'0 self)
   -> ([%#sfuse1] produces'0 self.final steps next)
   -> ([%#sfuse2] steps = (Seq.empty : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_refl [#"../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 80 14 80 45
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 81 27 81 29
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap4 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap2] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_Map'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26] (self : t_Map'0) : ()
  
  goal vc_produces_refl'0 : [%#smap0] produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_trans [#"../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 85 15 85 32
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 86 15 86 32
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 87 14 87 42
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 88 91 88 93
  let%span smap4 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap5 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap6 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap5] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter15] produces'1 a ab b)
   -> ([%#siter16] produces'1 b bc c)  -> ([%#siter17] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter14] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap6] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap4] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  constant a  : t_Map'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_Map'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_Map'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90] (a : t_Map'0) (ab : Seq.seq t_B'0) (b : t_Map'0) (bc : Seq.seq t_B'0) (c : t_Map'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#smap0] produces'0 a ab b)
   -> ([%#smap1] produces'0 b bc c)  -> ([%#smap2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 27 24 29
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops9] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops6] unnest'0 self b)
   -> ([%#sops7] unnest'0 b c)  -> ([%#sops8] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops5] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops3] postcondition_mut'0 self args res_state res)
   -> ([%#sops4] unnest'0 self res_state)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter11] produces'1 a ab b)
   -> ([%#siter12] produces'1 b bc c)  -> ([%#siter13] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter10] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv2] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  constant self  : t_MapInv'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : ()
  
  goal vc_produces_refl'0 : [%#smap_inv0] produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv4] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  constant a  : t_MapInv'0
  
  constant ab  : Seq.seq t_B'0
  
  constant b  : t_MapInv'0
  
  constant bc  : Seq.seq t_B'0
  
  constant c  : t_MapInv'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#smap_inv0] produces'0 a ab b)
   -> ([%#smap_inv1] produces'0 b bc c)  -> ([%#smap_inv2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence [#"../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 62 15 62 39
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 63 14 63 31
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 64 32 64 34
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  
  use seq.Seq
  
  type t_I'0
  
  type t_F'0
  
  type t_B'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_B'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Seq.seq t_B'0) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_MapInv'0) =
    match _1 with
      | {t_MapInv__iter'0 = x0 ; t_MapInv__func'0 = x1 ; t_MapInv__produced'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self : t_MapInv'0) =
    [%#smap_inv3] resolve'3 self.t_MapInv__iter'0 /\ resolve'2 self.t_MapInv__func'0
  
  constant self  : t_MapInv'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31] (self : t_MapInv'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#smap_inv0] structural_resolve'0 self)  -> ([%#smap_inv1] resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next [#"../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 91 39 91 58
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 94 16 94 76
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 95 31 95 71
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 99 38 99 88
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 100 32 100 63
  let%span smap_inv5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 105 32 105 56
  let%span smap_inv6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 17 90 21
  let%span smap_inv7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 26 90 44
  let%span smap_inv8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 86 14 89 5
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 169 27 169 52
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 170 26 170 71
  let%span smap_inv12 = "../../creusot-contracts/src/std/iter/map_inv.rs" 163 15 163 31
  let%span smap_inv13 = "../../creusot-contracts/src/std/iter/map_inv.rs" 164 4 164 60
  let%span smap_inv14 = "../../creusot-contracts/src/std/iter/map_inv.rs" 165 15 165 30
  let%span smap_inv15 = "../../creusot-contracts/src/std/iter/map_inv.rs" 166 15 166 64
  let%span smap_inv16 = "../../creusot-contracts/src/std/iter/map_inv.rs" 167 14 167 74
  let%span smap_inv17 = "../../creusot-contracts/src/std/iter/map_inv.rs" 168 14 168 75
  let%span smap_inv18 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 68
  let%span smap_inv19 = "../../creusot-contracts/src/std/iter/map_inv.rs" 182 12 187 74
  let%span smap_inv20 = "../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv21 = "../../creusot-contracts/src/std/iter/map_inv.rs" 74 12 76 73
  let%span smap_inv22 = "../../creusot-contracts/src/std/iter/map_inv.rs" 124 14 124 81
  let%span smap_inv23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 127 12 132 88
  let%span smap_inv24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 117 12 119 63
  let%span smap_inv25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sresolve26 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smap_inv27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 27 24 29
  let%span smap_inv29 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv30 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv31 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv32 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span siter33 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter34 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter35 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter36 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops37 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops38 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops39 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops40 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops41 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops42 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops43 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span smap_inv44 = "../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 156 47
  let%span smap_inv45 = "../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  let%span sinvariant46 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_I'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_I'0) =
    [%#sinvariant46] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_I'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_I'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'9 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Item'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'5 x] . inv'5 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'9 a_0
    end
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter34] produces'0 a ab b)
   -> ([%#siter35] produces'0 b bc c)  -> ([%#siter36] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter33] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  let rec next'1 (self:MutBorrow.t t_I'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'0)-> {inv'5 result}
      {[%#siter9] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Item'0))= any
    [ good (field_0:t_Item'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_B'0
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_F'0) =
    [%#sinvariant46] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_F'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_F'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : tuple'0 [inv'7 x] . inv'7 x = (let {_0'0 = x0 ; _1'0 = x1} = x in inv'9 x0)
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops43] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'2 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops40] unnest'0 self b)
   -> ([%#sops41] unnest'0 b c)  -> ([%#sops42] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops39] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops37] postcondition_mut'0 self args res_state res)
   -> ([%#sops38] unnest'0 self res_state)
  
  let rec call_mut'0 (self:MutBorrow.t t_F'0) (args:tuple'0) (return'  (ret:t_B'0))= {[@expl:call_mut 'self' type invariant] inv'6 self}
    {[@expl:call_mut 'args' type invariant] inv'7 args}
    {[@expl:call_mut requires] [%#sops10] precondition'0 self.current args}
    any
    [ return' (result:t_B'0)-> {inv'8 result}
      {[%#sops11] postcondition_mut'0 self.current args self.final result}
      (! return' {result}) ]
  
  
  predicate next_precondition'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 115 4 115 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv24] forall e : t_Item'0, i : t_I'0 . produces'0 iter (Seq.singleton e) i
     -> precondition'0 func { _0'0 = e; _1'0 = produced }
  
  predicate preservation'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 49] (iter : t_I'0) (func : t_F'0)
  
   =
    [%#smap_inv45] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _0'0 = e1; _1'0 = s }
     -> postcondition_mut'0 f.current { _0'0 = e1; _1'0 = s } f.final b
     -> precondition'0 f.final { _0'0 = e2; _1'0 = Seq.snoc s e1 }
  
  predicate reinitialize'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 33]  =
    [%#smap_inv44] forall iter : MutBorrow.t t_I'0, func : t_F'0 . completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  predicate preservation_inv'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv23] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _0'0 = e1; _1'0 = Seq.(++) produced s }
     -> postcondition_mut'0 f.current { _0'0 = e1; _1'0 = Seq.(++) produced s } f.final b
     -> precondition'0 f.final { _0'0 = e2; _1'0 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv22] produced
  = (Seq.empty : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 72 4 72 30] (self : t_MapInv'0) =
    [%#smap_inv21] reinitialize'0
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
  
  function produces_one_invariant'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 169 4 169 73] (self : t_MapInv'0) (e : t_Item'0) (r : t_B'0) (f : MutBorrow.t t_F'0) (iter : t_I'0) : ()
  
  
  axiom produces_one_invariant'0_spec : forall self : t_MapInv'0, e : t_Item'0, r : t_B'0, f : MutBorrow.t t_F'0, iter : t_I'0 . ([%#smap_inv12] invariant'0 self)
   -> ([%#smap_inv13] produces'0 self.t_MapInv__iter'0 (Seq.singleton e) iter)
   -> ([%#smap_inv14] f.current = self.t_MapInv__func'0)
   -> ([%#smap_inv15] postcondition_mut'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 } f.final r)
   -> ([%#smap_inv16] preservation_inv'0 iter f.final (Seq.snoc self.t_MapInv__produced'0 e))
  && ([%#smap_inv17] next_precondition'0 iter f.final (Seq.snoc self.t_MapInv__produced'0 e))
  
  predicate produces'1 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv25] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'0 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
   =
    [%#smap_inv32] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv29] produces'1 a ab b)
   -> ([%#smap_inv30] produces'1 b bc c)  -> ([%#smap_inv31] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : () =
    [%#smap_inv28] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . [%#smap_inv27] produces'1 self (Seq.empty : Seq.seq t_B'0) self
  
  predicate produces_one'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv19] exists f : MutBorrow.t t_F'0, e : t_Item'0 . f.current = self.t_MapInv__func'0
    /\ f.final = succ.t_MapInv__func'0
    /\ produces'0 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.snoc self.t_MapInv__produced'0 e
    /\ precondition'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 }
    /\ postcondition_mut'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 } f.final visited
  
  axiom produces_one'0_spec : forall self : t_MapInv'0, visited : t_B'0, succ : t_MapInv'0 . [%#smap_inv18] produces_one'0 self visited succ
  = produces'1 self (Seq.singleton visited) succ
  
  predicate inv'10 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_MapInv'0 [inv'10 x] . inv'10 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'0 iter /\ inv'1 func
    end)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_MapInv'0) =
    [%#sinvariant46] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_MapInv'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_MapInv'0) =
    [%#sresolve26] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_MapInv'0) =
    resolve'1 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_B'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'8 a_0
    end
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : MutBorrow.t t_MapInv'0)
   =
    [%#smap_inv20] (self.final).t_MapInv__produced'0 = (Seq.empty : Seq.seq t_Item'0)
    /\ completed'1 (MutBorrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  meta "compute_max_steps" 1000000
  
  let rec next'0[#"../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44] (self:MutBorrow.t t_MapInv'0) (return'  (ret:t_Option'1))= {[@expl:next 'self' type invariant] [%#smap_inv6] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#smap_inv0] self.current ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 (self.current).t_MapInv__iter'0}
        MutBorrow.borrow_final
          <t_I'0>
          {(self.current).t_MapInv__iter'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_I'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_MapInv__iter'0 = _ret'.final } } ] 
            s1)
      | s1 = next'1 {_6} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_5 = C_None'0} (! bb5) | br1 (x0:t_Item'0)-> {_5 = C_Some'0 x0} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = v_Some'0 {_5} (fun (r0'0:t_Item'0) ->  [ &v <- r0'0 ] s1)
      | s1 = {[@expl:assertion] [%#smap_inv1] precondition'0 (self.current).t_MapInv__func'0 { _0'0 = v;
                                                                                               _1'0 = (self.current).t_MapInv__produced'0 }}
        s2
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &produced <- [%#smap_inv2] Seq.snoc (self.current).t_MapInv__produced'0 v ] s1 | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = {inv'1 (self.current).t_MapInv__func'0}
        MutBorrow.borrow_final
          <t_F'0>
          {(self.current).t_MapInv__func'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_F'0) ->
             [ &_14 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { self.current with t_MapInv__func'0 = _ret'.final } } ] 
            s1)
      | s1 =  [ &_15 <- { _0'0 = v; _1'0 = (self.current).t_MapInv__produced'0 } ] s2
      | s2 = call_mut'0 {_14} {_15} (fun (_ret':t_B'0) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_MapInv__produced'0 = produced } } ] s1
      | s1 =  [ &_19 <- [%#smap_inv3] let _ = () in () ] s2
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = {[@expl:assertion] [%#smap_inv4] produces_one'0 old_self r self.current} s1 | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'2 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 =  [ &_0 <- C_Some'1 r ] s3
      | s3 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb17
    | bb5 = s0 [ s0 =  [ &_24 <- [%#smap_inv5] Seq.empty : Seq.seq t_Item'0 ] s1 | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_MapInv__produced'0 = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv'2 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- C_None'1 ] s4
      | s4 = bb17 ]
    
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : t_Option'1 = Any.any_l ()
    | & self : MutBorrow.t t_MapInv'0 = self
    | & old_self : t_MapInv'0 = Any.any_l ()
    | & _5 : t_Option'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_I'0 = Any.any_l ()
    | & v : t_Item'0 = Any.any_l ()
    | & produced : Seq.seq t_Item'0 = Any.any_l ()
    | & r : t_B'0 = Any.any_l ()
    | & _14 : MutBorrow.t t_F'0 = Any.any_l ()
    | & _15 : tuple'0 = Any.any_l ()
    | & _19 : () = Any.any_l ()
    | & _24 : Seq.seq t_Item'0 = Any.any_l () ]
    
    [ return' (result:t_Option'1)-> {[@expl:next result type invariant] [%#smap_inv7] inv'3 result}
      {[@expl:next ensures] [%#smap_inv8] match result with
        | C_None'1 -> completed'0 self
        | C_Some'1 v -> produces_one'0 self.current v self.final
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__preservation_inv [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 124 14 124 81
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 127 12 132 88
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops9] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops6] unnest'0 self b)
   -> ([%#sops7] unnest'0 b c)  -> ([%#sops8] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops5] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops3] postcondition_mut'0 self args res_state res)
   -> ([%#sops4] unnest'0 self res_state)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter11] produces'0 a ab b)
   -> ([%#siter12] produces'0 b bc c)  -> ([%#siter13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter10] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate preservation'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 49] (iter : t_I'0) (func : t_F'0)
  
   =
    [%#smap_inv2] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _0'0 = e1; _1'0 = s }
     -> postcondition_mut'0 f.current { _0'0 = e1; _1'0 = s } f.final b
     -> precondition'0 f.final { _0'0 = e2; _1'0 = Seq.snoc s e1 }
  
  constant iter  : t_I'0
  
  constant func  : t_F'0
  
  constant produced  : Seq.seq t_Item'0
  
  predicate preservation_inv'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
  
  goal vc_preservation_inv'0 : [%#smap_inv0] produced = (Seq.empty : Seq.seq t_Item'0)
   -> ([%#smap_inv1] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
   -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
   -> precondition'0 f.current { _0'0 = e1; _1'0 = Seq.(++) produced s }
   -> postcondition_mut'0 f.current { _0'0 = e1; _1'0 = Seq.(++) produced s } f.final b
   -> precondition'0 f.final { _0'0 = e2; _1'0 = Seq.snoc (Seq.(++) produced s) e1 })
  = preservation'0 iter func
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi6396809843712938673__produces_one [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (* std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 68
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 182 12 187 74
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 27 24 29
  let%span smap_inv5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops15 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops16 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops17 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops18 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops19 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops19] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops16] unnest'0 self b)
   -> ([%#sops17] unnest'0 b c)  -> ([%#sops18] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops15] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops13] postcondition_mut'0 self args res_state res)
   -> ([%#sops14] unnest'0 self res_state)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter9] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv2] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
   =
    [%#smap_inv8] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv5] produces'0 a ab b)
   -> ([%#smap_inv6] produces'0 b bc c)  -> ([%#smap_inv7] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : () =
    [%#smap_inv4] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . [%#smap_inv3] produces'0 self (Seq.empty : Seq.seq t_B'0) self
  
  constant self  : t_MapInv'0
  
  constant visited  : t_B'0
  
  constant succ  : t_MapInv'0
  
  predicate produces_one'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
  
  
  goal vc_produces_one'0 : [%#smap_inv0] ([%#smap_inv1] exists f : MutBorrow.t t_F'0, e : t_Item'0 . f.current
  = self.t_MapInv__func'0
  /\ f.final = succ.t_MapInv__func'0
  /\ produces'1 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
  /\ succ.t_MapInv__produced'0 = Seq.snoc self.t_MapInv__produced'0 e
  /\ precondition'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 }
  /\ postcondition_mut'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 } f.final visited)
  = produces'0 self (Seq.singleton visited) succ
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl [#"../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 31 14 31 45
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 32 27 32 29
  let%span sonce2 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_Once'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26] (self : t_Once'0) : ()
  
  goal vc_produces_refl'0 : [%#sonce0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans [#"../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 36 15 36 32
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 37 15 37 32
  let%span sonce2 = "../../creusot-contracts/src/std/iter/once.rs" 38 14 38 42
  let%span sonce3 = "../../creusot-contracts/src/std/iter/once.rs" 39 91 39 93
  let%span sonce4 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant a  : t_Once'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Once'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Once'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90] (a : t_Once'0) (ab : Seq.seq t_T'0) (b : t_Once'0) (bc : Seq.seq t_T'0) (c : t_Once'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sonce0] produces'0 a ab b)
   -> ([%#sonce1] produces'0 b bc c)  -> ([%#sonce2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 35 14 35 45
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 36 27 36 29
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange2] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  constant self  : t_Range'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26] (self : t_Range'0) : ()
  
  goal vc_produces_refl'0 : [%#srange0] produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 40 15 40 32
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 41 15 41 32
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 42 14 42 42
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 43 91 43 93
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange4] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  constant a  : t_Range'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_Range'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_Range'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90] (a : t_Range'0) (ab : Seq.seq t_Idx'0) (b : t_Range'0) (bc : Seq.seq t_Idx'0) (c : t_Range'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srange0] produces'0 a ab b)
   -> ([%#srange1] produces'0 b bc c)  -> ([%#srange2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 62 14 62 50
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 63 32 63 34
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange2] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  constant self  : t_Range'0
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31] (self : t_Range'0) : ()
  
  goal vc_produces_back_refl'0 : [%#srange0] produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 67 15 67 37
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 68 15 68 37
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 69 14 69 47
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 70 96 70 98
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange4] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  constant a  : t_Range'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_Range'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_Range'0
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95] (a : t_Range'0) (ab : Seq.seq t_Idx'0) (b : t_Range'0) (bc : Seq.seq t_Idx'0) (c : t_Range'0) : ()
  
  
  goal vc_produces_back_trans'0 : ([%#srange0] produces_back'0 a ab b)
   -> ([%#srange1] produces_back'0 b bc c)  -> ([%#srange2] produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__range_inclusive_len [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92]
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span sops1 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops1] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  constant r  : t_RangeInclusive'0
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
  
  goal vc_range_inclusive_len'0 : ([%#sops1] not is_empty_log'0 r
   -> deep_model'0 (start_log'0 r) <= deep_model'0 (end_log'0 r))
   -> (if is_empty_log'0 r then
    [%#srange0] is_empty_log'0 r = (0 = 0)
  else
    [%#srange0] is_empty_log'0 r = (deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1 = 0)
  )
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl [#"../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 107 14 107 45
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 108 27 108 29
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops5] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange4] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange3] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange2] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  constant self  : t_RangeInclusive'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26] (self : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_refl'0 : [%#srange0] produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans [#"../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 112 15 112 32
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 113 15 113 32
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 114 14 114 42
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 115 91 115 93
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange5 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange6 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops7] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange6] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange5] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange4] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  constant a  : t_RangeInclusive'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_RangeInclusive'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_RangeInclusive'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90] (a : t_RangeInclusive'0) (ab : Seq.seq t_Idx'0) (b : t_RangeInclusive'0) (bc : Seq.seq t_Idx'0) (c : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srange0] produces'0 a ab b)
   -> ([%#srange1] produces'0 b bc c)  -> ([%#srange2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl [#"../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 134 14 134 50
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 135 32 135 34
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops5] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange4] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange3] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange2] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  constant self  : t_RangeInclusive'0
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31] (self : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_back_refl'0 : [%#srange0] produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans [#"../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 139 15 139 37
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 140 15 140 37
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 141 14 141 47
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 142 96 142 98
  let%span srange4 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange5 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange6 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops7] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange6] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange5] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange4] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  constant a  : t_RangeInclusive'0
  
  constant ab  : Seq.seq t_Idx'0
  
  constant b  : t_RangeInclusive'0
  
  constant bc  : Seq.seq t_Idx'0
  
  constant c  : t_RangeInclusive'0
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95] (a : t_RangeInclusive'0) (ab : Seq.seq t_Idx'0) (b : t_RangeInclusive'0) (bc : Seq.seq t_Idx'0) (c : t_RangeInclusive'0) : ()
  
  
  goal vc_produces_back_trans'0 : ([%#srange0] produces_back'0 a ab b)
   -> ([%#srange1] produces_back'0 b bc c)  -> ([%#srange2] produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl [#"../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 31 14 31 45
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 32 27 32 29
  let%span srepeat2 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat2] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  constant self  : t_Repeat'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26] (self : t_Repeat'0) : ()
  
  goal vc_produces_refl'0 : [%#srepeat0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans [#"../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 36 15 36 32
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 37 15 37 32
  let%span srepeat2 = "../../creusot-contracts/src/std/iter/repeat.rs" 38 14 38 42
  let%span srepeat3 = "../../creusot-contracts/src/std/iter/repeat.rs" 39 91 39 93
  let%span srepeat4 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat4] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  constant a  : t_Repeat'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Repeat'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Repeat'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90] (a : t_Repeat'0) (ab : Seq.seq t_T'0) (b : t_Repeat'0) (bc : Seq.seq t_T'0) (c : t_Repeat'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srepeat0] produces'0 a ab b)
   -> ([%#srepeat1] produces'0 b bc c)  -> ([%#srepeat2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl [#"../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 47 14 47 45
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 48 27 48 29
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev3 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  use seq.Seq
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces_back'0 a ab b)
   -> ([%#siter6] produces_back'0 b bc c)  -> ([%#siter7] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter4] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev2] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  constant self  : t_Rev'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26] (self : t_Rev'0) : ()
  
  goal vc_produces_refl'0 : [%#srev0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans [#"../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 52 15 52 32
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 53 15 53 32
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 54 14 54 42
  let%span srev3 = "../../creusot-contracts/src/std/iter/rev.rs" 55 91 55 93
  let%span srev4 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev5 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  use seq.Seq
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter7] produces_back'0 a ab b)
   -> ([%#siter8] produces_back'0 b bc c)  -> ([%#siter9] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter6] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev5] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev4] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  constant a  : t_Rev'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Rev'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Rev'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90] (a : t_Rev'0) (ab : Seq.seq t_Item'0) (b : t_Rev'0) (bc : Seq.seq t_Item'0) (c : t_Rev'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#srev0] produces'0 a ab b)
   -> ([%#srev1] produces'0 b bc c)  -> ([%#srev2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl [#"../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 73 14 73 45
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 74 27 74 29
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip4 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip3] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip4] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip2] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant self  : t_Skip'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26] (self : t_Skip'0) : ()
  
  goal vc_produces_refl'0 : [%#sskip0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 78 15 78 32
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 32
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 80 14 80 42
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 81 91 81 93
  let%span sskip4 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip5 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip6 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip5] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip6] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip4] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  constant a  : t_Skip'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Skip'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Skip'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (a : t_Skip'0) (ab : Seq.seq t_Item'0) (b : t_Skip'0) (bc : Seq.seq t_Item'0) (c : t_Skip'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sskip0] produces'0 a ab b)
   -> ([%#sskip1] produces'0 b bc c)  -> ([%#sskip2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl [#"../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 71 14 71 45
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 72 27 72 29
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake4 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake3] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake4] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake2] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant self  : t_Take'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26] (self : t_Take'0) : ()
  
  goal vc_produces_refl'0 : [%#stake0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 76 15 76 32
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 77 15 77 32
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 78 14 78 42
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 79 91 79 93
  let%span stake4 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake5 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake6 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake5] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake6] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake4] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  constant a  : t_Take'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Take'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Take'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (a : t_Take'0) (ab : Seq.seq t_Item'0) (b : t_Take'0) (bc : Seq.seq t_Item'0) (c : t_Take'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#stake0] produces'0 a ab b)
   -> ([%#stake1] produces'0 b bc c)  -> ([%#stake2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl [#"../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 55 14 55 45
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 56 27 56 29
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip4 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A'0
  
  type t_B'0
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: t_Item'1 }
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_A'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'1 (itera'0 self)
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter6] produces'2 a ab b)
   -> ([%#siter7] produces'2 b bc c)  -> ([%#siter8] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_B'0 . [%#siter5] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip4] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq tuple'0) (o : t_Zip'0)
  
   =
    [%#szip2] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _0'0 = Seq.get p1 i; _1'0 = Seq.get p2 i })
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  constant self  : t_Zip'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26] (self : t_Zip'0) : ()
  
  goal vc_produces_refl'0 : [%#szip0] produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans [#"../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 60 15 60 32
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 61 15 61 32
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 62 14 62 42
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 63 91 63 93
  let%span szip4 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip5 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip6 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A'0
  
  type t_B'0
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: t_Item'1 }
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter8] produces'1 a ab b)
   -> ([%#siter9] produces'1 b bc c)  -> ([%#siter10] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_A'0 . [%#siter7] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip5] inv'0 self  -> inv'1 (itera'0 self)
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'2 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'2_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter8] produces'2 a ab b)
   -> ([%#siter9] produces'2 b bc c)  -> ([%#siter10] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_B'0 . [%#siter7] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip6] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq tuple'0) (o : t_Zip'0)
  
   =
    [%#szip4] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _0'0 = Seq.get p1 i; _1'0 = Seq.get p2 i })
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  constant a  : t_Zip'0
  
  constant ab  : Seq.seq tuple'0
  
  constant b  : t_Zip'0
  
  constant bc  : Seq.seq tuple'0
  
  constant c  : t_Zip'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90] (a : t_Zip'0) (ab : Seq.seq tuple'0) (b : t_Zip'0) (bc : Seq.seq tuple'0) (c : t_Zip'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#szip0] produces'0 a ab b)
   -> ([%#szip1] produces'0 b bc c)  -> ([%#szip2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl [#"../../creusot-contracts/src/std/iter.rs" 263 4 263 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 262 14 262 45
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 263 27 263 29
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I'0
  
  type t_Item'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter2] produces'1 self.current visited o.current /\ self.final = o.final
  
  constant self  : MutBorrow.t t_I'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 263 4 263 26] (self : MutBorrow.t t_I'0) : ()
  
  goal vc_produces_refl'0 : [%#siter0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans [#"../../creusot-contracts/src/std/iter.rs" 270 4 270 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 267 15 267 32
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 268 15 268 32
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 269 14 269 42
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 270 91 270 93
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter8 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I'0
  
  type t_Item'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter6] produces'1 a ab b)
   -> ([%#siter7] produces'1 b bc c)  -> ([%#siter8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter4] produces'1 self.current visited o.current /\ self.final = o.final
  
  constant a  : MutBorrow.t t_I'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : MutBorrow.t t_I'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : MutBorrow.t t_I'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 270 4 270 90] (a : MutBorrow.t t_I'0) (ab : Seq.seq t_Item'0) (b : MutBorrow.t t_I'0) (bc : Seq.seq t_Item'0) (c : MutBorrow.t t_I'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#siter0] produces'0 a ab b)
   -> ([%#siter1] produces'0 b bc c)  -> ([%#siter2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_replace_body [#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52]
  let%span smem0 = "../../creusot-contracts/src/std/mem.rs" 10 26 10 30
  let%span smem1 = "../../creusot-contracts/src/std/mem.rs" 10 40 10 43
  let%span smem2 = "../../creusot-contracts/src/std/mem.rs" 10 51 10 52
  let%span smem3 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem4 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span smem5 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem6 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span sresolve7 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant8] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  let rec swap'0 (x:MutBorrow.t t_T'0) (y:MutBorrow.t t_T'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'1 x}
    {[@expl:swap 'y' type invariant] inv'1 y}
    any [ return' (result:())-> {[%#smem5] x.final = y.current} {[%#smem6] y.final = x.current} (! return' {result}) ] 
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve7] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_replace_body'0[#"../../creusot-contracts/src/std/mem.rs" 10 12 10 52] (dest:MutBorrow.t t_T'0) (src:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_mem_replace_body 'dest' type invariant] [%#smem0] inv'1 dest}
    {[@expl:extern_spec_std_mem_replace_body 'src' type invariant] [%#smem1] inv'0 src}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 =  [ &src1 <- src ] s1
      | s1 = {inv'0 dest.current}
        MutBorrow.borrow_final <t_T'0> {dest.current} {MutBorrow.get_id dest}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_7 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &dest <- { dest with current = _ret'.final } ] 
            s2)
      | s2 = {inv'0 src1}
        MutBorrow.borrow_mut <t_T'0> {src1}
          (fun (_ret':MutBorrow.t t_T'0) ->  [ &_9 <- _ret' ] -{inv'0 _ret'.final}-  [ &src1 <- _ret'.final ] s3)
      | s3 = {inv'0 _9.current}
        MutBorrow.borrow_final <t_T'0> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_8 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_9 <- { _9 with current = _ret'.final } ] 
            s4)
      | s4 = swap'0 {_7} {_8} (fun (_ret':()) ->  [ &_6 <- _ret' ] s5)
      | s5 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _9} s1
      | s1 = -{resolve'0 _9}- s2
      | s2 = {[@expl:type invariant] inv'1 dest} s3
      | s3 = -{resolve'0 dest}- s4
      | s4 =  [ &_0 <- src1 ] s5
      | s5 = bb3 ]
    
    | bb3 = bb4
    | bb4 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & dest : MutBorrow.t t_T'0 = dest
    | & src : t_T'0 = src
    | & src1 : t_T'0 = Any.any_l ()
    | & _6 : () = Any.any_l ()
    | & _7 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _8 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_mem_replace_body result type invariant] [%#smem2] inv'0 result}
      {[@expl:extern_spec_std_mem_replace_body ensures #0] [%#smem3] dest.final = src}
      {[@expl:extern_spec_std_mem_replace_body ensures #1] [%#smem4] result = dest.current}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_take_body [#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50]
  let%span smem0 = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem1 = "../../creusot-contracts/src/std/mem.rs" 23 49 23 50
  let%span smem2 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem3 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 42
  let%span sdefault4 = "../../creusot-contracts/src/std/default.rs" 31 26 31 45
  let%span smem5 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem6 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span sresolve7 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate is_default'0 [#"../../creusot-contracts/src/std/default.rs" 24 4 24 32] (self : t_T'0)
  
  let rec default'0 (return'  (ret:t_T'0))= any
    [ return' (result:t_T'0)-> {inv'0 result} {[%#sdefault4] is_default'0 result} (! return' {result}) ]
  
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant8] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  let rec replace'0 (dest:MutBorrow.t t_T'0) (src:t_T'0) (return'  (ret:t_T'0))= {[@expl:replace 'dest' type invariant] inv'1 dest}
    {[@expl:replace 'src' type invariant] inv'0 src}
    any
    [ return' (result:t_T'0)-> {inv'0 result}
      {[%#smem5] dest.final = src}
      {[%#smem6] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve7] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_take_body'0[#"../../creusot-contracts/src/std/mem.rs" 23 12 23 50] (dest:MutBorrow.t t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_mem_take_body 'dest' type invariant] [%#smem0] inv'1 dest}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 dest.current}
        MutBorrow.borrow_final <t_T'0> {dest.current} {MutBorrow.get_id dest}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &dest <- { dest with current = _ret'.final } ] 
            s1)
      | s1 = default'0 (fun (_ret':t_T'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = replace'0 {_4} {_5} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'1 dest} s1 | s1 = -{resolve'0 dest}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & dest : MutBorrow.t t_T'0 = dest
    | & _4 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _5 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_mem_take_body result type invariant] [%#smem1] inv'0 result}
      {[@expl:extern_spec_std_mem_take_body ensures #0] [%#smem2] result = dest.current}
      {[@expl:extern_spec_std_mem_take_body ensures #1] [%#smem3] is_default'0 dest.final}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_drop_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1]
  let%span smem0 = "../../creusot-contracts/src/std/mem.rs" 29 23 29 25
  let%span smem1 = "../../creusot-contracts/src/std/mem.rs" 28 22 28 34
  
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_drop_body'0[#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1] (_x:t_T'0) (return'  (ret:()))= {[@expl:extern_spec_std_mem_drop_body '_x' type invariant] [%#smem0] inv'0 _x}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv'0 _x} s1 | s1 = -{resolve'0 _x}- s2 | s2 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : () = Any.any_l () | & _x : t_T'0 = _x ] 
    [ return' (result:())-> {[@expl:extern_spec_std_mem_drop_body ensures] [%#smem1] resolve'0 _x}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__mem__extern_spec_std_mem_forget_body [#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1]
  let%span smem0 = "../../creusot-contracts/src/std/mem.rs" 33 25 33 26
  let%span smem1 = "../../creusot-contracts/src/std/mem.rs" 32 22 32 33
  
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_mem_forget_body'0[#"../../creusot-contracts/src/std/mem.rs" 4 0 36 1] (t:t_T'0) (return'  (ret:()))= {[@expl:extern_spec_std_mem_forget_body 't' type invariant] [%#smem0] inv'0 t}
    (! bb0
    [ bb0 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve'0 t}- s2 | s2 = bb1 ]  | bb1 = return' {_0} ]
    ) [ & _0 : () = Any.any_l () | & t : t_T'0 = t ] 
    [ return' (result:())-> {[@expl:extern_spec_std_mem_forget_body ensures] [%#smem1] resolve'0 t}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_PartialEq_Option_T_eq_body [#"../../creusot-contracts/src/std/option.rs" 24 16 24 48]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 28 29 28 34
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 26 40 26 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 22 16 22 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 24 29 24 32
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span scmp5 = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant8] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant8] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function deep_model'4 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'3 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'4 self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel6] deep_model'3 self
  
  let rec eq'0 (self:t_T'0) (other:t_T'0) (return'  (ret:bool))= {[@expl:eq 'self' type invariant] inv'1 self}
    {[@expl:eq 'other' type invariant] inv'1 other}
    any [ return' (result:bool)-> {[%#scmp5] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ] 
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant8] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_DeepModelTy'0
  
  function deep_model'2 [#"../../creusot-contracts/src/std/option.rs" 10 4 10 44] (self : t_Option'0) : t_Option'1 =
    [%#soption7] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'4 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_Option'0) : t_Option'1 =
    [%#smodel6] deep_model'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_PartialEq_Option_T_eq_body'0[#"../../creusot-contracts/src/std/option.rs" 24 16 24 48] (self_:t_Option'0) (rhs:t_Option'0) (return'  (ret:bool))= {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'self_' type invariant] [%#soption2] inv'0 self_}
    {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body 'rhs' type invariant] [%#soption3] inv'0 rhs}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _0'0 = self_; _1'0 = rhs } ] s1
      | s1 = any [ br0 -> {_4._0'0 = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {_4._0'0 = C_Some'0 x0} (! bb4) ]  ]
    
    | bb4 = any [ br0 -> {_4._1'0 = C_None'0} (! bb12) | br1 (x0:t_T'0)-> {_4._1'0 = C_Some'0 x0} (! bb5) ] 
    | bb12 = bb1
    | bb5 = bb6
    | bb6 = s0
      [ s0 = v_Some'0 {_4._0'0} (fun (r0'0:t_T'0) ->  [ &x <- r0'0 ] s1)
      | s1 = v_Some'0 {_4._1'0} (fun (r0'1:t_T'0) ->  [ &y <- r0'1 ] s2)
      | s2 = eq'0 {x} {y} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb8 ]
    
    | bb8 = bb9
    | bb2 = any [ br0 -> {_4._1'0 = C_None'0} (! bb3) | br1 (x0:t_T'0)-> {_4._1'0 = C_Some'0 x0} (! bb1) ] 
    | bb1 = s0 [ s0 =  [ &_0 <- [%#soption0] false ] s1 | s1 = bb9 ] 
    | bb3 = bb7
    | bb7 = s0 [ s0 =  [ &_0 <- [%#soption1] true ] s1 | s1 = bb9 ] 
    | bb9 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & rhs : t_Option'0 = rhs
    | & _4 : tuple'0 = Any.any_l ()
    | & x : t_T'0 = Any.any_l ()
    | & y : t_T'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_option_T_PartialEq_Option_T_eq_body ensures] [%#soption4] result
      = (deep_model'0 self_ = deep_model'0 rhs)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_body [#"../../creusot-contracts/src/std/option.rs" 42 16 42 41]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 45 35 45 39
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 44 32 44 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 40 16 40 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 41 26 41 51
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_some_body'0[#"../../creusot-contracts/src/std/option.rs" 42 16 42 41] (self_:t_Option'0) (return'  (ret:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_body 'self_' type invariant] [%#soption2] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption0] true ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption1] false ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self_ : t_Option'0 = self_ ] 
    [ return' (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_body ensures] [%#soption3] result
      = (self_ <> C_None'0)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_some_and_body [#"../../creusot-contracts/src/std/option.rs" 57 16 57 71]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 59 32 59 37
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 49 16 49 17
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 57 37 57 38
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 49 27 52 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 53 26 56 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type impl_FnOnce_T_____bool'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : impl_FnOnce_T_____bool'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = (let x0 = x in inv'3 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : impl_FnOnce_T_____bool'0) (args : t_T'0)
  
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : impl_FnOnce_T_____bool'0) (args : t_T'0) (result : bool)
  
  
  let rec call_once'0 (self:impl_FnOnce_T_____bool'0) (args:t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'2 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any [ return' (result:bool)-> {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : impl_FnOnce_T_____bool'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_some_and_body'0[#"../../creusot-contracts/src/std/option.rs" 57 16 57 71] (self_:t_Option'0) (f:impl_FnOnce_T_____bool'0) (return'  (ret:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'self_' type invariant] [%#soption1] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body 'f' type invariant] [%#soption2] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body requires] [%#soption3] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once'0 {f} {_8} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- [%#soption0] false ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : impl_FnOnce_T_____bool'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _8 : t_T'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_some_and_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = false
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_is_none_body [#"../../creusot-contracts/src/std/option.rs" 66 16 66 41]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 69 35 69 40
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 68 32 68 36
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 64 16 64 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_is_none_body'0[#"../../creusot-contracts/src/std/option.rs" 66 16 66 41] (self_:t_Option'0) (return'  (ret:bool))= {[@expl:extern_spec_std_option_T_Option_T_is_none_body 'self_' type invariant] [%#soption2] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- [%#soption0] false ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#soption1] true ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self_ : t_Option'0 = self_ ] 
    [ return' (result:bool)-> {[@expl:extern_spec_std_option_T_Option_T_is_none_body ensures] [%#soption3] result
      = (self_ = C_None'0)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_ref_body [#"../../creusot-contracts/src/std/option.rs" 78 16 78 46]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 73 16 73 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 78 36 78 46
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 74 26 74 58
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 76 20 76 89
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_T'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'1) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant4] inv'4 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_ref_body'0[#"../../creusot-contracts/src/std/option.rs" 78 16 78 46] (self_:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_ref_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 =  [ &_0 <- C_Some'1 t ] s2 | s2 = bb5 ]
    
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_ : t_Option'1 = self_ | & t : t_T'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_ref_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #0] [%#soption2] self_ = C_None'0
       -> result = C_None'1}
      {[@expl:extern_spec_std_option_T_Option_T_as_ref_body ensures #1] [%#soption3] self_ = C_None'0
      \/ (exists r : t_T'0 . result = C_Some'1 r /\ self_ = C_Some'0 r)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_body [#"../../creusot-contracts/src/std/option.rs" 91 16 91 54]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 85 16 85 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 91 40 91 54
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 86 26 86 75
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 88 20 89 100
  let%span sresolve4 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant5] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve4] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'2 _1
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'1 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'1) =
    [%#sinvariant5] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'1) =
    [%#sresolve4] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'1) =
    resolve'3 _1
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_mut_body'0[#"../../creusot-contracts/src/std/option.rs" 91 16 91 54] (self_:MutBorrow.t t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_body 'self_' type invariant] [%#soption0] inv'2 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'0 r0'0}
            MutBorrow.borrow_final <t_T'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T'0> {t.current} {MutBorrow.get_id t}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_0 <- C_Some'1 _6 ] s3
      | s3 = {[@expl:type invariant] inv'1 t} s4
      | s4 = -{resolve'0 t}- s5
      | s5 = bb5 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb4 ] 
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv'2 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'1 = self_
    | & t : MutBorrow.t t_T'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_body result type invariant] [%#soption1] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #0] [%#soption2] self_.current = C_None'0
       -> result = C_None'1 /\ self_.final = C_None'0}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_body ensures #1] [%#soption3] self_.current = C_None'0
      \/ (exists r : MutBorrow.t t_T'0 . result = C_Some'1 r
      /\ self_.current = C_Some'0 (r.current) /\ self_.final = C_Some'0 (r.final))}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_slice_body [#"../../creusot-contracts/src/std/option.rs" 103 16 103 42]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 98 16 98 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 103 38 103 42
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 99 26 102 17
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 372 22 372 40
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 373 22 373 38
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 17 20 17 30
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed11 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant8] inv'5 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'5 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed11] inv'5 self
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_T'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 [#"../../creusot-contracts/src/logic/seq.rs" 628 4 628 30] (self : Seq.seq t_T'0) =
    [%#sseq10] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'7 (Seq.get self i)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Seq.seq t_T'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'1 self = Slice64.id self)
  
  predicate invariant'3 [#"../../creusot-contracts/src/std/slice.rs" 16 4 16 30] (self : Slice64.slice t_T'0) =
    [%#sslice9] inv'6 (view'1 self)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : Slice64.slice t_T'0) =
    [%#sinvariant8] inv'4 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'1 self
  
  let rec from_ref'0 (s:t_T'0) (return'  (ret:Slice64.slice t_T'0))= {[@expl:from_ref 's' type invariant] inv'2 s}
    any
    [ return' (result:Slice64.slice t_T'0)-> {inv'1 result}
      {[%#sslice3] Seq.length (view'0 result) = 1}
      {[%#sslice4] Seq.get (view'0 result) 0 = s}
      (! return' {result}) ]
  
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_slice_body'0 (return'  (ret:Slice64.array t_T'0))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T'0)-> (! -{Seq.length __arr_temp.elts = 0}-  [ &_1 <- __arr_temp ] s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Slice64.array t_T'0 = Any.any_l () | & _1 : Slice64.array t_T'0 = Any.any_l () ] 
    [ return' (result:Slice64.array t_T'0)-> return' {result} ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant8] inv'3 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_slice_body'0[#"../../creusot-contracts/src/std/option.rs" 103 16 103 42] (self_:t_Option'0) (return'  (ret:Slice64.slice t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_as_slice_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 = from_ref'0 {t} (fun (_ret':Slice64.slice t_T'0) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_3 <- _9 ] s1 | s1 = bb6 ] 
    | bb2 = bb4
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_slice_body'0 
          (fun (pr0:Slice64.array t_T'0) ->  [ &_11 <- pr0 ] s1)
      | s1 =  [ &_6 <- _11 ] s2
      | s2 =  [ &_3 <- _6 ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- _3 ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : Slice64.slice t_T'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & _3 : Slice64.slice t_T'0 = Any.any_l ()
    | & _6 : Slice64.array t_T'0 = Any.any_l ()
    | & t : t_T'0 = Any.any_l ()
    | & _9 : Slice64.slice t_T'0 = Any.any_l ()
    | & _11 : Slice64.array t_T'0 = Any.any_l () ]
    
    [ return' (result:Slice64.slice t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_as_slice_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_slice_body ensures] [%#soption2] match self_ with
        | C_None'0 -> Seq.length (view'0 result) = 0
        | C_Some'0 t -> Seq.length (view'0 result) = 1 /\ Seq.get (view'0 result) 0 = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_as_mut_slice_body [#"../../creusot-contracts/src/std/option.rs" 118 16 118 54]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 110 16 110 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 118 46 118 54
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 111 26 117 17
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 377 22 377 40
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 378 22 378 38
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 379 22 379 43
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 380 22 380 41
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sresolve10 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sslice11 = "../../creusot-contracts/src/std/slice.rs" 17 20 17 30
  let%span sinvariant12 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sarray13 = "../../creusot-contracts/src/std/array.rs" 14 20 14 30
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant12] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'7 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed15] inv'0 self
  
  predicate inv'9 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_T'0 [inv'9 x] . inv'9 x = invariant'7 x
  
  predicate invariant'6 [#"../../creusot-contracts/src/logic/seq.rs" 628 4 628 30] (self : Seq.seq t_T'0) =
    [%#sseq14] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Seq.seq t_T'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : Slice64.slice t_T'0 . ([%#sslice8] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice9] view'1 self = Slice64.id self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/slice.rs" 16 4 16 30] (self : Slice64.slice t_T'0) =
    [%#sslice11] inv'7 (view'1 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t (Slice64.slice t_T'0))
  
   =
    [%#sinvariant12] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t (Slice64.slice t_T'0))
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t (Slice64.slice t_T'0) [inv'2 x] . inv'2 x = invariant'1 x
  
  function view'0 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel7] view'1 self.current
  
  let rec from_mut'0 (s:MutBorrow.t t_T'0) (return'  (ret:MutBorrow.t (Slice64.slice t_T'0)))= {[@expl:from_mut 's' type invariant] inv'3 s}
    any
    [ return' (result:MutBorrow.t (Slice64.slice t_T'0))-> {inv'2 result}
      {[%#sslice3] Seq.length (view'0 result) = 1}
      {[%#sslice4] Seq.get (view'0 result) 0 = s.current}
      {[%#sslice5] Seq.length (view'1 result.final) = 1}
      {[%#sslice6] Seq.get (view'1 result.final) 0 = s.final}
      (! return' {result}) ]
  
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t (Slice64.slice t_T'0))
   =
    [%#sresolve10] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t (Slice64.slice t_T'0)) =
    resolve'4 _1
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve10] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'5 _1
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Option'0 [inv'8 x] . inv'8 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant12] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve10] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  predicate invariant'4 [#"../../creusot-contracts/src/std/array.rs" 13 4 13 30] (self : Slice64.array t_T'0) =
    [%#sarray13] inv'7 (Slice64.id self)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Slice64.array t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Slice64.array t_T'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  let rec promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body'0 (return'  (ret:MutBorrow.t (Slice64.array t_T'0)))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array t_T'0)-> (! -{Seq.length __arr_temp.elts = 0}-  [ &_1 <- __arr_temp ] s1) ]
      
      | s1 = {inv'5 _1}
        MutBorrow.borrow_mut <Slice64.array t_T'0> {_1}
          (fun (_ret':MutBorrow.t (Slice64.array t_T'0)) ->
             [ &_0 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_1 <- _ret'.final ] 
            s2)
      | s2 = return' {_0} ]
     ]
     [ & _0 : MutBorrow.t (Slice64.array t_T'0) = Any.any_l () | & _1 : Slice64.array t_T'0 = Any.any_l () ] 
    [ return' (result:MutBorrow.t (Slice64.array t_T'0))-> return' {result} ]
  
  
  predicate invariant'5 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t (Slice64.array t_T'0))
  
   =
    [%#sinvariant12] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t (Slice64.array t_T'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t (Slice64.array t_T'0) [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate resolve'7 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t (Slice64.array t_T'0))
   =
    [%#sresolve10] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t (Slice64.array t_T'0)) =
    resolve'7 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_as_mut_slice_body'0[#"../../creusot-contracts/src/std/option.rs" 118 16 118 54] (self_:MutBorrow.t t_Option'0) (return'  (ret:MutBorrow.t (Slice64.slice t_T'0)))= {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body 'self_' type invariant] [%#soption0] inv'4 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'0 r0'0}
            MutBorrow.borrow_final <t_T'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T'0> {t.current} {MutBorrow.get_id t}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_11 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s2)
      | s2 = from_mut'0 {_11} (fun (_ret':MutBorrow.t (Slice64.slice t_T'0)) ->  [ &_10 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = {inv'1 _10.current}
        MutBorrow.borrow_final <Slice64.slice t_T'0> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret':MutBorrow.t (Slice64.slice t_T'0)) ->
             [ &_4 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_10 <- { _10 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'3 t} s4
      | s4 = -{resolve'1 t}- s5
      | s5 = bb6 ]
    
    | bb2 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = bb4 ] 
    | bb4 = s0
      [ s0 = promoted0__extern_spec_std_option_T_Option_T_as_mut_slice_body'0 
          (fun (pr0:MutBorrow.t (Slice64.array t_T'0)) ->  [ &_12 <- pr0 ] s1)
      | s1 = {inv'5 _12.current}
        MutBorrow.borrow_final <Slice64.array t_T'0> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret':MutBorrow.t (Slice64.array t_T'0)) ->
             [ &_7 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_12 <- { _12 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'5 _7.current}
        MutBorrow.borrow_final <Slice64.array t_T'0> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret':MutBorrow.t (Slice64.array t_T'0)) ->
             [ &_6 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_7 <- { _7 with current = _ret'.final } ] 
            s3)
      | s3 =  [ &_4 <- _6 ] s4
      | s4 = {[@expl:type invariant] inv'6 _7} s5
      | s5 = -{resolve'3 _7}- s6
      | s6 = bb8 ]
    
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'6 _12} s1 | s1 = -{resolve'3 _12}- s2 | s2 = bb6 ] 
    | bb6 = s0
      [ s0 = {inv'1 _4.current}
        MutBorrow.borrow_final <Slice64.slice t_T'0> {_4.current} {MutBorrow.get_id _4}
          (fun (_ret':MutBorrow.t (Slice64.slice t_T'0)) ->
             [ &_2 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_4 <- { _4 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _2.current}
        MutBorrow.borrow_final <Slice64.slice t_T'0> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret':MutBorrow.t (Slice64.slice t_T'0)) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_2 <- { _2 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _4} s3
      | s3 = -{resolve'0 _4}- s4
      | s4 = {[@expl:type invariant] inv'2 _2} s5
      | s5 = -{resolve'0 _2}- s6
      | s6 = {[@expl:type invariant] inv'4 self_} s7
      | s7 = -{resolve'2 self_}- s8
      | s8 = return' {_0} ]
     ]
    )
    [ & _0 : MutBorrow.t (Slice64.slice t_T'0) = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & _2 : MutBorrow.t (Slice64.slice t_T'0) = Any.any_l ()
    | & _4 : MutBorrow.t (Slice64.slice t_T'0) = Any.any_l ()
    | & _6 : MutBorrow.t (Slice64.array t_T'0) = Any.any_l ()
    | & _7 : MutBorrow.t (Slice64.array t_T'0) = Any.any_l ()
    | & t : MutBorrow.t t_T'0 = Any.any_l ()
    | & _10 : MutBorrow.t (Slice64.slice t_T'0) = Any.any_l ()
    | & _11 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _12 : MutBorrow.t (Slice64.array t_T'0) = Any.any_l () ]
    
    [ return' (result:MutBorrow.t (Slice64.slice t_T'0))-> {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body result type invariant] [%#soption1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_as_mut_slice_body ensures] [%#soption2] match self_.current with
        | C_None'0 -> Seq.length (view'0 result) = 0
        | C_Some'0 _ -> exists b : MutBorrow.t t_T'0 . self_.current = C_Some'0 (b.current)
        /\ self_.final = C_Some'0 (b.final)
        /\ Seq.get (view'1 result.current) 0 = b.current
        /\ Seq.get (view'1 result.final) 0 = b.final
        /\ Seq.length (view'1 result.current) = 1 /\ Seq.length (view'1 result.final) = 1
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_expect_body [#"../../creusot-contracts/src/std/option.rs" 128 16 128 47]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 125 16 125 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 126 27 126 39
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 128 46 128 47
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 127 26 127 46
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_expect_body'0[#"../../creusot-contracts/src/std/option.rs" 128 16 128 47] (self_:t_Option'0) (msg:string) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_expect_body 'self_' type invariant] [%#soption0] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_expect_body requires] [%#soption1] self_ <> C_None'0}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return' {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0 : t_T'0 = Any.any_l () | & self_ : t_Option'0 = self_ | & t : t_T'0 = Any.any_l () ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_expect_body result type invariant] [%#soption2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_expect_body ensures] [%#soption3] C_Some'0 result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_body [#"../../creusot-contracts/src/std/option.rs" 138 16 138 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 135 16 135 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 138 35 138 36
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_body'0[#"../../creusot-contracts/src/std/option.rs" 138 16 138 36] (self_:t_Option'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_body 'self_' type invariant] [%#soption0] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_body requires] [%#soption1] self_ <> C_None'0}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return' {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0 : t_T'0 = Any.any_l () | & self_ : t_Option'0 = self_ | & t : t_T'0 = Any.any_l () ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_body result type invariant] [%#soption2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_body ensures] [%#soption3] C_Some'0 result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_body [#"../../creusot-contracts/src/std/option.rs" 148 16 148 51]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 145 16 145 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 148 35 148 42
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 148 50 148 51
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 146 26 146 60
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 147 26 147 85
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_body'0[#"../../creusot-contracts/src/std/option.rs" 148 16 148 51] (self_:t_Option'0) (default:t_T'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body 'default' type invariant] [%#soption1] inv'0 default}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- default ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_T'0 = default
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body result type invariant] [%#soption2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #0] [%#soption3] self_ = C_None'0
       -> result = default}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_body ensures #1] [%#soption4] self_ = C_None'0
      \/ self_ = C_Some'0 result /\ resolve'0 default}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_else_body [#"../../creusot-contracts/src/std/option.rs" 160 16 162 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 155 16 155 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 160 43 160 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 155 27 155 62
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 160 52 160 53
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 156 26 159 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_T'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_T'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_T'0)-> {inv'2 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 160 16 162 36] (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body requires] [%#soption2] self_ = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & _7 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_else_body ensures] [%#soption4] match self_ with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_or_default_body [#"../../creusot-contracts/src/std/option.rs" 171 16 173 30]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 169 16 169 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 171 46 171 47
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 169 26 169 62
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 170 26 170 62
  let%span sdefault4 = "../../creusot-contracts/src/std/default.rs" 31 26 31 45
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate is_default'0 [#"../../creusot-contracts/src/std/default.rs" 24 4 24 32] (self : t_T'0)
  
  let rec default'0 (return'  (ret:t_T'0))= any
    [ return' (result:t_T'0)-> {inv'1 result} {[%#sdefault4] is_default'0 result} (! return' {result}) ]
  
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_or_default_body'0[#"../../creusot-contracts/src/std/option.rs" 171 16 173 30] (self_:t_Option'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 = default'0 (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = return' {_0} ]
    ) [ & _0 : t_T'0 = Any.any_l () | & self_ : t_Option'0 = self_ | & t : t_T'0 = Any.any_l () ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #0] [%#soption2] self_ = C_None'0
       -> is_default'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_or_default_body ensures #1] [%#soption3] self_ = C_None'0
      \/ self_ = C_Some'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_unwrap_unchecked_body [#"../../creusot-contracts/src/std/option.rs" 183 16 183 53]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 180 16 180 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 181 27 181 39
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 183 52 183 53
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 182 26 182 46
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_unwrap_unchecked_body'0[#"../../creusot-contracts/src/std/option.rs" 183 16 183 53] (self_:t_Option'0) (return'  (ret:t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] [%#soption0] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body requires] [%#soption1] self_ <> C_None'0}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0 [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 =  [ &_0 <- t ] s2 | s2 = bb7 ] 
    | bb7 = bb8
    | bb8 = return' {_0}
    | bb4 = bb6
    | bb6 = {false} any ]
    ) [ & _0 : t_T'0 = Any.any_l () | & self_ : t_Option'0 = self_ | & t : t_T'0 = Any.any_l () ] 
    [ return' (result:t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body result type invariant] [%#soption2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_unwrap_unchecked_body ensures] [%#soption3] C_Some'0 result = self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_body [#"../../creusot-contracts/src/std/option.rs" 198 16 200 37]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 190 16 190 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 198 35 198 36
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 190 27 193 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 198 44 198 53
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 194 26 197 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_U'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let x0 = x in inv'5 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'4 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_body'0[#"../../creusot-contracts/src/std/option.rs" 198 16 200 37] (self_:t_Option'1) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_map_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_9 <- t ] s2
      | s2 = call_once'0 {f} {_9} (fun (_ret':t_U'0) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'1 _7 ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _7 : t_U'0 = Any.any_l ()
    | & _9 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> exists r : t_U'0 . result = C_Some'1 r /\ postcondition_once'0 f t r
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_inspect_body [#"../../creusot-contracts/src/std/option.rs" 216 16 218 33]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 207 16 207 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 216 36 216 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 207 27 210 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 216 45 216 54
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 211 26 211 40
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 212 26 215 17
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant8] inv'3 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'0 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = (let x0 = x in inv'4 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : ())
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:()))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'2 args}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any [ return' (result:())-> {[%#sops7] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_inspect_body'0[#"../../creusot-contracts/src/std/option.rs" 216 16 218 33] (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_inspect_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = any [ br0 -> {self_ = C_None'0} (! bb5) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb6) ] 
    | bb6 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_12 <- t ] s2
      | s2 =  [ &_10 <- _12 ] s3
      | s3 = call_once'0 {f} {_10} (fun (_ret':()) ->  [ &_8 <- _ret' ] s4)
      | s4 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb5 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _10 : t_T'0 = Any.any_l ()
    | & _12 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_inspect_body result type invariant] [%#soption3] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #0] [%#soption4] result = self_}
      {[@expl:extern_spec_std_option_T_Option_T_inspect_body ensures #1] [%#soption5] match self_ with
        | C_None'0 -> true
        | C_Some'0 t -> postcondition_once'0 f t ()
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_body [#"../../creusot-contracts/src/std/option.rs" 233 16 235 37]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 225 16 225 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 233 38 233 45
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 233 50 233 51
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 225 27 228 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 233 59 233 60
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 229 26 232 17
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_U'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_U'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_F'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let x0 = x in inv'4 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'0 result} {[%#sops7] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_body'0[#"../../creusot-contracts/src/std/option.rs" 233 16 235 37] (self_:t_Option'0) (default:t_U'0) (f:t_F'0) (return'  (ret:t_U'0))= {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'default' type invariant] [%#soption1] inv'0 default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body 'f' type invariant] [%#soption2] inv'1 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_body requires] [%#soption3] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_9 <- t ] s4
      | s4 = call_once'0 {f} {_9} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- default ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_U'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_U'0 = default
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _9 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_U'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_body result type invariant] [%#soption4] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_body ensures] [%#soption5] match self_ with
        | C_None'0 -> result = default
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_map_or_else_body [#"../../creusot-contracts/src/std/option.rs" 250 16 253 37]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 242 16 242 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 250 46 250 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 250 58 250 59
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 242 27 245 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 250 67 250 68
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 246 26 249 17
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_D'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_D'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_D'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_U'0
  
  type t_F'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = (let x0 = x in inv'5 x0)
  
  predicate precondition'1 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate postcondition_once'1 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_U'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'4 args}
    {[@expl:call_once requires] [%#sops6] precondition'1 self args}
    any
    [ return' (result:t_U'0)-> {inv'3 result} {[%#sops7] postcondition_once'1 self args result} (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_D'0) (args : ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_D'0) (args : ()) (result : t_U'0)
  
  
  let rec call_once'1 (self:t_D'0) (args:()) (return'  (ret:t_U'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once requires] [%#sops6] precondition'0 self args}
    any
    [ return' (result:t_U'0)-> {inv'3 result} {[%#sops7] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_map_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 250 16 253 37] (self_:t_Option'0) (default:t_D'0) (f:t_F'0) (return'  (ret:t_U'0))= {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'default' type invariant] [%#soption1] inv'0 default}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body 'f' type invariant] [%#soption2] inv'1 f}
    {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body requires] [%#soption3] match self_ with
      | C_None'0 -> precondition'0 default ()
      | C_Some'0 t -> precondition'1 f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 default} s1
      | s1 = -{resolve'0 default}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_11 <- t ] s4
      | s4 = call_once'0 {f} {_11} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 f} s1 | s1 = -{resolve'1 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 = call_once'1 {default} {_8} (fun (_ret':t_U'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_U'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & default : t_D'0 = default
    | & f : t_F'0 = f
    | & _8 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l ()
    | & _11 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_U'0)-> {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body result type invariant] [%#soption4] inv'3 result}
      {[@expl:extern_spec_std_option_T_Option_T_map_or_else_body ensures] [%#soption5] match self_ with
        | C_None'0 -> postcondition_once'0 default () result
        | C_Some'0 t -> postcondition_once'1 f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_body [#"../../creusot-contracts/src/std/option.rs" 265 16 265 57]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 260 16 260 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 265 34 265 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 265 45 265 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 261 26 264 17
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_E'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_E'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_E'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Result'0  =
    | C_Ok'0 t_T'0
    | C_Err'0 t_E'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Result'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'0 [inv'2 x] . inv'2 x
  = match x with
    | C_Ok'0 a_0 -> inv'3 a_0
    | C_Err'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_body'0[#"../../creusot-contracts/src/std/option.rs" 265 16 265 57] (self_:t_Option'0) (err:t_E'0) (return'  (ret:t_Result'0))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_body 'err' type invariant] [%#soption1] inv'0 err}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None'0} (! bb3) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb4) ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'0 err} s1
      | s1 = -{resolve'0 err}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Ok'0 t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- C_Err'0 err ] s1 | s1 = bb6 ] 
    | bb6 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_Result'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & err : t_E'0 = err
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_body ensures] [%#soption3] match self_ with
        | C_None'0 -> result = C_Err'0 err
        | C_Some'0 t -> result = C_Ok'0 t /\ resolve'0 err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_ok_or_else_body [#"../../creusot-contracts/src/std/option.rs" 277 16 279 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 272 16 272 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 277 42 277 45
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 272 27 272 64
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 277 53 277 65
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 273 26 276 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_E'0
  
  type t_Result'0  =
    | C_Ok'0 t_T'0
    | C_Err'0 t_E'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_E'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_E'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_E'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_E'0)-> {inv'3 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Result'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'0 [inv'2 x] . inv'2 x
  = match x with
    | C_Ok'0 a_0 -> inv'4 a_0
    | C_Err'0 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_ok_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 277 16 279 36] (self_:t_Option'0) (err:t_F'0) (return'  (ret:t_Result'0))= {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body 'err' type invariant] [%#soption1] inv'0 err}
    {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body requires] [%#soption2] self_ = C_None'0
     -> precondition'0 err ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 err} s1
      | s1 = -{resolve'0 err}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Ok'0 t ] s4
      | s4 = bb9 ]
    
    | bb9 = bb10
    | bb10 = bb11
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {err} {_8} (fun (_ret':t_E'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- C_Err'0 _6 ] s1 | s1 = bb8 ] 
    | bb8 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = return' {_0} ]
    )
    [ & _0 : t_Result'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & err : t_F'0 = err
    | & _6 : t_E'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Result'0)-> {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_ok_or_else_body ensures] [%#soption4] match self_ with
        | C_None'0 -> exists r : t_E'0 . result = C_Err'0 r /\ postcondition_once'0 err () r
        | C_Some'0 t -> result = C_Ok'0 t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_body [#"../../creusot-contracts/src/std/option.rs" 289 16 289 61]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 286 16 286 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 289 32 289 36
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 289 52 289 61
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 287 26 287 75
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 288 26 288 76
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'1) =
    [%#sresolve5] match self with
      | C_Some'0 x -> resolve'5 x
      | C_None'0 -> true
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'1) =
    resolve'3 _1
  
  type t_U'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_U'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve5] match self with
      | C_Some'1 x -> resolve'4 x
      | C_None'1 -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'2 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_body'0[#"../../creusot-contracts/src/std/option.rs" 289 16 289 61] (self_:t_Option'1) (optb:t_Option'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_body 'self_' type invariant] [%#soption0] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_body 'optb' type invariant] [%#soption1] inv'1 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 self_} s1
      | s1 = -{resolve'0 self_}- s2
      | s2 =  [ &_0 <- optb ] s3
      | s3 = bb7 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'1 optb} s1
      | s1 = -{resolve'1 optb}- s2
      | s2 = {[@expl:type invariant] inv'0 self_} s3
      | s3 = -{resolve'0 self_}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb7 ] 
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return' {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_ : t_Option'1 = self_ | & optb : t_Option'0 = optb ] 
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_body result type invariant] [%#soption2] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #0] [%#soption3] self_ = C_None'0
       -> result = C_None'1 /\ resolve'2 optb}
      {[@expl:extern_spec_std_option_T_Option_T_and_body ensures #1] [%#soption4] self_ = C_None'0
      \/ result = optb /\ resolve'3 self_}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_and_then_body [#"../../creusot-contracts/src/std/option.rs" 304 16 306 45]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 296 16 296 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 304 40 304 41
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 296 27 299 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 304 49 304 58
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 300 26 303 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_U'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_U'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let x0 = x in inv'4 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_T'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_T'0) (result : t_Option'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:t_T'0) (return'  (ret:t_Option'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#sops6] postcondition_once'0 self args result}
      (! return' {result}) ]
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_and_then_body'0[#"../../creusot-contracts/src/std/option.rs" 304 16 306 45] (self_:t_Option'1) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_and_then_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_8 <- t ] s2
      | s2 = call_once'0 {f} {_8} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 f} s1 | s1 = -{resolve'0 f}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & f : t_F'0 = f
    | & t : t_T'0 = Any.any_l ()
    | & _8 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_and_then_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_and_then_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_filter_body [#"../../creusot-contracts/src/std/option.rs" 324 16 326 41]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 313 16 313 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 324 35 324 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 313 27 316 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 324 52 324 61
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 317 26 323 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  let%span sinvariant7 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_P'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_P'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant7] inv'0 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'0 x
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = (let x0 = x in inv'4 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_P'0) (args : t_T'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_P'0) (args : t_T'0) (result : bool)
  
  
  let rec call_once'0 (self:t_P'0) (args:t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'1 self}
    {[@expl:call_once 'args' type invariant] inv'3 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any [ return' (result:bool)-> {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_P'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_filter_body'0[#"../../creusot-contracts/src/std/option.rs" 324 16 326 41] (self_:t_Option'0) (predicate':t_P'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_filter_body 'self_' type invariant] [%#soption0] inv'2 self_}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body 'predicate' type invariant] [%#soption1] inv'1 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_filter_body requires] [%#soption2] match self_ with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 predicate' t
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 =  [ &_11 <- t ] s2
      | s2 =  [ &_9 <- _11 ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
    
    | bb7 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ] 
    | bb8 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb9 ] 
    | bb9 = bb12
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'0 t} s1 | s1 = -{resolve'0 t}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'1 predicate'} s1 | s1 = -{resolve'1 predicate'}- s2 | s2 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb14 ] 
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & predicate' : t_P'0 = predicate'
    | & t : t_T'0 = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : t_T'0 = Any.any_l ()
    | & _11 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_filter_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_filter_body ensures] [%#soption4] match self_ with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> match result with
          | C_None'0 -> postcondition_once'0 predicate' t false /\ resolve'0 t
          | C_Some'0 r -> postcondition_once'0 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_body [#"../../creusot-contracts/src/std/option.rs" 336 16 336 57]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 333 16 333 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 336 28 336 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 336 48 336 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 334 26 334 57
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 335 26 335 76
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve5] match self with
      | C_Some'0 x -> resolve'2 x
      | C_None'0 -> true
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_body'0[#"../../creusot-contracts/src/std/option.rs" 336 16 336 57] (self_:t_Option'0) (optb:t_Option'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_or_body 'self_' type invariant] [%#soption0] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_body 'optb' type invariant] [%#soption1] inv'0 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 optb} s1
      | s1 = -{resolve'0 optb}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Some'0 t ] s4
      | s4 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- optb ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & optb : t_Option'0 = optb
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_or_body result type invariant] [%#soption2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #0] [%#soption3] self_ = C_None'0  -> result = optb}
      {[@expl:extern_spec_std_option_T_Option_T_or_body ensures #1] [%#soption4] self_ = C_None'0
      \/ result = self_ /\ resolve'1 optb}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_or_else_body [#"../../creusot-contracts/src/std/option.rs" 348 16 350 44]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 343 16 343 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 348 36 348 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 343 27 343 62
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 348 45 348 54
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 344 26 347 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_Option'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_Option'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_Option'0)-> {inv'1 result}
      {[%#sops6] postcondition_once'0 self args result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_or_else_body'0[#"../../creusot-contracts/src/std/option.rs" 348 16 350 44] (self_:t_Option'0) (f:t_F'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_or_else_body requires] [%#soption2] self_ = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s3)
      | s3 =  [ &_0 <- C_Some'0 t ] s4
      | s4 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb10
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_7} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = bb10
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & f : t_F'0 = f
    | & _7 : () = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_or_else_body result type invariant] [%#soption3] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_T_or_else_body ensures] [%#soption4] match self_ with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = C_Some'0 t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_xor_body [#"../../creusot-contracts/src/std/option.rs" 364 16 364 58]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 357 16 357 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 364 29 364 33
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 364 49 364 58
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 358 26 363 17
  let%span sresolve4 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve4] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'2 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_xor_body'0[#"../../creusot-contracts/src/std/option.rs" 364 16 364 58] (self_:t_Option'0) (optb:t_Option'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_xor_body 'self_' type invariant] [%#soption0] inv'0 self_}
    {[@expl:extern_spec_std_option_T_Option_T_xor_body 'optb' type invariant] [%#soption1] inv'0 optb}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_4 <- { _0'0 = self_; _1'0 = optb } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = any [ br0 -> {_4._0'0 = C_None'0} (! bb7) | br1 (x0:t_T'0)-> {_4._0'0 = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_1'0 = x'0} -> inv'0 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_1'0 = x'1} -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 = any [ br0 -> {_4._1'0 = C_None'0} (! bb6) | br1 (x0:t_T'0)-> {_4._1'0 = C_Some'0 x0} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_0'0 = C_Some'0 x'0} -> inv'1 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_0'0 = C_Some'0 x'1} -> resolve'1 x'1
          | _ -> true
          end}-
        s2
      | s2 = bb4 ]
    
    | bb6 = bb10
    | bb10 = s0 [ s0 = v_Some'0 {_4._0'0} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 = bb11 ] 
    | bb7 = any [ br0 -> {_4._1'0 = C_None'0} (! bb26) | br1 (x0:t_T'0)-> {_4._1'0 = C_Some'0 x0} (! bb8) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_1'0 = C_Some'0 x'0} -> inv'1 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_1'0 = C_Some'0 x'1} -> resolve'1 x'1
          | _ -> true
          end}-
        s2
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb14 ] 
    | bb8 = bb9
    | bb9 = s0 [ s0 = v_Some'0 {_4._1'0} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_Some'0 t ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = bb17
    | bb17 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & optb : t_Option'0 = optb
    | & _4 : tuple'0 = Any.any_l ()
    | & t : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_xor_body result type invariant] [%#soption2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_xor_body ensures] [%#soption3] match { _0'0 = self_; _1'0 = optb } with
        | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> result = C_None'0
        | {_0'0 = C_Some'0 t1 ; _1'0 = C_Some'0 t2} -> result = C_None'0 /\ resolve'1 t1 /\ resolve'1 t2
        | {_0'0 = C_Some'0 t ; _1'0 = C_None'0} -> result = C_Some'0 t
        | {_0'0 = C_None'0 ; _1'0 = C_Some'0 t} -> result = C_Some'0 t
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_insert_body [#"../../creusot-contracts/src/std/option.rs" 377 16 377 56]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 371 16 371 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 377 37 377 42
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 377 50 377 56
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 372 26 375 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 376 26 376 68
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sresolve6 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant7 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve5] match self with
      | C_Some'0 x -> resolve'3 x
      | C_None'0 -> true
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'4 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant7] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve6] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'5 _1
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant7] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve6] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_insert_body'0[#"../../creusot-contracts/src/std/option.rs" 377 16 377 56] (self_:MutBorrow.t t_Option'0) (value:t_T'0) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_insert_body 'self_' type invariant] [%#soption0] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_insert_body 'value' type invariant] [%#soption1] inv'1 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_6 <- C_Some'0 value ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = s0
      [ s0 = {[@expl:type invariant] match self_ with
          | {current = x'0} -> inv'0 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self_ with
          | {current = x'1} -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_ <- { self_ with current = _6 } ] s3
      | s3 = bb5 ]
    
    | bb5 = any [ br0 -> {self_.current = C_None'0} (! bb7) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb8) ] 
    | bb8 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'1 r0'0}
            MutBorrow.borrow_final <t_T'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &v <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'1 v.current}
        MutBorrow.borrow_final <t_T'0> {v.current} {MutBorrow.get_id v}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_8 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &v <- { v with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 v} s3
      | s3 = -{resolve'1 v}- s4
      | s4 = {inv'1 _8.current}
        MutBorrow.borrow_final <t_T'0> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_8 <- { _8 with current = _ret'.final } ] 
            s5)
      | s5 = {inv'1 _3.current}
        MutBorrow.borrow_final <t_T'0> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'2 _8} s7
      | s7 = -{resolve'1 _8}- s8
      | s8 = {[@expl:type invariant] inv'2 _3} s9
      | s9 = -{resolve'1 _3}- s10
      | s10 = bb10 ]
    
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = return' {_0} ] 
    | bb7 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'2 self_}- s2 | s2 = bb9 ] 
    | bb9 = {false} any ]
    )
    [ & _0 : MutBorrow.t t_T'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & value : t_T'0 = value
    | & _3 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _8 : MutBorrow.t t_T'0 = Any.any_l ()
    | & v : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_insert_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #0] [%#soption3] match self_.current with
        | C_Some'0 t -> resolve'3 t
        | C_None'0 -> true
        end}
      {[@expl:extern_spec_std_option_T_Option_T_insert_body ensures #1] [%#soption4] result.current = value
      /\ self_.final = C_Some'0 (result.final)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_body [#"../../creusot-contracts/src/std/option.rs" 390 16 390 63]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 385 16 385 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 390 44 390 49
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 390 57 390 63
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 386 26 389 17
  let%span sresolve4 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve4] match self with
      | C_Some'0 x -> resolve'0 x
      | C_None'0 -> true
      end
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'4 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant6] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'5 _1
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant6] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_body'0[#"../../creusot-contracts/src/std/option.rs" 390 16 390 63] (self_:MutBorrow.t t_Option'0) (value:t_T'0) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'self_' type invariant] [%#soption0] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body 'value' type invariant] [%#soption1] inv'0 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_.current = C_None'0} (! bb3) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb4) ] 
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 value} s1 | s1 = -{resolve'0 value}- s2 | s2 = bb10 ] 
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_7 <- C_Some'0 value ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match self_ with
          | {current = x'0} -> inv'1 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self_ with
          | {current = x'1} -> resolve'1 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_ <- { self_ with current = _7 } ] s3
      | s3 = bb9 ]
    
    | bb9 = bb10
    | bb10 = any
      [ br0 -> {self_.current = C_None'0} (! bb12) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb13) ]
    
    | bb13 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'0 r0'0}
            MutBorrow.borrow_final <t_T'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &v <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'0 v.current}
        MutBorrow.borrow_final <t_T'0> {v.current} {MutBorrow.get_id v}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &v <- { v with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 v} s3
      | s3 = -{resolve'2 v}- s4
      | s4 = {inv'0 _9.current}
        MutBorrow.borrow_final <t_T'0> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_3 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_9 <- { _9 with current = _ret'.final } ] 
            s5)
      | s5 = {inv'0 _3.current}
        MutBorrow.borrow_final <t_T'0> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final } ] 
            s6)
      | s6 = {[@expl:type invariant] inv'2 _9} s7
      | s7 = -{resolve'2 _9}- s8
      | s8 = {[@expl:type invariant] inv'2 _3} s9
      | s9 = -{resolve'2 _3}- s10
      | s10 = bb15 ]
    
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = return' {_0} ] 
    | bb12 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = bb14 ] 
    | bb14 = {false} any ]
    )
    [ & _0 : MutBorrow.t t_T'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & value : t_T'0 = value
    | & _3 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _7 : t_Option'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_T'0 = Any.any_l ()
    | & v : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body result type invariant] [%#soption2] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_body ensures] [%#soption3] match self_.current with
        | C_None'0 -> result.current = value /\ self_.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self_.current = C_Some'0 (result.current)
        /\ self_.final = C_Some'0 (result.final) /\ resolve'0 value
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_get_or_insert_with_body [#"../../creusot-contracts/src/std/option.rs" 406 16 408 36]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 401 16 401 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 406 52 406 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 401 27 401 63
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 406 61 406 67
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 402 26 405 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 86 26 86 75
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 88 20 89 100
  let%span soption9 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption10 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span sresolve11 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sresolve12 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant13 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_F'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant13] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve11] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'4 _1
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : ())
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : ()) (result : t_T'0)
  
  
  let rec call_once'0 (self:t_F'0) (args:()) (return'  (ret:t_T'0))= {[@expl:call_once 'self' type invariant] inv'0 self}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any
    [ return' (result:t_T'0)-> {inv'1 result} {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate resolve'7 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve12] match self with
      | C_Some'0 x -> resolve'7 x
      | C_None'0 -> true
      end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'0) =
    resolve'5 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant13] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'1 [inv'5 x] . inv'5 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'1)-> {inv'5 result}
      {[%#soption7] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption8] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_T'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:unwrap 'self' type invariant] inv'5 self}
    {[@expl:unwrap requires] [%#soption9] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_T'0)-> {inv'2 result} {[%#soption10] C_Some'1 result = self} (! return' {result}) ]
  
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve11] self.final = self.current
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_get_or_insert_with_body'0[#"../../creusot-contracts/src/std/option.rs" 406 16 408 36] (self_:MutBorrow.t t_Option'0) (f:t_F'0) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] [%#soption0] inv'4 self_}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body 'f' type invariant] [%#soption1] inv'0 f}
    {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body requires] [%#soption2] self_.current = C_None'0
     -> precondition'0 f ()}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_.current = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 f} s1
      | s1 = -{resolve'0 f}- s2
      | s2 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'1 r0'0}
            MutBorrow.borrow_final <t_T'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 1}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s3))
      | s3 = {inv'1 t.current}
        MutBorrow.borrow_final <t_T'0> {t.current} {MutBorrow.get_id t}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'2 t} s5
      | s5 = -{resolve'1 t}- s6
      | s6 = bb14 ]
    
    | bb4 = bb6
    | bb6 = s0 [ s0 = call_once'0 {f} {_12} (fun (_ret':t_T'0) ->  [ &_10 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_9 <- C_Some'0 _10 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self_ with
          | {current = x'0} -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self_ with
          | {current = x'1} -> resolve'2 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self_ <- { self_ with current = _9 } ] s3
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'3 self_.current}
        MutBorrow.borrow_final <t_Option'0> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':t_Option'1) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':MutBorrow.t t_T'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {inv'1 _13.current}
        MutBorrow.borrow_final <t_T'0> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_8 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _8.current}
        MutBorrow.borrow_final <t_T'0> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_8 <- { _8 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _13} s3
      | s3 = -{resolve'1 _13}- s4
      | s4 = {[@expl:type invariant] inv'2 _8} s5
      | s5 = -{resolve'1 _8}- s6
      | s6 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'1 _6.current}
        MutBorrow.borrow_final <t_T'0> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_3 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_6 <- { _6 with current = _ret'.final } ] 
            s1)
      | s1 = {inv'1 _3.current}
        MutBorrow.borrow_final <t_T'0> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_3 <- { _3 with current = _ret'.final } ] 
            s2)
      | s2 = {[@expl:type invariant] inv'2 _6} s3
      | s3 = -{resolve'1 _6}- s4
      | s4 = {[@expl:type invariant] inv'2 _3} s5
      | s5 = -{resolve'1 _3}- s6
      | s6 = bb15 ]
    
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'4 self_} s1 | s1 = -{resolve'3 self_}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : MutBorrow.t t_T'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & f : t_F'0 = f
    | & _3 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _8 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _9 : t_Option'0 = Any.any_l ()
    | & _10 : t_T'0 = Any.any_l ()
    | & _12 : () = Any.any_l ()
    | & _13 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _14 : t_Option'1 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & t : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_T'0)-> {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_get_or_insert_with_body ensures] [%#soption4] match self_.current with
        | C_None'0 -> postcondition_once'0 f () result.current /\ self_.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self_.current = C_Some'0 (result.current) /\ self_.final = C_Some'0 (result.final)
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_body [#"../../creusot-contracts/src/std/option.rs" 417 16 417 47]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 415 16 415 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 417 38 417 47
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 416 26 416 58
  let%span smem3 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem4 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant6] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  let rec replace'0 (dest:MutBorrow.t t_Option'0) (src:t_Option'0) (return'  (ret:t_Option'0))= {[@expl:replace 'dest' type invariant] inv'1 dest}
    {[@expl:replace 'src' type invariant] inv'0 src}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem3] dest.final = src}
      {[%#smem4] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_body'0[#"../../creusot-contracts/src/std/option.rs" 417 16 417 47] (self_:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_take_body 'self_' type invariant] [%#soption0] inv'1 self_}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self_.current}
        MutBorrow.borrow_final <t_Option'0> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_3 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 =  [ &_4 <- C_None'0 ] s2
      | s2 = replace'0 {_3} {_4} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & _3 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _4 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_take_body result type invariant] [%#soption1] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_body ensures] [%#soption2] result = self_.current
      /\ self_.final = C_None'0}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_take_if_body [#"../../creusot-contracts/src/std/option.rs" 435 16 437 45]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 421 16 421 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 435 41 435 50
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 421 27 424 17
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 435 58 435 67
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 425 26 434 17
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 163 27 163 49
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 164 26 164 62
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 416 26 416 58
  let%span sresolve8 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant9 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_P'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_P'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant9] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'5 x] . inv'5 x = (let x0 = x in inv'1 x0)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_P'0) (args : MutBorrow.t t_T'0)
  
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_P'0) (args : MutBorrow.t t_T'0) (result : bool)
  
  
  let rec call_once'0 (self:t_P'0) (args:MutBorrow.t t_T'0) (return'  (ret:bool))= {[@expl:call_once 'self' type invariant] inv'4 self}
    {[@expl:call_once 'args' type invariant] inv'5 args}
    {[@expl:call_once requires] [%#sops5] precondition'0 self args}
    any [ return' (result:bool)-> {[%#sops6] postcondition_once'0 self args result} (! return' {result}) ] 
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve8] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'3 _1
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant9] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  let rec take'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#soption7] result = self.current /\ self.final = C_None'0}
      (! return' {result}) ]
  
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve8] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'4 _1
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_P'0)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_take_if_body'0[#"../../creusot-contracts/src/std/option.rs" 435 16 437 45] (self_:MutBorrow.t t_Option'0) (predicate':t_P'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'self_' type invariant] [%#soption0] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body 'predicate' type invariant] [%#soption1] inv'4 predicate'}
    {[@expl:extern_spec_std_option_T_Option_T_take_if_body requires] [%#soption2] match self_.current with
      | C_None'0 -> true
      | C_Some'0 t -> forall b : MutBorrow.t t_T'0 . inv'1 b /\ b.current = t  -> precondition'0 predicate' b
      end}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_.current = C_None'0} (! bb4) | br1 (x0:t_T'0)-> {self_.current = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_.current}
          (fun (r0'0:t_T'0) ->
            {inv'0 r0'0}
            MutBorrow.borrow_mut <t_T'0> {r0'0}
              (fun (_ret':MutBorrow.t t_T'0) ->
                 [ &t <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &self_ <- { self_ with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = {inv'0 t.current}
        MutBorrow.borrow_final <t_T'0> {t.current} {MutBorrow.get_id t}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &t <- { t with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_9 <- _10 ] s3
      | s3 = call_once'0 {predicate'} {_9} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 = any [ br0 -> {_7 = false} (! bb10) | br1 -> {_7} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 = {inv'2 self_.current}
        MutBorrow.borrow_final <t_Option'0> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_11 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 = take'0 {_11} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb12 ] 
    | bb10 = s0 [ s0 = {[@expl:type invariant] inv'3 self_} s1 | s1 = -{resolve'1 self_}- s2 | s2 = bb11 ] 
    | bb11 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb12 ] 
    | bb12 = bb13
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'4 predicate'} s1
      | s1 = -{resolve'2 predicate'}- s2
      | s2 = {[@expl:type invariant] inv'3 self_} s3
      | s3 = -{resolve'1 self_}- s4
      | s4 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb13 ] 
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & predicate' : t_P'0 = predicate'
    | & t : MutBorrow.t t_T'0 = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _10 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _11 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_take_if_body result type invariant] [%#soption3] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option_T_take_if_body ensures] [%#soption4] match self_.current with
        | C_None'0 -> result = C_None'0 /\ self_.final = C_None'0
        | C_Some'0 cur -> exists b : MutBorrow.t t_T'0, res : bool . inv'1 b
        /\ cur = b.current
        /\ postcondition_once'0 predicate' b res
        /\ (if res then
          self_.final = C_None'0 /\ result = C_Some'0 (b.final)
        else
          self_.final = C_Some'0 (b.final) /\ result = C_None'0
        )
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_replace_body [#"../../creusot-contracts/src/std/option.rs" 446 16 446 60]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 444 16 444 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 446 38 446 43
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 446 51 446 60
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 445 26 445 65
  let%span smem4 = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem5 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span sresolve6 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant7 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Option'0) =
    [%#sinvariant7] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  let rec replace'0 (dest:MutBorrow.t t_Option'0) (src:t_Option'0) (return'  (ret:t_Option'0))= {[@expl:replace 'dest' type invariant] inv'1 dest}
    {[@expl:replace 'src' type invariant] inv'0 src}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem4] dest.final = src}
      {[%#smem5] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Option'0) =
    [%#sresolve6] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Option'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_replace_body'0[#"../../creusot-contracts/src/std/option.rs" 446 16 446 60] (self_:MutBorrow.t t_Option'0) (value:t_T'0) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_replace_body 'self_' type invariant] [%#soption0] inv'1 self_}
    {[@expl:extern_spec_std_option_T_Option_T_replace_body 'value' type invariant] [%#soption1] inv'2 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = {inv'0 self_.current}
        MutBorrow.borrow_final <t_Option'0> {self_.current} {MutBorrow.get_id self_}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self_ <- { self_ with current = _ret'.final } ] 
            s1)
      | s1 =  [ &_5 <- C_Some'0 value ] s2
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = replace'0 {_4} {_5} (fun (_ret':t_Option'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self_} s1 | s1 = -{resolve'0 self_}- s2 | s2 = bb4 ] 
    | bb4 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : MutBorrow.t t_Option'0 = self_
    | & value : t_T'0 = value
    | & _4 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _5 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_replace_body result type invariant] [%#soption2] inv'0 result}
      {[@expl:extern_spec_std_option_T_Option_T_replace_body ensures] [%#soption3] result = self_.current
      /\ self_.final = C_Some'0 value}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_T_zip_body [#"../../creusot-contracts/src/std/option.rs" 456 16 456 67]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 450 16 450 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 456 32 456 37
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 456 53 456 67
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 451 26 455 17
  let%span sresolve4 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_U'0
  
  type t_Option'2  =
    | C_None'1
    | C_Some'1 t_U'0
  
  type tuple'0  =
    { _0'0: t_Option'1; _1'0: t_Option'2 }
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'2)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'2 [inv'0 x] . inv'0 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_U'0)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'2) =
    [%#sresolve4] match self with
      | C_Some'1 x -> resolve'2 x
      | C_None'1 -> true
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Option'2) =
    resolve'3 _1
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  type tuple'1  =
    { _0'1: t_T'0; _1'1: t_U'0 }
  
  type t_Option'0  =
    | C_None'2
    | C_Some'2 tuple'1
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  let rec v_Some'1 (input:t_Option'2) (ret  (field_0:t_U'0))= any
    [ good (field_0:t_U'0)-> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_U'0 [C_Some'1 field_0 : t_Option'2] . C_Some'1 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : tuple'1 [inv'5 x] . inv'5 x
  = (let {_0'1 = x0 ; _1'1 = x1} = x in inv'1 x0 /\ inv'2 x1)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'5 a_0
    end
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'1) =
    [%#sresolve4] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_T_zip_body'0[#"../../creusot-contracts/src/std/option.rs" 456 16 456 67] (self_:t_Option'1) (other:t_Option'2) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_T_zip_body 'self_' type invariant] [%#soption0] inv'3 self_}
    {[@expl:extern_spec_std_option_T_Option_T_zip_body 'other' type invariant] [%#soption1] inv'0 other}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &_4 <- { _0'0 = self_; _1'0 = other } ] s1 | s1 = bb2 ] 
    | bb2 = bb3
    | bb3 = any [ br0 -> {_4._0'0 = C_None'0} (! bb26) | br1 (x0:t_T'0)-> {_4._0'0 = C_Some'0 x0} (! bb5) ] 
    | bb26 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_1'0 = x'0} -> inv'0 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_1'0 = x'1} -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_0'0 = C_Some'0 x'2} -> inv'1 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_0'0 = C_Some'0 x'3} -> resolve'1 x'3
          | _ -> true
          end}-
        s4
      | s4 = bb4 ]
    
    | bb5 = any [ br0 -> {_4._1'0 = C_None'1} (! bb27) | br1 (x0:t_U'0)-> {_4._1'0 = C_Some'1 x0} (! bb6) ] 
    | bb27 = s0
      [ s0 = {[@expl:type invariant] match _4 with
          | {_1'0 = C_Some'1 x'0} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _4 with
          | {_1'0 = C_Some'1 x'1} -> resolve'2 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match _4 with
          | {_0'0 = C_Some'0 x'2} -> inv'1 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match _4 with
          | {_0'0 = C_Some'0 x'3} -> resolve'1 x'3
          | _ -> true
          end}-
        s4
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'2 ] s1 | s1 = bb13 ] 
    | bb6 = bb7
    | bb7 = s0
      [ s0 = v_Some'0 {_4._0'0} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 = v_Some'1 {_4._1'0} (fun (r0'1:t_U'0) ->  [ &u <- r0'1 ] s2)
      | s2 =  [ &_11 <- { _0'1 = t; _1'1 = u } ] s3
      | s3 = bb8 ]
    
    | bb8 = bb9
    | bb9 = s0 [ s0 =  [ &_0 <- C_Some'2 _11 ] s1 | s1 = bb10 ] 
    | bb10 = bb11
    | bb11 = bb12
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & other : t_Option'2 = other
    | & _4 : tuple'0 = Any.any_l ()
    | & t : t_T'0 = Any.any_l ()
    | & u : t_U'0 = Any.any_l ()
    | & _11 : tuple'1 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_T_zip_body result type invariant] [%#soption2] inv'4 result}
      {[@expl:extern_spec_std_option_T_Option_T_zip_body ensures] [%#soption3] match { _0'0 = self_; _1'0 = other } with
        | {_0'0 = C_None'0} -> result = C_None'2 /\ resolve'3 other
        | {_1'0 = C_None'1} -> result = C_None'2 /\ resolve'4 self_
        | {_0'0 = C_Some'0 t ; _1'0 = C_Some'1 u} -> result = C_Some'2 { _0'1 = t; _1'1 = u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body [#"../../creusot-contracts/src/std/option.rs" 470 16 470 56]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 465 16 465 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 470 34 470 56
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 466 26 469 17
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_U'0
  
  type tuple'0  =
    { _0'0: t_T'0; _1'0: t_U'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:tuple'0))= any
    [ good (field_0:tuple'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : tuple'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_T'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_U'0
  
  type tuple'1  =
    { _0'1: t_Option'1; _1'1: t_Option'2 }
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_U'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : tuple'0 [inv'2 x] . inv'2 x
  = (let {_0'0 = x0 ; _1'0 = x1} = x in inv'5 x0 /\ inv'6 x1)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'2)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'2 [inv'4 x] . inv'4 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'6 a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : tuple'1 [inv'1 x] . inv'1 x
  = (let {_0'1 = x0 ; _1'1 = x1} = x in inv'3 x0 /\ inv'4 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_U_Optionqy95z_tuple2_T_U_unzip_body'0[#"../../creusot-contracts/src/std/option.rs" 470 16 470 56] (self_:t_Option'0) (return'  (ret:tuple'1))= {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:tuple'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = bb5
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:tuple'0) ->  [ &t <- r0'0._0'0 ] s1)
      | s1 = v_Some'0 {self_} (fun (r0'1:tuple'0) ->  [ &u <- r0'1._1'0 ] s2)
      | s2 =  [ &_6 <- C_Some'1 t ] s3
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 =  [ &_8 <- C_Some'2 u ] s1 | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &_0 <- { _0'1 = _6; _1'1 = _8 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = bb14
    | bb4 = s0
      [ s0 =  [ &_10 <- C_None'1 ] s1
      | s1 =  [ &_11 <- C_None'2 ] s2
      | s2 =  [ &_0 <- { _0'1 = _10; _1'1 = _11 } ] s3
      | s3 = bb12 ]
    
    | bb12 = bb13
    | bb13 = bb14
    | bb14 = bb15
    | bb15 = return' {_0} ]
    )
    [ & _0 : tuple'1 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & t : t_T'0 = Any.any_l ()
    | & u : t_U'0 = Any.any_l ()
    | & _6 : t_Option'1 = Any.any_l ()
    | & _8 : t_Option'2 = Any.any_l ()
    | & _10 : t_Option'1 = Any.any_l ()
    | & _11 : t_Option'2 = Any.any_l () ]
    
    [ return' (result:tuple'1)-> {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_U_Option__tuple2_T_U_unzip_body ensures] [%#soption2] match self_ with
        | C_None'0 -> result = { _0'1 = C_None'1; _1'1 = C_None'2 }
        | C_Some'0 {_0'0 = t ; _1'0 = u} -> result = { _0'1 = C_Some'1 t; _1'1 = C_Some'2 u }
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 482 16 484 27]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 479 16 479 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 482 35 482 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 480 26 480 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 481 26 481 93
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_T'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_copied_body'0[#"../../creusot-contracts/src/std/option.rs" 482 16 484 27] (self_:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1) | s1 =  [ &_0 <- C_Some'1 t ] s2 | s2 = bb5 ]
    
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_ : t_Option'1 = self_ | & t : t_T'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures #0] [%#soption2] self_ = C_None'0
       -> result = C_None'1}
      {[@expl:extern_spec_std_option_T_Option__ref_T_copied_body ensures #1] [%#soption3] self_ = C_None'0
      \/ (exists t : t_T'0 . self_ = C_Some'0 t /\ result = C_Some'1 t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 493 16 495 28]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 491 16 491 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 493 35 493 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 491 26 491 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 492 26 492 93
  let%span sclone4 = "../../creusot-contracts/src/std/clone.rs" 15 26 15 41
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_T'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant5] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  let rec clone'0 (self:t_T'0) (return'  (ret:t_T'0))= {[@expl:clone 'self' type invariant] inv'2 self}
    any [ return' (result:t_T'0)-> {inv'3 result} {[%#sclone4] result = self} (! return' {result}) ] 
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_ref_T_cloned_body'0[#"../../creusot-contracts/src/std/option.rs" 493 16 495 28] (self_:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 = clone'0 {t} (fun (_ret':t_T'0) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_0 <- C_Some'1 _6 ] s1 | s1 = bb6 ] 
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb7 ] 
    | bb7 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & t : t_T'0 = Any.any_l ()
    | & _6 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures #0] [%#soption2] self_ = C_None'0
       -> result = C_None'1}
      {[@expl:extern_spec_std_option_T_Option__ref_T_cloned_body ensures #1] [%#soption3] self_ = C_None'0
      \/ (exists t : t_T'0 . self_ = C_Some'0 t /\ result = C_Some'1 t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body [#"../../creusot-contracts/src/std/option.rs" 510 16 512 27]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 504 16 504 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 510 35 510 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 505 26 505 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 507 20 508 93
  let%span sresolve4 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:MutBorrow.t t_T'0))= any
    [ good (field_0:MutBorrow.t t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant5] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve4] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'1 _1
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_T'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_copied_body'0[#"../../creusot-contracts/src/std/option.rs" 510 16 512 27] (self_:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body 'self_' type invariant] [%#soption0] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:MutBorrow.t t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:MutBorrow.t t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 t} s2
      | s2 = -{resolve'0 t}- s3
      | s3 =  [ &_0 <- C_Some'1 (t.current) ] s4
      | s4 = bb5 ]
    
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_ : t_Option'1 = self_ | & t : MutBorrow.t t_T'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body result type invariant] [%#soption1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures #0] [%#soption2] self_ = C_None'0
       -> result = C_None'1}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_copied_body ensures #1] [%#soption3] self_ = C_None'0
      \/ (exists t : MutBorrow.t t_T'0 . self_ = C_Some'0 t /\ result = C_Some'1 (t.current) /\ resolve'1 t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body [#"../../creusot-contracts/src/std/option.rs" 524 16 526 28]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 519 16 519 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 524 35 524 44
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 519 26 519 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 521 20 522 93
  let%span sclone4 = "../../creusot-contracts/src/std/clone.rs" 15 26 15 41
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant7 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:MutBorrow.t t_T'0))= any
    [ good (field_0:MutBorrow.t t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_T'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant7] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  let rec clone'0 (self:t_T'0) (return'  (ret:t_T'0))= {[@expl:clone 'self' type invariant] inv'3 self}
    any [ return' (result:t_T'0)-> {inv'4 result} {[%#sclone4] result = self} (! return' {result}) ] 
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant6] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'1 _1
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_T'0
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'1 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'0 a_0
    end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Optionqy95z_refmut_T_cloned_body'0[#"../../creusot-contracts/src/std/option.rs" 524 16 526 28] (self_:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body 'self_' type invariant] [%#soption0] inv'1 self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = C_None'0} (! bb2) | br1 (x0:MutBorrow.t t_T'0)-> {self_ = C_Some'0 x0} (! bb3) ] 
    | bb3 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:MutBorrow.t t_T'0) ->  [ &t <- r0'0 ] s1)
      | s1 = clone'0 {t.current} (fun (_ret':t_T'0) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'0 t} s1
      | s1 = -{resolve'0 t}- s2
      | s2 =  [ &_0 <- C_Some'1 _6 ] s3
      | s3 = bb6 ]
    
    | bb6 = bb7
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb7 ] 
    | bb7 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self_ : t_Option'1 = self_
    | & t : MutBorrow.t t_T'0 = Any.any_l ()
    | & _6 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body result type invariant] [%#soption1] inv'2 result}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures #0] [%#soption2] self_ = C_None'0
       -> result = C_None'1}
      {[@expl:extern_spec_std_option_T_Option__refmut_T_cloned_body ensures #1] [%#soption3] self_ = C_None'0
      \/ (exists t : MutBorrow.t t_T'0 . self_ = C_Some'0 t /\ result = C_Some'1 (t.current) /\ resolve'1 t)}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_E_Option_Result_T_E_transpose_body [#"../../creusot-contracts/src/std/option.rs" 541 16 541 58]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 535 16 535 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 541 38 541 58
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 536 26 540 17
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_E'0
  
  type t_Result'0  =
    | C_Ok'0 t_T'0
    | C_Err'0 t_E'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Result'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Result'0))= any
    [ good (field_0:t_Result'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Result'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  let rec v_Err'0 (input:t_Result'0) (ret  (field_0:t_E'0))= any
    [ good (field_0:t_E'0)-> {C_Err'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_E'0 [C_Err'0 field_0 : t_Result'0] . C_Err'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_T'0
  
  type t_Result'1  =
    | C_Ok'1 t_Option'1
    | C_Err'1 t_E'0
  
  let rec v_Ok'0 (input:t_Result'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Ok'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Ok'0 field_0 : t_Result'0] . C_Ok'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_E'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Result'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Result'0 [inv'2 x] . inv'2 x
  = match x with
    | C_Ok'0 a_0 -> inv'5 a_0
    | C_Err'0 a_0 -> inv'4 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Result'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Result'1 [inv'1 x] . inv'1 x
  = match x with
    | C_Ok'1 a_0 -> inv'3 a_0
    | C_Err'1 a_0 -> inv'4 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_E_Option_Result_T_E_transpose_body'0[#"../../creusot-contracts/src/std/option.rs" 541 16 541 58] (self_:t_Option'0) (return'  (ret:t_Result'1))= {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = any [ br0 -> {self_ = C_None'0} (! bb3) | br1 (x0:t_Result'0)-> {self_ = C_Some'0 x0} (! bb4) ] 
    | bb4 = v_Some'0 {self_}
        (fun (r0'0:t_Result'0) ->
          any [ br0 (x0:t_T'0)-> {r0'0 = C_Ok'0 x0} (! bb5) | br1 (x0:t_E'0)-> {r0'0 = C_Err'0 x0} (! bb6) ] )
    | bb6 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_Result'0) -> v_Err'0 {r0'0} (fun (r0'1:t_E'0) ->  [ &err <- r0'1 ] s1))
      | s1 =  [ &_0 <- C_Err'1 err ] s2
      | s2 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb15
    | bb5 = bb7
    | bb7 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_Result'0) -> v_Ok'0 {r0'0} (fun (r0'1:t_T'0) ->  [ &ok <- r0'1 ] s1))
      | s1 =  [ &_7 <- C_Some'1 ok ] s2
      | s2 = bb10 ]
    
    | bb10 = s0 [ s0 =  [ &_0 <- C_Ok'1 _7 ] s1 | s1 = bb11 ] 
    | bb11 = bb12
    | bb12 = bb15
    | bb3 = bb8
    | bb8 = s0 [ s0 =  [ &_5 <- C_None'1 ] s1 | s1 =  [ &_0 <- C_Ok'1 _5 ] s2 | s2 = bb9 ] 
    | bb9 = bb15
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : t_Result'1 = Any.any_l ()
    | & self_ : t_Option'0 = self_
    | & _5 : t_Option'1 = Any.any_l ()
    | & ok : t_T'0 = Any.any_l ()
    | & _7 : t_Option'1 = Any.any_l ()
    | & err : t_E'0 = Any.any_l () ]
    
    [ return' (result:t_Result'1)-> {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_E_Option_Result_T_E_transpose_body ensures] [%#soption2] match self_ with
        | C_None'0 -> result = C_Ok'1 (C_None'1)
        | C_Some'0 (C_Ok'0 ok) -> result = C_Ok'1 (C_Some'1 ok)
        | C_Some'0 (C_Err'0 err) -> result = C_Err'1 err
        end}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__extern_spec_std_option_T_Option_Option_T_flatten_body [#"../../creusot-contracts/src/std/option.rs" 554 16 554 45]
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 551 16 551 17
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 554 36 554 45
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 552 26 552 57
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 553 26 553 62
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_T'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_Option'0
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_Option'0))= any
    [ good (field_0:t_Option'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Option'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'1 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec extern_spec_std_option_T_Option_Option_T_flatten_body'0[#"../../creusot-contracts/src/std/option.rs" 554 16 554 45] (self_:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body 'self_' type invariant] [%#soption0] inv'0 self_}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = any [ br0 -> {self_ = C_None'0} (! bb4) | br1 (x0:t_Option'0)-> {self_ = C_Some'0 x0} (! bb5) ] 
    | bb5 = s0
      [ s0 = v_Some'0 {self_} (fun (r0'0:t_Option'0) ->  [ &opt <- r0'0 ] s1) | s1 =  [ &_0 <- opt ] s2 | s2 = bb7 ]
    
    | bb7 = bb8
    | bb4 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = return' {_0} ]
    ) [ & _0 : t_Option'0 = Any.any_l () | & self_ : t_Option'1 = self_ | & opt : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body result type invariant] [%#soption1] inv'1 result}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #0] [%#soption2] self_ = C_None'0
       -> result = C_None'1}
      {[@expl:extern_spec_std_option_T_Option_Option_T_flatten_body ensures #1] [%#soption3] self_ = C_None'0
      \/ self_ = C_Some'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o <> C_Greater'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o = C_Less'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o <> C_Less'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord2] cmp_log'0 self o = C_Greater'0
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : t_Option'0) (y : t_Option'0) : ()
  
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : t_Option'0) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption4] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  constant z  : t_Option'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : t_Option'0) (y : t_Option'0) (z : t_Option'0) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption3] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  constant x  : t_Option'0
  
  constant y  : t_Option'0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : t_Option'0) (y : t_Option'0) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl [#"../../creusot-contracts/src/std/option.rs" 617 4 617 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 616 14 616 45
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 617 27 617 29
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 609 12 610 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 593 4 593 30] (self : t_IntoIter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 607 4 607 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/option.rs" 617 4 617 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans [#"../../creusot-contracts/src/std/option.rs" 624 4 624 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 621 15 621 32
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 622 15 622 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 623 14 623 42
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 624 91 624 93
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 609 12 610 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 593 4 593 30] (self : t_IntoIter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 607 4 607 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/option.rs" 624 4 624 90] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#soption0] produces'0 a ab b)
   -> ([%#soption1] produces'0 b bc c)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl [#"../../creusot-contracts/src/std/option.rs" 670 4 670 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 669 14 669 45
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 670 27 670 29
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 662 12 663 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 646 4 646 34] (self : t_Iter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 660 4 660 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption2] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/option.rs" 670 4 670 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans [#"../../creusot-contracts/src/std/option.rs" 677 4 677 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 674 15 674 32
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 675 15 675 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 676 14 676 42
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 677 91 677 93
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 662 12 663 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 646 4 646 34] (self : t_Iter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 660 4 660 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption4] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/option.rs" 677 4 677 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#soption0] produces'0 a ab b)
   -> ([%#soption1] produces'0 b bc c)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl [#"../../creusot-contracts/src/std/option.rs" 726 4 726 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 725 14 725 45
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 726 27 726 29
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 718 12 719 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 702 4 702 38] (self : t_IterMut'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 716 4 716 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption2] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/option.rs" 726 4 726 26] (self : t_IterMut'0) : ()
  
  goal vc_produces_refl'0 : [%#soption0] produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans [#"../../creusot-contracts/src/std/option.rs" 733 4 733 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 730 15 730 32
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 731 15 731 32
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 732 14 732 42
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 733 91 733 93
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 718 12 719 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 702 4 702 38] (self : t_IterMut'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 716 4 716 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption4] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (MutBorrow.t t_T'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (MutBorrow.t t_T'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/option.rs" 733 4 733 90] (a : t_IterMut'0) (ab : Seq.seq (MutBorrow.t t_T'0)) (b : t_IterMut'0) (bc : Seq.seq (MutBorrow.t t_T'0)) (c : t_IterMut'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#soption0] produces'0 a ab b)
   -> ([%#soption1] produces'0 b bc c)  -> ([%#soption2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  constant self  : Opaque.ptr
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (self : Opaque.ptr) : bool
  
  goal vc_is_null_logic'0 : [%#sptr0] (addr_logic'0 self = 0) = (addr_logic'0 self = 0)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic [#"../../creusot-contracts/src/std/ptr.rs" 97 4 97 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 96 14 96 48
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 98 8 98 30
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 90 4 90 30] (self : Opaque.ptr) : int
  
  constant self  : Opaque.ptr
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 97 4 97 34] (self : Opaque.ptr) : bool
  
  goal vc_is_null_logic'0 : [%#sptr0] (addr_logic'0 self = 0) = (addr_logic'0 self = 0)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 441 14 441 45
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 442 27 442 29
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel5] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice3] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice2] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant self  : t_Iter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 26] (self : t_Iter'0) : ()
  
  goal vc_produces_refl'0 : [%#sslice0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 449 4 449 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 446 15 446 32
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 447 15 447 32
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 448 14 448 42
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 449 91 449 93
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex8 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice10 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice9] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice10] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel7] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex8] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice5] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice4] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  constant a  : t_Iter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_Iter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_Iter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/slice.rs" 449 4 449 90] (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sslice0] produces'0 a ab b)
   -> ([%#sslice1] produces'0 b bc c)  -> ([%#sslice2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl [#"../../creusot-contracts/src/std/slice.rs" 496 4 496 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 495 14 495 45
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 496 27 496 29
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 489 12 489 66
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 457 14 457 50
  let%span smodel6 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex7 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice8] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice9] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel6] view'2 self.current
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex7] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice3] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice4] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 458 4 458 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice5] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice2] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  constant self  : t_IterMut'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/slice.rs" 496 4 496 26] (self : t_IterMut'0) : ()
  
  goal vc_produces_refl'0 : [%#sslice0] produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans [#"../../creusot-contracts/src/std/slice.rs" 503 4 503 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 500 15 500 32
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 501 15 501 32
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 502 14 502 42
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 503 91 503 93
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 489 12 489 66
  let%span sslice5 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 457 14 457 50
  let%span smodel8 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex9 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice10 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice11 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice10] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice11] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel8] view'2 self.current
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex9] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice5] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice6] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 458 4 458 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice7] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice4] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  constant a  : t_IterMut'0
  
  constant ab  : Seq.seq (MutBorrow.t t_T'0)
  
  constant b  : t_IterMut'0
  
  constant bc  : Seq.seq (MutBorrow.t t_T'0)
  
  constant c  : t_IterMut'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/slice.rs" 503 4 503 90] (a : t_IterMut'0) (ab : Seq.seq (MutBorrow.t t_T'0)) (b : t_IterMut'0) (bc : Seq.seq (MutBorrow.t t_T'0)) (c : t_IterMut'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#sslice0] produces'0 a ab b)
   -> ([%#sslice1] produces'0 b bc c)  -> ([%#sslice2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl [#"../../creusot-contracts/src/std/vec.rs" 283 4 283 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 282 14 282 45
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 283 27 283 29
  let%span svec2 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec2] view'0 self = Seq.(++) visited (view'0 rhs)
  
  constant self  : t_IntoIter'0
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/vec.rs" 283 4 283 26] (self : t_IntoIter'0) : ()
  
  goal vc_produces_refl'0 : [%#svec0] produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans [#"../../creusot-contracts/src/std/vec.rs" 290 4 290 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 287 15 287 32
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 288 15 288 32
  let%span svec2 = "../../creusot-contracts/src/std/vec.rs" 289 14 289 42
  let%span svec3 = "../../creusot-contracts/src/std/vec.rs" 290 73 290 75
  let%span svec4 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec4] view'0 self = Seq.(++) visited (view'0 rhs)
  
  constant a  : t_IntoIter'0
  
  constant ab  : Seq.seq t_T'0
  
  constant b  : t_IntoIter'0
  
  constant bc  : Seq.seq t_T'0
  
  constant c  : t_IntoIter'0
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/vec.rs" 290 4 290 72] (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#svec0] produces'0 a ab b)
   -> ([%#svec1] produces'0 b bc c)  -> ([%#svec2] produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Real.(<=) x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Real.(<) x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Real.(>=) x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Real.real) (y : Real.real) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Real.(>) x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Real.real) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span snum_rational4 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational4] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  constant z  : Real.real
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Real.real) (y : Real.real) (z : Real.real) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span snum_rational3 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational3] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span snum_rational3 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational3] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Real.real) (y : Real.real) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span snum_rational2 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational2] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Real.real
  
  constant y  : Real.real
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Real.real) (y : Real.real) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone [#"../../creusot-contracts/src/ghost.rs" 48 4 48 27] (* <ghost::Ghost<T> as std::clone::Clone> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 48 14 48 18
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 48 23 48 27
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 47 14 47 29
  let%span sclone3 = "../../creusot-contracts/src/std/clone.rs" 15 26 15 41
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  let rec clone'1 (self:t_T'0) (return'  (ret:t_T'0))= {[@expl:clone 'self' type invariant] inv'2 self}
    any [ return' (result:t_T'0)-> {inv'3 result} {[%#sclone3] result = self} (! return' {result}) ] 
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost6] self.t_Ghost__0'0
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost5] inv'3 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Ghost'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/ghost.rs" 48 4 48 27] (self:t_Ghost'0) (return'  (ret:t_Ghost'0))= {[@expl:clone 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 = clone'1 {self.t_Ghost__0'0} (fun (_ret':t_T'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_Ghost__0'0 = _3 } ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_Ghost'0 = Any.any_l () | & self : t_Ghost'0 = self | & _3 : t_T'0 = Any.any_l () ] 
    [ return' (result:t_Ghost'0)-> {[@expl:clone result type invariant] [%#sghost1] inv'1 result}
      {[@expl:clone ensures] [%#sghost2] result = self}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi17169751950936808565__deref [#"../../creusot-contracts/src/ghost.rs" 67 4 67 36] (* <ghost::Ghost<T> as std::ops::Deref> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 67 14 67 18
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 67 23 67 36
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 66 14 66 46
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost5] inv'3 (inner_logic'0 self)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Ghost'0) =
    [%#sinvariant4] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  meta "compute_max_steps" 1000000
  
  let rec deref'0[#"../../creusot-contracts/src/ghost.rs" 67 4 67 36] (self:t_Ghost'0) (return'  (ret:t_T'0))= {[@expl:deref 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_3 <- self.t_Ghost__0'0 ] s1 | s1 =  [ &_0 <- _3 ] s2 | s2 = return' {_0} ]  ] )
    [ & _0 : t_T'0 = Any.any_l () | & self : t_Ghost'0 = self | & _3 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:deref result type invariant] [%#sghost1] inv'1 result}
      {[@expl:deref ensures] [%#sghost2] inner_logic'0 self = result}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi16054780730576886888__deref_mut [#"../../creusot-contracts/src/ghost.rs" 84 4 84 48] (* <ghost::Ghost<T> as std::ops::DerefMut> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 84 22 84 26
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 84 31 84 48
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 82 14 82 46
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 83 14 83 46
  let%span sghost4 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant6] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'2 _1
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost4] self.t_Ghost__0'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost7] inv'0 (inner_logic'0 self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'3 x] . inv'3 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'0 a_0
    end)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Ghost'0) =
    [%#sinvariant6] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Ghost'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Ghost'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Ghost'0) =
    resolve'3 _1
  
  meta "compute_max_steps" 1000000
  
  let rec deref_mut'0[#"../../creusot-contracts/src/ghost.rs" 84 4 84 48] (self:MutBorrow.t t_Ghost'0) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_Ghost__0'0}
        MutBorrow.borrow_final <t_T'0> {(self.current).t_Ghost__0'0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Ghost__0'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _6.current}
        MutBorrow.borrow_final <t_T'0> {_6.current} {MutBorrow.get_id _6}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_5 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_6 <- { _6 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'0 _5.current}
        MutBorrow.borrow_final <t_T'0> {_5.current} {MutBorrow.get_id _5}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_2 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final } ] 
            s3)
      | s3 = {inv'0 _2.current}
        MutBorrow.borrow_final <t_T'0> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_2 <- { _2 with current = _ret'.final } ] 
            s4)
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = {[@expl:type invariant] inv'1 _5} s7
      | s7 = -{resolve'0 _5}- s8
      | s8 = {[@expl:type invariant] inv'1 _2} s9
      | s9 = -{resolve'0 _2}- s10
      | s10 = {[@expl:type invariant] inv'2 self} s11
      | s11 = -{resolve'1 self}- s12
      | s12 = return' {_0} ]
     ]
    )
    [ & _0 : MutBorrow.t t_T'0 = Any.any_l ()
    | & self : MutBorrow.t t_Ghost'0 = self
    | & _2 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_T'0)-> {[@expl:deref_mut result type invariant] [%#sghost1] inv'1 result}
      {[@expl:deref_mut ensures #0] [%#sghost2] result.current = inner_logic'0 self.current}
      {[@expl:deref_mut ensures #1] [%#sghost3] result.final = inner_logic'0 self.final}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi8064556118965643473__resolve_coherence [#"../../creusot-contracts/src/ghost.rs" 124 4 124 31] (* <ghost::Ghost<T> as resolve::Resolve> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 122 15 122 39
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 123 14 123 31
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 124 32 124 34
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 117 8 117 36
  let%span sghost4 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Ghost'0) =
    match _1 with
      | {t_Ghost__0'0 = x0} -> resolve'1 x0
      end
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost4] self.t_Ghost__0'0
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 116 4 116 28] (self : t_Ghost'0) =
    [%#sghost3] resolve'1 (inner_logic'0 self)
  
  constant self  : t_Ghost'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/ghost.rs" 124 4 124 31] (self : t_Ghost'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sghost0] structural_resolve'0 self)  -> ([%#sghost1] resolve'0 self)
end
module M_creusot_contracts__ghost__qyi5572048714256451829__borrow [#"../../creusot-contracts/src/ghost.rs" 131 4 131 37] (* ghost::Ghost<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 131 19 131 23
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 131 28 131 37
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 130 14 130 32
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Ghost'1  =
    { t_Ghost__0'0: t_T'0 }
  
  type t_Ghost'0  =
    { t_Ghost__0'1: t_T'0 }
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'1 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'1) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'0
  
  predicate invariant'3 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'1) =
    [%#sghost5] inv'4 (inner_logic'1 self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Ghost'1 [inv'3 x] . inv'3 x
  = (invariant'3 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'4 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Ghost'1) =
    [%#sinvariant4] inv'3 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'1 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant4] inv'4 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'1
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost5] inv'2 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'1 = a_0} -> inv'2 a_0
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec borrow'0[#"../../creusot-contracts/src/ghost.rs" 131 4 131 37] (self:t_Ghost'1) (return'  (ret:t_Ghost'0))= {[@expl:borrow 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- self.t_Ghost__0'0 ] s1 | s1 =  [ &_0 <- { t_Ghost__0'1 = _4 } ] s2 | s2 = return' {_0} ]
     ]
    ) [ & _0 : t_Ghost'0 = Any.any_l () | & self : t_Ghost'1 = self | & _4 : t_T'0 = Any.any_l () ] 
    [ return' (result:t_Ghost'0)-> {[@expl:borrow result type invariant] [%#sghost1] inv'1 result}
      {[@expl:borrow ensures] [%#sghost2] inner_logic'0 result = inner_logic'1 self}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi5572048714256451829__borrow_mut [#"../../creusot-contracts/src/ghost.rs" 146 4 146 49] (* ghost::Ghost<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 146 27 146 31
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 146 36 146 49
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 144 14 144 60
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 145 14 145 60
  let%span sghost4 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  type t_Ghost'1  =
    { t_Ghost__0'0: t_T'0 }
  
  type t_Ghost'0  =
    { t_Ghost__0'1: MutBorrow.t t_T'0 }
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant6] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_T'0) =
    resolve'2 _1
  
  function inner_logic'1 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'1) : t_T'0 =
    [%#sghost4] self.t_Ghost__0'0
  
  predicate invariant'3 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'1) =
    [%#sghost7] inv'0 (inner_logic'1 self)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Ghost'1 [inv'4 x] . inv'4 x
  = (invariant'3 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'0 a_0
    end)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Ghost'1) =
    [%#sinvariant6] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Ghost'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Ghost'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_Ghost'1) =
    [%#sresolve5] self.final = self.current
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : MutBorrow.t t_Ghost'1) =
    resolve'3 _1
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : MutBorrow.t t_T'0 =
    [%#sghost4] self.t_Ghost__0'1
  
  predicate invariant'2 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost7] inv'1 (inner_logic'0 self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'3 x] . inv'3 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'1 = a_0} -> inv'1 a_0
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec borrow_mut'0[#"../../creusot-contracts/src/ghost.rs" 146 4 146 49] (self:MutBorrow.t t_Ghost'1) (return'  (ret:t_Ghost'0))= {[@expl:borrow_mut 'self' type invariant] [%#sghost0] inv'2 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_Ghost__0'0}
        MutBorrow.borrow_final <t_T'0> {(self.current).t_Ghost__0'0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_5 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Ghost__0'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _5.current}
        MutBorrow.borrow_final <t_T'0> {_5.current} {MutBorrow.get_id _5}
          (fun (_ret':MutBorrow.t t_T'0) ->
             [ &_4 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_5 <- { _5 with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_0 <- { t_Ghost__0'1 = _4 } ] s3
      | s3 = {[@expl:type invariant] inv'1 _5} s4
      | s4 = -{resolve'0 _5}- s5
      | s5 = {[@expl:type invariant] inv'2 self} s6
      | s6 = -{resolve'1 self}- s7
      | s7 = return' {_0} ]
     ]
    )
    [ & _0 : t_Ghost'0 = Any.any_l ()
    | & self : MutBorrow.t t_Ghost'1 = self
    | & _4 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Ghost'0)-> {[@expl:borrow_mut result type invariant] [%#sghost1] inv'3 result}
      {[@expl:borrow_mut ensures #0] [%#sghost2] (inner_logic'0 result).current = inner_logic'1 self.current}
      {[@expl:borrow_mut ensures #1] [%#sghost3] (inner_logic'0 result).final = inner_logic'1 self.final}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi5572048714256451829__conjure [#"../../creusot-contracts/src/ghost.rs" 165 4 165 28] (* ghost::Ghost<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 164 15 164 20
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 165 24 165 28
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'0
  
  predicate invariant'0 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost2] inv'1 (inner_logic'0 self)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'1 a_0
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec conjure'0[#"../../creusot-contracts/src/ghost.rs" 165 4 165 28] (return'  (ret:t_Ghost'0))= {[@expl:conjure requires] [%#sghost0] false}
    (! bb0 [ bb0 = {false} any ] )
    [ return' (result:t_Ghost'0)-> {[@expl:conjure result type invariant] [%#sghost1] inv'0 result}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi5572048714256451829__new [#"../../creusot-contracts/src/ghost.rs" 191 4 191 28] (* ghost::Ghost<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 191 15 191 16
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 191 24 191 28
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 189 14 189 26
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sghost4 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'0
  
  predicate invariant'0 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost4] inv'0 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'0 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'0 a_0
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"../../creusot-contracts/src/ghost.rs" 191 4 191 28] (x:t_T'0) (return'  (ret:t_Ghost'0))= {[@expl:new 'x' type invariant] [%#sghost0] inv'0 x}
    (! bb0
    [ bb0 = bb1 | bb1 = s0 [ s0 =  [ &_0 <- { t_Ghost__0'0 = x } ] s1 | s1 = bb2 ]  | bb2 = bb3 | bb3 = return' {_0} ]
    ) [ & _0 : t_Ghost'0 = Any.any_l () | & x : t_T'0 = x ] 
    [ return' (result:t_Ghost'0)-> {[@expl:new result type invariant] [%#sghost1] inv'1 result}
      {[@expl:new ensures] [%#sghost2] inner_logic'0 result = x}
      (! return' {result}) ]

end
module M_creusot_contracts__ghost__qyi5572048714256451829__new_logic [#"../../creusot-contracts/src/ghost.rs" 206 4 206 34] (* ghost::Ghost<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 205 14 205 26
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 207 8 207 15
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost2] self.t_Ghost__0'0
  
  constant x  : t_T'0
  
  function new_logic'0 [#"../../creusot-contracts/src/ghost.rs" 206 4 206 34] (x : t_T'0) : t_Ghost'0
  
  goal vc_new_logic'0 : [%#sghost0] inner_logic'0 { t_Ghost__0'0 = x } = x
end
module M_creusot_contracts__ghost__qyi5572048714256451829__into_inner [#"../../creusot-contracts/src/ghost.rs" 216 4 216 32] (* ghost::Ghost<T> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 216 22 216 26
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 216 31 216 32
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 214 14 214 29
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sghost4 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'0
  
  predicate invariant'0 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost4] inv'1 (inner_logic'0 self)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'1 a_0
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec into_inner'0[#"../../creusot-contracts/src/ghost.rs" 216 4 216 32] (self:t_Ghost'0) (return'  (ret:t_T'0))= {[@expl:into_inner 'self' type invariant] [%#sghost0] inv'0 self}
    (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- self.t_Ghost__0'0 ] s1 | s1 = bb1 ]  | bb1 = return' {_0} ] )
    [ & _0 : t_T'0 = Any.any_l () | & self : t_Ghost'0 = self ]
    
    [ return' (result:t_T'0)-> {[@expl:into_inner result type invariant] [%#sghost1] inv'1 result}
      {[@expl:into_inner ensures] [%#sghost2] result = inner_logic'0 self}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__subtract [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 196 15 196 33
  let%span sfmap1 = "../../creusot-contracts/src/logic/fmap.rs" 197 14 197 36
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 198 14 198 46
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 199 14 203 5
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 181 14 185 5
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 205 8 205 33
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 155 12 155 89
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 147 19 147 71
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 164 15 164 35
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 165 14 171 5
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 172 14 172 54
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  
  use map.Map
  use mach.int.Int
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap16] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
  
   =
    [%#sfmap14] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap'0) (k : t_K'0) : bool
  
   =
    [%#sfmap15] get_unsized'0 self k <> C_None'0
  
  function subset'0 [#"../../creusot-contracts/src/logic/fmap.rs" 153 4 153 44] (self : t_FMap'0) (other : t_FMap'0) : bool
  
   =
    [%#sfmap6] forall k : t_K'0 . contains'0 self k  -> get_unsized'0 other k = get_unsized'0 self k
  
  function disjoint'0 [#"../../creusot-contracts/src/logic/fmap.rs" 146 4 146 46] (self : t_FMap'0) (other : t_FMap'0) : bool
  
   =
    [%#sfmap7] forall k : t_K'0 . not contains'0 self k \/ not contains'0 other k
  
  function ext_eq'0 [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self : t_FMap'0) (other : t_FMap'0) : bool
  
   =
    [%#sfmap10] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap8] ext_eq'0 self other  -> self = other)
  && ([%#sfmap9] (forall k : t_K'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap17] len'0 self >= 0
  
  function union'0 [#"../../creusot-contracts/src/logic/fmap.rs" 173 4 173 43] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
  
  
  axiom union'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap11] disjoint'0 self other)
   -> ([%#sfmap12] forall k : t_K'0 . get_unsized'0 (union'0 self other) k
  = (if contains'0 self k then
    get_unsized'0 self k
  else
    if contains'0 other k then get_unsized'0 other k else C_None'0
  ))
  && ([%#sfmap13] len'0 (union'0 self other) = len'0 self + len'0 other)
  
  function subtract_keys'0 [#"../../creusot-contracts/src/logic/fmap.rs" 186 4 186 51] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
  
  
  axiom subtract_keys'0_spec : forall self : t_FMap'0, other : t_FMap'0 . [%#sfmap4] forall k : t_K'0 . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k)
  
  constant self  : t_FMap'0
  
  constant other  : t_FMap'0
  
  function subtract'0 [#"../../creusot-contracts/src/logic/fmap.rs" 204 4 204 46] (self : t_FMap'0) (other : t_FMap'0) : t_FMap'0
  
  
  goal vc_subtract'0 : ([%#sfmap0] subset'0 other self)
   -> ([%#sfmap4] forall k : t_K'0 . get_unsized'0 (subtract_keys'0 self other) k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k))
   -> (let result = subtract_keys'0 self other in ([%#sfmap1] disjoint'0 result other)
  && ([%#sfmap2] ext_eq'0 (union'0 other result) self)
  && ([%#sfmap3] forall k : t_K'0 . get_unsized'0 result k
  = (if contains'0 other k then C_None'0 else get_unsized'0 self k)))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__ext_eq [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap1 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  
  use map.Map
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap2] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
  
   =
    [%#sfmap4] Map.get (view'0 self) k
  
  constant self  : t_FMap'0
  
  constant other  : t_FMap'0
  
  function ext_eq'0 [#"../../creusot-contracts/src/logic/fmap.rs" 217 4 217 44] (self : t_FMap'0) (other : t_FMap'0) : bool
  
  
  goal vc_ext_eq'0 : ([%#sfmap2] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2  -> view'0 m1 <> view'0 m2)
   -> ([%#sfmap2] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2  -> view'0 m1 <> view'0 m2)
   -> (let result = view'0 self = view'0 other in ([%#sfmap0] result  -> self = other)
  && ([%#sfmap1] (forall k : t_K'0 . get_unsized'0 self k = get_unsized'0 other k)  -> result))
end
module M_creusot_contracts__logic__fmap__qyi17941324210461407630__contains_ghost [#"../../creusot-contracts/src/logic/fmap.rs" 286 4 286 49] (* logic::fmap::FMap<K, V> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 286 27 286 31
  let%span sfmap1 = "../../creusot-contracts/src/logic/fmap.rs" 286 33 286 36
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 285 14 285 43
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 315 40 315 50
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 41 26 41 51
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil11 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil12 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sinvariant13 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sboxed16 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use map.Map
  use creusot.prelude.Any
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_FMap'0
  
  type t_K'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'1
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap14] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'1
  
   =
    [%#sfmap10] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap'0) (k : t_K'0) : bool
  
   =
    [%#sfmap8] get_unsized'0 self k <> C_None'1
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_K'0)
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  predicate invariant'5 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_V'0) =
    [%#sboxed16] inv'7 self
  
  predicate inv'8 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_V'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  function unwrap'0 [#"../../creusot-contracts/src/util.rs" 57 0 57 36] (op : t_Option'1) : t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'1 . ([%#sutil11] op <> C_None'1)
   -> ([%#sutil12] C_Some'1 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self : t_FMap'0) (k : t_K'0) : t_V'0
  
   =
    [%#sfmap9] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'4 [#"../../creusot-contracts/src/logic/fmap.rs" 489 4 489 30] (self : t_FMap'0) =
    [%#sfmap15] forall k : t_K'0 . contains'0 self k  -> inv'6 k /\ inv'8 (lookup_unsized'0 self k)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_FMap'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_FMap'0) =
    [%#sinvariant13] inv'5 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FMap'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_K'0) =
    [%#sinvariant13] inv'6 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_K'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_K'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'3 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_V'0) =
    [%#sinvariant13] inv'7 self
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_V'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:t_K'0) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap3] inv'0 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap4] inv'1 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap5] inv'2 result}
      {[%#sfmap6] if contains'0 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant13] inv'2 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  let rec is_some'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_some 'self' type invariant] inv'3 self}
    any [ return' (result:bool)-> {[%#soption7] result = (self <> C_None'0)} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec contains_ghost'0[#"../../creusot-contracts/src/logic/fmap.rs" 286 4 286 49] (self:t_FMap'0) (key:t_K'0) (return'  (ret:bool))= {[@expl:contains_ghost 'self' type invariant] [%#sfmap0] inv'0 self}
    {[@expl:contains_ghost 'key' type invariant] [%#sfmap1] inv'1 key}
    (! bb0
    [ bb0 = s0 [ s0 = get_ghost'0 {self} {key} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = is_some'0 {_5} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l () | & self : t_FMap'0 = self | & key : t_K'0 = key | & _5 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:contains_ghost ensures] [%#sfmap2] result = contains'0 self key}
      (! return' {result}) ]

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__ext_eq [#"../../creusot-contracts/src/logic/fset.rs" 198 4 200 17] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 197 14 197 38
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 203 12 203 63
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use set.Fset
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset2] Fset.mem e self
  
  constant self  : Fset.fset t_T'0
  
  constant other  : Fset.fset t_T'0
  
  predicate ext_eq'0 [#"../../creusot-contracts/src/logic/fset.rs" 198 4 200 17] (self : Fset.fset t_T'0) (other : Fset.fset t_T'0)
  
  
  goal vc_ext_eq'0 : [%#sfset0] ([%#sfset1] forall e : t_T'0 . contains'0 self e = contains'0 other e)  -> self = other
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__singleton [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset2] Fset.mem e self
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset t_T'0) (e : t_T'0) : Fset.fset t_T'0
  
   =
    [%#sfset3] Fset.add e self
  
  constant x  : t_T'0
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : t_T'0) : Fset.fset t_T'0
  
  goal vc_singleton'0 : [%#sfset0] forall y : t_T'0 . contains'0 (insert'0 (Fset.empty : Fset.fset t_T'0) x) y = (x = y)
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__unions [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 220 14 220 102
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 221 14 221 24
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 223 8 228 9
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use map.Map
  use mach.int.Int
  
  type t_T'0
  
  type t_U'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_U'0) (e : t_U'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function remove'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self : Fset.fset t_T'0) (e : t_T'0) : Fset.fset t_T'0
  
   =
    [%#sfset4] Fset.remove e self
  
  constant self  : Fset.fset t_T'0
  
  constant f  : Map.map t_T'0 (Fset.fset t_U'0)
  
  function unions'0 [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (self : Fset.fset t_T'0) (f : Map.map t_T'0 (Fset.fset t_U'0)) : Fset.fset t_U'0
  
  
  goal vc_unions'0 : if Fset.cardinal self = 0 then
    [%#sfset0] forall y : t_U'0 . contains'0 (Fset.empty : Fset.fset t_U'0) y
    = (exists x : t_T'0 . contains'1 self x /\ contains'0 (Map.get f x) y)
  else
    let x = Fset.pick self in (0 <= ([%#sfset1] Fset.cardinal self)
    /\ ([%#sfset1] Fset.cardinal (remove'0 self x)) < ([%#sfset1] Fset.cardinal self))
    /\ (([%#sfset0] forall y : t_U'0 . contains'0 (unions'0 (remove'0 self x) f) y
    = (exists x' : t_T'0 . contains'1 (remove'0 self x) x' /\ contains'0 (Map.get f x') y))
     -> ([%#sfset0] forall y : t_U'0 . contains'0 (Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)) y
    = (exists x : t_T'0 . contains'1 self x /\ contains'0 (Map.get f x) y)))

end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 282 32 282 85
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 285 32 285 108
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq9 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset8] Fset.mem e self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq9] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset8] Fset.mem e self
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset12] Fset.add e self
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset10] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq11] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  constant self  : Fset.fset t_T'0
  
  constant n  : int
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  goal vc_replicate'0 : ([%#sfset0] n >= 0)
   -> (if n = 0 then
    ([%#sfset3] forall xs : Seq.seq t_T'0 . Seq.length xs = 0  -> xs = (Seq.empty : Seq.seq t_T'0))
    && (let _ = () in let _ = () in ([%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) y
    = ((Seq.empty : Seq.seq t_T'0) = y))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) xs
    = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x))))
  else
    ([%#sfset5] forall xs : Seq.seq t_T'0, i : int . 0 < i /\ i < Seq.length xs
     -> Seq.get xs i = Seq.get (tail'0 xs) (i - 1))
    && (let _ = () in let _ = () in (([@expl:replicate requires] [%#sfset0] n - 1 >= 0)
    /\ 0 <= ([%#sfset2] n) /\ ([%#sfset2] n - 1) < ([%#sfset2] n))
    /\ (([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self (n - 1)) xs
    = (Seq.length xs = n - 1 /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
     -> ([%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 self (replicate'0 self (n - 1))) xs
    = (0 < Seq.length xs /\ contains'2 self (Seq.get xs 0) /\ contains'0 (replicate'0 self (n - 1)) (tail'0 xs)))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 self (replicate'0 self (n - 1))) xs
    = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))))
  )
end
module M_creusot_contracts__logic__fset__qyi15838233236912513155__replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (* logic::fset::FSet<T> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 294 15 294 21
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 295 14 295 123
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 296 14 296 15
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 300 32 300 85
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 299 12 304 13
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq10 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset13 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sseq15 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use set.Fset
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq10] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset13] Fset.add e self
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset11] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq15] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset14] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset5] n >= 0)
   -> replicate'0 self n
  = ([%#sfset12] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    let _ = let _ = () in () in cons'0 self (replicate'0 self (n - 1))
  )
  
  axiom replicate'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset5] n >= 0)
   -> ([%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
  = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  constant self  : Fset.fset t_T'0
  
  constant n  : int
  
  function replicate_up_to'0 [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  goal vc_replicate_up_to'0 : ([%#sfset0] n >= 0)
   -> (if n = 0 then
    ([%#sfset3] forall xs : Seq.seq t_T'0 . Seq.length xs = 0  -> xs = (Seq.empty : Seq.seq t_T'0))
    && (let _ = () in let _ = () in ([%#sfset4] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) y
    = ((Seq.empty : Seq.seq t_T'0) = y))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) xs
    = (Seq.length xs <= n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x))))
  else
    (([@expl:replicate_up_to requires] [%#sfset0] n - 1 >= 0)
    /\ 0 <= ([%#sfset2] n) /\ ([%#sfset2] n - 1) < ([%#sfset2] n))
    /\ (([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (replicate_up_to'0 self (n - 1)) xs
    = (Seq.length xs <= n - 1 /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
     -> ([@expl:replicate requires] [%#sfset5] n >= 0)
    /\ (([%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
    = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
     -> ([%#sfset1] forall xs : Seq.seq t_T'0 . contains'0 (Fset.union (replicate_up_to'0 self (n
    - 1)) (replicate'0 self n)) xs
    = (Seq.length xs <= n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))))
  )
end
module M_creusot_contracts__logic__fset__unions_union [#"../../creusot-contracts/src/logic/fset.rs" 481 0 481 27]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 478 10 478 125
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 479 10 480 76
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 481 28 481 30
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 220 14 220 102
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 221 14 221 24
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 223 8 228 9
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use map.Map
  
  type t_T'0
  
  type t_U'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_U'0) (e : t_U'0)
  
   =
    [%#sfset6] Fset.mem e self
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset6] Fset.mem e self
  
  function remove'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 92 4 92 37] (self : Fset.fset t_T'0) (e : t_T'0) : Fset.fset t_T'0
  
   =
    [%#sfset7] Fset.remove e self
  
  function unions'0 [#"../../creusot-contracts/src/logic/fset.rs" 222 4 222 61] (self : Fset.fset t_T'0) (f : Map.map t_T'0 (Fset.fset t_U'0)) : Fset.fset t_U'0
  
  
  axiom unions'0_def : forall self : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0) . unions'0 self f
  = ([%#sfset5] if Fset.cardinal self = 0 then
    Fset.empty : Fset.fset t_U'0
  else
    let x = Fset.pick self in Fset.union (Map.get f x) (unions'0 (remove'0 self x) f)
  )
  
  axiom unions'0_spec : forall self : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0) . [%#sfset3] forall y : t_U'0 . contains'0 (unions'0 self f) y
  = (exists x : t_T'0 . contains'1 self x /\ contains'0 (Map.get f x) y)
  
  function unions_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 481 0 481 27]  : ()
  
  goal vc_unions_union'0 : ([%#sfset0] forall s1 : Fset.fset t_T'0, s2 : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0) . unions'0 (Fset.union s1 s2) f
  = Fset.union (unions'0 s1 f) (unions'0 s2 f))
  && ([%#sfset1] forall s : Fset.fset t_T'0, f : Map.map t_T'0 (Fset.fset t_U'0), g : Map.map t_T'0 (Fset.fset t_U'0) . unions'0 s (fun (x : t_T'0) -> Fset.union (Map.get f x) (Map.get g x))
  = Fset.union (unions'0 s f) (unions'0 s g))
end
module M_creusot_contracts__logic__fset__map_union [#"../../creusot-contracts/src/logic/fset.rs" 487 0 487 24]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 486 10 486 104
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 487 25 487 27
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 243 8 243 27
  
  use set.Fset
  use map.Map
  
  type t_T'0
  
  type t_U'0
  
  function map'0 [#"../../creusot-contracts/src/logic/fset.rs" 242 4 242 52] (self : Fset.fset t_T'0) (f : Map.map t_T'0 t_U'0) : Fset.fset t_U'0
  
   =
    [%#sfset2] Fset.map f self
  
  function map_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 487 0 487 24]  : ()
  
  goal vc_map_union'0 : [%#sfset0] forall s : Fset.fset t_T'0, t : Fset.fset t_T'0, f : Map.map t_T'0 t_U'0 . map'0 (Fset.union s t) f
  = Fset.union (map'0 s f) (map'0 t f)
end
module M_creusot_contracts__logic__fset__concat_union [#"../../creusot-contracts/src/logic/fset.rs" 496 0 496 24]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 492 10 493 83
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 494 10 495 83
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 496 25 496 27
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset4] Fset.mem e self
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset3] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  function concat_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 496 0 496 24]  : ()
  
  goal vc_concat_union'0 : ([%#sfset0] forall s1 : Fset.fset (Seq.seq t_T'0), s2 : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . concat'0 (Fset.union s1 s2) t
  = Fset.union (concat'0 s1 t) (concat'0 s2 t))
  && ([%#sfset1] forall s : Fset.fset (Seq.seq t_T'0), t1 : Fset.fset (Seq.seq t_T'0), t2 : Fset.fset (Seq.seq t_T'0) . concat'0 s (Fset.union t1 t2)
  = Fset.union (concat'0 s t1) (concat'0 s t2))
end
module M_creusot_contracts__logic__fset__cons_concat [#"../../creusot-contracts/src/logic/fset.rs" 502 0 502 23]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 501 10 501 133
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 503 20 503 115
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 504 20 504 74
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 505 20 505 89
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 503 4 503 117
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sseq7 = "../../creusot-contracts/src/logic/seq.rs" 247 8 247 27
  let%span sseq8 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset5] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains'1 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset9] Fset.mem e self
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq8] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset6] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'1 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function push_front'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/seq.rs" 246 4 246 41] (self : Seq.seq t_T'0) (x : t_T'0) : Seq.seq t_T'0
  
   =
    [%#sseq7] Seq.cons x self
  
  function cons_concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 502 0 502 23]  : ()
  
  goal vc_cons_concat'0 : ([%#sfset1] forall x : t_T'0, xs : Seq.seq t_T'0, ys : Seq.seq t_T'0 . Seq.(++) (push_front'0 xs x) ys
  = push_front'0 (Seq.(++) xs ys) x)
  && (let _ = () in let _ = () in ([%#sfset2] forall x : t_T'0, ys : Seq.seq t_T'0 . tail'0 (push_front'0 ys x) = ys)
  && (let _ = () in let _ = () in ([%#sfset3] forall ys : Seq.seq t_T'0 . 0 < Seq.length ys
   -> ys = push_front'0 (tail'0 ys) (Seq.get ys 0))
  && (let _ = () in let _ = () in [%#sfset0] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
  = cons'0 s (concat'0 t u))))
end
module M_creusot_contracts__logic__fset__concat_replicate [#"../../creusot-contracts/src/logic/fset.rs" 514 0 514 54]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 511 11 511 27
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 512 10 512 76
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 513 10 513 11
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 528 10 528 59
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 529 10 529 59
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 501 10 501 133
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 516 8 521 9
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq13 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset15 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset16 = "../../creusot-contracts/src/logic/fset.rs" 531 4 531 68
  let%span sfset17 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset18 = "../../creusot-contracts/src/logic/fset.rs" 503 4 503 117
  let%span sfset19 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sseq20 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq13] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset12] Fset.mem e self
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset19] Fset.add e self
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset15] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset14] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq20] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset17] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> replicate'0 self n
  = ([%#sfset10] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    let _ = let _ = () in () in cons'0 self (replicate'0 self (n - 1))
  )
  
  axiom replicate'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> ([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
  = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset11] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty'0 [#"../../creusot-contracts/src/logic/fset.rs" 530 0 530 39] (s : Fset.fset (Seq.seq t_T'0)) : ()
  
   =
    [%#sfset16] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty'0_spec : forall s : Fset.fset (Seq.seq t_T'0) . ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) s
  = s)
  && ([%#sfset7] concat'0 s (singleton'0 (Seq.empty : Seq.seq t_T'0)) = s)
  
  function cons_concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 502 0 502 23]  : () =
    [%#sfset18] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat'0_spec : [%#sfset8] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
  = cons'0 s (concat'0 t u)
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T'0
  
  function concat_replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 514 0 514 54] (n : int) (m : int) (s : Fset.fset t_T'0) : ()
  
  
  goal vc_concat_replicate'0 : ([%#sfset0] 0 <= n /\ 0 <= m)
   -> (if n = 0 then
    ([@expl:replicate requires] [%#sfset3] m >= 0)
    /\ (([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 s m) xs
    = (Seq.length xs = m /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 s x)))
     -> ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) (replicate'0 s m) = replicate'0 s m)
    && ([%#sfset7] concat'0 (replicate'0 s m) (singleton'0 (Seq.empty : Seq.seq t_T'0)) = replicate'0 s m)
     -> (let _ = concat_empty'0 (replicate'0 s m) in [%#sfset1] replicate'0 s (n + m)
    = concat'0 (replicate'0 s n) (replicate'0 s m)))
  else
    ([%#sfset8] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
    = cons'0 s (concat'0 t u))
     -> (let _ = cons_concat'0 in (([@expl:concat_replicate requires] [%#sfset0] 0 <= n - 1 /\ 0 <= m)
    /\ 0 <= ([%#sfset2] n) /\ ([%#sfset2] n - 1) < ([%#sfset2] n))
    /\ (([%#sfset1] replicate'0 s (n - 1 + m) = concat'0 (replicate'0 s (n - 1)) (replicate'0 s m))
     -> (let _ = concat_replicate'0 (n - 1) m s in [%#sfset1] replicate'0 s (n + m)
    = concat'0 (replicate'0 s n) (replicate'0 s m))))
  )
end
module M_creusot_contracts__logic__fset__concat_empty [#"../../creusot-contracts/src/logic/fset.rs" 530 0 530 39]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 528 10 528 59
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 529 10 529 59
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 531 20 531 66
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 532 20 532 66
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 531 4 531 68
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  
  use seq.Seq
  use set.Fset
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset8] Fset.mem e self
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset5] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset9] Fset.add e self
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset7] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset6] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  constant s  : Fset.fset (Seq.seq t_T'0)
  
  function concat_empty'0 [#"../../creusot-contracts/src/logic/fset.rs" 530 0 530 39] (s : Fset.fset (Seq.seq t_T'0)) : ()
  
  
  goal vc_concat_empty'0 : ([%#sfset2] forall xs : Seq.seq t_T'0 . Seq.(++) xs (Seq.empty : Seq.seq t_T'0) = xs)
  && (let _ = () in let _ = () in ([%#sfset3] forall xs : Seq.seq t_T'0 . Seq.(++) (Seq.empty : Seq.seq t_T'0) xs = xs)
  && (let _ = () in let _ = () in ([%#sfset0] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) s = s)
  && ([%#sfset1] concat'0 s (singleton'0 (Seq.empty : Seq.seq t_T'0)) = s)))
end
module M_creusot_contracts__logic__fset__concat_replicate_up_to [#"../../creusot-contracts/src/logic/fset.rs" 542 0 542 60]
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 538 11 538 26
  let%span sfset1 = "../../creusot-contracts/src/logic/fset.rs" 539 10 540 67
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 541 10 541 11
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 276 15 276 21
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 277 14 277 123
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 278 14 278 15
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 528 10 528 59
  let%span sfset7 = "../../creusot-contracts/src/logic/fset.rs" 529 10 529 59
  let%span sfset8 = "../../creusot-contracts/src/logic/fset.rs" 492 10 493 83
  let%span sfset9 = "../../creusot-contracts/src/logic/fset.rs" 494 10 495 83
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 511 11 511 27
  let%span sfset11 = "../../creusot-contracts/src/logic/fset.rs" 512 10 512 76
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 513 10 513 11
  let%span sfset13 = "../../creusot-contracts/src/logic/fset.rs" 544 8 550 9
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 294 15 294 21
  let%span sfset15 = "../../creusot-contracts/src/logic/fset.rs" 295 14 295 123
  let%span sfset16 = "../../creusot-contracts/src/logic/fset.rs" 296 14 296 15
  let%span sfset17 = "../../creusot-contracts/src/logic/fset.rs" 299 12 304 13
  let%span sfset18 = "../../creusot-contracts/src/logic/fset.rs" 268 14 268 144
  let%span sfset19 = "../../creusot-contracts/src/logic/fset.rs" 281 12 287 13
  let%span sfset20 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq21 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfset22 = "../../creusot-contracts/src/logic/fset.rs" 212 14 212 57
  let%span sfset23 = "../../creusot-contracts/src/logic/fset.rs" 214 8 214 29
  let%span sfset24 = "../../creusot-contracts/src/logic/fset.rs" 531 4 531 68
  let%span sfset25 = "../../creusot-contracts/src/logic/fset.rs" 496 25 496 27
  let%span sfset26 = "../../creusot-contracts/src/logic/fset.rs" 516 8 521 9
  let%span sfset27 = "../../creusot-contracts/src/logic/fset.rs" 259 14 259 117
  let%span sfset28 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset29 = "../../creusot-contracts/src/logic/fset.rs" 501 10 501 133
  let%span sfset30 = "../../creusot-contracts/src/logic/fset.rs" 503 4 503 117
  let%span sseq31 = "../../creusot-contracts/src/logic/seq.rs" 169 8 169 39
  
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0)
  
   =
    [%#sfset20] Fset.mem e self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq21] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains'2 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset20] Fset.mem e self
  
  function insert'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 65 4 65 37] (self : Fset.fset (Seq.seq t_T'0)) (e : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset28] Fset.add e self
  
  function singleton'0 [#"../../creusot-contracts/src/logic/fset.rs" 213 4 213 34] (x : Seq.seq t_T'0) : Fset.fset (Seq.seq t_T'0)
  
   =
    [%#sfset23] insert'0 (Fset.empty : Fset.fset (Seq.seq t_T'0)) x
  
  axiom singleton'0_spec : forall x : Seq.seq t_T'0 . [%#sfset22] forall y : Seq.seq t_T'0 . contains'0 (singleton'0 x) y
  = (x = y)
  
  function tail'0 [#"../../creusot-contracts/src/logic/seq.rs" 168 4 168 29] (self : Seq.seq t_T'0) : Seq.seq t_T'0 =
    [%#sseq31] Seq.([..]) self 1 (Seq.length self)
  
  function cons'0 [#"../../creusot-contracts/src/logic/fset.rs" 260 4 260 61] (s : Fset.fset t_T'0) (ss : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom cons'0_spec : forall s : Fset.fset t_T'0, ss : Fset.fset (Seq.seq t_T'0) . [%#sfset27] forall xs : Seq.seq t_T'0 . contains'0 (cons'0 s ss) xs
  = (0 < Seq.length xs /\ contains'2 s (Seq.get xs 0) /\ contains'0 ss (tail'0 xs))
  
  function replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 279 4 279 50] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> replicate'0 self n
  = ([%#sfset19] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    let _ = let _ = () in () in cons'0 self (replicate'0 self (n - 1))
  )
  
  axiom replicate'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset3] n >= 0)
   -> ([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 self n) xs
  = (Seq.length xs = n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  function replicate_up_to'0 [#"../../creusot-contracts/src/logic/fset.rs" 297 4 297 56] (self : Fset.fset t_T'0) (n : int) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom replicate_up_to'0_def : forall self : Fset.fset t_T'0, n : int . ([%#sfset14] n >= 0)
   -> replicate_up_to'0 self n
  = ([%#sfset17] if n = 0 then
    let _ = let _ = () in () in singleton'0 (Seq.empty : Seq.seq t_T'0)
  else
    Fset.union (replicate_up_to'0 self (n - 1)) (replicate'0 self n)
  )
  
  axiom replicate_up_to'0_spec : forall self : Fset.fset t_T'0, n : int . ([%#sfset14] n >= 0)
   -> ([%#sfset15] forall xs : Seq.seq t_T'0 . contains'0 (replicate_up_to'0 self n) xs
  = (Seq.length xs <= n /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 self x)))
  
  function concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 269 4 269 67] (s : Fset.fset (Seq.seq t_T'0)) (t : Fset.fset (Seq.seq t_T'0)) : Fset.fset (Seq.seq t_T'0)
  
  
  axiom concat'0_spec : forall s : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . [%#sfset18] forall xs : Seq.seq t_T'0 . contains'0 (concat'0 s t) xs
  = (exists ys : Seq.seq t_T'0, zs : Seq.seq t_T'0 . contains'0 s ys /\ contains'0 t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty'0 [#"../../creusot-contracts/src/logic/fset.rs" 530 0 530 39] (s : Fset.fset (Seq.seq t_T'0)) : ()
  
   =
    [%#sfset24] let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom concat_empty'0_spec : forall s : Fset.fset (Seq.seq t_T'0) . ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) s
  = s)
  && ([%#sfset7] concat'0 s (singleton'0 (Seq.empty : Seq.seq t_T'0)) = s)
  
  function concat_union'0 [#"../../creusot-contracts/src/logic/fset.rs" 496 0 496 24]  : () =
    [%#sfset25] ()
  
  axiom concat_union'0_spec : ([%#sfset8] forall s1 : Fset.fset (Seq.seq t_T'0), s2 : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . concat'0 (Fset.union s1 s2) t
  = Fset.union (concat'0 s1 t) (concat'0 s2 t))
  && ([%#sfset9] forall s : Fset.fset (Seq.seq t_T'0), t1 : Fset.fset (Seq.seq t_T'0), t2 : Fset.fset (Seq.seq t_T'0) . concat'0 s (Fset.union t1 t2)
  = Fset.union (concat'0 s t1) (concat'0 s t2))
  
  function cons_concat'0 [#"../../creusot-contracts/src/logic/fset.rs" 502 0 502 23]  : () =
    [%#sfset30] let _ = let _ = () in () in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom cons_concat'0_spec : [%#sfset29] forall s : Fset.fset t_T'0, t : Fset.fset (Seq.seq t_T'0), u : Fset.fset (Seq.seq t_T'0) . concat'0 (cons'0 s t) u
  = cons'0 s (concat'0 t u)
  
  function concat_replicate'0 [#"../../creusot-contracts/src/logic/fset.rs" 514 0 514 54] (n : int) (m : int) (s : Fset.fset t_T'0) : ()
  
  
  axiom concat_replicate'0_def : forall n : int, m : int, s : Fset.fset t_T'0 . ([%#sfset10] 0 <= n /\ 0 <= m)
   -> concat_replicate'0 n m s
  = ([%#sfset26] if n = 0 then
    let _ = concat_empty'0 (replicate'0 s m) in ()
  else
    let _ = cons_concat'0 in let _ = concat_replicate'0 (n - 1) m s in ()
  )
  
  axiom concat_replicate'0_spec : forall n : int, m : int, s : Fset.fset t_T'0 . ([%#sfset10] 0 <= n /\ 0 <= m)
   -> ([%#sfset11] replicate'0 s (n + m) = concat'0 (replicate'0 s n) (replicate'0 s m))
  
  constant n  : int
  
  constant m  : int
  
  constant s  : Fset.fset t_T'0
  
  function concat_replicate_up_to'0 [#"../../creusot-contracts/src/logic/fset.rs" 542 0 542 60] (n : int) (m : int) (s : Fset.fset t_T'0) : ()
  
  
  goal vc_concat_replicate_up_to'0 : ([%#sfset0] 0 <= n /\ n < m)
   -> (if n + 1 = m then
    ([@expl:replicate requires] [%#sfset3] n + 1 >= 0)
    /\ (([%#sfset4] forall xs : Seq.seq t_T'0 . contains'0 (replicate'0 s (n + 1)) xs
    = (Seq.length xs = n + 1 /\ (forall x : t_T'0 . contains'1 xs x  -> contains'2 s x)))
     -> ([%#sfset6] concat'0 (singleton'0 (Seq.empty : Seq.seq t_T'0)) (replicate'0 s (n + 1)) = replicate'0 s (n + 1))
    && ([%#sfset7] concat'0 (replicate'0 s (n + 1)) (singleton'0 (Seq.empty : Seq.seq t_T'0)) = replicate'0 s (n + 1))
     -> (let _ = concat_empty'0 (replicate'0 s (n + 1)) in [%#sfset1] replicate_up_to'0 s m
    = Fset.union (replicate_up_to'0 s n) (concat'0 (replicate'0 s (n + 1)) (replicate_up_to'0 s (m - n - 1)))))
  else
    ([%#sfset8] forall s1 : Fset.fset (Seq.seq t_T'0), s2 : Fset.fset (Seq.seq t_T'0), t : Fset.fset (Seq.seq t_T'0) . concat'0 (Fset.union s1 s2) t
    = Fset.union (concat'0 s1 t) (concat'0 s2 t))
    && ([%#sfset9] forall s : Fset.fset (Seq.seq t_T'0), t1 : Fset.fset (Seq.seq t_T'0), t2 : Fset.fset (Seq.seq t_T'0) . concat'0 s (Fset.union t1 t2)
    = Fset.union (concat'0 s t1) (concat'0 s t2))
     -> (let _ = concat_union'0 in ([@expl:concat_replicate requires] [%#sfset10] 0 <= n /\ 0 <= m - n - 1)
    /\ (([%#sfset11] replicate'0 s (n + (m - n - 1)) = concat'0 (replicate'0 s n) (replicate'0 s (m - n - 1)))
     -> (let _ = concat_replicate'0 n (m - n - 1) s in (([@expl:concat_replicate_up_to requires] [%#sfset0] 0 <= n
    /\ n < m - 1)
    /\ 0 <= ([%#sfset2] m) /\ ([%#sfset2] m - 1) < ([%#sfset2] m))
    /\ (([%#sfset1] replicate_up_to'0 s (m - 1)
    = Fset.union (replicate_up_to'0 s n) (concat'0 (replicate'0 s (n + 1)) (replicate_up_to'0 s (m - 1 - n - 1))))
     -> (let _ = concat_replicate_up_to'0 n (m - 1) s in [%#sfset1] replicate_up_to'0 s m
    = Fset.union (replicate_up_to'0 s n) (concat'0 (replicate'0 s (n + 1)) (replicate_up_to'0 s (m - n - 1))))))))
  )
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : int) (y : int) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] (x <= y) = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : int) (y : int) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] (x < y) = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : int) (y : int) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] (x >= y) = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : int) (y : int) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] (x > y) = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : int) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord4] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  constant z  : int
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : int) (y : int) (z : int) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord3] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : int) (y : int) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord3] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : int) (y : int) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord2] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : int
  
  constant y  : int
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : int) (y : int) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt8.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  constant z  : UInt8.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt8.t) (y : UInt8.t) (z : UInt8.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt8.t
  
  constant y  : UInt8.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt8.t) (y : UInt8.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt16.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  constant z  : UInt16.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt16.t) (y : UInt16.t) (z : UInt16.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt16.t
  
  constant y  : UInt16.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt16.t) (y : UInt16.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt32.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  constant z  : UInt32.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt32.t) (y : UInt32.t) (z : UInt32.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt32.t
  
  constant y  : UInt32.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt32.t) (y : UInt32.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt128.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  constant z  : UInt128.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt128.t) (y : UInt128.t) (z : UInt128.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt128.t
  
  constant y  : UInt128.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt128.t) (y : UInt128.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : UInt64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord4] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  constant z  : UInt64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord3] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord2] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : UInt64.t
  
  constant y  : UInt64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : UInt64.t) (y : UInt64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int8.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord4] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  constant z  : Int8.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int8.t) (y : Int8.t) (z : Int8.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord3] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord3] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord2] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int8.t
  
  constant y  : Int8.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int8.t) (y : Int8.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int16.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord4] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  constant z  : Int16.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int16.t) (y : Int16.t) (z : Int16.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord3] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord3] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord2] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int16.t
  
  constant y  : Int16.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int16.t) (y : Int16.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int32.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord4] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  constant z  : Int32.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int32.t) (y : Int32.t) (z : Int32.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord3] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord3] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord2] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int32.t
  
  constant y  : Int32.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int32.t) (y : Int32.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord4] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int128.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord4] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  constant z  : Int128.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int128.t) (y : Int128.t) (z : Int128.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord3] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord3] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord2] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int128.t
  
  constant y  : Int128.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int128.t) (y : Int128.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Int64.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord4] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  constant z  : Int64.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord3] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord2] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Int64.t
  
  constant y  : Int64.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Int64.t) (y : Int64.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Char.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Char.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Char.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : Char.t) (y : Char.t) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Char.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : Char.t) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord4] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  constant z  : Char.t
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : Char.t) (y : Char.t) (z : Char.t) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord3] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : Char.t) (y : Char.t) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord3] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : Char.t) (y : Char.t) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord2] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : Char.t
  
  constant y  : Char.t
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : Char.t) (y : Char.t) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] Bool.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] Bool.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] Bool.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : bool) (y : bool) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] Bool.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : bool) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord4] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  constant z  : bool
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : bool) (y : bool) (z : bool) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord3] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord3] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : bool) (y : bool) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord2] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  constant x  : bool
  
  constant y  : bool
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : bool) (y : bool) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 130 40 130 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'2 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self : tuple'0) (o : tuple'0) =
    [%#sord2] self._0'0 = o._0'0 /\ le_log'1 self._1'0 o._1'0 \/ lt_log'0 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_cmp_le_log'0 : [%#sord0] le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 135 40 135 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'2 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self : tuple'0) (o : tuple'0) =
    [%#sord2] self._0'0 = o._0'0 /\ lt_log'1 self._1'0 o._1'0 \/ lt_log'2 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_cmp_lt_log'0 : [%#sord0] lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 140 40 140 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'2 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self : tuple'0) (o : tuple'0) =
    [%#sord2] self._0'0 = o._0'0 /\ ge_log'1 self._1'0 o._1'0 \/ gt_log'0 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_cmp_ge_log'0 : [%#sord0] ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 145 40 145 42
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'2 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self : tuple'0) (o : tuple'0) =
    [%#sord2] self._0'0 = o._0'0 /\ gt_log'1 self._1'0 o._1'0 \/ gt_log'2 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_cmp_gt_log'0 : [%#sord0] gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 150 25 150 27
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'2 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'2_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (x : tuple'0) : ()
  
  goal vc_refl'0 : [%#sord0] cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 157 57 157 59
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord17] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord15] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Less'0)
   -> ([%#sord14] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord10] cmp_log'1 x y = o)
   -> ([%#sord11] cmp_log'1 y z = o)  -> ([%#sord12] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord9] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord8] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord17] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord15] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord16] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Less'0)
   -> ([%#sord14] cmp_log'2 y x = C_Greater'0)
  
  function trans'2 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'2_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord10] cmp_log'2 x y = o)
   -> ([%#sord11] cmp_log'2 y z = o)  -> ([%#sord12] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord9] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord8] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord4] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  constant z  : tuple'0
  
  constant o  : t_Ordering'0
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (x : tuple'0) (y : tuple'0) (z : tuple'0) (o : t_Ordering'0) : ()
  
  
  goal vc_trans'0 : ([%#sord0] cmp_log'0 x y = o)  -> ([%#sord1] cmp_log'0 y z = o)  -> ([%#sord2] cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 163 38 163 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'2 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_antisym1'0 : ([%#sord0] cmp_log'0 x y = C_Less'0)  -> ([%#sord1] cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 169 38 169 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord16] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord14] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Less'0)
   -> ([%#sord13] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord9] cmp_log'1 x y = o)
   -> ([%#sord10] cmp_log'1 y z = o)  -> ([%#sord11] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord8] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord7] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord16] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord14] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Less'0)
   -> ([%#sord13] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord9] cmp_log'2 x y = o)
   -> ([%#sord10] cmp_log'2 y z = o)  -> ([%#sord11] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord8] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord7] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord3] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_antisym2'0 : ([%#sord0] cmp_log'0 x y = C_Greater'0)  -> ([%#sord1] cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 174 36 174 38
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'2 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'2_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  constant x  : tuple'0
  
  constant y  : tuple'0
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (x : tuple'0) (y : tuple'0) : ()
  
  goal vc_eq_cmp'0 : [%#sord0] (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__seq__qyi14265726700160510826__concat_contains [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17] (* logic::seq::Seq<T> *)
  let%span sseq0 = "../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq1 = "../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  let%span sseq2 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq2] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  function concat_contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 380 4 382 17]  : ()
  
  goal vc_concat_contains'0 : [%#sseq0] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
end
module M_creusot_contracts__pcell__qyi11656593191764906533__clone [#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (* <pcell::Id as std::clone::Clone> *)
  let%span spcell0 = "../../creusot-contracts/src/pcell.rs" 33 14 33 29
  
  use creusot.prelude.Any
  
  type t_Id'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (self:t_Id'0) (return'  (ret:t_Id'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_Id'0 = Any.any_l () | & self : t_Id'0 = self ] 
    [ return' (result:t_Id'0)-> {[@expl:clone ensures] [%#spcell0] result = self} (! return' {result}) ]

end
module M_creusot_contracts__pcell__qyi14846468513926953542__take [#"../../creusot-contracts/src/pcell.rs" 263 4 263 65] (* pcell::PCell<T> *)
  let%span spcell0 = "../../creusot-contracts/src/pcell.rs" 263 24 263 28
  let%span spcell1 = "../../creusot-contracts/src/pcell.rs" 263 30 263 34
  let%span spcell2 = "../../creusot-contracts/src/pcell.rs" 259 15 259 37
  let%span spcell3 = "../../creusot-contracts/src/pcell.rs" 263 64 263 65
  let%span spcell4 = "../../creusot-contracts/src/pcell.rs" 260 14 260 53
  let%span spcell5 = "../../creusot-contracts/src/pcell.rs" 261 14 261 46
  let%span spcell6 = "../../creusot-contracts/src/pcell.rs" 262 14 262 49
  let%span sdefault7 = "../../creusot-contracts/src/std/default.rs" 31 26 31 45
  let%span spcell8 = "../../creusot-contracts/src/pcell.rs" 136 27 136 31
  let%span spcell9 = "../../creusot-contracts/src/pcell.rs" 136 33 136 37
  let%span spcell10 = "../../creusot-contracts/src/pcell.rs" 136 64 136 67
  let%span spcell11 = "../../creusot-contracts/src/pcell.rs" 132 15 132 37
  let%span spcell12 = "../../creusot-contracts/src/pcell.rs" 136 75 136 76
  let%span spcell13 = "../../creusot-contracts/src/pcell.rs" 133 14 133 43
  let%span spcell14 = "../../creusot-contracts/src/pcell.rs" 134 14 134 46
  let%span spcell15 = "../../creusot-contracts/src/pcell.rs" 135 14 135 53
  let%span spcell16 = "../../creusot-contracts/src/pcell.rs" 71 8 71 15
  let%span spcell17 = "../../creusot-contracts/src/pcell.rs" 54 4 54 12
  let%span sinvariant18 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sinvariant20 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed21 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate is_default'0 [#"../../creusot-contracts/src/std/default.rs" 24 4 24 32] (self : t_T'0)
  
  let rec default'0 (return'  (ret:t_T'0))= any
    [ return' (result:t_T'0)-> {inv'2 result} {[%#sdefault7] is_default'0 result} (! return' {result}) ]
  
  
  type t_UnsafeCell'0  =
    { t_UnsafeCell__value'0: t_T'0 }
  
  type t_PCell'0  =
    { t_PCell__0'0: t_UnsafeCell'0 }
  
  type t_Id'0
  
  type t_PCellOwn'0  =
    { t_PCellOwn__qy95zprivate'0: (); t_PCellOwn__id'0: t_Id'0; t_PCellOwn__val'0: t_T'0 }
  
  type t_Ghost'0  =
    { t_Ghost__0'0: MutBorrow.t t_PCellOwn'0 }
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_UnsafeCell'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_UnsafeCell'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_UnsafeCell__value'0 = value} -> inv'2 value
    end
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PCell'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PCell'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_PCell__0'0 = a_0} -> inv'5 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_PCell'0) =
    [%#sinvariant18] inv'4 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PCell'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_PCell'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'3 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed21] inv'2 self
  
  predicate inv'7 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_T'0 [inv'7 x] . inv'7 x = invariant'3 x
  
  predicate inv'6 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PCellOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PCellOwn'0 [inv'6 x] . inv'6 x
  = match x with
    | {t_PCellOwn__qy95zprivate'0 = _private ; t_PCellOwn__id'0 = id ; t_PCellOwn__val'0 = val'} -> inv'7 val'
    end
  
  predicate invariant'2 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_PCellOwn'0) =
    [%#sinvariant20] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_PCellOwn'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_PCellOwn'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : MutBorrow.t t_PCellOwn'0
  
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost19] inv'3 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  function id'0 [#"../../creusot-contracts/src/pcell.rs" 221 4 221 25] (self : t_PCell'0) : t_Id'0
  
  function id'1 [#"../../creusot-contracts/src/pcell.rs" 70 4 70 25] (self : t_PCellOwn'0) : t_Id'0 =
    [%#spcell16] self.t_PCellOwn__id'0
  
  function view'0 [#"../../creusot-contracts/src/pcell.rs" 56 4 56 33] (self : t_PCellOwn'0) : t_T'0 =
    [%#spcell17] self.t_PCellOwn__val'0
  
  let rec replace'0 (self:t_PCell'0) (perm:t_Ghost'0) (val':t_T'0) (return'  (ret:t_T'0))= {[@expl:replace 'self' type invariant] [%#spcell8] inv'0 self}
    {[@expl:replace 'perm' type invariant] [%#spcell9] inv'1 perm}
    {[@expl:replace 'val' type invariant] [%#spcell10] inv'2 val'}
    {[@expl:replace requires] [%#spcell11] id'0 self = id'1 (inner_logic'0 perm).current}
    any
    [ return' (result:t_T'0)-> {[%#spcell12] inv'2 result}
      {[%#spcell13] val' = view'0 (inner_logic'0 perm).final}
      {[%#spcell14] result = view'0 (inner_logic'0 perm).current}
      {[%#spcell15] id'0 self = id'1 (inner_logic'0 perm).final}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec take'0[#"../../creusot-contracts/src/pcell.rs" 263 4 263 65] (self:t_PCell'0) (perm:t_Ghost'0) (return'  (ret:t_T'0))= {[@expl:take 'self' type invariant] [%#spcell0] inv'0 self}
    {[@expl:take 'perm' type invariant] [%#spcell1] inv'1 perm}
    {[@expl:take requires] [%#spcell2] id'0 self = id'1 (inner_logic'0 perm).current}
    (! bb0
    [ bb0 = s0 [ s0 = default'0 (fun (_ret':t_T'0) ->  [ &_9 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = replace'0 {self} {perm} {_9} (fun (_ret':t_T'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self : t_PCell'0 = self
    | & perm : t_Ghost'0 = perm
    | & _9 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:take result type invariant] [%#spcell3] inv'2 result}
      {[@expl:take ensures #0] [%#spcell4] id'0 self = id'1 (inner_logic'0 perm).final}
      {[@expl:take ensures #1] [%#spcell5] result = view'0 (inner_logic'0 perm).current}
      {[@expl:take ensures #2] [%#spcell6] is_default'0 (view'0 (inner_logic'0 perm).final)}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18263836234684628832__clone [#"../../creusot-contracts/src/peano.rs" 35 9 35 14] (* <peano::PeanoInt as std::clone::Clone> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 35 9 35 14
  let%span sclone1 = "../../creusot-contracts/src/std/clone.rs" 15 26 15 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  let rec clone'1 (self:UInt64.t) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#sclone1] result = self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/peano.rs" 35 9 35 14] (self:t_PeanoInt'0) (return'  (ret:t_PeanoInt'0))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_5 <- self.t_PeanoInt__0'0 ] s1
      | s1 = clone'1 {_5} (fun (_ret':UInt64.t) ->  [ &_3 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0'0 = _3 } ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : t_PeanoInt'0 = Any.any_l ()
    | & self : t_PeanoInt'0 = self
    | & _3 : UInt64.t = Any.any_l ()
    | & _5 : UInt64.t = Any.any_l () ]
     [ return' (result:t_PeanoInt'0)-> {[@expl:clone ensures] [%#speano0] result = self} (! return' {result}) ] 
end
module M_creusot_contracts__peano__qyi17635635094782400840__default [#"../../creusot-contracts/src/peano.rs" 35 22 35 29] (* <peano::PeanoInt as std::default::Default> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 35 22 35 29
  let%span sdefault1 = "../../creusot-contracts/src/std/default.rs" 31 26 31 45
  let%span snum2 = "../../creusot-contracts/src/std/num.rs" 33 28 33 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  predicate is_default'1 [#"../../creusot-contracts/src/std/num.rs" 32 12 32 39] (self : UInt64.t) =
    [%#snum2] self = (0 : UInt64.t)
  
  let rec default'1 (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#sdefault1] is_default'1 result} (! return' {result}) ]
  
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  predicate is_default'0 [#"../../creusot-contracts/src/peano.rs" 35 22 35 29] (self : t_PeanoInt'0) =
    [%#speano0] true /\ is_default'1 self.t_PeanoInt__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec default'0[#"../../creusot-contracts/src/peano.rs" 35 22 35 29] (return'  (ret:t_PeanoInt'0))= (! bb0
    [ bb0 = s0 [ s0 = default'1 (fun (_ret':UInt64.t) ->  [ &_2 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0'0 = _2 } ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_PeanoInt'0 = Any.any_l () | & _2 : UInt64.t = Any.any_l () ] 
    [ return' (result:t_PeanoInt'0)-> {[@expl:default ensures] [%#speano0] is_default'0 result} (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__new [#"../../creusot-contracts/src/peano.rs" 51 4 51 24] (* peano::PeanoInt *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 52 13 52 14
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 50 14 50 26
  let%span speano2 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano2] UInt64.t'int self.t_PeanoInt__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"../../creusot-contracts/src/peano.rs" 51 4 51 24] (return'  (ret:t_PeanoInt'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_PeanoInt__0'0 = ([%#speano0] (0 : UInt64.t)) } ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_PeanoInt'0 = Any.any_l () ] 
    [ return' (result:t_PeanoInt'0)-> {[@expl:new ensures] [%#speano1] view'0 result = 0} (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u64 [#"../../creusot-contracts/src/peano.rs" 81 4 81 30] (* peano::PeanoInt *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 80 14 80 30
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano1] UInt64.t'int self.t_PeanoInt__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec to_u64'0[#"../../creusot-contracts/src/peano.rs" 81 4 81 30] (self:t_PeanoInt'0) (return'  (ret:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self.t_PeanoInt__0'0 ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & self : t_PeanoInt'0 = self ] 
    [ return' (result:UInt64.t)-> {[@expl:to_u64 ensures] [%#speano0] UInt64.t'int result = view'0 self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_u128 [#"../../creusot-contracts/src/peano.rs" 96 4 96 32] (* peano::PeanoInt *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 95 14 95 30
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano1] UInt64.t'int self.t_PeanoInt__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec to_u128'0[#"../../creusot-contracts/src/peano.rs" 96 4 96 32] (self:t_PeanoInt'0) (return'  (ret:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self.t_PeanoInt__0'0} (fun (_ret_from:UInt128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return' {_0} ]
     ]
    ) [ & _0 : UInt128.t = Any.any_l () | & self : t_PeanoInt'0 = self ] 
    [ return' (result:UInt128.t)-> {[@expl:to_u128 ensures] [%#speano0] UInt128.t'int result = view'0 self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi4712407557780062981__to_i128 [#"../../creusot-contracts/src/peano.rs" 103 4 103 32] (* peano::PeanoInt *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 102 14 102 30
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano1] UInt64.t'int self.t_PeanoInt__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec to_i128'0[#"../../creusot-contracts/src/peano.rs" 103 4 103 32] (self:t_PeanoInt'0) (return'  (ret:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self.t_PeanoInt__0'0} (fun (_ret_from:Int128.t) ->  [ &_0 <- _ret_from ] s1)
      | s1 = return' {_0} ]
     ]
    ) [ & _0 : Int128.t = Any.any_l () | & self : t_PeanoInt'0 = self ] 
    [ return' (result:Int128.t)-> {[@expl:to_i128 ensures] [%#speano0] Int128.to_int result = view'0 self}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi924939193479538090__from [#"../../creusot-contracts/src/peano.rs" 110 4 110 34] (* <u64 as std::convert::From<peano::PeanoInt>> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 109 14 109 29
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 80 14 80 30
  let%span speano2 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano2] UInt64.t'int self.t_PeanoInt__0'0
  
  let rec to_u64'0 (self:t_PeanoInt'0) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#speano1] UInt64.t'int result = view'0 self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from'0[#"../../creusot-contracts/src/peano.rs" 110 4 110 34] (val':t_PeanoInt'0) (return'  (ret:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u64'0 {val'} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : UInt64.t = Any.any_l () | & val' : t_PeanoInt'0 = val' ] 
    [ return' (result:UInt64.t)-> {[@expl:from ensures] [%#speano0] UInt64.t'int result = view'0 val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi18279771819627139730__from [#"../../creusot-contracts/src/peano.rs" 117 4 117 34] (* <i64 as std::convert::From<peano::PeanoInt>> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 116 14 116 29
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 88 14 88 30
  let%span speano2 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.Int64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano2] UInt64.t'int self.t_PeanoInt__0'0
  
  let rec to_i64'0 (self:t_PeanoInt'0) (return'  (ret:Int64.t))= any
    [ return' (result:Int64.t)-> {[%#speano1] Int64.to_int result = view'0 self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from'0[#"../../creusot-contracts/src/peano.rs" 117 4 117 34] (val':t_PeanoInt'0) (return'  (ret:Int64.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i64'0 {val'} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ]  | bb1 = return' {_0} ]
    ) [ & _0 : Int64.t = Any.any_l () | & val' : t_PeanoInt'0 = val' ] 
    [ return' (result:Int64.t)-> {[@expl:from ensures] [%#speano0] Int64.to_int result = view'0 val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi6128796959392123454__from [#"../../creusot-contracts/src/peano.rs" 124 4 124 34] (* <u128 as std::convert::From<peano::PeanoInt>> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 123 14 123 29
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 95 14 95 30
  let%span speano2 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.UInt128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano2] UInt64.t'int self.t_PeanoInt__0'0
  
  let rec to_u128'0 (self:t_PeanoInt'0) (return'  (ret:UInt128.t))= any
    [ return' (result:UInt128.t)-> {[%#speano1] UInt128.t'int result = view'0 self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from'0[#"../../creusot-contracts/src/peano.rs" 124 4 124 34] (val':t_PeanoInt'0) (return'  (ret:UInt128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_u128'0 {val'} (fun (_ret':UInt128.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : UInt128.t = Any.any_l () | & val' : t_PeanoInt'0 = val' ] 
    [ return' (result:UInt128.t)-> {[@expl:from ensures] [%#speano0] UInt128.t'int result = view'0 val'}
      (! return' {result}) ]

end
module M_creusot_contracts__peano__qyi11594489632978387465__from [#"../../creusot-contracts/src/peano.rs" 131 4 131 34] (* <i128 as std::convert::From<peano::PeanoInt>> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 130 14 130 29
  let%span speano1 = "../../creusot-contracts/src/peano.rs" 102 14 102 30
  let%span speano2 = "../../creusot-contracts/src/peano.rs" 40 4 40 12
  
  use creusot.int.Int128
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 [#"../../creusot-contracts/src/peano.rs" 42 4 42 24] (self : t_PeanoInt'0) : int =
    [%#speano2] UInt64.t'int self.t_PeanoInt__0'0
  
  let rec to_i128'0 (self:t_PeanoInt'0) (return'  (ret:Int128.t))= any
    [ return' (result:Int128.t)-> {[%#speano1] Int128.to_int result = view'0 self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec from'0[#"../../creusot-contracts/src/peano.rs" 131 4 131 34] (val':t_PeanoInt'0) (return'  (ret:Int128.t))= (! bb0
    [ bb0 = s0 [ s0 = to_i128'0 {val'} (fun (_ret':Int128.t) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = return' {_0} ]
    ) [ & _0 : Int128.t = Any.any_l () | & val' : t_PeanoInt'0 = val' ] 
    [ return' (result:Int128.t)-> {[@expl:from ensures] [%#speano0] Int128.to_int result = view'0 val'}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__new [#"../../creusot-contracts/src/ptr_own.rs" 59 4 59 53] (* ptr_own::PtrOwn<T> *)
  let%span sptr_own0 = "../../creusot-contracts/src/ptr_own.rs" 59 15 59 16
  let%span sptr_own1 = "../../creusot-contracts/src/ptr_own.rs" 59 24 59 53
  let%span sptr_own2 = "../../creusot-contracts/src/ptr_own.rs" 58 14 58 64
  let%span sptr_own3 = "../../creusot-contracts/src/ptr_own.rs" 68 20 68 23
  let%span sptr_own4 = "../../creusot-contracts/src/ptr_own.rs" 68 36 68 65
  let%span sptr_own5 = "../../creusot-contracts/src/ptr_own.rs" 67 14 67 67
  let%span sptr_own6 = "../../creusot-contracts/src/ptr_own.rs" 36 8 36 16
  let%span sptr_own7 = "../../creusot-contracts/src/ptr_own.rs" 43 8 43 16
  let%span sboxed8 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost9 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sptr_own10 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr11 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr12 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_T'0 }
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_PtrOwn'0 }
  
  type tuple'0  =
    { _0'0: Opaque.ptr; _1'0: t_Ghost'0 }
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed8] inv'0 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (self : Opaque.ptr) : bool =
    [%#sptr12] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr11] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 [#"../../creusot-contracts/src/ptr_own.rs" 35 4 35 34] (self : t_PtrOwn'0) : Opaque.ptr =
    [%#sptr_own6] self.t_PtrOwn__ptr'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ptr_own.rs" 50 4 50 30] (self : t_PtrOwn'0) =
    [%#sptr_own10] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x
  = (invariant'2 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'2 val'
    end)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_PtrOwn'0
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost9] inv'4 (inner_logic'0 self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'3 x] . inv'3 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'4 a_0
    end)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : tuple'0 [inv'1 x] . inv'1 x = (let {_0'0 = x0 ; _1'0 = x1} = x in inv'3 x1)
  
  function val'0 [#"../../creusot-contracts/src/ptr_own.rs" 42 4 42 34] (self : t_PtrOwn'0) : t_T'0 =
    [%#sptr_own7] self.t_PtrOwn__val'0
  
  let rec from_box'0 (val':t_T'0) (return'  (ret:tuple'0))= {[@expl:from_box 'val' type invariant] [%#sptr_own3] inv'2 val'}
    any
    [ return' (result:tuple'0)-> {[%#sptr_own4] inv'1 result}
      {[%#sptr_own5] ptr'0 (inner_logic'0 result._1'0) = result._0'0 /\ val'0 (inner_logic'0 result._1'0) = val'}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"../../creusot-contracts/src/ptr_own.rs" 59 4 59 53] (v:t_T'0) (return'  (ret:tuple'0))= {[@expl:new 'v' type invariant] [%#sptr_own0] inv'0 v}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0 [ s0 = from_box'0 {v} (fun (_ret':tuple'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : tuple'0 = Any.any_l () | & v : t_T'0 = v ] 
    [ return' (result:tuple'0)-> {[@expl:new result type invariant] [%#sptr_own1] inv'1 result}
      {[@expl:new ensures] [%#sptr_own2] ptr'0 (inner_logic'0 result._1'0) = result._0'0
      /\ val'0 (inner_logic'0 result._1'0) = v}
      (! return' {result}) ]

end
module M_creusot_contracts__ptr_own__qyi13445900742793785996__drop [#"../../creusot-contracts/src/ptr_own.rs" 133 4 133 61] (* ptr_own::PtrOwn<T> *)
  let%span sptr_own0 = "../../creusot-contracts/src/ptr_own.rs" 133 39 133 42
  let%span sptr_own1 = "../../creusot-contracts/src/ptr_own.rs" 132 15 132 31
  let%span sptr_own2 = "../../creusot-contracts/src/ptr_own.rs" 120 41 120 44
  let%span sptr_own3 = "../../creusot-contracts/src/ptr_own.rs" 117 15 117 31
  let%span sptr_own4 = "../../creusot-contracts/src/ptr_own.rs" 120 67 120 73
  let%span sptr_own5 = "../../creusot-contracts/src/ptr_own.rs" 118 14 118 35
  let%span sptr_own6 = "../../creusot-contracts/src/ptr_own.rs" 36 8 36 16
  let%span sptr_own7 = "../../creusot-contracts/src/ptr_own.rs" 43 8 43 16
  let%span sresolve8 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sghost10 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sptr_own11 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr12 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr13 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_T'0 }
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_PtrOwn'0 }
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  function is_null_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (self : Opaque.ptr) : bool =
    [%#sptr13] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr12] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 [#"../../creusot-contracts/src/ptr_own.rs" 35 4 35 34] (self : t_PtrOwn'0) : Opaque.ptr =
    [%#sptr_own6] self.t_PtrOwn__ptr'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ptr_own.rs" 50 4 50 30] (self : t_PtrOwn'0) =
    [%#sptr_own11] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed9] inv'3 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_PtrOwn'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'0 val'
    end)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_PtrOwn'0
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost10] inv'2 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  function val'0 [#"../../creusot-contracts/src/ptr_own.rs" 42 4 42 34] (self : t_PtrOwn'0) : t_T'0 =
    [%#sptr_own7] self.t_PtrOwn__val'0
  
  let rec to_box'0 (ptr:Opaque.ptr) (own:t_Ghost'0) (return'  (ret:t_T'0))= {[@expl:to_box 'own' type invariant] [%#sptr_own2] inv'1 own}
    {[@expl:to_box requires] [%#sptr_own3] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_T'0)-> {[%#sptr_own4] inv'0 result}
      {[%#sptr_own5] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve8] resolve'2 self
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec drop'0[#"../../creusot-contracts/src/ptr_own.rs" 133 4 133 61] (ptr:Opaque.ptr) (own:t_Ghost'0) (return'  (ret:()))= {[@expl:drop 'own' type invariant] [%#sptr_own0] inv'1 own}
    {[@expl:drop requires] [%#sptr_own1] ptr = ptr'0 (inner_logic'0 own)}
    (! bb0
    [ bb0 = s0 [ s0 = to_box'0 {ptr} {own} (fun (_ret':t_T'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 _4} s1 | s1 = -{resolve'0 _4}- s2 | s2 = bb2 ] 
    | bb2 = bb3
    | bb3 = return' {_0} ]
    ) [ & _0 : () = Any.any_l () | & ptr : Opaque.ptr = ptr | & own : t_Ghost'0 = own | & _4 : t_T'0 = Any.any_l () ] 
    [ return' (result:())-> (! return' {result}) ]

end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 47 4 47 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 45 15 45 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 46 14 46 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 47 32 47 34
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  
  type t_T1'0
  
  type t_T2'0
  
  type tuple'0  =
    { _0'0: t_T1'0; _1'0: t_T2'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T2'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T1'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : tuple'0) =
    match _1 with
      | {_0'0 = x0 ; _1'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : tuple'0) =
    [%#sresolve3] resolve'2 self._0'0 /\ resolve'1 self._1'0
  
  constant self  : tuple'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 47 4 47 31] (self : tuple'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 61 4 61 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 59 15 59 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 60 14 60 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 61 32 61 34
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : MutBorrow.t t_T'0) =
    _1.final = _1.current
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve3] self.final = self.current
  
  constant self  : MutBorrow.t t_T'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 61 4 61 31] (self : MutBorrow.t t_T'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 73 15 73 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 74 14 74 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 75 32 75 34
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  
  type t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve3] resolve'1 self
  
  constant self  : t_T'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (self : t_T'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence [#"../../creusot-contracts/src/resolve.rs" 92 4 92 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 90 15 90 39
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 91 14 91 31
  let%span sresolve2 = "../../creusot-contracts/src/resolve.rs" 92 32 92 34
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Option'0) =
    match _1 with
      | C_None'0 -> true
      | C_Some'0 x0 -> resolve'1 x0
      end
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve3] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  constant self  : t_Option'0
  
  function resolve_coherence'0 [#"../../creusot-contracts/src/resolve.rs" 92 4 92 31] (self : t_Option'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sresolve0] structural_resolve'0 self)  -> ([%#sresolve1] resolve'0 self)
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone [#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot0 = "../../creusot-contracts/src/snapshot.rs" 56 14 56 29
  
  use creusot.prelude.Any
  
  type t_T'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (self:t_T'0) (return'  (ret:t_T'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_T'0 = Any.any_l () | & self : t_T'0 = self ] 
    [ return' (result:t_T'0)-> {[@expl:clone ensures] [%#ssnapshot0] result = self} (! return' {result}) ]

end
module M_creusot_contracts__util__unwrap [#"../../creusot-contracts/src/util.rs" 57 0 57 36]
  let%span sutil0 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil1 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sutil2 = "../../creusot-contracts/src/util.rs" 45 11 45 16
  let%span sutil3 = "../../creusot-contracts/src/util.rs" 46 10 46 15
  let%span sutil4 = "../../creusot-contracts/src/util.rs" 47 10 47 11
  let%span sutil5 = "../../creusot-contracts/src/util.rs" 58 4 61 5
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function unreachable'0 [#"../../creusot-contracts/src/util.rs" 48 0 48 28]  : t_T'0
  
  axiom unreachable'0_spec : ([%#sutil2] false)  -> ([%#sutil3] false)
  
  constant op  : t_Option'0
  
  function unwrap'0 [#"../../creusot-contracts/src/util.rs" 57 0 57 36] (op : t_Option'0) : t_T'0
  
  goal vc_unwrap'0 : ([%#sutil0] op <> C_None'0)
   -> match op with
    | C_Some'0 t -> [%#sutil1] C_Some'0 t = op
    | C_None'0 -> ([@expl:unreachable requires] [%#sutil2] false)
    /\ (([%#sutil3] false)  -> ([%#sutil1] C_Some'0 unreachable'0 = op))
    end
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_refl__refines [#"../../creusot-contracts/src/std/array.rs" 75 4 75 26] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 75 4 75 26
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray1] view'0 self = Seq.(++) visited (view'0 o)
  
  goal refines : [%#sarray0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__array__qyi15910554087305746489__produces_trans__refines [#"../../creusot-contracts/src/std/array.rs" 82 4 82 90] (* <std::array::IntoIter<T, N> as std::iter::Iterator> *)
  let%span sarray0 = "../../creusot-contracts/src/std/array.rs" 82 4 82 90
  let%span sarray1 = "../../creusot-contracts/src/std/array.rs" 63 20 63 47
  
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use seq.Seq
  
  type t_T'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_T'0 }
  
  type t_MaybeUninit'0  =
    { t_MaybeUninit__uninit'0: (); t_MaybeUninit__value'0: t_ManuallyDrop'0 }
  
  type t_IndexRange'0  =
    { t_IndexRange__start'0: UInt64.t; t_IndexRange__end'0: UInt64.t }
  
  type t_IntoIter'0  =
    { t_IntoIter__data'0: Slice64.array t_MaybeUninit'0; t_IntoIter__alive'0: t_IndexRange'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/array.rs" 54 4 54 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/array.rs" 62 4 62 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#sarray1] view'0 self = Seq.(++) visited (view'0 o)
  
  goal refines : [%#sarray0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 79 4 79 26
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'1  =
    { _0'1: t_NonNull'0; _1'1: t_Layout'0; _2'0: () }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 tuple'1
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap6] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap5] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq tuple'0) self
   -> produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi2751221633790567300__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90] (* <std::collections::hash_map::IntoIter<K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 86 4 86 90
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'1  =
    { _0'1: t_NonNull'0; _1'1: t_Layout'0; _2'0: () }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 tuple'1
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 45 4 45 33] (self : t_IntoIter'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap6] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap5] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 53 4 53 64] (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map0] forall a : t_IntoIter'0 . forall ab : Seq.seq tuple'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq tuple'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 138 4 138 90
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq tuple'0) (o : t_Iter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map0] forall a : t_Iter'0 . forall ab : Seq.seq tuple'0 . forall b : t_Iter'0 . forall bc : Seq.seq tuple'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi17229515035433614012__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26] (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 131 4 131 26
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 97 4 97 33] (self : t_Iter'0) : t_FMap'0
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'1 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 105 4 105 64] (self : t_Iter'0) (visited : Seq.seq tuple'0) (o : t_Iter'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq tuple'0) self
   -> produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 190 4 190 90
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: MutBorrow.t t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq tuple'0) (o : t_IterMut'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k
    /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'1 (Seq.get visited i1)._0'0 = deep_model'1 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map0] forall a : t_IterMut'0 . forall ab : Seq.seq tuple'0 . forall b : t_IterMut'0 . forall bc : Seq.seq tuple'0 . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_map__qyi7200148303891188075__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26] (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::Iterator> *)
  let%span shash_map0 = "../../creusot-contracts/src/std/collections/hash_map.rs" 183 4 183 26
  let%span shash_map1 = "../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sseq3 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: MutBorrow.t t_V'0 }
  
  type t_FMap'0
  
  function len'0 [#"../../creusot-contracts/src/logic/fmap.rs" 50 4 50 27] (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap2] len'0 self >= 0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 149 4 149 33] (self : t_IterMut'0) : t_FMap'0
  
  
  predicate contains'0 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq tuple'0) (x : tuple'0)
   =
    [%#sseq3] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  function view'1 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap7] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1
  
   =
    [%#sfmap6] Map.get (view'1 self) k
  
  function get'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 89 4 91 17] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0
  
   =
    [%#sfmap4] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel5] deep_model'0 self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_map.rs" 157 4 157 64] (self : t_IterMut'0) (visited : Seq.seq tuple'0) (o : t_IterMut'0)
  
   =
    [%#shash_map1] len'0 (view'0 self) = Seq.length visited + len'0 (view'0 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'0 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'0 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 o) k = C_Some'0 v
     -> get'0 (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'1 k2 = k
    /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'1 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'1 (Seq.get visited i1)._0'0 = deep_model'1 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  goal refines : [%#shash_map0] forall self : t_IterMut'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq tuple'0) self
   -> produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 111 4 111 26] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 111 4 111 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 99 8 99 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'0  =
    { _0'0: t_NonNull'0; _1'0: t_Layout'0; _2'0: () }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple'0
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 55 4 55 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 98 4 98 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi16362841949556730032__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 118 4 118 90] (* <std::collections::hash_set::IntoIter<T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 118 4 118 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 99 8 99 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq4 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'0  =
    { _0'0: t_NonNull'0; _1'0: t_Layout'0; _2'0: () }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple'0
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 55 4 55 33] (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq4] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 98 4 98 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 157 4 157 90] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 157 4 157 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 138 8 138 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 129 4 129 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 137 4 137 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi14856790125802176998__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 150 4 150 26] (* <std::collections::hash_set::Iter<'a, T> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 150 4 150 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 138 8 138 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'0 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 129 4 129 33] (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 137 4 137 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 243 4 243 90] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 243 4 243 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 204 4 204 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 223 4 223 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall a : t_Intersection'0 . forall ab : Seq.seq t_T'0 . forall b : t_Intersection'0 . forall bc : Seq.seq t_T'0 . forall c : t_Intersection'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi1282364555482257102__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 236 4 236 26] (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 236 4 236 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 204 4 204 33] (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 223 4 223 64] (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall self : t_Intersection'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_refl__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 264 4 264 26] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 264 4 264 26
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 8 252 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Difference'0  =
    { t_Difference__iter'0: t_Iter'0; t_Difference__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 215 4 215 33] (self : t_Difference'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Difference'0) (visited : Seq.seq t_T'0) (end' : t_Difference'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 251 4 251 64] (self : t_Difference'0) (visited : Seq.seq t_T'0) (o : t_Difference'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall self : t_Difference'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__collections__hash_set__qyi3953735896298504416__produces_trans__refines [#"../../creusot-contracts/src/std/collections/hash_set.rs" 271 4 271 90] (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::Iterator> *)
  let%span shash_set0 = "../../creusot-contracts/src/std/collections/hash_set.rs" 271 4 271 90
  let%span shash_set1 = "../../creusot-contracts/src/std/collections/hash_set.rs" 252 8 252 38
  let%span shash_set2 = "../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq5 = "../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use set.Fset
  use mach.int.Int
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_S'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_S'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_Difference'0  =
    { t_Difference__iter'0: t_Iter'0; t_Difference__other'0: t_HashSet'0 }
  
  type t_T'0
  
  type t_DeepModelTy'0
  
  function view'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 215 4 215 33] (self : t_Difference'0) : Fset.fset t_DeepModelTy'0
  
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel4] deep_model'1 self
  
  predicate contains'1 [#"../../creusot-contracts/src/logic/seq.rs" 347 4 349 17] (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq5] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 62 0 66 9] (start : t_Difference'0) (visited : Seq.seq t_T'0) (end' : t_Difference'0)
  
   =
    [%#shash_set2] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'0 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'0 start) (deep_model'0 x) /\ not contains'0 (view'0 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'0 end') x
     -> contains'0 (view'0 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/collections/hash_set.rs" 251 4 251 64] (self : t_Difference'0) (visited : Seq.seq t_T'0) (o : t_Difference'0)
  
   =
    [%#shash_set1] set_produces'0 self visited o
  
  goal refines : [%#shash_set0] forall a : t_Difference'0 . forall ab : Seq.seq t_T'0 . forall b : t_Difference'0 . forall bc : Seq.seq t_T'0 . forall c : t_Difference'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_refl__refines [#"../../creusot-contracts/src/std/deque.rs" 185 4 185 26] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 185 4 185 26
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sdeque0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__deque__qyi7285194934641240501__produces_trans__refines [#"../../creusot-contracts/src/std/deque.rs" 192 4 192 90] (* <std::collections::vec_deque::Iter<'a, T> as std::iter::Iterator> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 192 4 192 90
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 178 12 178 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'1  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_Iter'0  =
    { t_Iter__i1'0: t_Iter'1; t_Iter__i2'0: t_Iter'1 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 162 4 162 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/deque.rs" 176 4 176 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sdeque1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sdeque0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_trans__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 65 4 65 90
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scloned0] forall a : t_Cloned'0 . forall ab : Seq.seq t_T'0 . forall b : t_Cloned'0 . forall bc : Seq.seq t_T'0 . forall c : t_Cloned'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi12959622540969022492__produces_refl__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26] (* <std::iter::Cloned<I> as std::iter::Iterator> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 58 4 58 26
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 48 12 51 79
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 46 4 46 64] (self : t_Cloned'0) (visited : Seq.seq t_T'0) (o : t_Cloned'0)
  
   =
    [%#scloned1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scloned0] forall self : t_Cloned'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_refl__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 58 4 58 26
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scopied0] forall self : t_Copied'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi13437018464510937253__produces_trans__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90] (* <std::iter::Copied<I> as std::iter::Iterator> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 65 4 65 90
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  type t_T'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_T'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_T'0) (b : t_I'0) (bc : Seq.seq t_T'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_T'0, b : t_I'0, bc : Seq.seq t_T'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'1 it
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 46 4 46 64] (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0)
  
   =
    [%#scopied1] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  goal refines : [%#scopied0] forall a : t_Copied'0 . forall ab : Seq.seq t_T'0 . forall b : t_Copied'0 . forall bc : Seq.seq t_T'0 . forall c : t_Copied'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_refl__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 19 4 19 26
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  goal refines : [%#sempty0] forall self : t_Empty'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__empty__qyi10224556657375706108__produces_trans__refines [#"../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90] (* <std::iter::Empty<T> as std::iter::Iterator> *)
  let%span sempty0 = "../../creusot-contracts/src/std/iter/empty.rs" 26 4 26 90
  let%span sempty1 = "../../creusot-contracts/src/std/iter/empty.rs" 13 20 13 54
  
  use seq.Seq
  
  type t_Empty'0  =
    { t_Empty__0'0: () }
  
  type t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/empty.rs" 12 4 12 64] (self : t_Empty'0) (visited : Seq.seq t_T'0) (o : t_Empty'0)
  
   =
    [%#sempty1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
  
  goal refines : [%#sempty0] forall a : t_Empty'0 . forall ab : Seq.seq t_T'0 . forall b : t_Empty'0 . forall bc : Seq.seq t_T'0 . forall c : t_Empty'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_trans__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 90 4 90 90
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate7 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  type tuple'0  =
    { _0'0: UInt64.t; _1'0: t_Item'0 }
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate7] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq tuple'0) (o : t_Enumerate'0)
  
   =
    [%#senumerate1] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._0'0 = n'0 self + i /\ (Seq.get visited i)._1'0 = Seq.get s i))
  
  goal refines : [%#senumerate0] forall a : t_Enumerate'0 . forall ab : Seq.seq tuple'0 . forall b : t_Enumerate'0 . forall bc : Seq.seq tuple'0 . forall c : t_Enumerate'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi17760969447503171583__produces_refl__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26] (* <std::iter::Enumerate<I> as std::iter::Iterator> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 83 4 83 26
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span senumerate7 = "../../creusot-contracts/src/std/iter/enumerate.rs" 45 12 49 85
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  type t_Item'0
  
  type tuple'0  =
    { _0'0: UInt64.t; _1'0: t_Item'0 }
  
  function n'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 21 4 21 21] (self : t_Enumerate'0) : int
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces'1 a ab b)
   -> ([%#siter5] produces'1 b bc c)  -> ([%#siter6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 43 4 43 30] (self : t_Enumerate'0) =
    [%#senumerate7] (forall s : Seq.seq t_Item'0, i : t_I'0 [produces'1 (iter'0 self) s i] . produces'1 (iter'0 self) s i
     -> n'0 self + Seq.length s < UInt64.t'int v_MAX'0)
    /\ (forall i : MutBorrow.t t_I'0 . completed'0 i  -> produces'1 i.current (Seq.empty : Seq.seq t_Item'0) i.final)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'1 iter
    end)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 70 4 70 64] (self : t_Enumerate'0) (visited : Seq.seq tuple'0) (o : t_Enumerate'0)
  
   =
    [%#senumerate1] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq t_Item'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (Seq.get visited i)._0'0 = n'0 self + i /\ (Seq.get visited i)._1'0 = Seq.get s i))
  
  goal refines : [%#senumerate0] forall self : t_Enumerate'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq tuple'0) self
   -> produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 105 4 105 26
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter2] forall f : t_F'0, i : t_Item'0 . precondition'0 f i
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 i f2 true
    /\ postcondition_mut'0 f1 i f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  goal refines : [%#sfilter0] forall self : t_Filter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter__qyi990465010469908032__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90] (* <std::iter::Filter<I, F> as std::iter::Iterator> *)
  let%span sfilter0 = "../../creusot-contracts/src/std/iter/filter.rs" 112 4 112 90
  let%span sfilter1 = "../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter2 = "../../creusot-contracts/src/std/iter/filter.rs" 34 12 40 124
  let%span sfilter3 = "../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter4 = "../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__predicate'0: t_F'0 }
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : bool)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops11] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops8] unnest'0 self b)
   -> ([%#sops9] unnest'0 b c)  -> ([%#sops10] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops7] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops5] postcondition_mut'0 self args res_state res)
   -> ([%#sops6] unnest'0 self res_state)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 31 4 31 30] (self : t_Filter'0) =
    [%#sfilter2] forall f : t_F'0, i : t_Item'0 . precondition'0 f i
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 i f2 true
    /\ postcondition_mut'0 f1 i f2 false))
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> inv'2 iter /\ inv'1 predicate'
    end)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 23 4 23 22] (self : t_Filter'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 16 4 16 22] (self : t_Filter'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter.rs" 85 4 85 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
  
   =
    [%#sfilter1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  goal refines : [%#sfilter0] forall a : t_Filter'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Filter'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Filter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_refl__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 105 4 105 26
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map5] forall i : t_Item'0 . precondition'0 f i
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map6] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map7] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 i f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 i f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map2] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  goal refines : [%#sfilter_map0] forall self : t_FilterMap'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__filter_map__qyi11148334412739605610__produces_trans__refines [#"../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90] (* <std::iter::FilterMap<I, F> as std::iter::Iterator> *)
  let%span sfilter_map0 = "../../creusot-contracts/src/std/iter/filter_map.rs" 112 4 112 90
  let%span sfilter_map1 = "../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map2 = "../../creusot-contracts/src/std/iter/filter_map.rs" 34 12 38 32
  let%span sfilter_map3 = "../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map4 = "../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map5 = "../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map6 = "../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map7 = "../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter16 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter17 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter18 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use map.Map
  
  type t_I'0
  
  type t_F'0
  
  type t_FilterMap'0  =
    { t_FilterMap__iter'0: t_I'0; t_FilterMap__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 47 0 47 68] (f : t_F'0) =
    [%#sfilter_map5] forall i : t_Item'0 . precondition'0 f i
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_Option'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_Option'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_Option'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_Option'0 . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_Option'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_Option'0 . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate immutable'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 55 0 55 62] (f : t_F'0) =
    [%#sfilter_map6] forall g : t_F'0 . unnest'0 f g  -> f = g
  
  predicate precise'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 62 0 62 61] (f1 : t_F'0) =
    [%#sfilter_map7] forall f2 : t_F'0, i : t_Item'0 . not ((exists b : t_B'0 . postcondition_mut'0 f1 i f2 (C_Some'0 b))
    /\ postcondition_mut'0 f1 i f2 (C_None'0))
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FilterMap'0)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 23 4 23 22] (self : t_FilterMap'0) : t_F'0
  
  axiom func'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map3] inv'0 self  -> inv'1 (func'0 self)
  
  predicate invariant'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 31 4 31 30] (self : t_FilterMap'0) =
    [%#sfilter_map2] no_precondition'0 (func'0 self) /\ immutable'0 (func'0 self) /\ precise'0 (func'0 self)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FilterMap'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_FilterMap__iter'0 = iter ; t_FilterMap__f'0 = f} -> inv'2 iter /\ inv'1 f
    end)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter16] produces'1 a ab b)
   -> ([%#siter17] produces'1 b bc c)  -> ([%#siter18] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter15] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 16 4 16 22] (self : t_FilterMap'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_FilterMap'0 . [%#sfilter_map4] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/filter_map.rs" 83 4 83 67] (self : t_FilterMap'0) (visited : Seq.seq t_B'0) (succ : t_FilterMap'0)
  
   =
    [%#sfilter_map1] invariant'0 self
     -> unnest'0 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut'0 (func'0 self) (Seq.get s (Map.get f i)) (func'0 self) (C_Some'0 (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut'0 (func'0 self) (Seq.get s j) (func'0 self) (C_None'0)))
  
  goal refines : [%#sfilter_map0] forall a : t_FilterMap'0 . forall ab : Seq.seq t_B'0 . forall b : t_FilterMap'0 . forall bc : Seq.seq t_B'0 . forall c : t_FilterMap'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_trans__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse2] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse3] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  goal refines : [%#sfuse0] forall a : t_Fuse'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Fuse'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Fuse'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi3534357438560453877__produces_refl__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (* <std::iter::Fuse<I> as std::iter::Iterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse2] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse3] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  goal refines : [%#sfuse0] forall self : t_Fuse'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 81 4 81 26
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap2] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter11] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap0] forall self : t_Map'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi5448977680930709257__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90] (* <std::iter::Map<I, F> as std::iter::Iterator> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 88 4 88 90
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 63 12 74 75
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops9 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops10 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  type t_B'0
  
  type t_Item'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Item'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : t_Item'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : t_B'0 . [%#sops10] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops7] unnest'0 self b)
   -> ([%#sops8] unnest'0 b c)  -> ([%#sops9] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops6] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : t_B'0 . ([%#sops4] postcondition_mut'0 self args res_state res)
   -> ([%#sops5] unnest'0 self res_state)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'1 f
    end
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap2] inv'0 self  -> inv'1 (func'0 self)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter12] produces'1 a ab b)
   -> ([%#siter13] produces'1 b bc c)  -> ([%#siter14] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter11] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap3] inv'0 self  -> inv'2 (iter'0 self)
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : t_Item'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map.rs" 61 4 61 67] (self : t_Map'0) (visited : Seq.seq t_B'0) (succ : t_Map'0)
  
   =
    [%#smap1] unnest'0 (func'0 self) (func'0 succ)
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 [produces'1 (iter'0 self) s (iter'0 succ)] . Seq.length s = Seq.length visited
    /\ produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      func'0 self = func'0 succ
    else
      (Seq.get fs 0).current = func'0 self /\ (Seq.get fs (Seq.length visited - 1)).final = func'0 succ
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 (func'0 self) (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i)
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap0] forall a : t_Map'0 . forall ab : Seq.seq t_B'0 . forall b : t_Map'0 . forall bc : Seq.seq t_B'0 . forall c : t_Map'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_refl__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops2 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops8] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops5] unnest'0 self b)
   -> ([%#sops6] unnest'0 b c)  -> ([%#sops7] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops4] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops2] postcondition_mut'0 self args res_state res)
   -> ([%#sops3] unnest'0 self res_state)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter9] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv1] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap_inv0] forall self : t_MapInv'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_B'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_B'0) self
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi10280853954906842925__produces_trans__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span sops2 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops3 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops5 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops6 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops7 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops8 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span siter9 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter10 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter11 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops8] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops5] unnest'0 self b)
   -> ([%#sops6] unnest'0 b c)  -> ([%#sops7] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops4] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops2] postcondition_mut'0 self args res_state res)
   -> ([%#sops3] unnest'0 self res_state)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter10] produces'1 a ab b)
   -> ([%#siter11] produces'1 b bc c)  -> ([%#siter12] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter9] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv1] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  goal refines : [%#smap_inv0] forall a : t_MapInv'0 . forall ab : Seq.seq t_B'0 . forall b : t_MapInv'0 . forall bc : Seq.seq t_B'0 . forall c : t_MapInv'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_trans__refines [#"../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 39 4 39 90
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#sonce0] forall a : t_Once'0 . forall ab : Seq.seq t_T'0 . forall b : t_Once'0 . forall bc : Seq.seq t_T'0 . forall c : t_Once'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__once__qyi403149096834806456__produces_refl__refines [#"../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26] (* <std::iter::Once<T> as std::iter::Iterator> *)
  let%span sonce0 = "../../creusot-contracts/src/std/iter/once.rs" 32 4 32 26
  let%span sonce1 = "../../creusot-contracts/src/std/iter/once.rs" 24 12 25 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  type t_Once'0  =
    { t_Once__inner'0: t_IntoIter'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/once.rs" 8 4 8 30] (self : t_Once'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/once.rs" 22 4 22 64] (self : t_Once'0) (visited : Seq.seq t_T'0) (o : t_Once'0)
  
   =
    [%#sonce1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#sonce0] forall self : t_Once'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 36 4 36 26
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  goal refines : [%#srange0] forall self : t_Range'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi990280207493253415__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90] (* <std::ops::Range<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 43 4 43 90
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 23 4 23 64] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  goal refines : [%#srange0] forall a : t_Range'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_Range'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_Range'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 115 4 115 90
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  goal refines : [%#srange0] forall a : t_RangeInclusive'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_RangeInclusive'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_RangeInclusive'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi2076862701479908027__produces_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26] (* <std::ops::RangeInclusive<Idx> as std::iter::Iterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 108 4 108 26
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 97 12 101 76
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/range.rs" 95 4 95 64] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ end_log'0 self = end_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (start_log'0 self) + i)
  
  goal refines : [%#srange0] forall self : t_RangeInclusive'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_refl__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 32 4 32 26
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  goal refines : [%#srepeat0] forall self : t_Repeat'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__iter__repeat__qyi13156433517158091792__produces_trans__refines [#"../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90] (* <std::iter::Repeat<T> as std::iter::Iterator> *)
  let%span srepeat0 = "../../creusot-contracts/src/std/iter/repeat.rs" 39 4 39 90
  let%span srepeat1 = "../../creusot-contracts/src/std/iter/repeat.rs" 24 12 25 78
  
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  type t_Repeat'0  =
    { t_Repeat__element'0: t_T'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 8 4 8 22] (self : t_Repeat'0) : t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/repeat.rs" 22 4 22 64] (self : t_Repeat'0) (visited : Seq.seq t_T'0) (o : t_Repeat'0)
  
   =
    [%#srepeat1] self = o /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = view'0 self)
  
  goal refines : [%#srepeat0] forall a : t_Repeat'0 . forall ab : Seq.seq t_T'0 . forall b : t_Repeat'0 . forall bc : Seq.seq t_T'0 . forall c : t_Repeat'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_refl__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 48 4 48 26
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  use seq.Seq
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces_back'0 a ab b)
   -> ([%#siter5] produces_back'0 b bc c)  -> ([%#siter6] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter3] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev1] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#srev0] forall self : t_Rev'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__rev__qyi8570485907461319344__produces_trans__refines [#"../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90] (* <std::iter::Rev<I> as std::iter::Iterator> *)
  let%span srev0 = "../../creusot-contracts/src/std/iter/rev.rs" 55 4 55 90
  let%span srev1 = "../../creusot-contracts/src/std/iter/rev.rs" 41 12 41 56
  let%span srev2 = "../../creusot-contracts/src/std/iter/rev.rs" 17 14 17 39
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 106 14 106 50
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 110 15 110 37
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 111 15 111 37
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 112 14 112 47
  
  use seq.Seq
  
  type t_I'0
  
  type t_Rev'0  =
    { t_Rev__iter'0: t_I'0 }
  
  type t_Item'0
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter.rs" 103 4 103 70] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_back_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 113 4 113 96] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_back_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter4] produces_back'0 a ab b)
   -> ([%#siter5] produces_back'0 b bc c)  -> ([%#siter6] produces_back'0 a (Seq.(++) ab bc) c)
  
  function produces_back_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 107 4 107 32] (self : t_I'0) : ()
  
  axiom produces_back_refl'0_spec : forall self : t_I'0 . [%#siter3] produces_back'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Rev'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Rev'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Rev__iter'0 = iter} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 18 4 18 22] (self : t_Rev'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Rev'0 . [%#srev2] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/rev.rs" 39 4 39 64] (self : t_Rev'0) (visited : Seq.seq t_Item'0) (o : t_Rev'0)
  
   =
    [%#srev1] produces_back'0 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#srev0] forall a : t_Rev'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Rev'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Rev'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_trans__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 81 4 81 90
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip1] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal refines : [%#sskip0] forall a : t_Skip'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Skip'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Skip'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi13252230069947492373__produces_refl__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26] (* <std::iter::Skip<I> as std::iter::Iterator> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 74 4 74 26
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip3 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 22 4 22 21] (self : t_Skip'0) : int
  
  axiom n'0_spec : forall self : t_Skip'0 . [%#sskip2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_Item'0)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 60 4 60 64] (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0)
  
   =
    [%#sskip1] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'0 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'0 self
    /\ produces'1 (iter'0 self) (Seq.(++) s visited) (iter'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'0 (Seq.get s i)))
  
  goal refines : [%#sskip0] forall self : t_Skip'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_refl__refines [#"../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 72 4 72 26
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake1] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#stake0] forall self : t_Take'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi10011901481142542325__produces_trans__refines [#"../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90] (* <std::iter::Take<I> as std::iter::Iterator> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 79 4 79 90
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span stake3 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  type t_Item'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 [#"../../creusot-contracts/src/std/iter/take.rs" 32 4 32 21] (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake2] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'1 iter
    end
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake3] inv'0 self  -> inv'1 (iter'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/take.rs" 63 4 63 64] (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0)
  
   =
    [%#stake1] n'0 self = n'0 o + Seq.length visited /\ produces'1 (iter'0 self) visited (iter'0 o)
  
  goal refines : [%#stake0] forall a : t_Take'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Take'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Take'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_trans__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 63 4 63 90
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A'0
  
  type t_B'0
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: t_Item'1 }
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_A'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip2] inv'0 self  -> inv'1 (itera'0 self)
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'2 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'2_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter5] produces'2 a ab b)
   -> ([%#siter6] produces'2 b bc c)  -> ([%#siter7] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_B'0 . [%#siter4] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq tuple'0) (o : t_Zip'0)
  
   =
    [%#szip1] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _0'0 = Seq.get p1 i; _1'0 = Seq.get p2 i })
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  goal refines : [%#szip0] forall a : t_Zip'0 . forall ab : Seq.seq tuple'0 . forall b : t_Zip'0 . forall bc : Seq.seq tuple'0 . forall c : t_Zip'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__zip__qyi9055347977946847871__produces_refl__refines [#"../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26] (* <std::iter::Zip<A, B> as std::iter::Iterator> *)
  let%span szip0 = "../../creusot-contracts/src/std/iter/zip.rs" 56 4 56 26
  let%span szip1 = "../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span szip2 = "../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span szip3 = "../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter6 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter7 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_A'0
  
  type t_B'0
  
  type t_Zip'0  =
    { t_Zip__a'0: t_A'0; t_Zip__b'0: t_B'0; t_Zip__index'0: UInt64.t; t_Zip__len'0: UInt64.t; t_Zip__a_len'0: UInt64.t }
  
  type t_Item'0
  
  type t_Item'1
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: t_Item'1 }
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_A'0) (visited : Seq.seq t_Item'0) (o : t_A'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_A'0) (ab : Seq.seq t_Item'0) (b : t_A'0) (bc : Seq.seq t_Item'0) (c : t_A'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_A'0, ab : Seq.seq t_Item'0, b : t_A'0, bc : Seq.seq t_Item'0, c : t_A'0 . ([%#siter5] produces'1 a ab b)
   -> ([%#siter6] produces'1 b bc c)  -> ([%#siter7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_A'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_A'0 . [%#siter4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Zip__a'0 = a ; t_Zip__b'0 = b ; t_Zip__index'0 = index ; t_Zip__len'0 = len ; t_Zip__a_len'0 = a_len} -> inv'1 a
    /\ inv'2 b
    end
  
  function itera'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 15 4 15 23] (self : t_Zip'0) : t_A'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip2] inv'0 self  -> inv'1 (itera'0 self)
  
  predicate produces'2 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_B'0) (visited : Seq.seq t_Item'1) (o : t_B'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_B'0) (ab : Seq.seq t_Item'1) (b : t_B'0) (bc : Seq.seq t_Item'1) (c : t_B'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_B'0, ab : Seq.seq t_Item'1, b : t_B'0, bc : Seq.seq t_Item'1, c : t_B'0 . ([%#siter5] produces'2 a ab b)
   -> ([%#siter6] produces'2 b bc c)  -> ([%#siter7] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_B'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_B'0 . [%#siter4] produces'2 self (Seq.empty : Seq.seq t_Item'1) self
  
  function iterb'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 22 4 22 23] (self : t_Zip'0) : t_B'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip3] inv'0 self  -> inv'2 (iterb'0 self)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/zip.rs" 43 4 43 64] (self : t_Zip'0) (visited : Seq.seq tuple'0) (o : t_Zip'0)
  
   =
    [%#szip1] exists p1 : Seq.seq t_Item'0, p2 : Seq.seq t_Item'1 . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> Seq.get visited i = { _0'0 = Seq.get p1 i; _1'0 = Seq.get p2 i })
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'2 (iterb'0 self) p2 (iterb'0 o)
  
  goal refines : [%#szip0] forall self : t_Zip'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq tuple'0) self
   -> produces'0 self (Seq.empty : Seq.seq tuple'0) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_refl__refines [#"../../creusot-contracts/src/std/iter.rs" 263 4 263 26] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 263 4 263 26
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I'0
  
  type t_Item'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter3] produces'1 a ab b)
   -> ([%#siter4] produces'1 b bc c)  -> ([%#siter5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter2] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter1] produces'1 self.current visited o.current /\ self.final = o.final
  
  goal refines : [%#siter0] forall self : MutBorrow.t t_I'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_creusot_contracts__stdqy35z1__iter__qyi15776886527438550973__produces_trans__refines [#"../../creusot-contracts/src/std/iter.rs" 270 4 270 90] (* <&mut I as std::iter::Iterator> *)
  let%span siter0 = "../../creusot-contracts/src/std/iter.rs" 270 4 270 90
  let%span siter1 = "../../creusot-contracts/src/std/iter.rs" 251 20 251 64
  let%span siter2 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter3 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter4 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter5 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I'0
  
  type t_Item'0
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter3] produces'1 a ab b)
   -> ([%#siter4] produces'1 b bc c)  -> ([%#siter5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#siter2] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter.rs" 250 4 250 64] (self : MutBorrow.t t_I'0) (visited : Seq.seq t_Item'0) (o : MutBorrow.t t_I'0)
  
   =
    [%#siter1] produces'1 self.current visited o.current /\ self.final = o.final
  
  goal refines : [%#siter0] forall a : MutBorrow.t t_I'0 . forall ab : Seq.seq t_Item'0 . forall b : MutBorrow.t t_I'0 . forall bc : Seq.seq t_Item'0 . forall c : MutBorrow.t t_I'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 617 4 617 26] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 617 4 617 26
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 609 12 610 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 593 4 593 30] (self : t_IntoIter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 607 4 607 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi16875853811649438191__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 624 4 624 90] (* <std::option::IntoIter<T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 624 4 624 90
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 609 12 610 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 593 4 593 30] (self : t_IntoIter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 607 4 607 64] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 670 4 670 26] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 670 4 670 26
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 662 12 663 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 646 4 646 34] (self : t_Iter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 660 4 660 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__option__qyi14990757896004605758__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 677 4 677 90] (* <std::option::Iter<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 677 4 677 90
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 662 12 663 96
  
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_Iter'0  =
    { t_Iter__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 646 4 646 34] (self : t_Iter'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 660 4 660 64] (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq t_T'0) /\ self = o
    \/ (exists e : t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_trans__refines [#"../../creusot-contracts/src/std/option.rs" 733 4 733 90] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 733 4 733 90
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 718 12 719 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 702 4 702 38] (self : t_IterMut'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 716 4 716 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall a : t_IterMut'0 . forall ab : Seq.seq (MutBorrow.t t_T'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (MutBorrow.t t_T'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__option__qyi3871448523939226478__produces_refl__refines [#"../../creusot-contracts/src/std/option.rs" 726 4 726 26] (* <std::option::IterMut<'_, T> as std::iter::Iterator> *)
  let%span soption0 = "../../creusot-contracts/src/std/option.rs" 726 4 726 26
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 718 12 719 96
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_T'0)
  
  type t_Item'0  =
    { t_Item__opt'0: t_Option'0 }
  
  type t_IterMut'0  =
    { t_IterMut__inner'0: t_Item'0 }
  
  function view'0 [#"../../creusot-contracts/src/std/option.rs" 702 4 702 38] (self : t_IterMut'0) : t_Option'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/option.rs" 716 4 716 64] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (o : t_IterMut'0)
  
   =
    [%#soption1] visited = (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) /\ self = o
    \/ (exists e : MutBorrow.t t_T'0 . view'0 self = C_Some'0 e /\ visited = Seq.singleton e /\ view'0 o = C_None'0)
  
  goal refines : [%#soption0] forall self : t_IterMut'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 449 4 449 90] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 449 4 449 90
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall a : t_Iter'0 . forall ab : Seq.seq t_T'0 . forall b : t_Iter'0 . forall bc : Seq.seq t_T'0 . forall c : t_Iter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__slice__qyi18390169926879820046__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 442 4 442 26] (* <std::slice::Iter<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 442 4 442 26
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span smodel4 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex5 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice6 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice6] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice7] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 53 4 53 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel4] view'2 self
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex5] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 99 4 99 35] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice2] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 419 4 419 33] (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 433 4 433 65] (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0)
  
   =
    [%#sslice1] to_ref_seq'0 (view'0 self) = Seq.(++) visited (to_ref_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall self : t_Iter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_refl__refines [#"../../creusot-contracts/src/std/slice.rs" 496 4 496 26] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 496 4 496 26
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 489 12 489 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 457 14 457 50
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel5] view'2 self.current
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice2] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 458 4 458 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice4] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice1] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall self : t_IterMut'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
   -> produces'0 self (Seq.empty : Seq.seq (MutBorrow.t t_T'0)) self
end
module M_creusot_contracts__stdqy35z1__slice__qyi16967112428427721086__produces_trans__refines [#"../../creusot-contracts/src/std/slice.rs" 503 4 503 90] (* <std::slice::IterMut<'a, T> as std::iter::Iterator> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 503 4 503 90
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 489 12 489 66
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 457 14 457 50
  let%span smodel5 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex6 = "../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sslice7 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice7] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice8] view'2 self = Slice64.id self)
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0
  
   =
    [%#smodel5] view'2 self.current
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 51 4 51 47] (self : Slice64.slice t_T'0) (ix : int) : t_T'0
  
   =
    [%#sindex6] Seq.get (view'2 self) ix
  
  function to_mut_seq'0 [#"../../creusot-contracts/src/std/slice.rs" 91 4 91 43] (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq (MutBorrow.t t_T'0)
  
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice t_T'0) . ([%#sslice2] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice3] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'0 self.current i) (index_logic'0 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 458 4 458 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice4] Seq.length (view'2 (view'0 self).final)
  = Seq.length (view'2 (view'0 self).current)
  
  predicate produces'0 [#"../../creusot-contracts/src/std/slice.rs" 487 4 487 65] (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t t_T'0)) (tl : t_IterMut'0)
  
   =
    [%#sslice1] to_mut_seq'0 (view'0 self) = Seq.(++) visited (to_mut_seq'0 (view'0 tl))
  
  goal refines : [%#sslice0] forall a : t_IterMut'0 . forall ab : Seq.seq (MutBorrow.t t_T'0) . forall b : t_IterMut'0 . forall bc : Seq.seq (MutBorrow.t t_T'0) . forall c : t_IterMut'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_trans__refines [#"../../creusot-contracts/src/std/vec.rs" 290 4 290 72] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 290 4 290 72
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  goal refines : [%#svec0] forall a : t_IntoIter'0 . forall ab : Seq.seq t_T'0 . forall b : t_IntoIter'0 . forall bc : Seq.seq t_T'0 . forall c : t_IntoIter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9182455043427114830__produces_refl__refines [#"../../creusot-contracts/src/std/vec.rs" 283 4 283 26] (* <std::vec::IntoIter<T, A> as std::iter::Iterator> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 283 4 283 26
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  type t_T'0
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate produces'0 [#"../../creusot-contracts/src/std/vec.rs" 274 4 274 57] (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (rhs : t_IntoIter'0)
  
   =
    [%#svec1] view'0 self = Seq.(++) visited (view'0 rhs)
  
  goal refines : [%#svec0] forall self : t_IntoIter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_T'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_T'0) self
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_lt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 161 4 161 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 161 4 161 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym1__refines [#"../../creusot-contracts/src/std/cmp.rs" 189 4 189 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 189 4 189 33
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__eq_cmp__refines [#"../../creusot-contracts/src/std/cmp.rs" 200 4 200 31] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 200 4 200 31
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__refl__refines [#"../../creusot-contracts/src/std/cmp.rs" 176 4 176 20] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 176 4 176 20
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__trans__refines [#"../../creusot-contracts/src/std/cmp.rs" 183 4 183 52] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 183 4 183 52
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall z : t_Reverse'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__antisym2__refines [#"../../creusot-contracts/src/std/cmp.rs" 195 4 195 33] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 195 4 195 33
  let%span scmp1 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp1] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_le_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 156 4 156 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 156 4 156 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_ge_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 166 4 166 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 166 4 166 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__cmp__qyi8793870187857001919__cmp_gt_log__refines [#"../../creusot-contracts/src/std/cmp.rs" 171 4 171 35] (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  let%span scmp0 = "../../creusot-contracts/src/std/cmp.rs" 171 4 171 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span scmp2 = "../../creusot-contracts/src/std/cmp.rs" 146 8 150 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Reverse'0  =
    { t_Reverse__0'0: t_T'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/cmp.rs" 145 4 145 41] (self : t_Reverse'0) (o : t_Reverse'0) : t_Ordering'0
  
   =
    [%#scmp2] match cmp_log'1 self.t_Reverse__0'0 o.t_Reverse__0'0 with
      | C_Equal'0 -> C_Equal'0
      | C_Less'0 -> C_Greater'0
      | C_Greater'0 -> C_Less'0
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Reverse'0) (o : t_Reverse'0) =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#scmp0] forall x : t_Reverse'0 . forall y : t_Reverse'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 47 20 47 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o <> C_Less'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 25 20 25 56
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o <> C_Greater'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 58 20 58 56
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o = C_Greater'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 36 20 36 53
  let%span soption2 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption2] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_Option'0) (o : t_Option'0) =
    [%#sord1] cmp_log'0 self o = C_Less'0
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'1_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'1_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__stdqy35z1__option__qyi15687504979643803552__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span soption1 = "../../creusot-contracts/src/std/option.rs" 577 8 582 9
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_T'0) (other : t_T'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_T'0) (y : t_T'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym2'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_T'0) (y : t_T'0) : ()
  
  axiom antisym1'0_spec : forall x : t_T'0, y : t_T'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_T'0) (y : t_T'0) (z : t_T'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_T'0, y : t_T'0, z : t_T'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_T'0) : ()
  
  axiom refl'0_spec : forall x : t_T'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_T'0) (o : t_T'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_T'0) (y : t_T'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_T'0, y : t_T'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/std/option.rs" 576 4 576 41] (self : t_Option'0) (o : t_Option'0) : t_Ordering'0
  
   =
    [%#soption1] match { _0'0 = self; _1'0 = o } with
      | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> C_Equal'0
      | {_0'0 = C_None'0 ; _1'0 = C_Some'0 _} -> C_Less'0
      | {_0'0 = C_Some'0 _ ; _1'0 = C_None'0} -> C_Greater'0
      | {_0'0 = C_Some'0 x ; _1'0 = C_Some'0 y} -> cmp_log'1 x y
      end
  
  goal refines : [%#sord0] forall x : t_Option'0 . forall y : t_Option'0 . forall z : t_Option'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<=) x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Real.(<=) x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(<) x y
  = (cmp_log'0 x y = C_Less'0)  -> Real.(<) x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>=) x y
  = (cmp_log'0 x y <> C_Less'0)  -> Real.(>=) x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall result : () . Real.(>) x y
  = (cmp_log'0 x y = C_Greater'0)  -> Real.(>) x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . forall z : Real.real . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall y : Real.real . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__num_rational__qyi7156484438548626841__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <num_rational::Real as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span snum_rational1 = "../../creusot-contracts/src/num_rational.rs" 32 8 38 9
  
  use real.Real
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/num_rational.rs" 31 4 31 41] (self : Real.real) (o : Real.real) : t_Ordering'0
  
   =
    [%#snum_rational1] if Real.(<) self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Real.real . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x >= y) = (cmp_log'0 x y <> C_Less'0)
   -> (x >= y) = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall result : () . cmp_log'0 x x = C_Equal'0  -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x > y)
  = (cmp_log'0 x y = C_Greater'0)  -> (x > y) = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x <= y)
  = (cmp_log'0 x y <> C_Greater'0)  -> (x <= y) = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x < y) = (cmp_log'0 x y = C_Less'0)
   -> (x < y) = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall result : () . (x = y) = (cmp_log'0 x y = C_Equal'0)
   -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8355372356285216375__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <logic::int::Int as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  
  use mach.int.Int
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 183 4 183 41] (self : int) (o : int) : t_Ordering'0 =
    [%#sord1] if self < o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : int . forall y : int . forall z : int . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall result : () . UInt8.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi15418235539824427604__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt8.t) (o : UInt8.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt8.t . forall y : UInt8.t . forall z : UInt8.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall z : UInt16.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . forall result : () . UInt16.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall y : UInt16.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi7305497527599188430__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt16.t) (o : UInt16.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt16.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall z : UInt32.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4526525114627399862__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt32.t) (o : UInt32.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt32.t . forall y : UInt32.t . forall result : () . UInt32.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi11489483489418918928__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall z : UInt128.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi13757098721041279861__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <u128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt128.t) (o : UInt128.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt128.t . forall y : UInt128.t . forall result : () . UInt128.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall z : UInt64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8186105652185060096__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <usize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : UInt64.t) (o : UInt64.t) : t_Ordering'0
  
   =
    [%#sord1] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : UInt64.t . forall y : UInt64.t . forall result : () . UInt64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int8.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int8.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int8.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . Int8.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int8.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall z : Int8.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall y : Int8.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi18413678402769648790__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i8 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int8.t) (o : Int8.t) : t_Ordering'0
  
   =
    [%#sord1] if Int8.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int8.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int16.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int16.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall z : Int16.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int16.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8040194823849327911__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i16 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int16
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int16.t) (o : Int16.t) : t_Ordering'0
  
   =
    [%#sord1] if Int16.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int16.t . forall y : Int16.t . forall result : () . Int16.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int16.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int32.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall z : Int32.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int32.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int32.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . forall result : () . Int32.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int32.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi211457485035727011__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i32 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int32
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int32.t) (o : Int32.t) : t_Ordering'0
  
   =
    [%#sord1] if Int32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int32.t . forall y : Int32.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2565746305859701215__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i64 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int128.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall z : Int128.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int128.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int128.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi2364657485180829964__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <i128 as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int128
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int128.t) (o : Int128.t) : t_Ordering'0
  
   =
    [%#sord1] if Int128.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int128.t . forall y : Int128.t . forall result : () . Int128.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int128.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Int64.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall result : () . Int64.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi8047313880300482848__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <isize as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Int64.t) (o : Int64.t) : t_Ordering'0
  
   =
    [%#sord1] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Int64.t . forall y : Int64.t . forall z : Int64.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Char.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Char.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall z : Char.t . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Char.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi10449924602577541611__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <char as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Char
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : Char.t) (o : Char.t) : t_Ordering'0
  
   =
    [%#sord1] if Char.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : Char.t . forall y : Char.t . forall result : () . Char.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Char.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.le x y
  = (cmp_log'0 x y <> C_Greater'0)  -> Bool.le x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.ge x y
  = (cmp_log'0 x y <> C_Less'0)  -> Bool.ge x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.lt x y
  = (cmp_log'0 x y = C_Less'0)  -> Bool.lt x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall z : bool . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi17836724837647357586__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <bool as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.Bool
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 229 12 229 49] (self : bool) (o : bool) : t_Ordering'0
   =
    [%#sord1] if Bool.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  goal refines : [%#sord0] forall x : bool . forall y : bool . forall result : () . Bool.gt x y
  = (cmp_log'0 x y = C_Greater'0)  -> Bool.gt x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_gt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 145 8 145 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 145 8 145 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 338 20 338 67
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'2 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 337 4 337 36] (self : tuple'0) (o : tuple'0) =
    [%#sord1] self._0'0 = o._0'0 /\ gt_log'1 self._1'0 o._1'0 \/ gt_log'2 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . forall result : () . gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)  -> gt_log'0 x y = (cmp_log'0 x y = C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_ge_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 140 8 140 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 140 8 140 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 332 20 332 68
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'0 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'2 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'1 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 331 4 331 36] (self : tuple'0) (o : tuple'0) =
    [%#sord1] self._0'0 = o._0'0 /\ ge_log'1 self._1'0 o._1'0 \/ gt_log'0 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . forall result : () . ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)  -> ge_log'0 x y = (cmp_log'0 x y <> C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym2__refines [#"../../creusot-contracts/src/logic/ord.rs" 169 8 169 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 169 8 169 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'2 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . cmp_log'0 x y = C_Greater'0
   -> cmp_log'0 x y = C_Greater'0 /\ (forall result : () . cmp_log'0 y x = C_Less'0  -> cmp_log'0 y x = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__eq_cmp__refines [#"../../creusot-contracts/src/logic/ord.rs" 174 8 174 35] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 174 8 174 35
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'2 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'2_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . forall result : () . (x = y)
  = (cmp_log'0 x y = C_Equal'0)  -> (x = y) = (cmp_log'0 x y = C_Equal'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_le_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 130 8 130 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 130 8 130 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 320 20 320 68
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'2 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 319 4 319 36] (self : tuple'0) (o : tuple'0) =
    [%#sord1] self._0'0 = o._0'0 /\ le_log'1 self._1'0 o._1'0 \/ lt_log'0 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . forall result : () . le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)  -> le_log'0 x y = (cmp_log'0 x y <> C_Greater'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__refl__refines [#"../../creusot-contracts/src/logic/ord.rs" 150 8 150 24] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 150 8 150 24
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'2 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'2_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall result : () . cmp_log'0 x x = C_Equal'0
   -> cmp_log'0 x x = C_Equal'0
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__trans__refines [#"../../creusot-contracts/src/logic/ord.rs" 157 8 157 56] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 157 8 157 56
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'2 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'2_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . forall z : tuple'0 . forall o : t_Ordering'0 . cmp_log'0 y z
  = o
  /\ cmp_log'0 x y = o
   -> cmp_log'0 y z = o /\ cmp_log'0 x y = o /\ (forall result : () . cmp_log'0 x z = o  -> cmp_log'0 x z = o)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__cmp_lt_log__refines [#"../../creusot-contracts/src/logic/ord.rs" 135 8 135 39] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 135 8 135 39
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 326 20 326 67
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord15] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord13] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'2 y x = C_Less'0)
  
  function antisym1'0 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'0_spec : forall x : t_B'0, y : t_B'0 . ([%#sord11] cmp_log'2 x y = C_Less'0)
   -> ([%#sord12] cmp_log'2 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord8] cmp_log'2 x y = o)
   -> ([%#sord9] cmp_log'2 y z = o)  -> ([%#sord10] cmp_log'2 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'0_spec : forall x : t_B'0 . [%#sord7] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord6] gt_log'0 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] ge_log'0 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] le_log'0 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord15] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord13] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord11] cmp_log'1 x y = C_Less'0)
   -> ([%#sord12] cmp_log'1 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord8] cmp_log'1 x y = o)
   -> ([%#sord9] cmp_log'1 y z = o)  -> ([%#sord10] cmp_log'1 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'1_spec : forall x : t_A'0 . [%#sord7] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord6] gt_log'1 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] ge_log'1 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'2_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] lt_log'2 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] le_log'1 x y = (cmp_log'1 x y <> C_Greater'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 325 4 325 36] (self : tuple'0) (o : tuple'0) =
    [%#sord1] self._0'0 = o._0'0 /\ lt_log'1 self._1'0 o._1'0 \/ lt_log'2 self._0'0 o._0'0
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord2] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . forall result : () . lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)  -> lt_log'0 x y = (cmp_log'0 x y = C_Less'0)
end
module M_creusot_contracts__logic__ord__qyi4707453745515736021__antisym1__refines [#"../../creusot-contracts/src/logic/ord.rs" 163 8 163 37] (* <(A, B) as logic::ord::OrdLogic> *)
  let%span sord0 = "../../creusot-contracts/src/logic/ord.rs" 163 8 163 37
  let%span sord1 = "../../creusot-contracts/src/logic/ord.rs" 308 12 308 40
  let%span sord2 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord3 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord4 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord5 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord6 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord7 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord8 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  type t_A'0
  
  type t_B'0
  
  type tuple'0  =
    { _0'0: t_A'0; _1'0: t_B'0 }
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_A'0) (other : t_A'0) : t_Ordering'0
  
  
  function eq_cmp'0 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_A'0) (y : t_A'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord14] (x = y) = (cmp_log'1 x y = C_Equal'0)
  
  function antisym2'0 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym2'0_spec : forall x : t_A'0, y : t_A'0 . ([%#sord12] cmp_log'1 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'1 y x = C_Less'0)
  
  function antisym1'1 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_A'0) (y : t_A'0) : ()
  
  axiom antisym1'1_spec : forall x : t_A'0, y : t_A'0 . ([%#sord10] cmp_log'1 x y = C_Less'0)
   -> ([%#sord11] cmp_log'1 y x = C_Greater'0)
  
  function trans'0 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_A'0) (y : t_A'0) (z : t_A'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'0_spec : forall x : t_A'0, y : t_A'0, z : t_A'0, o : t_Ordering'0 . ([%#sord7] cmp_log'1 x y = o)
   -> ([%#sord8] cmp_log'1 y z = o)  -> ([%#sord9] cmp_log'1 x z = o)
  
  function refl'0 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_A'0) : ()
  
  axiom refl'0_spec : forall x : t_A'0 . [%#sord6] cmp_log'1 x x = C_Equal'0
  
  predicate gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_gt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord5] gt_log'0 x y = (cmp_log'1 x y = C_Greater'0)
  
  predicate ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_ge_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord4] ge_log'0 x y = (cmp_log'1 x y <> C_Less'0)
  
  predicate lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_lt_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord3] lt_log'0 x y = (cmp_log'1 x y = C_Less'0)
  
  predicate le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_A'0) (o : t_A'0)
  
  function cmp_le_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_A'0) (y : t_A'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_A'0, y : t_A'0 . [%#sord2] le_log'0 x y = (cmp_log'1 x y <> C_Greater'0)
  
  function cmp_log'2 [#"../../creusot-contracts/src/logic/ord.rs" 19 4 19 46] (self : t_B'0) (other : t_B'0) : t_Ordering'0
  
  
  function eq_cmp'1 [#"../../creusot-contracts/src/logic/ord.rs" 96 4 96 32] (x : t_B'0) (y : t_B'0) : ()
  
  axiom eq_cmp'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord14] (x = y) = (cmp_log'2 x y = C_Equal'0)
  
  function antisym2'1 [#"../../creusot-contracts/src/logic/ord.rs" 91 4 91 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym2'1_spec : forall x : t_B'0, y : t_B'0 . ([%#sord12] cmp_log'2 x y = C_Greater'0)
   -> ([%#sord13] cmp_log'2 y x = C_Less'0)
  
  function antisym1'2 [#"../../creusot-contracts/src/logic/ord.rs" 83 4 83 34] (x : t_B'0) (y : t_B'0) : ()
  
  axiom antisym1'2_spec : forall x : t_B'0, y : t_B'0 . ([%#sord10] cmp_log'2 x y = C_Less'0)
   -> ([%#sord11] cmp_log'2 y x = C_Greater'0)
  
  function trans'1 [#"../../creusot-contracts/src/logic/ord.rs" 75 4 75 53] (x : t_B'0) (y : t_B'0) (z : t_B'0) (o : t_Ordering'0) : ()
  
  
  axiom trans'1_spec : forall x : t_B'0, y : t_B'0, z : t_B'0, o : t_Ordering'0 . ([%#sord7] cmp_log'2 x y = o)
   -> ([%#sord8] cmp_log'2 y z = o)  -> ([%#sord9] cmp_log'2 x z = o)
  
  function refl'1 [#"../../creusot-contracts/src/logic/ord.rs" 68 4 68 21] (x : t_B'0) : ()
  
  axiom refl'1_spec : forall x : t_B'0 . [%#sord6] cmp_log'2 x x = C_Equal'0
  
  predicate gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 57 4 57 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_gt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 63 4 63 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_gt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord5] gt_log'1 x y = (cmp_log'2 x y = C_Greater'0)
  
  predicate ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 46 4 46 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_ge_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 52 4 52 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_ge_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord4] ge_log'1 x y = (cmp_log'2 x y <> C_Less'0)
  
  predicate lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 35 4 35 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_lt_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 41 4 41 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_lt_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord3] lt_log'1 x y = (cmp_log'2 x y = C_Less'0)
  
  predicate le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 24 4 24 36] (self : t_B'0) (o : t_B'0)
  
  function cmp_le_log'1 [#"../../creusot-contracts/src/logic/ord.rs" 30 4 30 36] (x : t_B'0) (y : t_B'0) : ()
  
  axiom cmp_le_log'1_spec : forall x : t_B'0, y : t_B'0 . [%#sord2] le_log'1 x y = (cmp_log'2 x y <> C_Greater'0)
  
  function cmp_log'0 [#"../../creusot-contracts/src/logic/ord.rs" 306 4 306 41] (self : tuple'0) (o : tuple'0) : t_Ordering'0
  
   =
    [%#sord1] let r = cmp_log'1 self._0'0 o._0'0 in if r = C_Equal'0 then cmp_log'2 self._1'0 o._1'0 else r
  
  goal refines : [%#sord0] forall x : tuple'0 . forall y : tuple'0 . cmp_log'0 x y = C_Less'0
   -> cmp_log'0 x y = C_Less'0 /\ (forall result : () . cmp_log'0 y x = C_Greater'0  -> cmp_log'0 y x = C_Greater'0)
end
module M_creusot_contracts__stdqy35z1__deque__qyi15330951746891243504__resolve_coherence__refines [#"../../creusot-contracts/src/std/deque.rs" 71 4 71 31] (* <std::collections::VecDeque<T> as resolve::Resolve> *)
  let%span sdeque0 = "../../creusot-contracts/src/std/deque.rs" 71 4 71 31
  let%span sdeque1 = "../../creusot-contracts/src/std/deque.rs" 64 20 64 83
  let%span sdeque2 = "../../creusot-contracts/src/std/deque.rs" 16 14 16 41
  let%span sdeque3 = "../../creusot-contracts/src/std/deque.rs" 44 8 44 31
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_VecDeque'0  =
    { t_VecDeque__head'0: UInt64.t; t_VecDeque__len'0: UInt64.t; t_VecDeque__buf'0: t_RawVec'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_RawVec'0) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_VecDeque'0) =
    match _1 with
      | {t_VecDeque__head'0 = x0 ; t_VecDeque__len'0 = x1 ; t_VecDeque__buf'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'2 x0
      end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_VecDeque'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_VecDeque'0 [inv'0 x] . inv'0 x = true
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'0 [#"../../creusot-contracts/src/std/deque.rs" 17 4 17 27] (self : t_VecDeque'0) : Seq.seq t_T'0
  
  axiom view'0_spec : forall self : t_VecDeque'0 . [%#sdeque2] Seq.length (view'0 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/std/deque.rs" 43 4 43 47] (self : t_VecDeque'0) (ix : int) : t_T'0
  
   =
    [%#sdeque3] Seq.get (view'0 self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/deque.rs" 63 4 63 28] (self : t_VecDeque'0) =
    [%#sdeque1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  goal refines : [%#sdeque0] forall self : t_VecDeque'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__cloned__qyi7712864753404203214__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31] (* <std::iter::Cloned<I> as resolve::Resolve> *)
  let%span scloned0 = "../../creusot-contracts/src/std/iter/cloned.rs" 28 4 28 31
  let%span scloned1 = "../../creusot-contracts/src/std/iter/cloned.rs" 21 8 21 29
  let%span scloned2 = "../../creusot-contracts/src/std/iter/cloned.rs" 11 14 11 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_Cloned'0  =
    { t_Cloned__it'0: t_I'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Cloned'0) =
    match _1 with
      | {t_Cloned__it'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Cloned'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Cloned__it'0 = it} -> inv'2 it
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Cloned'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Cloned'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Cloned'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 12 4 12 22] (self : t_Cloned'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Cloned'0 . [%#scloned2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/cloned.rs" 20 4 20 28] (self : t_Cloned'0) =
    [%#scloned1] resolve'1 (iter'0 self)
  
  goal refines : [%#scloned0] forall self : t_Cloned'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__copied__qyi10817769304312191898__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31] (* <std::iter::Copied<I> as resolve::Resolve> *)
  let%span scopied0 = "../../creusot-contracts/src/std/iter/copied.rs" 28 4 28 31
  let%span scopied1 = "../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied2 = "../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_Copied'0  =
    { t_Copied__it'0: t_I'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Copied'0) =
    match _1 with
      | {t_Copied__it'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Copied'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Copied__it'0 = it} -> inv'2 it
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Copied'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 12 4 12 22] (self : t_Copied'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/copied.rs" 20 4 20 28] (self : t_Copied'0) =
    [%#scopied1] resolve'1 (iter'0 self)
  
  goal refines : [%#scopied0] forall self : t_Copied'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__enumerate__qyi7229971731912667430__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31] (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  let%span senumerate0 = "../../creusot-contracts/src/std/iter/enumerate.rs" 37 4 37 31
  let%span senumerate1 = "../../creusot-contracts/src/std/iter/enumerate.rs" 30 8 30 29
  let%span senumerate2 = "../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.int.UInt64
  
  type t_I'0
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_I'0; t_Enumerate__count'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Enumerate'0) =
    match _1 with
      | {t_Enumerate__iter'0 = x0 ; t_Enumerate__count'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  axiom inv_axiom'1 : forall x : t_Enumerate'0 [inv'1 x] . inv'1 x
   -> match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Enumerate'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Enumerate'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 15 4 15 22] (self : t_Enumerate'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/enumerate.rs" 29 4 29 28] (self : t_Enumerate'0) =
    [%#senumerate1] resolve'2 (iter'0 self)
  
  goal refines : [%#senumerate0] forall self : t_Enumerate'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map__qyi7619436869179474426__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map.rs" 40 4 40 31] (* <std::iter::Map<I, F> as resolve::Resolve> *)
  let%span smap0 = "../../creusot-contracts/src/std/iter/map.rs" 40 4 40 31
  let%span smap1 = "../../creusot-contracts/src/std/iter/map.rs" 32 8 32 54
  let%span smap2 = "../../creusot-contracts/src/std/iter/map.rs" 15 14 15 39
  let%span smap3 = "../../creusot-contracts/src/std/iter/map.rs" 22 14 22 39
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_I'0
  
  type t_F'0
  
  type t_Map'0  =
    { t_Map__iter'0: t_I'0; t_Map__f'0: t_F'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Map'0) =
    match _1 with
      | {t_Map__iter'0 = x0 ; t_Map__f'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Map'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Map__iter'0 = iter ; t_Map__f'0 = f} -> inv'2 iter /\ inv'3 f
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Map'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/map.rs" 16 4 16 22] (self : t_Map'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Map'0 . [%#smap2] inv'1 self  -> inv'2 (iter'0 self)
  
  function func'0 [#"../../creusot-contracts/src/std/iter/map.rs" 23 4 23 22] (self : t_Map'0) : t_F'0
  
  axiom func'0_spec : forall self : t_Map'0 . [%#smap3] inv'1 self  -> inv'3 (func'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/map.rs" 31 4 31 28] (self : t_Map'0) =
    [%#smap1] resolve'2 (iter'0 self) /\ resolve'1 (func'0 self)
  
  goal refines : [%#smap0] forall self : t_Map'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi17145477625495501557__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31] (* <std::iter::map_inv::MapInv<I, B, F> as resolve::Resolve> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 64 4 64 31
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use seq.Seq
  
  type t_I'0
  
  type t_F'0
  
  type t_B'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_B'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Seq.seq t_B'0) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_MapInv'0) =
    match _1 with
      | {t_MapInv__iter'0 = x0 ; t_MapInv__func'0 = x1 ; t_MapInv__produced'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'1 : forall x : t_MapInv'0 [inv'1 x] . inv'1 x
   -> match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'2 iter /\ inv'3 func
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_MapInv'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_MapInv'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 56 4 56 28] (self : t_MapInv'0) =
    [%#smap_inv1] resolve'3 self.t_MapInv__iter'0 /\ resolve'2 self.t_MapInv__func'0
  
  goal refines : [%#smap_inv0] forall self : t_MapInv'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__skip__qyi1800235112549046777__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31] (* <std::iter::Skip<I> as resolve::Resolve> *)
  let%span sskip0 = "../../creusot-contracts/src/std/iter/skip.rs" 40 4 40 31
  let%span sskip1 = "../../creusot-contracts/src/std/iter/skip.rs" 32 12 32 33
  let%span sskip2 = "../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.int.UInt64
  
  type t_I'0
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_I'0; t_Skip__n'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Skip'0) =
    match _1 with
      | {t_Skip__iter'0 = x0 ; t_Skip__n'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Skip'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Skip'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 15 4 15 22] (self : t_Skip'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Skip'0 . [%#sskip2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/skip.rs" 30 4 30 28] (self : t_Skip'0) =
    [%#sskip1] resolve'2 (iter'0 self)
  
  goal refines : [%#sskip0] forall self : t_Skip'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__take__qyi7846602308660485643__resolve_coherence__refines [#"../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31] (* <std::iter::Take<I> as resolve::Resolve> *)
  let%span stake0 = "../../creusot-contracts/src/std/iter/take.rs" 48 4 48 31
  let%span stake1 = "../../creusot-contracts/src/std/iter/take.rs" 41 8 41 29
  let%span stake2 = "../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.int.UInt64
  
  type t_I'0
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_I'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Take'0) =
    match _1 with
      | {t_Take__iter'0 = x0 ; t_Take__n'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Take'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'2 iter
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Take'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Take'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Take'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function iter'0 [#"../../creusot-contracts/src/std/iter/take.rs" 18 4 18 22] (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake2] inv'1 self  -> inv'2 (iter'0 self)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/iter/take.rs" 40 4 40 28] (self : t_Take'0) =
    [%#stake1] resolve'2 (iter'0 self)
  
  goal refines : [%#stake0] forall self : t_Take'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__slice__qyi6798028551487775744__resolve_coherence__refines [#"../../creusot-contracts/src/std/slice.rs" 475 4 475 31] (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  let%span sslice0 = "../../creusot-contracts/src/std/slice.rs" 475 4 475 31
  let%span sslice1 = "../../creusot-contracts/src/std/slice.rs" 467 20 467 36
  let%span sslice2 = "../../creusot-contracts/src/std/slice.rs" 457 14 457 50
  let%span sslice3 = "../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice4 = "../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ()) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Opaque.ptr) =
    true
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_NonNull'0) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_IterMut'0) =
    match _1 with
      | {t_IterMut__ptr'0 = x0 ; t_IterMut__end_or_len'0 = x1 ; t_IterMut__qy95zmarker'0 = x2} -> resolve'1 x2
      /\ resolve'2 x1 /\ resolve'3 x0
      end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 [#"../../creusot-contracts/src/std/slice.rs" 29 4 29 33] (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : Slice64.slice t_T'0 . ([%#sslice3] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice4] view'1 self = Slice64.id self)
  
  function view'0 [#"../../creusot-contracts/src/std/slice.rs" 458 4 458 33] (self : t_IterMut'0) : MutBorrow.t (Slice64.slice t_T'0)
  
  
  axiom view'0_spec : forall self : t_IterMut'0 . [%#sslice2] Seq.length (view'1 (view'0 self).final)
  = Seq.length (view'1 (view'0 self).current)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/slice.rs" 466 4 466 28] (self : t_IterMut'0) =
    [%#sslice1] (view'0 self).current = (view'0 self).final
  
  goal refines : [%#sslice0] forall self : t_IterMut'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi16169840827095121464__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 61 4 61 31] (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 61 4 61 31
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 54 20 54 83
  let%span svec2 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex3 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span svec5 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq6 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed7 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_A'0
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: t_A'0 }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_RawVec'0) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Vec'0) =
    match _1 with
      | {t_Vec__buf'0 = x0 ; t_Vec__len'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  type t_T'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'3 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed7] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 [#"../../creusot-contracts/src/logic/seq.rs" 628 4 628 30] (self : Seq.seq t_T'0) =
    [%#sseq6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 22 4 22 27] (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec2] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/vec.rs" 70 4 70 30] (self : t_Vec'0) =
    [%#svec5] inv'2 (view'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Vec'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  function index_logic'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/ops/index.rs" 28 4 28 47] (self : t_Vec'0) (ix : int) : t_T'0
  
   =
    [%#sindex3] Seq.get (view'0 self) ix
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 53 4 53 28] (self : t_Vec'0) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'3 (index_logic'0 self i)
  
  goal refines : [%#svec0] forall self : t_Vec'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__vec__qyi9945000909994515642__resolve_coherence__refines [#"../../creusot-contracts/src/std/vec.rs" 261 4 261 31] (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  let%span svec0 = "../../creusot-contracts/src/std/vec.rs" 261 4 261 31
  let%span svec1 = "../../creusot-contracts/src/std/vec.rs" 254 20 254 83
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_A'0
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: t_A'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : Opaque.ptr) =
    true
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_NonNull'0) =
    true
  
  predicate resolve'3 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_ManuallyDrop'0) =
    true
  
  predicate resolve'4 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : UInt64.t) =
    true
  
  predicate resolve'5 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : ()) =
    true
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_IntoIter'0) =
    match _1 with
      | {t_IntoIter__buf'0 = x0 ; t_IntoIter__phantom'0 = x1 ; t_IntoIter__cap'0 = x2 ; t_IntoIter__alloc'0 = x3 ; t_IntoIter__ptr'0 = x4 ; t_IntoIter__end'0 = x5} -> resolve'1 x5
      /\ resolve'2 x4 /\ resolve'3 x3 /\ resolve'4 x2 /\ resolve'5 x1 /\ resolve'2 x0
      end
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_A'0)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_ManuallyDrop'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_ManuallyDrop'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_ManuallyDrop__value'0 = value} -> inv'3 value
    end
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_IntoIter__buf'0 = buf ; t_IntoIter__phantom'0 = phantom ; t_IntoIter__cap'0 = cap ; t_IntoIter__alloc'0 = alloc ; t_IntoIter__ptr'0 = ptr ; t_IntoIter__end'0 = end'} -> inv'2 alloc
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_IntoIter'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_IntoIter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IntoIter'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_T'0
  
  function view'0 [#"../../creusot-contracts/src/std/vec.rs" 244 4 244 33] (self : t_IntoIter'0) : Seq.seq t_T'0
  
  predicate resolve'6 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate resolve'0 [#"../../creusot-contracts/src/std/vec.rs" 253 4 253 28] (self : t_IntoIter'0) =
    [%#svec1] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'6 (Seq.get (view'0 self) i)
  
  goal refines : [%#svec0] forall self : t_IntoIter'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__ghost__qyi8064556118965643473__resolve_coherence__refines [#"../../creusot-contracts/src/ghost.rs" 124 4 124 31] (* <ghost::Ghost<T> as resolve::Resolve> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 124 4 124 31
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 117 8 117 36
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost4 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Ghost'0) =
    match _1 with
      | {t_Ghost__0'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost2] self.t_Ghost__0'0
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost4] inv'2 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Ghost'0) =
    [%#sinvariant3] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/ghost.rs" 116 4 116 28] (self : t_Ghost'0) =
    [%#sghost1] resolve'1 (inner_logic'0 self)
  
  goal refines : [%#sghost0] forall self : t_Ghost'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi14648068534830670712__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 47 4 47 31] (* <(T1, T2) as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 47 4 47 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_T1'0
  
  type t_T2'0
  
  type tuple'0  =
    { _0'0: t_T1'0; _1'0: t_T2'0 }
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T2'0)
  
  predicate resolve'2 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T1'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : tuple'0) =
    match _1 with
      | {_0'0 = x0 ; _1'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T1'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T2'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : tuple'0 [inv'1 x] . inv'1 x
  = (let {_0'0 = x0 ; _1'0 = x1} = x in inv'2 x0 /\ inv'3 x1)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : tuple'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : tuple'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : tuple'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 39 4 39 28] (self : tuple'0) =
    [%#sresolve1] resolve'2 self._0'0 /\ resolve'1 self._1'0
  
  goal refines : [%#sresolve0] forall self : tuple'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi2388451659218500115__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 61 4 61 31] (* <&mut T as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 61 4 61 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sinvariant3 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : MutBorrow.t t_T'0) =
    _1.final = _1.current
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant3] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 53 4 53 28] (self : MutBorrow.t t_T'0) =
    [%#sresolve1] self.final = self.current
  
  goal refines : [%#sresolve0] forall self : MutBorrow.t t_T'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi1404978253314751379__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 75 4 75 31] (* <std::boxed::Box<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 75 4 75 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed3 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_T'0) =
    resolve'1 _1
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed3] inv'2 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 67 4 67 28] (self : t_T'0) =
    [%#sresolve1] resolve'1 self
  
  goal refines : [%#sresolve0] forall self : t_T'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__resolve__qyi11332258715134532170__resolve_coherence__refines [#"../../creusot-contracts/src/resolve.rs" 92 4 92 31] (* <std::option::Option<T> as resolve::Resolve> *)
  let%span sresolve0 = "../../creusot-contracts/src/resolve.rs" 92 4 92 31
  let%span sresolve1 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  type t_T'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'1 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_T'0)
  
  predicate structural_resolve'0 [#"../../creusot-contracts/src/resolve.rs" 27 0 27 51] (_1 : t_Option'0) =
    match _1 with
      | C_None'0 -> true
      | C_Some'0 x0 -> resolve'1 x0
      end
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Option'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 81 4 81 28] (self : t_Option'0) =
    [%#sresolve1] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  goal refines : [%#sresolve0] forall self : t_Option'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_creusot_contracts__stdqy35z1__iter__fuse__qyi12953744680688287360__is_fused__refines [#"../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62] (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  let%span sfuse0 = "../../creusot-contracts/src/std/iter/fuse.rs" 66 4 66 62
  let%span sfuse1 = "../../creusot-contracts/src/std/iter/fuse.rs" 29 12 35 13
  let%span sfuse2 = "../../creusot-contracts/src/std/iter/fuse.rs" 20 12 21 28
  let%span sfuse3 = "../../creusot-contracts/src/std/iter/fuse.rs" 41 14 41 45
  let%span sfuse4 = "../../creusot-contracts/src/std/iter/fuse.rs" 42 27 42 29
  let%span sfuse5 = "../../creusot-contracts/src/std/iter/fuse.rs" 46 15 46 32
  let%span sfuse6 = "../../creusot-contracts/src/std/iter/fuse.rs" 47 15 47 32
  let%span sfuse7 = "../../creusot-contracts/src/std/iter/fuse.rs" 48 14 48 42
  let%span sfuse8 = "../../creusot-contracts/src/std/iter/fuse.rs" 49 91 49 93
  let%span sfuse9 = "../../creusot-contracts/src/std/iter/fuse.rs" 8 14 8 39
  let%span sfuse10 = "../../creusot-contracts/src/std/iter/fuse.rs" 9 14 9 71
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_I'0
  
  type t_Fuse'0  =
    { t_Fuse__iter'0: t_Option'0 }
  
  type t_Item'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Fuse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Fuse'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Fuse__iter'0 = iter} -> inv'1 iter
    end
  
  function view'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 10 4 10 30] (self : t_Fuse'0) : t_Option'0
  
  axiom view'0_spec : forall self : t_Fuse'0 . ([%#sfuse9] inv'0 self  -> inv'1 (view'0 self))
  && ([%#sfuse10] forall other : t_Fuse'0 . view'0 self = view'0 other  -> self = other)
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 27 4 27 65] (self : t_Fuse'0) (prod : Seq.seq t_Item'0) (other : t_Fuse'0)
  
   =
    [%#sfuse1] match view'0 self with
      | C_None'0 -> prod = (Seq.empty : Seq.seq t_Item'0) /\ view'0 other = view'0 self
      | C_Some'0 i -> match view'0 other with
        | C_Some'0 i2 -> produces'1 i prod i2
        | C_None'0 -> false
        end
      end
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 49 4 49 90] (a : t_Fuse'0) (ab : Seq.seq t_Item'0) (b : t_Fuse'0) (bc : Seq.seq t_Item'0) (c : t_Fuse'0) : ()
  
   =
    [%#sfuse8] ()
  
  axiom produces_trans'0_spec : forall a : t_Fuse'0, ab : Seq.seq t_Item'0, b : t_Fuse'0, bc : Seq.seq t_Item'0, c : t_Fuse'0 . ([%#sfuse5] produces'0 a ab b)
   -> ([%#sfuse6] produces'0 b bc c)  -> ([%#sfuse7] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 42 4 42 26] (self : t_Fuse'0) : () =
    [%#sfuse4] ()
  
  axiom produces_refl'0_spec : forall self : t_Fuse'0 . [%#sfuse3] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  function view'1 [#"../../creusot-contracts/src/model.rs" 71 4 71 33] (self : MutBorrow.t t_Fuse'0) : t_Option'0 =
    [%#smodel11] view'0 self.current
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/fuse.rs" 18 4 18 35] (self : MutBorrow.t t_Fuse'0) =
    [%#sfuse2] (view'1 self = C_None'0
    \/ (exists it : MutBorrow.t t_I'0 . completed'1 it /\ view'1 self = C_Some'0 (it.current)))
    /\ view'0 self.final = C_None'0
  
  goal refines : [%#sfuse0] forall self : MutBorrow.t t_Fuse'0 . forall steps : Seq.seq t_Item'0 . forall next : t_Fuse'0 . produces'0 self.final steps next
  /\ completed'0 self
   -> produces'0 self.final steps next
  /\ completed'0 self
  /\ (forall result : () . steps = (Seq.empty : Seq.seq t_Item'0) /\ self.final = next
   -> steps = (Seq.empty : Seq.seq t_Item'0) /\ self.final = next)
end
module M_creusot_contracts__stdqy35z1__iter__map_inv__qyi8002351551305542163__next__refines [#"../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44] (* <std::iter::map_inv::MapInv<I, <I as std::iter::Iterator>::Item, F> as std::iter::Iterator> *)
  let%span smap_inv0 = "../../creusot-contracts/src/std/iter/map_inv.rs" 90 4 90 44
  let%span smap_inv1 = "../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv2 = "../../creusot-contracts/src/std/iter/map_inv.rs" 179 14 179 68
  let%span smap_inv3 = "../../creusot-contracts/src/std/iter/map_inv.rs" 182 12 187 74
  let%span smap_inv4 = "../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span smap_inv5 = "../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv6 = "../../creusot-contracts/src/std/iter/map_inv.rs" 24 27 24 29
  let%span smap_inv7 = "../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv8 = "../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv9 = "../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span smap_inv10 = "../../creusot-contracts/src/std/iter/map_inv.rs" 31 91 31 93
  let%span sinvariant11 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span siter12 = "../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter13 = "../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter14 = "../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter15 = "../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sops16 = "../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops17 = "../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops18 = "../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops19 = "../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops20 = "../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops21 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops22 = "../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span smap_inv23 = "../../creusot-contracts/src/std/iter/map_inv.rs" 74 12 76 73
  let%span smap_inv24 = "../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 156 47
  let%span smap_inv25 = "../../creusot-contracts/src/std/iter/map_inv.rs" 124 14 124 81
  let%span smap_inv26 = "../../creusot-contracts/src/std/iter/map_inv.rs" 127 12 132 88
  let%span smap_inv27 = "../../creusot-contracts/src/std/iter/map_inv.rs" 117 12 119 63
  let%span smap_inv28 = "../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_I'0
  
  type t_F'0
  
  type t_Item'0
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_I'0; t_MapInv__func'0: t_F'0; t_MapInv__produced'0: Seq.seq t_Item'0 }
  
  predicate produces'1 [#"../../creusot-contracts/src/std/iter.rs" 36 4 36 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  
  function produces_trans'1 [#"../../creusot-contracts/src/std/iter.rs" 49 4 49 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter13] produces'1 a ab b)
   -> ([%#siter14] produces'1 b bc c)  -> ([%#siter15] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"../../creusot-contracts/src/std/iter.rs" 43 4 43 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#siter12] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate completed'1 [#"../../creusot-contracts/src/std/iter.rs" 39 4 39 36] (self : MutBorrow.t t_I'0)
  
  type tuple'0  =
    { _0'0: t_Item'0; _1'0: Seq.seq t_Item'0 }
  
  predicate precondition'0 [#"../../creusot-contracts/src/std/ops.rs" 82 4 82 45] (self : t_F'0) (args : tuple'0)
  
  predicate next_precondition'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 115 4 115 78] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv27] forall e : t_Item'0, i : t_I'0 . produces'1 iter (Seq.singleton e) i
     -> precondition'0 func { _0'0 = e; _1'0 = produced }
  
  type t_B'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : tuple'0) (result : t_B'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : tuple'0) (result_state : t_F'0) (result : t_B'0)
  
  
  function fn_mut_once'0 [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (self : t_F'0) (args : tuple'0) (res : t_B'0) : ()
  
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : tuple'0, res : t_B'0 . [%#sops22] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops19] unnest'0 self b)
   -> ([%#sops20] unnest'0 b c)  -> ([%#sops21] unnest'0 self c)
  
  function unnest_refl'0 [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops18] unnest'0 self self
  
  function postcondition_mut_unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (self : t_F'0) (args : tuple'0) (res_state : t_F'0) (res : t_B'0) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : tuple'0, res_state : t_F'0, res : t_B'0 . ([%#sops16] postcondition_mut'0 self args res_state res)
   -> ([%#sops17] unnest'0 self res_state)
  
  predicate preservation'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 138 4 138 49] (iter : t_I'0) (func : t_F'0)
  
   =
    [%#smap_inv28] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _0'0 = e1; _1'0 = s }
     -> postcondition_mut'0 f.current { _0'0 = e1; _1'0 = s } f.final b
     -> precondition'0 f.final { _0'0 = e2; _1'0 = Seq.snoc s e1 }
  
  predicate reinitialize'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 151 4 151 33]  =
    [%#smap_inv24] forall iter : MutBorrow.t t_I'0, func : t_F'0 . completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty : Seq.seq t_Item'0) /\ preservation'0 iter.final func
  
  predicate preservation_inv'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 125 4 125 73] (iter : t_I'0) (func : t_F'0) (produced : Seq.seq t_Item'0)
  
   =
    [%#smap_inv26] forall s : Seq.seq t_Item'0, e1 : t_Item'0, e2 : t_Item'0, f : MutBorrow.t t_F'0, b : t_B'0, i : t_I'0 . unnest'0 func f.current
     -> produces'1 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current { _0'0 = e1; _1'0 = Seq.(++) produced s }
     -> postcondition_mut'0 f.current { _0'0 = e1; _1'0 = Seq.(++) produced s } f.final b
     -> precondition'0 f.final { _0'0 = e2; _1'0 = Seq.snoc (Seq.(++) produced s) e1 }
  
  axiom preservation_inv'0_spec : forall iter : t_I'0, func : t_F'0, produced : Seq.seq t_Item'0 . [%#smap_inv25] produced
  = (Seq.empty : Seq.seq t_Item'0)  -> preservation_inv'0 iter func produced = preservation'0 iter func
  
  predicate invariant'1 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 72 4 72 30] (self : t_MapInv'0) =
    [%#smap_inv23] reinitialize'0
    /\ preservation_inv'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
    /\ next_precondition'0 self.t_MapInv__iter'0 self.t_MapInv__func'0 self.t_MapInv__produced'0
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_I'0)
  
  predicate inv'5 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_F'0)
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_MapInv'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_MapInv'0 [inv'3 x] . inv'3 x
  = (invariant'1 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> inv'4 iter /\ inv'5 func
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_MapInv'0) =
    [%#sinvariant11] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_MapInv'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_MapInv'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_B'0
  
  predicate produces'0 [@inline:trivial] [#"../../creusot-contracts/src/std/iter/map_inv.rs" 36 4 36 67] (self : t_MapInv'0) (visited : Seq.seq t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv4] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t t_F'0) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = Seq.length visited
    /\ produces'1 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                               _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) }
    /\ postcondition_mut'0 (Seq.get fs i).current { _0'0 = Seq.get s i;
                                                    _1'0 = Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 31 4 31 90] (a : t_MapInv'0) (ab : Seq.seq t_B'0) (b : t_MapInv'0) (bc : Seq.seq t_B'0) (c : t_MapInv'0) : ()
  
   =
    [%#smap_inv10] ()
  
  axiom produces_trans'0_spec : forall a : t_MapInv'0, ab : Seq.seq t_B'0, b : t_MapInv'0, bc : Seq.seq t_B'0, c : t_MapInv'0 . ([%#smap_inv7] produces'0 a ab b)
   -> ([%#smap_inv8] produces'0 b bc c)  -> ([%#smap_inv9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 24 4 24 26] (self : t_MapInv'0) : () =
    [%#smap_inv6] ()
  
  axiom produces_refl'0_spec : forall self : t_MapInv'0 . [%#smap_inv5] produces'0 self (Seq.empty : Seq.seq t_B'0) self
  
  predicate completed'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 14 4 14 35] (self : MutBorrow.t t_MapInv'0)
   =
    [%#smap_inv1] (self.final).t_MapInv__produced'0 = (Seq.empty : Seq.seq t_Item'0)
    /\ completed'1 (MutBorrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  predicate produces_one'0 [#"../../creusot-contracts/src/std/iter/map_inv.rs" 180 4 180 57] (self : t_MapInv'0) (visited : t_B'0) (succ : t_MapInv'0)
  
   =
    [%#smap_inv3] exists f : MutBorrow.t t_F'0, e : t_Item'0 . f.current = self.t_MapInv__func'0
    /\ f.final = succ.t_MapInv__func'0
    /\ produces'1 self.t_MapInv__iter'0 (Seq.singleton e) succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.snoc self.t_MapInv__produced'0 e
    /\ precondition'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 }
    /\ postcondition_mut'0 f.current { _0'0 = e; _1'0 = self.t_MapInv__produced'0 } f.final visited
  
  axiom produces_one'0_spec : forall self : t_MapInv'0, visited : t_B'0, succ : t_MapInv'0 . [%#smap_inv2] produces_one'0 self visited succ
  = produces'0 self (Seq.singleton visited) succ
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_B'0)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  goal refines : [%#smap_inv0] forall self : MutBorrow.t t_MapInv'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : t_Option'0 . match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces_one'0 self.current v self.final
    end
  /\ inv'1 result
   -> match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 63 4 63 31
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  goal refines : [%#srange0] forall self : t_Range'0 . forall result : () . produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi9685214752154132849__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95] (* <std::ops::Range<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 70 4 70 95
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 52 12 56 68
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_Range'0  =
    { t_Range__start'0: t_Idx'0; t_Range__end'0: t_Idx'0 }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 50 4 50 69] (self : t_Range'0) (visited : Seq.seq t_Idx'0) (o : t_Range'0)
  
   =
    [%#srange1] self.t_Range__start'0 = o.t_Range__start'0
    /\ deep_model'0 self.t_Range__end'0 >= deep_model'0 o.t_Range__end'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__end'0 >= deep_model'0 o.t_Range__start'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__end'0 - deep_model'0 self.t_Range__end'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__end'0 - i)
  
  goal refines : [%#srange0] forall a : t_Range'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_Range'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_Range'0 . produces_back'0 b bc c
  /\ produces_back'0 a ab b
   -> produces_back'0 b bc c
  /\ produces_back'0 a ab b
  /\ (forall result : () . produces_back'0 a (Seq.(++) ab bc) c  -> produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_refl__refines [#"../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 135 4 135 31
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  goal refines : [%#srange0] forall self : t_RangeInclusive'0 . forall result : () . produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
   -> produces_back'0 self (Seq.empty : Seq.seq t_Idx'0) self
end
module M_creusot_contracts__stdqy35z1__iter__range__qyi12388694168379144585__produces_back_trans__refines [#"../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95] (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIterator> *)
  let%span srange0 = "../../creusot-contracts/src/std/iter/range.rs" 142 4 142 95
  let%span srange1 = "../../creusot-contracts/src/std/iter/range.rs" 124 12 128 74
  let%span srange2 = "../../creusot-contracts/src/std/iter/range.rs" 75 10 75 43
  let%span srange3 = "../../creusot-contracts/src/std/iter/range.rs" 78 8 79 74
  let%span sops4 = "../../creusot-contracts/src/std/ops.rs" 212 14 212 86
  
  use seq.Seq
  use mach.int.Int
  
  type t_Idx'0
  
  type t_RangeInclusive'0  =
    { t_RangeInclusive__start'0: t_Idx'0; t_RangeInclusive__end'0: t_Idx'0; t_RangeInclusive__exhausted'0: bool }
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 27 4 27 45] (self : t_Idx'0) : int
  
  function start_log'0 [#"../../creusot-contracts/src/std/ops.rs" 200 4 200 29] (self : t_RangeInclusive'0) : t_Idx'0
  
  function end_log'0 [#"../../creusot-contracts/src/std/ops.rs" 206 4 206 27] (self : t_RangeInclusive'0) : t_Idx'0
  
  function is_empty_log'0 [#"../../creusot-contracts/src/std/ops.rs" 213 4 216 35] (self : t_RangeInclusive'0) : bool
  
  axiom is_empty_log'0_spec : forall self : t_RangeInclusive'0 . [%#sops4] not is_empty_log'0 self
   -> deep_model'0 (start_log'0 self) <= deep_model'0 (end_log'0 self)
  
  function range_inclusive_len'0 [#"../../creusot-contracts/src/std/iter/range.rs" 76 0 76 92] (r : t_RangeInclusive'0) : int
  
   =
    [%#srange3] if is_empty_log'0 r then 0 else deep_model'0 (end_log'0 r) - deep_model'0 (start_log'0 r) + 1
  
  axiom range_inclusive_len'0_spec : forall r : t_RangeInclusive'0 . [%#srange2] is_empty_log'0 r
  = (range_inclusive_len'0 r = 0)
  
  predicate produces_back'0 [#"../../creusot-contracts/src/std/iter/range.rs" 122 4 122 69] (self : t_RangeInclusive'0) (visited : Seq.seq t_Idx'0) (o : t_RangeInclusive'0)
  
   =
    [%#srange1] Seq.length visited = range_inclusive_len'0 self - range_inclusive_len'0 o
    /\ (is_empty_log'0 self  -> is_empty_log'0 o)
    /\ (is_empty_log'0 o \/ start_log'0 self = start_log'0 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 (end_log'0 self) - i)
  
  goal refines : [%#srange0] forall a : t_RangeInclusive'0 . forall ab : Seq.seq t_Idx'0 . forall b : t_RangeInclusive'0 . forall bc : Seq.seq t_Idx'0 . forall c : t_RangeInclusive'0 . produces_back'0 b bc c
  /\ produces_back'0 a ab b
   -> produces_back'0 b bc c
  /\ produces_back'0 a ab b
  /\ (forall result : () . produces_back'0 a (Seq.(++) ab bc) c  -> produces_back'0 a (Seq.(++) ab bc) c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__unnest_trans__refines [#"../../creusot-contracts/src/std/ops.rs" 129 4 129 43] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 129 4 129 43
  
  type t_F'0
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall b : t_F'0 . forall c : t_F'0 . unnest'0 b c /\ unnest'0 self b
   -> unnest'0 b c /\ unnest'0 self b /\ (forall result : () . unnest'0 self c  -> unnest'0 self c)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__unnest_refl__refines [#"../../creusot-contracts/src/std/ops.rs" 122 4 122 24] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 122 4 122 24
  
  type t_F'0
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall result : () . unnest'0 self self  -> unnest'0 self self
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__fn_mut_once__refines [#"../../creusot-contracts/src/std/ops.rs" 135 4 135 55] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 135 4 135 55
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
   -> postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi67194259310281437__postcondition_mut_unnest__refines [#"../../creusot-contracts/src/std/ops.rs" 117 4 117 85] (* <F as std::ops::FnMutExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 117 4 117 85
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
  
  
  predicate unnest'0 [#"../../creusot-contracts/src/std/ops.rs" 109 4 109 36] (self : t_F'0) (_2 : t_F'0)
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res_state : t_F'0 . forall res : t_Output'0 . postcondition_mut'0 self args res_state res
   -> postcondition_mut'0 self args res_state res
  /\ (forall result : () . unnest'0 self res_state  -> unnest'0 self res_state)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_mut__refines [#"../../creusot-contracts/src/std/ops.rs" 151 4 151 67] (* <F as std::ops::FnExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 151 4 151 67
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_mut'0 [#"../../creusot-contracts/src/std/ops.rs" 101 4 101 92] (self : t_F'0) (args : t_Args'0) (result_state : t_F'0) (result : t_Output'0)
  
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 144 4 144 68] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res_state : t_F'0 . forall res : t_Output'0 . forall result : () . postcondition_mut'0 self args res_state res
  = (self = res_state /\ postcondition'0 self args res)
   -> postcondition_mut'0 self args res_state res = (self = res_state /\ postcondition'0 self args res)
end
module M_creusot_contracts__stdqy35z1__ops__qyi396835551462182716__fn_once__refines [#"../../creusot-contracts/src/std/ops.rs" 156 4 156 51] (* <F as std::ops::FnExt<Args>> *)
  let%span sops0 = "../../creusot-contracts/src/std/ops.rs" 156 4 156 51
  
  type t_F'0
  
  type t_Args'0
  
  type t_Output'0
  
  predicate postcondition_once'0 [#"../../creusot-contracts/src/std/ops.rs" 90 4 90 73] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  predicate resolve'0 [#"../../creusot-contracts/src/resolve.rs" 19 0 19 40] (_1 : t_F'0)
  
  predicate postcondition'0 [#"../../creusot-contracts/src/std/ops.rs" 144 4 144 68] (self : t_F'0) (args : t_Args'0) (result : t_Output'0)
  
  
  goal refines : [%#sops0] forall self : t_F'0 . forall args : t_Args'0 . forall res : t_Output'0 . forall result : () . postcondition_once'0 self args res
  = (resolve'0 self /\ postcondition'0 self args res)
   -> postcondition_once'0 self args res = (resolve'0 self /\ postcondition'0 self args res)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi12668724543816282100__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 81 4 81 34] (* <*const T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 81 4 81 34
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 74 4 74 30] (self : Opaque.ptr) : int
  
  goal refines : [%#sptr0] forall self : Opaque.ptr . forall result : bool . result = (addr_logic'0 self = 0)
   -> result = (addr_logic'0 self = 0)
end
module M_creusot_contracts__stdqy35z1__ptr__qyi13421408995332327298__is_null_logic__refines [#"../../creusot-contracts/src/std/ptr.rs" 97 4 97 34] (* <*mut T as std::ptr::PointerExt<T>> *)
  let%span sptr0 = "../../creusot-contracts/src/std/ptr.rs" 97 4 97 34
  
  use creusot.prelude.Opaque
  
  function addr_logic'0 [#"../../creusot-contracts/src/std/ptr.rs" 90 4 90 30] (self : Opaque.ptr) : int
  
  goal refines : [%#sptr0] forall self : Opaque.ptr . forall result : bool . result = (addr_logic'0 self = 0)
   -> result = (addr_logic'0 self = 0)
end
module M_creusot_contracts__ghost__qyi11517682701084838082__clone__refines [#"../../creusot-contracts/src/ghost.rs" 48 4 48 27] (* <ghost::Ghost<T> as std::clone::Clone> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 48 4 48 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost2 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost3] self.t_Ghost__0'0
  
  predicate invariant'1 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost2] inv'2 (inner_logic'0 self)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Ghost'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sghost0] forall self : t_Ghost'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_Ghost'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__fmap__qyi1775402764303793352__clone__refines [#"../../creusot-contracts/src/logic/fmap.rs" 476 4 476 27] (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  let%span sfmap0 = "../../creusot-contracts/src/logic/fmap.rs" 476 4 476 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap2 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap3 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap4 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap5 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil6 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil7 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use map.Map
  
  type t_FMap'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  function view'0 [#"../../creusot-contracts/src/logic/fmap.rs" 60 4 60 35] (self : t_FMap'0) : Map.map t_K'0 t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 103 4 103 55] (self : t_FMap'0) (k : t_K'0) : t_Option'0
  
   =
    [%#sfmap5] Map.get (view'0 self) k
  
  function contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 132 4 132 39] (self : t_FMap'0) (k : t_K'0) : bool
  
   =
    [%#sfmap3] get_unsized'0 self k <> C_None'0
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_K'0)
  
  predicate inv'4 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_V'0) =
    [%#sboxed9] inv'4 self
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_V'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_V'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  function unwrap'0 [#"../../creusot-contracts/src/util.rs" 57 0 57 36] (op : t_Option'0) : t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil6] op <> C_None'0)
   -> ([%#sutil7] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fmap.rs" 124 4 124 50] (self : t_FMap'0) (k : t_K'0) : t_V'0
  
   =
    [%#sfmap4] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'1 [#"../../creusot-contracts/src/logic/fmap.rs" 489 4 489 30] (self : t_FMap'0) =
    [%#sfmap2] forall k : t_K'0 . contains'0 self k  -> inv'2 k /\ inv'3 (lookup_unsized'0 self k)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FMap'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_FMap'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_FMap'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_FMap'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sfmap0] forall self : t_FMap'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_FMap'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__fset__qyi13324666171263681189__clone__refines [#"../../creusot-contracts/src/logic/fset.rs" 455 4 455 27] (* <logic::fset::FSet<T> as std::clone::Clone> *)
  let%span sfset0 = "../../creusot-contracts/src/logic/fset.rs" 455 4 455 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfset2 = "../../creusot-contracts/src/logic/fset.rs" 469 20 469 63
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use set.Fset
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] [#"../../creusot-contracts/src/logic/fset.rs" 46 4 46 39] (self : Fset.fset t_T'0) (e : t_T'0)
  
   =
    [%#sfset3] Fset.mem e self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'1 [#"../../creusot-contracts/src/logic/fset.rs" 468 4 468 30] (self : Fset.fset t_T'0) =
    [%#sfset2] forall x : t_T'0 . contains'0 self x  -> inv'2 x
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Fset.fset t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Fset.fset t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : Fset.fset t_T'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Fset.fset t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Fset.fset t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sfset0] forall self : Fset.fset t_T'0 . inv'0 self
   -> inv'0 self /\ (forall result : Fset.fset t_T'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__logic__int__qyi3540547019284611154__clone__refines [#"../../creusot-contracts/src/logic/int.rs" 33 4 33 27] (* <logic::int::Int as std::clone::Clone> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 33 4 33 27
  
  goal refines : [%#sint0] forall self : int . forall result : int . result = self  -> result = self
end
module M_creusot_contracts__logic__seq__qyi7164078029063507335__clone__refines [#"../../creusot-contracts/src/logic/seq.rs" 616 4 616 27] (* <logic::seq::Seq<T> as std::clone::Clone> *)
  let%span sseq0 = "../../creusot-contracts/src/logic/seq.rs" 616 4 616 27
  let%span sinvariant1 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sseq2 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed3 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use seq.Seq
  use mach.int.Int
  
  type t_T'0
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  predicate invariant'2 [#"../../creusot-contracts/src/std/boxed.rs" 32 4 32 30] (self : t_T'0) =
    [%#sboxed3] inv'3 self
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/logic/seq.rs" 628 4 628 30] (self : Seq.seq t_T'0) =
    [%#sseq2] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'2 (Seq.get self i)
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : Seq.seq t_T'0) =
    [%#sinvariant1] inv'1 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Seq.seq t_T'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  goal refines : [%#sseq0] forall self : Seq.seq t_T'0 . inv'0 self
   -> inv'0 self /\ (forall result : Seq.seq t_T'0 . result = self /\ inv'1 result  -> result = self /\ inv'1 result)
end
module M_creusot_contracts__pcell__qyi11656593191764906533__clone__refines [#"../../creusot-contracts/src/pcell.rs" 34 4 34 27] (* <pcell::Id as std::clone::Clone> *)
  let%span spcell0 = "../../creusot-contracts/src/pcell.rs" 34 4 34 27
  
  type t_Id'0
  
  goal refines : [%#spcell0] forall self : t_Id'0 . forall result : t_Id'0 . result = self  -> result = self
end
module M_creusot_contracts__peano__qyi18263836234684628832__clone__refines [#"../../creusot-contracts/src/peano.rs" 35 9 35 14] (* <peano::PeanoInt as std::clone::Clone> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 35 9 35 14
  
  use creusot.int.UInt64
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  goal refines : [%#speano0] forall self : t_PeanoInt'0 . forall result : t_PeanoInt'0 . result = self  -> result = self
end
module M_creusot_contracts__snapshot__qyi17576604998327728858__clone__refines [#"../../creusot-contracts/src/snapshot.rs" 57 4 57 27] (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  let%span ssnapshot0 = "../../creusot-contracts/src/snapshot.rs" 57 4 57 27
  
  type t_T'0
  
  goal refines : [%#ssnapshot0] forall self : t_T'0 . forall result : t_T'0 . result = self  -> result = self
end
module M_creusot_contracts__ghost__qyi17169751950936808565__deref__refines [#"../../creusot-contracts/src/ghost.rs" 67 4 67 36] (* <ghost::Ghost<T> as std::ops::Deref> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 67 4 67 36
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost1] self.t_Ghost__0'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost3] inv'3 (inner_logic'0 self)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_Ghost'0) =
    [%#sinvariant2] inv'2 self
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 24 4 24 30] (self : t_T'0) =
    [%#sinvariant2] inv'3 self
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  goal refines : [%#sghost0] forall self : t_Ghost'0 . inv'0 self
   -> inv'0 self /\ (forall result : t_T'0 . inner_logic'0 self = result /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__ghost__qyi16054780730576886888__deref_mut__refines [#"../../creusot-contracts/src/ghost.rs" 84 4 84 48] (* <ghost::Ghost<T> as std::ops::DerefMut> *)
  let%span sghost0 = "../../creusot-contracts/src/ghost.rs" 84 4 84 48
  let%span sghost1 = "../../creusot-contracts/src/ghost.rs" 234 8 234 14
  let%span sinvariant2 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sghost3 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  
  use creusot.prelude.MutBorrow
  
  type t_T'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_T'0 }
  
  predicate inv'3 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_T'0)
  
  function inner_logic'0 [#"../../creusot-contracts/src/ghost.rs" 233 4 233 33] (self : t_Ghost'0) : t_T'0 =
    [%#sghost1] self.t_Ghost__0'0
  
  predicate invariant'2 [#"../../creusot-contracts/src/ghost.rs" 108 4 108 30] (self : t_Ghost'0) =
    [%#sghost3] inv'3 (inner_logic'0 self)
  
  predicate inv'2 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate invariant'0 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_Ghost'0) =
    [%#sinvariant2] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'0 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Ghost'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate invariant'1 [#"../../creusot-contracts/src/invariant.rs" 34 4 34 30] (self : MutBorrow.t t_T'0) =
    [%#sinvariant2] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'1 [#"../../creusot-contracts/src/invariant.rs" 42 0 42 35] (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  goal refines : [%#sghost0] forall self : MutBorrow.t t_Ghost'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : MutBorrow.t t_T'0 . result.final = inner_logic'0 self.final
  /\ result.current = inner_logic'0 self.current /\ inv'1 result  -> inv'1 result)
end
module M_creusot_contracts__logic__int__qyi8495612394334423323__eq__refines [#"../../creusot-contracts/src/logic/int.rs" 238 4 238 38] (* <logic::int::Int as std::cmp::PartialEq> *)
  let%span sint0 = "../../creusot-contracts/src/logic/int.rs" 238 4 238 38
  let%span smodel1 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel2 = "../../creusot-contracts/src/model.rs" 92 8 92 12
  
  function deep_model'1 [#"../../creusot-contracts/src/model.rs" 91 4 91 44] (self : int) : int =
    [%#smodel2] self
  
  function deep_model'0 [#"../../creusot-contracts/src/model.rs" 44 4 44 44] (self : int) : int =
    [%#smodel1] deep_model'1 self
  
  goal refines : [%#sint0] forall self : int . forall other : int . forall result : bool . result = (self = other)
   -> result = (deep_model'0 self = deep_model'0 other)
end
module M_creusot_contracts__peano__qyi17635635094782400840__default__refines [#"../../creusot-contracts/src/peano.rs" 35 22 35 29] (* <peano::PeanoInt as std::default::Default> *)
  let%span speano0 = "../../creusot-contracts/src/peano.rs" 35 22 35 29
  let%span snum1 = "../../creusot-contracts/src/std/num.rs" 33 28 33 41
  
  use creusot.int.UInt64
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  predicate is_default'1 [#"../../creusot-contracts/src/std/num.rs" 32 12 32 39] (self : UInt64.t) =
    [%#snum1] self = (0 : UInt64.t)
  
  predicate is_default'0 [#"../../creusot-contracts/src/peano.rs" 35 22 35 29] (self : t_PeanoInt'0) =
    [%#speano0] true /\ is_default'1 self.t_PeanoInt__0'0
  
  goal refines : [%#speano0] forall result : t_PeanoInt'0 . is_default'0 result  -> is_default'0 result
end
