module M_bitwalker__peek_bit_u8 [#"bitwalker.rs" 9 0 9 42]
  let%span sbitwalker0 = "bitwalker.rs" 10 27 10 33
  let%span sbitwalker1 = "bitwalker.rs" 10 19 10 22
  let%span sbitwalker2 = "bitwalker.rs" 11 18 11 19
  let%span sbitwalker3 = "bitwalker.rs" 8 11 8 24
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord17] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord14] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord12] cmp_log'0 x y = C_Less'0)
   -> ([%#sord13] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord9] cmp_log'0 x y = o)
   -> ([%#sord10] cmp_log'0 y z = o)  -> ([%#sord11] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord8] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord7] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord6] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord5] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord4] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
  
  meta "compute_max_steps" 1000000
  
  let rec peek_bit_u8'0[#"bitwalker.rs" 9 0 9 42] (x:UInt8.t) (left:UInt64.t) (return'  (ret:bool))= {[@expl:peek_bit_u8 requires] [%#sbitwalker3] UInt64.lt left (8 : UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker0] (7 : UInt64.t)} {left} (fun (_ret':UInt64.t) ->  [ &_5 <- _ret' ] s1)
      | s1 = UInt8.shl {[%#sbitwalker1] (1 : UInt8.t)} {UInt64.t'int _5} (fun (_ret':UInt8.t) ->  [ &mask <- _ret' ] s2)
      | s2 =  [ &_7 <- UInt8.bw_and x mask ] s3
      | s3 =  [ &_0 <- _7 <> ([%#sbitwalker2] (0 : UInt8.t)) ] s4
      | s4 = return' {_0} ]
     ]
    )
    [ & _0 : bool = Any.any_l ()
    | & x : UInt8.t = x
    | & left : UInt64.t = left
    | & mask : UInt8.t = Any.any_l ()
    | & _5 : UInt64.t = Any.any_l ()
    | & _7 : UInt8.t = Any.any_l () ]
     [ return' (result:bool)-> (! return' {result}) ] 
end
module M_bitwalker__peek_bit_array8 [#"bitwalker.rs" 15 0 15 52]
  let%span sbitwalker0 = "bitwalker.rs" 16 26 16 27
  let%span sbitwalker1 = "bitwalker.rs" 16 19 16 27
  let%span sbitwalker2 = "bitwalker.rs" 17 42 17 43
  let%span sbitwalker3 = "bitwalker.rs" 17 35 17 43
  let%span sbitwalker4 = "bitwalker.rs" 19 20 19 25
  let%span sbitwalker5 = "bitwalker.rs" 20 12 20 17
  let%span sbitwalker6 = "bitwalker.rs" 19 12 19 26
  let%span sbitwalker7 = "bitwalker.rs" 14 11 14 34
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 263 18 263 100
  let%span sslice9 = "../../../creusot-contracts/src/std/slice.rs" 264 18 264 55
  let%span sbitwalker10 = "bitwalker.rs" 8 11 8 24
  let%span smodel11 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 123 20 123 37
  let%span sslice13 = "../../../creusot-contracts/src/std/slice.rs" 130 20 130 37
  let%span sslice14 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice15 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt8
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 UInt8.t
  
  predicate inv'0 (_1 : Slice64.slice UInt8.t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Slice64.slice UInt8.t [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : UInt64.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : UInt64.t [inv'1 x] . inv'1 x = true
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x = true
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  use seq.Seq
  
  use mach.int.Int
  
  predicate in_bounds'0 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq UInt8.t) =
    [%#sslice12] UInt64.t'int self < Seq.length seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.slice.Slice64
  
  function view'1 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t
  
  axiom view'1_spec : forall self : Slice64.slice UInt8.t . ([%#sslice14] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice15] view'1 self = Slice64.id self)
  
  function view'0 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t =
    [%#smodel11] view'1 self
  
  use seq.Seq
  
  predicate has_value'0 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq UInt8.t) (out : UInt8.t) =
    [%#sslice13] Seq.get seq (UInt64.t'int self) = out
  
  let rec get'0 (self:Slice64.slice UInt8.t) (index:UInt64.t) (return'  (ret:t_Option'0))= {[@expl:get 'self' type invariant] inv'0 self}
    {[@expl:get 'index' type invariant] inv'1 index}
    any
    [ return' (result:t_Option'0)-> {inv'2 result}
      {[%#sslice8] in_bounds'0 index (view'0 self)
       -> (exists r : UInt8.t . result = C_Some'0 r /\ has_value'0 index (view'0 self) r)}
      {[%#sslice9] in_bounds'0 index (view'0 self) \/ result = C_None'0}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:UInt8.t))= any
    [ good (field_0:UInt8.t)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : UInt8.t [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord29] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord28] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord26] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord27] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord24] cmp_log'0 x y = C_Less'0)
   -> ([%#sord25] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord21] cmp_log'0 x y
  = o)  -> ([%#sord22] cmp_log'0 y z = o)  -> ([%#sord23] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord20] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord19] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord18] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord17] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec peek_bit_u8'0 (x:UInt8.t) (left:UInt64.t) (return'  (ret:bool))= {[@expl:peek_bit_u8 requires] [%#sbitwalker10] UInt64.lt left (8 : UInt64.t)}
    any [ return' (result:bool)-> (! return' {result}) ] 
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec peek_bit_array8'0[#"bitwalker.rs" 15 0 15 52] (addr:Slice64.slice UInt8.t) (left:UInt64.t) (return'  (ret:bool))= {[@expl:peek_bit_array8 requires] [%#sbitwalker7] UInt64.t'int left
    < 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_8 <- ([%#sbitwalker0] (8 : UInt64.t)) = ([%#sbitwalker1] (0 : UInt64.t)) ] s1
      | s1 = {[@expl:division by zero] [%#sbitwalker1] not _8} s2
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = UInt64.div {left} {[%#sbitwalker0] (8 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_6 <- _ret' ] s1)
      | s1 = get'0 {addr} {_6} (fun (_ret':t_Option'0) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = C_None'0} (! bb5) | br1 (x0:UInt8.t)-> {_4 = C_Some'0 x0} (! bb4) ] 
    | bb4 = bb6
    | bb6 = s0
      [ s0 = v_Some'0 {_4} (fun (r0'0:UInt8.t) ->  [ &v <- r0'0 ] s1)
      | s1 =  [ &_14 <- ([%#sbitwalker2] (8 : UInt64.t)) = ([%#sbitwalker3] (0 : UInt64.t)) ] s2
      | s2 = {[@expl:remainder by zero] [%#sbitwalker3] not _14} s3
      | s3 = bb7 ]
    
    | bb7 = s0
      [ s0 = UInt64.rem {left} {[%#sbitwalker2] (8 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_12 <- _ret' ] s1)
      | s1 = peek_bit_u8'0 {v} {_12} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = bb11
    | bb5 = any [ br0 -> {([%#sbitwalker4] false) = false} (! bb9) | br1 -> {[%#sbitwalker4] false} (! bb10) ] 
    | bb10 = s0 [ s0 =  [ &_0 <- [%#sbitwalker5] false ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0}
    | bb9 = {[%#sbitwalker6] false} any ]
    )
    [ & _0 : bool = Any.any_l ()
    | & addr : Slice64.slice UInt8.t = addr
    | & left : UInt64.t = left
    | & _4 : t_Option'0 = Any.any_l ()
    | & _6 : UInt64.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & v : UInt8.t = Any.any_l ()
    | & _12 : UInt64.t = Any.any_l ()
    | & _14 : bool = Any.any_l () ]
     [ return' (result:bool)-> (! return' {result}) ] 
end
module M_bitwalker__poke_bit_64 [#"bitwalker.rs" 28 0 28 58]
  let%span sbitwalker0 = "bitwalker.rs" 29 29 29 36
  let%span sbitwalker1 = "bitwalker.rs" 29 20 29 24
  let%span sbitwalker2 = "bitwalker.rs" 27 11 27 25
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord16] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord13] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord11] cmp_log'0 x y = C_Less'0)
   -> ([%#sord12] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord8] cmp_log'0 x y = o)
   -> ([%#sord9] cmp_log'0 y z = o)  -> ([%#sord10] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord7] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord6] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord5] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord4] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord3] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
  
  meta "compute_max_steps" 1000000
  
  let rec poke_bit_64'0[#"bitwalker.rs" 28 0 28 58] (value:UInt64.t) (left:UInt64.t) (flag:bool) (return'  (ret:UInt64.t))= {[@expl:poke_bit_64 requires] [%#sbitwalker2] UInt64.lt left (64 : UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker0] (63 : UInt64.t)} {left} (fun (_ret':UInt64.t) ->  [ &_6 <- _ret' ] s1)
      | s1 = UInt64.shl {[%#sbitwalker1] (1 : UInt64.t)} {UInt64.t'int _6}
          (fun (_ret':UInt64.t) ->  [ &mask <- _ret' ] s2)
      | s2 = any [ br0 -> {flag = false} (! bb2) | br1 -> {flag} (! bb1) ]  ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- UInt64.bw_or value mask ] s1 | s1 = bb3 ] 
    | bb2 = s0 [ s0 =  [ &_14 <- UInt64.bw_not mask ] s1 | s1 =  [ &_0 <- UInt64.bw_and value _14 ] s2 | s2 = bb3 ] 
    | bb3 = return' {_0} ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & value : UInt64.t = value
    | & left : UInt64.t = left
    | & flag : bool = flag
    | & mask : UInt64.t = Any.any_l ()
    | & _6 : UInt64.t = Any.any_l ()
    | & _14 : UInt64.t = Any.any_l () ]
     [ return' (result:UInt64.t)-> (! return' {result}) ] 
end
module M_bitwalker__peek [#"bitwalker.rs" 44 0 44 56]
  let%span sbitwalker0 = "bitwalker.rs" 45 26 45 27
  let%span sbitwalker1 = "bitwalker.rs" 48 26 48 27
  let%span sbitwalker2 = "bitwalker.rs" 49 23 49 24
  let%span sbitwalker3 = "bitwalker.rs" 52 37 52 44
  let%span sbitwalker4 = "bitwalker.rs" 53 13 53 14
  let%span sbitwalker5 = "bitwalker.rs" 41 11 41 33
  let%span sbitwalker6 = "bitwalker.rs" 42 11 42 28
  let%span sbitwalker7 = "bitwalker.rs" 43 11 43 46
  let%span sslice8 = "../../../creusot-contracts/src/std/slice.rs" 254 18 254 40
  let%span sbitwalker9 = "bitwalker.rs" 14 11 14 34
  let%span sbitwalker10 = "bitwalker.rs" 27 11 27 25
  let%span smodel11 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice13 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt8
  
  predicate inv'0 (_1 : Slice64.slice UInt8.t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Slice64.slice UInt8.t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'1 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t
  
  axiom view'1_spec : forall self : Slice64.slice UInt8.t . ([%#sslice12] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice13] view'1 self = Slice64.id self)
  
  function view'0 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t =
    [%#smodel11] view'1 self
  
  let rec len'0 (self:Slice64.slice UInt8.t) (return'  (ret:UInt64.t))= {[@expl:len 'self' type invariant] inv'0 self}
    any
    [ return' (result:UInt64.t)-> {[%#sslice8] Seq.length (view'0 self) = UInt64.t'int result} (! return' {result}) ]
  
  
  let rec peek_bit_array8'0 (addr:Slice64.slice UInt8.t) (left:UInt64.t) (return'  (ret:bool))= {[@expl:peek_bit_array8 requires] [%#sbitwalker9] UInt64.t'int left
    < 8 * Seq.length (view'0 addr)}
    any [ return' (result:bool)-> (! return' {result}) ] 
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord27] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord26] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord24] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord25] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord22] cmp_log'0 x y = C_Less'0)
   -> ([%#sord23] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord19] cmp_log'0 x y
  = o)  -> ([%#sord20] cmp_log'0 y z = o)  -> ([%#sord21] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord18] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord17] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord14] UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec poke_bit_64'0 (value:UInt64.t) (left:UInt64.t) (flag:bool) (return'  (ret:UInt64.t))= {[@expl:poke_bit_64 requires] [%#sbitwalker10] UInt64.lt left (64 : UInt64.t)}
    any [ return' (result:UInt64.t)-> (! return' {result}) ] 
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec peek'0[#"bitwalker.rs" 44 0 44 56] (start:UInt64.t) (length:UInt64.t) (addr:Slice64.slice UInt8.t) (return'  (ret:UInt64.t))= {[@expl:peek requires #0] [%#sbitwalker5] Seq.length (view'0 addr)
    < 10000000}
    {[@expl:peek requires #1] [%#sbitwalker6] UInt64.le length (64 : UInt64.t)}
    {[@expl:peek requires #2] [%#sbitwalker7] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {start} {length} (fun (_ret':UInt64.t) ->  [ &_10 <- _ret' ] s1)
      | s1 = len'0 {addr} (fun (_ret':UInt64.t) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = UInt64.mul {[%#sbitwalker0] (8 : UInt64.t)} {_14} (fun (_ret':UInt64.t) ->  [ &_13 <- _ret' ] s1)
      | s1 =  [ &_9 <- UInt64.gt _10 _13 ] s2
      | s2 = any [ br0 -> {_9 = false} (! bb3) | br1 -> {_9} (! bb2) ]  ]
    
    | bb2 = {false} any
    | bb3 = s0
      [ s0 =  [ &retval <- [%#sbitwalker1] (0 : UInt64.t) ] s1
      | s1 =  [ &i <- [%#sbitwalker2] (0 : UInt64.t) ] s2
      | s2 = bb4 ]
    
    | bb4 = bb4
      [ bb4 = (! bb5)
        [ bb5 = s0
          [ s0 =  [ &_21 <- UInt64.lt i length ] s1
          | s1 = any [ br0 -> {_21 = false} (! bb9) | br1 -> {_21} (! bb6) ]  ]
        
        | bb6 = s0
          [ s0 = UInt64.add {start} {i} (fun (_ret':UInt64.t) ->  [ &_26 <- _ret' ] s1)
          | s1 = peek_bit_array8'0 {addr} {_26} (fun (_ret':bool) ->  [ &flag <- _ret' ] s2)
          | s2 = bb7 ]
        
        | bb7 = s0
          [ s0 = UInt64.sub {length} {i} (fun (_ret':UInt64.t) ->  [ &_32 <- _ret' ] s1)
          | s1 = UInt64.sub {[%#sbitwalker3] (64 : UInt64.t)} {_32} (fun (_ret':UInt64.t) ->  [ &_31 <- _ret' ] s2)
          | s2 = poke_bit_64'0 {retval} {_31} {flag} (fun (_ret':UInt64.t) ->  [ &_29 <- _ret' ] s3)
          | s3 = bb8 ]
        
        | bb8 = s0
          [ s0 =  [ &retval <- _29 ] s1
          | s1 = UInt64.add {i} {[%#sbitwalker4] (1 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
         ]
       ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- retval ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & start : UInt64.t = start
    | & length : UInt64.t = length
    | & addr : Slice64.slice UInt8.t = addr
    | & _9 : bool = Any.any_l ()
    | & _10 : UInt64.t = Any.any_l ()
    | & _13 : UInt64.t = Any.any_l ()
    | & _14 : UInt64.t = Any.any_l ()
    | & retval : UInt64.t = Any.any_l ()
    | & i : UInt64.t = Any.any_l ()
    | & _21 : bool = Any.any_l ()
    | & flag : bool = Any.any_l ()
    | & _26 : UInt64.t = Any.any_l ()
    | & _29 : UInt64.t = Any.any_l ()
    | & _31 : UInt64.t = Any.any_l ()
    | & _32 : UInt64.t = Any.any_l () ]
     [ return' (result:UInt64.t)-> (! return' {result}) ] 
end
module M_bitwalker__peek_64bit [#"bitwalker.rs" 63 0 63 46]
  let%span sbitwalker0 = "bitwalker.rs" 64 29 64 36
  let%span sbitwalker1 = "bitwalker.rs" 64 20 64 24
  let%span sbitwalker2 = "bitwalker.rs" 65 22 65 23
  let%span sbitwalker3 = "bitwalker.rs" 62 11 62 25
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord17] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord14] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord15] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord12] cmp_log'0 x y = C_Less'0)
   -> ([%#sord13] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord9] cmp_log'0 x y = o)
   -> ([%#sord10] cmp_log'0 y z = o)  -> ([%#sord11] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord8] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord7] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord6] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord5] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord4] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
  
  meta "compute_max_steps" 1000000
  
  let rec peek_64bit'0[#"bitwalker.rs" 63 0 63 46] (value:UInt64.t) (left:UInt64.t) (return'  (ret:bool))= {[@expl:peek_64bit requires] [%#sbitwalker3] UInt64.lt left (64 : UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker0] (63 : UInt64.t)} {left} (fun (_ret':UInt64.t) ->  [ &_5 <- _ret' ] s1)
      | s1 = UInt64.shl {[%#sbitwalker1] (1 : UInt64.t)} {UInt64.t'int _5}
          (fun (_ret':UInt64.t) ->  [ &mask <- _ret' ] s2)
      | s2 =  [ &_7 <- UInt64.bw_and value mask ] s3
      | s3 =  [ &_0 <- _7 <> ([%#sbitwalker2] (0 : UInt64.t)) ] s4
      | s4 = return' {_0} ]
     ]
    )
    [ & _0 : bool = Any.any_l ()
    | & value : UInt64.t = value
    | & left : UInt64.t = left
    | & mask : UInt64.t = Any.any_l ()
    | & _5 : UInt64.t = Any.any_l ()
    | & _7 : UInt64.t = Any.any_l () ]
     [ return' (result:bool)-> (! return' {result}) ] 
end
module M_bitwalker__poke_8bit [#"bitwalker.rs" 69 0 69 53]
  let%span sbitwalker0 = "bitwalker.rs" 70 23 70 29
  let%span sbitwalker1 = "bitwalker.rs" 70 15 70 18
  let%span sbitwalker2 = "bitwalker.rs" 68 11 68 24
  let%span sord3 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord4 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord5 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord6 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord7 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord8 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord9 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord10 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord11 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord12 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord16] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord13] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord14] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord11] cmp_log'0 x y = C_Less'0)
   -> ([%#sord12] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord8] cmp_log'0 x y = o)
   -> ([%#sord9] cmp_log'0 y z = o)  -> ([%#sord10] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord7] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord6] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord5] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord4] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord3] UInt64.le x y = (cmp_log'0 x y <> C_Greater'0)
  
  meta "compute_max_steps" 1000000
  
  let rec poke_8bit'0[#"bitwalker.rs" 69 0 69 53] (byte:UInt8.t) (left:UInt64.t) (flag:bool) (return'  (ret:UInt8.t))= {[@expl:poke_8bit requires] [%#sbitwalker2] UInt64.lt left (8 : UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.sub {[%#sbitwalker0] (7 : UInt64.t)} {left} (fun (_ret':UInt64.t) ->  [ &_6 <- _ret' ] s1)
      | s1 = UInt8.shl {[%#sbitwalker1] (1 : UInt8.t)} {UInt64.t'int _6} (fun (_ret':UInt8.t) ->  [ &mask <- _ret' ] s2)
      | s2 = any [ br0 -> {flag = false} (! bb2) | br1 -> {flag} (! bb1) ]  ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- UInt8.bw_or byte mask ] s1 | s1 = bb3 ] 
    | bb2 = s0 [ s0 =  [ &_14 <- UInt8.bw_not mask ] s1 | s1 =  [ &_0 <- UInt8.bw_and byte _14 ] s2 | s2 = bb3 ] 
    | bb3 = return' {_0} ]
    )
    [ & _0 : UInt8.t = Any.any_l ()
    | & byte : UInt8.t = byte
    | & left : UInt64.t = left
    | & flag : bool = flag
    | & mask : UInt8.t = Any.any_l ()
    | & _6 : UInt64.t = Any.any_l ()
    | & _14 : UInt8.t = Any.any_l () ]
     [ return' (result:UInt8.t)-> (! return' {result}) ] 
end
module M_bitwalker__poke_8bit_array [#"bitwalker.rs" 80 0 80 60]
  let%span sbitwalker0 = "bitwalker.rs" 81 26 81 27
  let%span sbitwalker1 = "bitwalker.rs" 81 19 81 27
  let%span sbitwalker2 = "bitwalker.rs" 82 26 82 27
  let%span sbitwalker3 = "bitwalker.rs" 82 19 82 27
  let%span sbitwalker4 = "bitwalker.rs" 83 24 83 31
  let%span sbitwalker5 = "bitwalker.rs" 83 4 83 11
  let%span sbitwalker6 = "bitwalker.rs" 78 11 78 34
  let%span sbitwalker7 = "bitwalker.rs" 79 10 79 39
  let%span sbitwalker8 = "bitwalker.rs" 68 11 68 24
  let%span smodel9 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice11 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sresolve12 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sord13 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord14 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.prelude.Opaque
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt8
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord26] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord25] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord23] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord24] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord21] cmp_log'0 x y = C_Less'0)
   -> ([%#sord22] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord18] cmp_log'0 x y
  = o)  -> ([%#sord19] cmp_log'0 y z = o)  -> ([%#sord20] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord17] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord14] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord13] UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec poke_8bit'0 (byte:UInt8.t) (left:UInt64.t) (flag:bool) (return'  (ret:UInt8.t))= {[@expl:poke_8bit requires] [%#sbitwalker8] UInt64.lt left (8 : UInt64.t)}
    any [ return' (result:UInt8.t)-> (! return' {result}) ] 
  
  use creusot.prelude.MutBorrow
  
  predicate resolve'1 (self : MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve12] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t (Slice64.slice UInt8.t)) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use seq.Seq
  
  use seq.Seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'1 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t
  
  axiom view'1_spec : forall self : Slice64.slice UInt8.t . ([%#sslice10] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice11] view'1 self = Slice64.id self)
  
  function view'0 (self : MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    [%#smodel9] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec poke_8bit_array'0[#"bitwalker.rs" 80 0 80 60] (addr:MutBorrow.t (Slice64.slice UInt8.t)) (left:UInt64.t) (flag:bool) (return'  (ret:()))= {[@expl:poke_8bit_array requires] [%#sbitwalker6] UInt64.t'int left
    < 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_8 <- ([%#sbitwalker0] (8 : UInt64.t)) = ([%#sbitwalker1] (0 : UInt64.t)) ] s1
      | s1 = {[@expl:division by zero] [%#sbitwalker1] not _8} s2
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = UInt64.div {left} {[%#sbitwalker0] (8 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &i <- _ret' ] s1)
      | s1 =  [ &_11 <- ([%#sbitwalker2] (8 : UInt64.t)) = ([%#sbitwalker3] (0 : UInt64.t)) ] s2
      | s2 = {[@expl:remainder by zero] [%#sbitwalker3] not _11} s3
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = UInt64.rem {left} {[%#sbitwalker2] (8 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &k <- _ret' ] s1)
      | s1 =  [ &_14 <- i ] s2
      | s2 = Opaque.fresh_ptr 
          (fun (_ptr:Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr.current}-  [ &_15 <- _ptr ] s3)
      | s3 =  [ &_16 <- Slice64.slice_ptr_len _15 ] s4
      | s4 =  [ &_17 <- UInt64.lt _14 _16 ] s5
      | s5 = {[@expl:index in bounds] [%#sbitwalker4] _17} s6
      | s6 = bb3 ]
    
    | bb3 = s0
      [ s0 = Slice64.get <UInt8.t> {addr.current} {_14}
          (fun (r'0:UInt8.t) -> poke_8bit'0 {r'0} {k} {flag} (fun (_ret':UInt8.t) ->  [ &_12 <- _ret' ] s1))
      | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_20 <- i ] s1
      | s1 = Opaque.fresh_ptr 
          (fun (_ptr:Opaque.ptr) -> -{Slice64.slice_ptr_len _ptr = Slice64.length addr.current}-  [ &_21 <- _ptr ] s2)
      | s2 =  [ &_22 <- Slice64.slice_ptr_len _21 ] s3
      | s3 =  [ &_23 <- UInt64.lt _20 _22 ] s4
      | s4 = {[@expl:index in bounds] [%#sbitwalker5] _23} s5
      | s5 = bb5 ]
    
    | bb5 = s0
      [ s0 = Slice64.set <UInt8.t> {addr.current} {_20} {_12}
          (fun (r'0:Slice64.slice UInt8.t) ->  [ &addr <- { addr with current = r'0 } ] s1)
      | s1 = -{resolve'0 addr}- s2
      | s2 = return' {_0} ]
     ]
    )
    [ & _0 : () = Any.any_l ()
    | & addr : MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & left : UInt64.t = left
    | & flag : bool = flag
    | & i : UInt64.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & k : UInt64.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & _12 : UInt8.t = Any.any_l ()
    | & _14 : UInt64.t = Any.any_l ()
    | & _15 : Opaque.ptr = Any.any_l ()
    | & _16 : UInt64.t = Any.any_l ()
    | & _17 : bool = Any.any_l ()
    | & _20 : UInt64.t = Any.any_l ()
    | & _21 : Opaque.ptr = Any.any_l ()
    | & _22 : UInt64.t = Any.any_l ()
    | & _23 : bool = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:poke_8bit_array ensures] [%#sbitwalker7] Seq.length (view'1 addr.final)
      = Seq.length (view'0 addr)}
      (! return' {result}) ]

end
module M_bitwalker__poke [#"bitwalker.rs" 90 0 90 71]
  let%span sbitwalker0 = "bitwalker.rs" 92 26 92 27
  let%span sbitwalker1 = "bitwalker.rs" 93 15 93 17
  let%span sbitwalker2 = "bitwalker.rs" 95 16 95 23
  let%span sbitwalker3 = "bitwalker.rs" 95 37 95 41
  let%span sbitwalker4 = "bitwalker.rs" 96 15 96 17
  let%span sbitwalker5 = "bitwalker.rs" 98 24 98 26
  let%span sbitwalker6 = "bitwalker.rs" 99 23 99 24
  let%span sbitwalker7 = "bitwalker.rs" 101 16 101 41
  let%span sbitwalker8 = "bitwalker.rs" 100 16 100 27
  let%span sbitwalker9 = "bitwalker.rs" 103 22 103 34
  let%span sbitwalker10 = "bitwalker.rs" 106 22 106 47
  let%span sbitwalker11 = "bitwalker.rs" 107 13 107 14
  let%span sbitwalker12 = "bitwalker.rs" 109 11 109 12
  let%span sbitwalker13 = "bitwalker.rs" 86 11 86 33
  let%span sbitwalker14 = "bitwalker.rs" 87 11 87 28
  let%span sbitwalker15 = "bitwalker.rs" 88 11 88 46
  let%span sbitwalker16 = "bitwalker.rs" 89 10 89 39
  let%span sslice17 = "../../../creusot-contracts/src/std/slice.rs" 254 18 254 40
  let%span smodel18 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sbitwalker19 = "bitwalker.rs" 62 11 62 25
  let%span sbitwalker20 = "bitwalker.rs" 78 11 78 34
  let%span sbitwalker21 = "bitwalker.rs" 79 10 79 39
  let%span sslice22 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice23 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span smodel24 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sresolve25 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord37 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord38 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord39 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt8
  
  use creusot.int.UInt64
  
  predicate inv'0 (_1 : Slice64.slice UInt8.t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : Slice64.slice UInt8.t [inv'0 x] . inv'0 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'1 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t
  
  axiom view'1_spec : forall self : Slice64.slice UInt8.t . ([%#sslice22] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice23] view'1 self = Slice64.id self)
  
  function view'2 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t =
    [%#smodel24] view'1 self
  
  let rec len'0 (self:Slice64.slice UInt8.t) (return'  (ret:UInt64.t))= {[@expl:len 'self' type invariant] inv'0 self}
    any
    [ return' (result:UInt64.t)-> {[%#sslice17] Seq.length (view'2 self) = UInt64.t'int result} (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  predicate resolve'1 (self : MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t (Slice64.slice UInt8.t)) =
    resolve'1 _1
  
  use creusot.int.Int8
  
  function view'0 (self : MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    [%#smodel18] view'1 self.current
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord39] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord38] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord36] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord37] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord34] cmp_log'0 x y = C_Less'0)
   -> ([%#sord35] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord31] cmp_log'0 x y
  = o)  -> ([%#sord32] cmp_log'0 y z = o)  -> ([%#sord33] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord30] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord29] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord28] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord27] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord26] UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec peek_64bit'0 (value:UInt64.t) (left:UInt64.t) (return'  (ret:bool))= {[@expl:peek_64bit requires] [%#sbitwalker19] UInt64.lt left (64 : UInt64.t)}
    any [ return' (result:bool)-> (! return' {result}) ] 
  
  let rec poke_8bit_array'0 (addr:MutBorrow.t (Slice64.slice UInt8.t)) (left:UInt64.t) (flag:bool) (return'  (ret:()))= {[@expl:poke_8bit_array requires] [%#sbitwalker20] UInt64.t'int left
    < 8 * Seq.length (view'0 addr)}
    any
    [ return' (result:())-> {[%#sbitwalker21] Seq.length (view'1 addr.final) = Seq.length (view'0 addr)}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec poke'0[#"bitwalker.rs" 90 0 90 71] (start:UInt64.t) (length:UInt64.t) (addr:MutBorrow.t (Slice64.slice UInt8.t)) (value:UInt64.t) (return'  (ret:Int8.t))= {[@expl:poke requires #0] [%#sbitwalker13] Seq.length (view'0 addr)
    < 10000000}
    {[@expl:poke requires #1] [%#sbitwalker14] UInt64.le length (64 : UInt64.t)}
    {[@expl:poke requires #2] [%#sbitwalker15] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0 [ s0 = len'0 {addr.current} (fun (_ret':UInt64.t) ->  [ &ghost_len <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = UInt64.add {start} {length} (fun (_ret':UInt64.t) ->  [ &_14 <- _ret' ] s1)
      | s1 = len'0 {addr.current} (fun (_ret':UInt64.t) ->  [ &_18 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = UInt64.mul {[%#sbitwalker0] (8 : UInt64.t)} {_18} (fun (_ret':UInt64.t) ->  [ &_17 <- _ret' ] s1)
      | s1 =  [ &_13 <- UInt64.gt _14 _17 ] s2
      | s2 = any [ br0 -> {_13 = false} (! bb4) | br1 -> {_13} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 = -{resolve'0 addr}- s1 | s1 =  [ &_0 <- [%#sbitwalker1] (-1 : Int8.t) ] s2 | s2 = bb16 ] 
    | bb4 = s0
      [ s0 =  [ &_22 <- UInt64.lt length ([%#sbitwalker2] (64 : UInt64.t)) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb6) | br1 -> {_22} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = UInt64.shl {[%#sbitwalker3] (1 : UInt64.t)} {UInt64.t'int length}
          (fun (_ret':UInt64.t) ->  [ &_26 <- _ret' ] s1)
      | s1 =  [ &_24 <- UInt64.ge value _26 ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb8) | br1 -> {_24} (! bb7) ]  ]
    
    | bb7 = s0 [ s0 = -{resolve'0 addr}- s1 | s1 =  [ &_0 <- [%#sbitwalker4] (-2 : Int8.t) ] s2 | s2 = bb16 ] 
    | bb8 = bb9
    | bb6 = bb9
    | bb9 = s0
      [ s0 = UInt64.sub {[%#sbitwalker5] (64 : UInt64.t)} {length} (fun (_ret':UInt64.t) ->  [ &lstart <- _ret' ] s1)
      | s1 =  [ &i <- [%#sbitwalker6] (0 : UInt64.t) ] s2
      | s2 =  [ &old_10_0 <- addr ] s3
      | s3 = bb10 ]
    
    | bb10 = bb10
      [ bb10 = {[@expl:mut invariant] old_10_0.final = addr.final}
        {[@expl:loop invariant #0] [%#sbitwalker8] UInt64.le i length}
        {[@expl:loop invariant #1] [%#sbitwalker7] Seq.length (view'0 addr) = UInt64.t'int ghost_len}
        (! s0) [ s0 = bb11 ] 
        [ bb11 = s0
          [ s0 =  [ &_37 <- UInt64.lt i length ] s1
          | s1 = any [ br0 -> {_37 = false} (! bb15) | br1 -> {_37} (! bb12) ]  ]
        
        | bb12 = s0
          [ s0 = {[@expl:assertion] [%#sbitwalker9] UInt64.t'int i < UInt64.t'int length} s1
          | s1 = UInt64.add {lstart} {i} (fun (_ret':UInt64.t) ->  [ &_44 <- _ret' ] s2)
          | s2 = peek_64bit'0 {value} {_44} (fun (_ret':bool) ->  [ &flag <- _ret' ] s3)
          | s3 = bb13 ]
        
        | bb13 = s0
          [ s0 = MutBorrow.borrow_mut <Slice64.slice UInt8.t> {addr.current}
              (fun (_ret':MutBorrow.t (Slice64.slice UInt8.t)) ->
                 [ &_48 <- _ret' ] 
                 [ &addr <- { addr with current = _ret'.final } ] 
                s1)
          | s1 = UInt64.add {start} {i} (fun (_ret':UInt64.t) ->  [ &_49 <- _ret' ] s2)
          | s2 = poke_8bit_array'0 {_48} {_49} {flag} (fun (_ret':()) ->  [ &_47 <- _ret' ] s3)
          | s3 = bb14 ]
        
        | bb14 = s0
          [ s0 = {[@expl:assertion] [%#sbitwalker10] Seq.length (view'0 addr) = UInt64.t'int ghost_len} s1
          | s1 = UInt64.add {i} {[%#sbitwalker11] (1 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &i <- _ret' ] s2)
          | s2 = bb10 ]
         ]
       ]
    
    | bb15 = s0 [ s0 = -{resolve'0 addr}- s1 | s1 =  [ &_0 <- [%#sbitwalker12] (0 : Int8.t) ] s2 | s2 = bb16 ] 
    | bb16 = return' {_0} ]
    )
    [ & _0 : Int8.t = Any.any_l ()
    | & start : UInt64.t = start
    | & length : UInt64.t = length
    | & addr : MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value : UInt64.t = value
    | & ghost_len : UInt64.t = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _14 : UInt64.t = Any.any_l ()
    | & _17 : UInt64.t = Any.any_l ()
    | & _18 : UInt64.t = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _24 : bool = Any.any_l ()
    | & _26 : UInt64.t = Any.any_l ()
    | & lstart : UInt64.t = Any.any_l ()
    | & i : UInt64.t = Any.any_l ()
    | & _37 : bool = Any.any_l ()
    | & flag : bool = Any.any_l ()
    | & _44 : UInt64.t = Any.any_l ()
    | & _47 : () = Any.any_l ()
    | & _48 : MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & _49 : UInt64.t = Any.any_l ()
    | & old_10_0 : MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ]
    
    [ return' (result:Int8.t)-> {[@expl:poke ensures] [%#sbitwalker16] Seq.length (view'1 addr.final)
      = Seq.length (view'0 addr)}
      (! return' {result}) ]

end
module M_bitwalker__peekthenpoke [#"bitwalker.rs" 119 0 119 67]
  let%span sbitwalker0 = "bitwalker.rs" 116 11 116 33
  let%span sbitwalker1 = "bitwalker.rs" 117 11 117 28
  let%span sbitwalker2 = "bitwalker.rs" 118 11 118 46
  let%span sbitwalker3 = "bitwalker.rs" 41 11 41 33
  let%span sbitwalker4 = "bitwalker.rs" 42 11 42 28
  let%span sbitwalker5 = "bitwalker.rs" 43 11 43 46
  let%span sbitwalker6 = "bitwalker.rs" 86 11 86 33
  let%span sbitwalker7 = "bitwalker.rs" 87 11 87 28
  let%span sbitwalker8 = "bitwalker.rs" 88 11 88 46
  let%span sbitwalker9 = "bitwalker.rs" 89 10 89 39
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel11 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice13 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sresolve14 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt8
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'2 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t
  
  axiom view'2_spec : forall self : Slice64.slice UInt8.t . ([%#sslice12] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice13] view'2 self = Slice64.id self)
  
  function view'1 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t =
    [%#smodel11] view'2 self
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord28] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord27] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord25] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord26] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord23] cmp_log'0 x y = C_Less'0)
   -> ([%#sord24] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord20] cmp_log'0 x y
  = o)  -> ([%#sord21] cmp_log'0 y z = o)  -> ([%#sord22] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord19] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord18] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord17] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec peek'0 (start:UInt64.t) (length:UInt64.t) (addr:Slice64.slice UInt8.t) (return'  (ret:UInt64.t))= {[@expl:peek requires #0] [%#sbitwalker3] Seq.length (view'1 addr)
    < 10000000}
    {[@expl:peek requires #1] [%#sbitwalker4] UInt64.le length (64 : UInt64.t)}
    {[@expl:peek requires #2] [%#sbitwalker5] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'1 addr)}
    any [ return' (result:UInt64.t)-> (! return' {result}) ] 
  
  use creusot.prelude.MutBorrow
  
  use creusot.int.Int8
  
  function view'0 (self : MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    [%#smodel10] view'2 self.current
  
  let rec poke'0 (start:UInt64.t) (length:UInt64.t) (addr:MutBorrow.t (Slice64.slice UInt8.t)) (value:UInt64.t) (return'  (ret:Int8.t))= {[@expl:poke requires #0] [%#sbitwalker6] Seq.length (view'0 addr)
    < 10000000}
    {[@expl:poke requires #1] [%#sbitwalker7] UInt64.le length (64 : UInt64.t)}
    {[@expl:poke requires #2] [%#sbitwalker8] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    any
    [ return' (result:Int8.t)-> {[%#sbitwalker9] Seq.length (view'2 addr.final) = Seq.length (view'0 addr)}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve14] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t (Slice64.slice UInt8.t)) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec peekthenpoke'0[#"bitwalker.rs" 119 0 119 67] (start:UInt64.t) (length:UInt64.t) (addr:MutBorrow.t (Slice64.slice UInt8.t)) (return'  (ret:Int8.t))= {[@expl:peekthenpoke requires #0] [%#sbitwalker0] Seq.length (view'0 addr)
    < 10000000}
    {[@expl:peekthenpoke requires #1] [%#sbitwalker1] UInt64.le length (64 : UInt64.t)}
    {[@expl:peekthenpoke requires #2] [%#sbitwalker2] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = peek'0 {start} {length} {addr.current} (fun (_ret':UInt64.t) ->  [ &value <- _ret' ] s1) | s1 = bb1 ]
    
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr.current} {MutBorrow.get_id addr}
          (fun (_ret':MutBorrow.t (Slice64.slice UInt8.t)) ->
             [ &_14 <- _ret' ] 
             [ &addr <- { addr with current = _ret'.final } ] 
            s1)
      | s1 = poke'0 {start} {length} {_14} {value} (fun (_ret':Int8.t) ->  [ &res <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = -{resolve'0 addr}- s1 | s1 =  [ &_0 <- res ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : Int8.t = Any.any_l ()
    | & start : UInt64.t = start
    | & length : UInt64.t = length
    | & addr : MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value : UInt64.t = Any.any_l ()
    | & res : Int8.t = Any.any_l ()
    | & _14 : MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l () ]
     [ return' (result:Int8.t)-> (! return' {result}) ] 
end
module M_bitwalker__pokethenpeek [#"bitwalker.rs" 133 0 133 84]
  let%span sbitwalker0 = "bitwalker.rs" 130 11 130 33
  let%span sbitwalker1 = "bitwalker.rs" 131 11 131 28
  let%span sbitwalker2 = "bitwalker.rs" 132 11 132 46
  let%span sbitwalker3 = "bitwalker.rs" 86 11 86 33
  let%span sbitwalker4 = "bitwalker.rs" 87 11 87 28
  let%span sbitwalker5 = "bitwalker.rs" 88 11 88 46
  let%span sbitwalker6 = "bitwalker.rs" 89 10 89 39
  let%span sbitwalker7 = "bitwalker.rs" 41 11 41 33
  let%span sbitwalker8 = "bitwalker.rs" 42 11 42 28
  let%span sbitwalker9 = "bitwalker.rs" 43 11 43 46
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sslice11 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span smodel13 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sresolve14 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sord15 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.MutBorrow
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt8
  
  use creusot.int.UInt64
  
  use creusot.int.Int8
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'1 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t
  
  axiom view'1_spec : forall self : Slice64.slice UInt8.t . ([%#sslice11] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice12] view'1 self = Slice64.id self)
  
  function view'0 (self : MutBorrow.t (Slice64.slice UInt8.t)) : Seq.seq UInt8.t =
    [%#smodel10] view'1 self.current
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt64
  
  function cmp_log'0 (self : UInt64.t) (o : UInt64.t) : t_Ordering'0 =
    [%#sord28] if UInt64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord27] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord25] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord26] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord23] cmp_log'0 x y = C_Less'0)
   -> ([%#sord24] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering'0 . ([%#sord20] cmp_log'0 x y
  = o)  -> ([%#sord21] cmp_log'0 y z = o)  -> ([%#sord22] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt64.t) : ()
  
  axiom refl'0_spec : forall x : UInt64.t . [%#sord19] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt64
  
  function cmp_gt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord18] UInt64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt64
  
  function cmp_ge_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord17] UInt64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord16] UInt64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt64
  
  function cmp_le_log'0 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt64.t, y : UInt64.t . [%#sord15] UInt64.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec poke'0 (start:UInt64.t) (length:UInt64.t) (addr:MutBorrow.t (Slice64.slice UInt8.t)) (value:UInt64.t) (return'  (ret:Int8.t))= {[@expl:poke requires #0] [%#sbitwalker3] Seq.length (view'0 addr)
    < 10000000}
    {[@expl:poke requires #1] [%#sbitwalker4] UInt64.le length (64 : UInt64.t)}
    {[@expl:poke requires #2] [%#sbitwalker5] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'0 addr)}
    any
    [ return' (result:Int8.t)-> {[%#sbitwalker6] Seq.length (view'1 addr.final) = Seq.length (view'0 addr)}
      (! return' {result}) ]
  
  
  function view'2 (self : Slice64.slice UInt8.t) : Seq.seq UInt8.t =
    [%#smodel13] view'1 self
  
  let rec peek'0 (start:UInt64.t) (length:UInt64.t) (addr:Slice64.slice UInt8.t) (return'  (ret:UInt64.t))= {[@expl:peek requires #0] [%#sbitwalker7] Seq.length (view'2 addr)
    < 10000000}
    {[@expl:peek requires #1] [%#sbitwalker8] UInt64.le length (64 : UInt64.t)}
    {[@expl:peek requires #2] [%#sbitwalker9] UInt64.t'int start + UInt64.t'int length <= 8 * Seq.length (view'2 addr)}
    any [ return' (result:UInt64.t)-> (! return' {result}) ] 
  
  predicate resolve'1 (self : MutBorrow.t (Slice64.slice UInt8.t)) =
    [%#sresolve14] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t (Slice64.slice UInt8.t)) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec pokethenpeek'0[#"bitwalker.rs" 133 0 133 84] (start:UInt64.t) (length:UInt64.t) (addr:MutBorrow.t (Slice64.slice UInt8.t)) (value:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:pokethenpeek requires #0] [%#sbitwalker0] Seq.length (view'0 addr)
    < 10000000}
    {[@expl:pokethenpeek requires #1] [%#sbitwalker1] UInt64.le length (64 : UInt64.t)}
    {[@expl:pokethenpeek requires #2] [%#sbitwalker2] UInt64.t'int start + UInt64.t'int length
    <= 8 * Seq.length (view'0 addr)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt8.t> {addr.current} {MutBorrow.get_id addr}
          (fun (_ret':MutBorrow.t (Slice64.slice UInt8.t)) ->
             [ &_11 <- _ret' ] 
             [ &addr <- { addr with current = _ret'.final } ] 
            s1)
      | s1 = poke'0 {start} {length} {_11} {value} (fun (_ret':Int8.t) ->  [ &_res <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = peek'0 {start} {length} {addr.current} (fun (_ret':UInt64.t) ->  [ &peek_result <- _ret' ] s1) | s1 = bb2 ]
    
    | bb2 = s0 [ s0 = -{resolve'0 addr}- s1 | s1 =  [ &_0 <- peek_result ] s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & start : UInt64.t = start
    | & length : UInt64.t = length
    | & addr : MutBorrow.t (Slice64.slice UInt8.t) = addr
    | & value : UInt64.t = value
    | & _res : Int8.t = Any.any_l ()
    | & _11 : MutBorrow.t (Slice64.slice UInt8.t) = Any.any_l ()
    | & peek_result : UInt64.t = Any.any_l () ]
     [ return' (result:UInt64.t)-> (! return' {result}) ] 
end
