module M_sparse_array__qyi1509881402265219485__resolve_coherence [#"sparse_array.rs" 60 4 60 31] (* <Sparse<T> as creusot_contracts::Resolve> *)
  let%span ssparse_array0 = "sparse_array.rs" 57 15 57 24
  let%span ssparse_array1 = "sparse_array.rs" 58 15 58 39
  let%span ssparse_array2 = "sparse_array.rs" 59 14 59 31
  let%span ssparse_array3 = "sparse_array.rs" 60 32 60 34
  let%span ssparse_array4 = "sparse_array.rs" 51 12 51 72
  let%span ssparse_array5 = "sparse_array.rs" 40 12 41 82
  let%span sinvariant6 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span svec7 = "../../creusot-contracts/src/std/vec.rs" 54 20 54 83
  let%span sresolve8 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span ssparse_array9 = "sparse_array.rs" 87 20 87 75
  let%span sindex10 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span svec11 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span ssparse_array12 = "sparse_array.rs" 68 12 74 68
  let%span svec13 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq14 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'0;
      t_Sparse__idx'0: t_Vec'1;
      t_Sparse__back'0: t_Vec'1 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : t_Vec'0 . [%#svec11] Seq.length (view'2 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'1 (self : t_Vec'1) : Seq.seq UInt64.t
  
  axiom view'1_spec : forall self : t_Vec'1 . [%#svec11] Seq.length (view'1 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'1) (ix : int) : UInt64.t =
    [%#sindex10] Seq.get (view'1 self) ix
  
  predicate invariant'1 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array12] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'2 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'1 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'5 (_1 : t_T'0)
  
  predicate invariant'4 (self : t_T'0) =
    [%#sboxed15] inv'5 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  predicate invariant'3 (self : Seq.seq t_T'0) =
    [%#sseq14] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'3 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Vec'0) =
    [%#svec13] inv'3 (view'2 self)
  
  predicate inv'2 (_1 : t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Vec'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate inv'1 (_1 : t_Sparse'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Sparse'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'2 values
    end)
  
  predicate invariant'0 (self : t_Sparse'0) =
    [%#sinvariant6] inv'1 self
  
  predicate inv'0 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'3 (_1 : UInt64.t) =
    true
  
  predicate resolve'5 (self : t_Vec'1) =
    [%#svec7] forall i : int . 0 <= i /\ i < Seq.length (view'1 self)  -> resolve'3 (index_logic'1 self i)
  
  predicate resolve'1 (_1 : t_Vec'1) =
    resolve'5 _1
  
  predicate resolve'8 (_1 : t_T'0)
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : t_T'0 =
    [%#sindex10] Seq.get (view'2 self) ix
  
  predicate resolve'6 (self : t_Vec'0) =
    [%#svec7] forall i : int . 0 <= i /\ i < Seq.length (view'2 self)  -> resolve'8 (index_logic'0 self i)
  
  predicate resolve'2 (_1 : t_Vec'0) =
    resolve'6 _1
  
  predicate structural_resolve'0 (_1 : t_Sparse'0) =
    match _1 with
      | {t_Sparse__size'0 = x0 ; t_Sparse__n'0 = x1 ; t_Sparse__values'0 = x2 ; t_Sparse__idx'0 = x3 ; t_Sparse__back'0 = x4} -> resolve'1 x4
      /\ resolve'1 x3 /\ resolve'2 x2 /\ resolve'3 x1 /\ resolve'3 x0
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'7 (self : t_Option'0) =
    [%#sresolve8] match self with
      | C_Some'0 x -> resolve'8 x
      | C_None'0 -> true
      end
  
  predicate resolve'4 (_1 : t_Option'0) =
    resolve'7 _1
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array9] UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i))) = i
  
  function view'0 [#"sparse_array.rs" 38 4 38 33] (self : t_Sparse'0) : Seq.seq t_Option'0 =
    [%#ssparse_array5] Seq.create (UInt64.t'int self.t_Sparse__size'0) (fun (i : int) -> if is_elt'0 self i then
      C_Some'0 (index_logic'0 self.t_Sparse__values'0 i)
    else
      C_None'0
    )
  
  predicate resolve'0 [#"sparse_array.rs" 49 4 49 28] (self : t_Sparse'0) =
    [%#ssparse_array4] forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__size'0
     -> resolve'4 (Seq.get (view'0 self) i)
  
  constant self  : t_Sparse'0
  
  function resolve_coherence'0 [#"sparse_array.rs" 60 4 60 31] (self : t_Sparse'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#ssparse_array0] inv'0 self)
   -> ([%#ssparse_array1] structural_resolve'0 self)  -> ([%#ssparse_array2] resolve'0 self)
end
module M_sparse_array__qyi16402981711463100202__get [#"sparse_array.rs" 101 4 101 45] (* Sparse<T> *)
  let%span ssparse_array0 = "sparse_array.rs" 101 16 101 20
  let%span ssparse_array1 = "sparse_array.rs" 92 15 92 31
  let%span ssparse_array2 = "sparse_array.rs" 101 35 101 45
  let%span ssparse_array3 = "sparse_array.rs" 93 14 96 5
  let%span ssparse_array4 = "sparse_array.rs" 97 14 100 5
  let%span svec5 = "../../creusot-contracts/src/std/vec.rs" 168 27 168 46
  let%span svec6 = "../../creusot-contracts/src/std/vec.rs" 169 26 169 54
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice8 = "../../creusot-contracts/src/std/slice.rs" 123 20 123 37
  let%span sslice9 = "../../creusot-contracts/src/std/slice.rs" 130 20 130 37
  let%span ssparse_array10 = "sparse_array.rs" 40 12 41 82
  let%span svec11 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sinvariant12 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span ssparse_array13 = "sparse_array.rs" 87 20 87 75
  let%span sindex14 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span ssparse_array15 = "sparse_array.rs" 68 12 74 68
  let%span svec16 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq17 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed18 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'1;
      t_Sparse__idx'0: t_Vec'0;
      t_Sparse__back'0: t_Vec'0 }
  
  predicate in_bounds'0 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq UInt64.t) =
    [%#sslice8] UInt64.t'int self < Seq.length seq
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : t_Vec'0) : Seq.seq UInt64.t
  
  axiom view'4_spec : forall self : t_Vec'0 . [%#svec11] Seq.length (view'4 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'1 (self : t_Vec'0) : Seq.seq UInt64.t =
    [%#smodel7] view'4 self
  
  predicate has_value'0 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq UInt64.t) (out : UInt64.t) =
    [%#sslice9] Seq.get seq (UInt64.t'int self) = out
  
  let rec index'0 (self:t_Vec'0) (index:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:index requires] [%#svec5] in_bounds'0 index (view'1 self)}
    any [ return' (result:UInt64.t)-> {[%#svec6] has_value'0 index (view'1 self) result} (! return' {result}) ] 
  
  type t_T'0
  
  predicate inv'6 (_1 : t_T'0)
  
  predicate invariant'6 (self : t_T'0) =
    [%#sboxed18] inv'6 self
  
  predicate inv'8 (_1 : t_T'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_T'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate invariant'5 (self : Seq.seq t_T'0) =
    [%#sseq17] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'8 (Seq.get self i)
  
  predicate inv'7 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Seq.seq t_T'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  function view'5 (self : t_Vec'1) : Seq.seq t_T'0
  
  axiom view'5_spec : forall self : t_Vec'1 . [%#svec11] Seq.length (view'5 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate invariant'4 (self : t_Vec'1) =
    [%#svec16] inv'7 (view'5 self)
  
  predicate inv'5 (_1 : t_Vec'1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Vec'1 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'1 (self : t_Vec'1) =
    [%#sinvariant12] inv'5 self
  
  predicate inv'2 (_1 : t_Vec'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Vec'1 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate in_bounds'1 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq t_T'0) =
    [%#sslice8] UInt64.t'int self < Seq.length seq
  
  function view'2 (self : t_Vec'1) : Seq.seq t_T'0 =
    [%#smodel7] view'5 self
  
  predicate invariant'2 (self : t_T'0) =
    [%#sinvariant12] inv'6 self
  
  predicate inv'3 (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate has_value'1 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq t_T'0) (out : t_T'0) =
    [%#sslice9] Seq.get seq (UInt64.t'int self) = out
  
  let rec index'1 (self:t_Vec'1) (index:UInt64.t) (return'  (ret:t_T'0))= {[@expl:index 'self' type invariant] inv'2 self}
    {[@expl:index requires] [%#svec5] in_bounds'1 index (view'2 self)}
    any
    [ return' (result:t_T'0)-> {inv'3 result} {[%#svec6] has_value'1 index (view'2 self) result} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'0) (ix : int) : UInt64.t =
    [%#sindex14] Seq.get (view'4 self) ix
  
  predicate invariant'3 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array15] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'5 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'4 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'4 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'1 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'4 (_1 : t_Sparse'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Sparse'0 [inv'4 x] . inv'4 x
  = (invariant'3 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'5 values
    end)
  
  predicate invariant'0 (self : t_Sparse'0) =
    [%#sinvariant12] inv'4 self
  
  predicate inv'0 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_T'0
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array13] UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i))) = i
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'1) (ix : int) : t_T'0 =
    [%#sindex14] Seq.get (view'5 self) ix
  
  function view'3 [#"sparse_array.rs" 38 4 38 33] (self : t_Sparse'0) : Seq.seq t_Option'1 =
    [%#ssparse_array10] Seq.create (UInt64.t'int self.t_Sparse__size'0) (fun (i : int) -> if is_elt'0 self i then
      C_Some'1 (index_logic'0 self.t_Sparse__values'0 i)
    else
      C_None'1
    )
  
  function view'0 (self : t_Sparse'0) : Seq.seq t_Option'1 =
    [%#smodel7] view'3 self
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  meta "compute_max_steps" 1000000
  
  let rec get'0[#"sparse_array.rs" 101 4 101 45] (self:t_Sparse'0) (i:UInt64.t) (return'  (ret:t_Option'0))= {[@expl:get 'self' type invariant] [%#ssparse_array0] inv'0 self}
    {[@expl:get requires] [%#ssparse_array1] UInt64.t'int i < Seq.length (view'0 self)}
    (! bb0
    [ bb0 = s0 [ s0 = index'0 {self.t_Sparse__idx'0} {i} (fun (_ret':UInt64.t) ->  [ &_7 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 =  [ &index <- _7 ] s1
      | s1 =  [ &_10 <- UInt64.lt index self.t_Sparse__n'0 ] s2
      | s2 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb2) ]  ]
    
    | bb2 = s0
      [ s0 = index'0 {self.t_Sparse__back'0} {index} (fun (_ret':UInt64.t) ->  [ &_15 <- _ret' ] s1) | s1 = bb3 ]
    
    | bb3 = s0 [ s0 =  [ &_13 <- _15 = i ] s1 | s1 = any [ br0 -> {_13 = false} (! bb6) | br1 -> {_13} (! bb4) ]  ] 
    | bb4 = s0 [ s0 = index'1 {self.t_Sparse__values'0} {i} (fun (_ret':t_T'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &_20 <- _21 ] s1 | s1 =  [ &_0 <- C_Some'0 _20 ] s2 | s2 = bb9 ] 
    | bb6 = bb8
    | bb7 = bb8
    | bb8 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb9 ] 
    | bb9 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self : t_Sparse'0 = self
    | & i : UInt64.t = i
    | & index : UInt64.t = Any.any_l ()
    | & _7 : UInt64.t = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : UInt64.t = Any.any_l ()
    | & _20 : t_T'0 = Any.any_l ()
    | & _21 : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:get result type invariant] [%#ssparse_array2] inv'1 result}
      {[@expl:get ensures #0] [%#ssparse_array3] match result with
        | C_None'0 -> Seq.get (view'0 self) (UInt64.t'int i) = C_None'1
        | C_Some'0 x -> Seq.get (view'0 self) (UInt64.t'int i) = C_Some'1 x
        end}
      {[@expl:get ensures #1] [%#ssparse_array4] match Seq.get (view'0 self) (UInt64.t'int i) with
        | C_None'1 -> result = C_None'0
        | C_Some'1 _ -> true
        end}
      (! return' {result}) ]

end
module M_sparse_array__qyi16402981711463100202__lemma_permutation [#"sparse_array.rs" 113 4 113 38] (* Sparse<T> *)
  let%span ssparse_array0 = "sparse_array.rs" 109 15 109 24
  let%span ssparse_array1 = "sparse_array.rs" 110 15 110 34
  let%span ssparse_array2 = "sparse_array.rs" 111 15 111 39
  let%span ssparse_array3 = "sparse_array.rs" 112 14 112 28
  let%span ssparse_array4 = "sparse_array.rs" 119 15 119 24
  let%span ssparse_array5 = "sparse_array.rs" 120 15 120 34
  let%span ssparse_array6 = "sparse_array.rs" 121 15 121 43
  let%span ssparse_array7 = "sparse_array.rs" 122 15 124 47
  let%span ssparse_array8 = "sparse_array.rs" 125 15 125 78
  let%span ssparse_array9 = "sparse_array.rs" 126 15 126 34
  let%span ssparse_array10 = "sparse_array.rs" 127 14 127 48
  let%span ssparse_array11 = "sparse_array.rs" 128 14 128 37
  let%span ssparse_array12 = "sparse_array.rs" 118 14 118 37
  let%span ssparse_array13 = "sparse_array.rs" 114 8 114 53
  let%span ssparse_array14 = "sparse_array.rs" 87 20 87 75
  let%span sfset15 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sindex16 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span ssparse_array17 = "sparse_array.rs" 131 12 136 13
  let%span svec18 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span ssparse_array19 = "sparse_array.rs" 142 15 142 65
  let%span ssparse_array20 = "sparse_array.rs" 143 15 143 23
  let%span ssparse_array21 = "sparse_array.rs" 144 14 144 28
  let%span ssparse_array22 = "sparse_array.rs" 141 14 141 17
  let%span ssparse_array23 = "sparse_array.rs" 146 8 148 9
  let%span sfset24 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span ssparse_array25 = "sparse_array.rs" 68 12 74 68
  let%span sfset26 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  let%span svec27 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq28 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed29 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  use set.Fset
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'0;
      t_Sparse__idx'0: t_Vec'1;
      t_Sparse__back'0: t_Vec'1 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : t_Vec'0 . [%#svec18] Seq.length (view'1 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'0 (self : t_Vec'1) : Seq.seq UInt64.t
  
  axiom view'0_spec : forall self : t_Vec'1 . [%#svec18] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'1) (ix : int) : UInt64.t =
    [%#sindex16] Seq.get (view'0 self) ix
  
  predicate invariant'0 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array25] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'0 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'0 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'0 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'4 (_1 : t_T'0)
  
  predicate invariant'3 (self : t_T'0) =
    [%#sboxed29] inv'4 self
  
  predicate inv'3 (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : Seq.seq t_T'0) =
    [%#sseq28] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'2 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : t_Vec'0) =
    [%#svec27] inv'2 (view'1 self)
  
  predicate inv'1 (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'0 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'1 values
    end)
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array14] UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'0 self.t_Sparse__back'0 (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 i))) = i
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset int) (e : int) =
    [%#sfset15] Fset.mem e self
  
  function remove'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset26] Fset.remove e self
  
  function bounded_fset_len'0 [#"sparse_array.rs" 145 4 145 47] (s : Fset.fset int) (bnd : int) : ()
  
  axiom bounded_fset_len'0_def : forall s : Fset.fset int, bnd : int . ([%#ssparse_array19] forall x : int . contains'0 s x
   -> 0 <= x /\ x < bnd)
   -> ([%#ssparse_array20] bnd >= 0)
   -> bounded_fset_len'0 s bnd
  = ([%#ssparse_array23] if bnd > 0 then bounded_fset_len'0 (remove'0 s (bnd - 1)) (bnd - 1) else ())
  
  axiom bounded_fset_len'0_spec : forall s : Fset.fset int, bnd : int . ([%#ssparse_array19] forall x : int . contains'0 s x
   -> 0 <= x /\ x < bnd)  -> ([%#ssparse_array20] bnd >= 0)  -> ([%#ssparse_array21] Fset.cardinal s <= bnd)
  
  function insert'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset24] Fset.add e self
  
  function lemma_permutation_aux'0 [#"sparse_array.rs" 129 4 129 76] (self : t_Sparse'0) (seen : Fset.fset int) (i : int) (cur : int) : int
  
  
  axiom lemma_permutation_aux'0_def : forall self : t_Sparse'0, seen : Fset.fset int, i : int, cur : int . ([%#ssparse_array4] inv'0 self)
   -> ([%#ssparse_array5] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array6] 0 <= cur /\ cur < UInt64.t'int self.t_Sparse__size'0)
   -> ([%#ssparse_array7] forall k : int . contains'0 seen k
   -> 0 <= k
  /\ k < UInt64.t'int self.t_Sparse__size'0
  /\ (k = i \/ contains'0 seen (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 k))))
   -> ([%#ssparse_array8] i = cur
  \/ contains'0 seen i /\ contains'0 seen (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 cur)))
   -> ([%#ssparse_array9] not contains'0 seen cur)
   -> lemma_permutation_aux'0 self seen i cur
  = ([%#ssparse_array17] if UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur) = i then
    cur
  else
    let _ = bounded_fset_len'0 seen (UInt64.t'int self.t_Sparse__size'0) in lemma_permutation_aux'0 self (insert'0 seen cur) i (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur))
  )
  
  axiom lemma_permutation_aux'0_spec : forall self : t_Sparse'0, seen : Fset.fset int, i : int, cur : int . ([%#ssparse_array4] inv'0 self)
   -> ([%#ssparse_array5] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array6] 0 <= cur /\ cur < UInt64.t'int self.t_Sparse__size'0)
   -> ([%#ssparse_array7] forall k : int . contains'0 seen k
   -> 0 <= k
  /\ k < UInt64.t'int self.t_Sparse__size'0
  /\ (k = i \/ contains'0 seen (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 k))))
   -> ([%#ssparse_array8] i = cur
  \/ contains'0 seen i /\ contains'0 seen (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 cur)))
   -> ([%#ssparse_array9] not contains'0 seen cur)
   -> ([%#ssparse_array10] 0 <= lemma_permutation_aux'0 self seen i cur
  /\ lemma_permutation_aux'0 self seen i cur < UInt64.t'int self.t_Sparse__size'0)
  && ([%#ssparse_array11] UInt64.t'int (index_logic'0 self.t_Sparse__back'0 (lemma_permutation_aux'0 self seen i cur))
  = i)
  
  constant self  : t_Sparse'0
  
  constant i  : int
  
  function lemma_permutation'0 [#"sparse_array.rs" 113 4 113 38] (self : t_Sparse'0) (i : int) : ()
  
  goal vc_lemma_permutation'0 : ([%#ssparse_array0] inv'0 self)
   -> ([%#ssparse_array1] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array2] 0 <= i /\ i < UInt64.t'int self.t_Sparse__size'0)
   -> (([@expl:lemma_permutation_aux requires #0] [%#ssparse_array4] inv'0 self)
  && ([@expl:lemma_permutation_aux requires #1] [%#ssparse_array5] self.t_Sparse__n'0 = self.t_Sparse__size'0)
  && ([@expl:lemma_permutation_aux requires #2] [%#ssparse_array6] 0 <= i /\ i < UInt64.t'int self.t_Sparse__size'0)
  && ([@expl:lemma_permutation_aux requires #3] [%#ssparse_array7] forall k : int . contains'0 (Fset.empty : Fset.fset int) k
   -> 0 <= k
  /\ k < UInt64.t'int self.t_Sparse__size'0
  /\ (k = i \/ contains'0 (Fset.empty : Fset.fset int) (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 k))))
  && ([@expl:lemma_permutation_aux requires #4] [%#ssparse_array8] i = i
  \/ contains'0 (Fset.empty : Fset.fset int) i
  /\ contains'0 (Fset.empty : Fset.fset int) (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 i)))
  && ([@expl:lemma_permutation_aux requires #5] [%#ssparse_array9] not contains'0 (Fset.empty : Fset.fset int) i))
  /\ (([%#ssparse_array10] 0 <= lemma_permutation_aux'0 self (Fset.empty : Fset.fset int) i i
  /\ lemma_permutation_aux'0 self (Fset.empty : Fset.fset int) i i < UInt64.t'int self.t_Sparse__size'0)
  && ([%#ssparse_array11] UInt64.t'int (index_logic'0 self.t_Sparse__back'0 (lemma_permutation_aux'0 self (Fset.empty : Fset.fset int) i i))
  = i)
   -> (let _ = lemma_permutation_aux'0 self (Fset.empty : Fset.fset int) i i in [%#ssparse_array3] is_elt'0 self i))
end
module M_sparse_array__qyi16402981711463100202__lemma_permutation_aux [#"sparse_array.rs" 129 4 129 76] (* Sparse<T> *)
  let%span ssparse_array0 = "sparse_array.rs" 119 15 119 24
  let%span ssparse_array1 = "sparse_array.rs" 120 15 120 34
  let%span ssparse_array2 = "sparse_array.rs" 121 15 121 43
  let%span ssparse_array3 = "sparse_array.rs" 122 15 124 47
  let%span ssparse_array4 = "sparse_array.rs" 125 15 125 78
  let%span ssparse_array5 = "sparse_array.rs" 126 15 126 34
  let%span ssparse_array6 = "sparse_array.rs" 127 14 127 48
  let%span ssparse_array7 = "sparse_array.rs" 128 14 128 37
  let%span ssparse_array8 = "sparse_array.rs" 118 14 118 37
  let%span ssparse_array9 = "sparse_array.rs" 142 15 142 65
  let%span ssparse_array10 = "sparse_array.rs" 143 15 143 23
  let%span ssparse_array11 = "sparse_array.rs" 144 14 144 28
  let%span ssparse_array12 = "sparse_array.rs" 141 14 141 17
  let%span ssparse_array13 = "sparse_array.rs" 131 12 136 13
  let%span sfset14 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sindex15 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span ssparse_array16 = "sparse_array.rs" 146 8 148 9
  let%span sfset17 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span svec18 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sfset19 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  let%span ssparse_array20 = "sparse_array.rs" 68 12 74 68
  let%span svec21 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq22 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed23 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use set.Fset
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'1;
      t_Sparse__idx'0: t_Vec'0;
      t_Sparse__back'0: t_Vec'0 }
  
  type t_T'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 (self : t_Vec'1) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : t_Vec'1 . [%#svec18] Seq.length (view'1 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'0 (self : t_Vec'0) : Seq.seq UInt64.t
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec18] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : UInt64.t =
    [%#sindex15] Seq.get (view'0 self) ix
  
  predicate invariant'0 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array20] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'0 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'0 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'0 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'4 (_1 : t_T'0)
  
  predicate invariant'3 (self : t_T'0) =
    [%#sboxed23] inv'4 self
  
  predicate inv'3 (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : Seq.seq t_T'0) =
    [%#sseq22] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)
  
  predicate inv'2 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_T'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : t_Vec'1) =
    [%#svec21] inv'2 (view'1 self)
  
  predicate inv'1 (_1 : t_Vec'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'1 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'0 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'1 values
    end)
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset int) (e : int) =
    [%#sfset14] Fset.mem e self
  
  function remove'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset19] Fset.remove e self
  
  function bounded_fset_len'0 [#"sparse_array.rs" 145 4 145 47] (s : Fset.fset int) (bnd : int) : ()
  
  axiom bounded_fset_len'0_def : forall s : Fset.fset int, bnd : int . ([%#ssparse_array9] forall x : int . contains'0 s x
   -> 0 <= x /\ x < bnd)
   -> ([%#ssparse_array10] bnd >= 0)
   -> bounded_fset_len'0 s bnd
  = ([%#ssparse_array16] if bnd > 0 then bounded_fset_len'0 (remove'0 s (bnd - 1)) (bnd - 1) else ())
  
  axiom bounded_fset_len'0_spec : forall s : Fset.fset int, bnd : int . ([%#ssparse_array9] forall x : int . contains'0 s x
   -> 0 <= x /\ x < bnd)  -> ([%#ssparse_array10] bnd >= 0)  -> ([%#ssparse_array11] Fset.cardinal s <= bnd)
  
  function insert'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset17] Fset.add e self
  
  constant self  : t_Sparse'0
  
  constant seen  : Fset.fset int
  
  constant i  : int
  
  constant cur  : int
  
  function lemma_permutation_aux'0 [#"sparse_array.rs" 129 4 129 76] (self : t_Sparse'0) (seen : Fset.fset int) (i : int) (cur : int) : int
  
  
  goal vc_lemma_permutation_aux'0 : ([%#ssparse_array0] inv'0 self)
   -> ([%#ssparse_array1] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array2] 0 <= cur /\ cur < UInt64.t'int self.t_Sparse__size'0)
   -> ([%#ssparse_array3] forall k : int . contains'0 seen k
   -> 0 <= k
  /\ k < UInt64.t'int self.t_Sparse__size'0
  /\ (k = i \/ contains'0 seen (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 k))))
   -> ([%#ssparse_array4] i = cur
  \/ contains'0 seen i /\ contains'0 seen (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 cur)))
   -> ([%#ssparse_array5] not contains'0 seen cur)
   -> (if UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur) = i then
    let result = cur in ([%#ssparse_array6] 0 <= result /\ result < UInt64.t'int self.t_Sparse__size'0)
    && ([%#ssparse_array7] UInt64.t'int (index_logic'0 self.t_Sparse__back'0 result) = i)
  else
    (([@expl:bounded_fset_len requires #0] [%#ssparse_array9] forall x : int . contains'0 seen x
     -> 0 <= x /\ x < UInt64.t'int self.t_Sparse__size'0)
    && ([@expl:bounded_fset_len requires #1] [%#ssparse_array10] UInt64.t'int self.t_Sparse__size'0 >= 0))
    /\ (([%#ssparse_array11] Fset.cardinal seen <= UInt64.t'int self.t_Sparse__size'0)
     -> (let _ = bounded_fset_len'0 seen (UInt64.t'int self.t_Sparse__size'0) in ((([@expl:lemma_permutation_aux requires #0] [%#ssparse_array0] inv'0 self)
    && ([@expl:lemma_permutation_aux requires #1] [%#ssparse_array1] self.t_Sparse__n'0 = self.t_Sparse__size'0)
    && ([@expl:lemma_permutation_aux requires #2] [%#ssparse_array2] 0
    <= UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur)
    /\ UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur) < UInt64.t'int self.t_Sparse__size'0)
    && ([@expl:lemma_permutation_aux requires #3] [%#ssparse_array3] forall k : int . contains'0 (insert'0 seen cur) k
     -> 0 <= k
    /\ k < UInt64.t'int self.t_Sparse__size'0
    /\ (k = i \/ contains'0 (insert'0 seen cur) (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 k))))
    && ([@expl:lemma_permutation_aux requires #4] [%#ssparse_array4] i
    = UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur)
    \/ contains'0 (insert'0 seen cur) i
    /\ contains'0 (insert'0 seen cur) (UInt64.t'int (index_logic'0 self.t_Sparse__idx'0 (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur)))))
    && ([@expl:lemma_permutation_aux requires #5] [%#ssparse_array5] not contains'0 (insert'0 seen cur) (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur))))
    /\ 0 <= ([%#ssparse_array8] UInt64.t'int self.t_Sparse__size'0 - Fset.cardinal seen)
    /\ ([%#ssparse_array8] UInt64.t'int self.t_Sparse__size'0 - Fset.cardinal (insert'0 seen cur))
    < ([%#ssparse_array8] UInt64.t'int self.t_Sparse__size'0 - Fset.cardinal seen))
    /\ (([%#ssparse_array6] 0
    <= lemma_permutation_aux'0 self (insert'0 seen cur) i (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur))
    /\ lemma_permutation_aux'0 self (insert'0 seen cur) i (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur))
    < UInt64.t'int self.t_Sparse__size'0)
    && ([%#ssparse_array7] UInt64.t'int (index_logic'0 self.t_Sparse__back'0 (lemma_permutation_aux'0 self (insert'0 seen cur) i (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur))))
    = i)
     -> (let result = lemma_permutation_aux'0 self (insert'0 seen cur) i (UInt64.t'int (index_logic'0 self.t_Sparse__back'0 cur)) in ([%#ssparse_array6] 0
    <= result
    /\ result < UInt64.t'int self.t_Sparse__size'0)
    && ([%#ssparse_array7] UInt64.t'int (index_logic'0 self.t_Sparse__back'0 result) = i)))))
  )
end
module M_sparse_array__qyi16402981711463100202__bounded_fset_len [#"sparse_array.rs" 145 4 145 47] (* Sparse<T> *)
  let%span ssparse_array0 = "sparse_array.rs" 142 15 142 65
  let%span ssparse_array1 = "sparse_array.rs" 143 15 143 23
  let%span ssparse_array2 = "sparse_array.rs" 144 14 144 28
  let%span ssparse_array3 = "sparse_array.rs" 141 14 141 17
  let%span ssparse_array4 = "sparse_array.rs" 146 8 148 9
  let%span sfset5 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset6 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  
  use set.Fset
  use mach.int.Int
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset int) (e : int) =
    [%#sfset5] Fset.mem e self
  
  function remove'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset6] Fset.remove e self
  
  constant s  : Fset.fset int
  
  constant bnd  : int
  
  function bounded_fset_len'0 [#"sparse_array.rs" 145 4 145 47] (s : Fset.fset int) (bnd : int) : ()
  
  goal vc_bounded_fset_len'0 : ([%#ssparse_array0] forall x : int . contains'0 s x  -> 0 <= x /\ x < bnd)
   -> ([%#ssparse_array1] bnd >= 0)
   -> (if bnd > 0 then
    ((([@expl:bounded_fset_len requires #0] [%#ssparse_array0] forall x : int . contains'0 (remove'0 s (bnd - 1)) x
     -> 0 <= x /\ x < bnd - 1)
    && ([@expl:bounded_fset_len requires #1] [%#ssparse_array1] bnd - 1 >= 0))
    /\ 0 <= ([%#ssparse_array3] bnd) /\ ([%#ssparse_array3] bnd - 1) < ([%#ssparse_array3] bnd))
    /\ (([%#ssparse_array2] Fset.cardinal (remove'0 s (bnd - 1)) <= bnd - 1)
     -> ([%#ssparse_array2] Fset.cardinal s <= bnd))
  else
    [%#ssparse_array2] Fset.cardinal s <= bnd
  )
end
module M_sparse_array__qyi16402981711463100202__set [#"sparse_array.rs" 157 4 157 41] (* Sparse<T> *)
  let%span ssparse_array0 = "sparse_array.rs" 162 12 162 46
  let%span ssparse_array1 = "sparse_array.rs" 163 26 163 46
  let%span ssparse_array2 = "sparse_array.rs" 167 22 167 23
  let%span ssparse_array3 = "sparse_array.rs" 157 20 157 24
  let%span ssparse_array4 = "sparse_array.rs" 157 36 157 37
  let%span ssparse_array5 = "sparse_array.rs" 153 15 153 31
  let%span ssparse_array6 = "sparse_array.rs" 154 14 154 43
  let%span ssparse_array7 = "sparse_array.rs" 155 14 155 93
  let%span ssparse_array8 = "sparse_array.rs" 156 14 156 37
  let%span svec9 = "../../creusot-contracts/src/std/vec.rs" 158 27 158 46
  let%span svec10 = "../../creusot-contracts/src/std/vec.rs" 159 26 159 54
  let%span svec11 = "../../creusot-contracts/src/std/vec.rs" 160 26 160 57
  let%span svec12 = "../../creusot-contracts/src/std/vec.rs" 161 26 161 62
  let%span svec13 = "../../creusot-contracts/src/std/vec.rs" 162 26 162 55
  let%span svec14 = "../../creusot-contracts/src/std/vec.rs" 168 27 168 46
  let%span svec15 = "../../creusot-contracts/src/std/vec.rs" 169 26 169 54
  let%span ssparse_array16 = "sparse_array.rs" 109 15 109 24
  let%span ssparse_array17 = "sparse_array.rs" 110 15 110 34
  let%span ssparse_array18 = "sparse_array.rs" 111 15 111 39
  let%span ssparse_array19 = "sparse_array.rs" 112 14 112 28
  let%span ssparse_array20 = "sparse_array.rs" 114 8 114 53
  let%span smodel21 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span ssparse_array22 = "sparse_array.rs" 40 12 41 82
  let%span sslice23 = "../../creusot-contracts/src/std/slice.rs" 123 20 123 37
  let%span sslice24 = "../../creusot-contracts/src/std/slice.rs" 130 20 130 37
  let%span svec25 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sslice26 = "../../creusot-contracts/src/std/slice.rs" 137 20 137 94
  let%span sresolve27 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel28 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span ssparse_array29 = "sparse_array.rs" 87 20 87 75
  let%span ssparse_array30 = "sparse_array.rs" 119 15 119 24
  let%span ssparse_array31 = "sparse_array.rs" 120 15 120 34
  let%span ssparse_array32 = "sparse_array.rs" 121 15 121 43
  let%span ssparse_array33 = "sparse_array.rs" 122 15 124 47
  let%span ssparse_array34 = "sparse_array.rs" 125 15 125 78
  let%span ssparse_array35 = "sparse_array.rs" 126 15 126 34
  let%span ssparse_array36 = "sparse_array.rs" 127 14 127 48
  let%span ssparse_array37 = "sparse_array.rs" 128 14 128 37
  let%span ssparse_array38 = "sparse_array.rs" 118 14 118 37
  let%span ssparse_array39 = "sparse_array.rs" 131 12 136 13
  let%span sindex40 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span svec41 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sinvariant42 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfset43 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span ssparse_array44 = "sparse_array.rs" 142 15 142 65
  let%span ssparse_array45 = "sparse_array.rs" 143 15 143 23
  let%span ssparse_array46 = "sparse_array.rs" 144 14 144 28
  let%span ssparse_array47 = "sparse_array.rs" 141 14 141 17
  let%span ssparse_array48 = "sparse_array.rs" 146 8 148 9
  let%span sfset49 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span ssparse_array50 = "sparse_array.rs" 68 12 74 68
  let%span sfset51 = "../../creusot-contracts/src/logic/fset.rs" 93 8 93 26
  let%span sseq52 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed53 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use set.Fset
  use creusot.prelude.Any
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_T'0
  
  predicate inv'1 (_1 : t_T'0)
  
  predicate invariant'6 (self : t_T'0) =
    [%#sboxed53] inv'1 self
  
  predicate inv'7 (_1 : t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_T'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  predicate invariant'5 (self : Seq.seq t_T'0) =
    [%#sseq52] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'7 (Seq.get self i)
  
  predicate inv'6 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : Seq.seq t_T'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'3 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'3_spec : forall self : t_Vec'0 . [%#svec25] Seq.length (view'3 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate invariant'0 (self : t_Vec'0) =
    [%#svec41] inv'6 (view'3 self)
  
  predicate inv'0 (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'0;
      t_Sparse__idx'0: t_Vec'1;
      t_Sparse__back'0: t_Vec'1 }
  
  predicate invariant'3 (self : MutBorrow.t t_Vec'0) =
    [%#sinvariant42] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Vec'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Vec'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate in_bounds'0 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq t_T'0) =
    [%#sslice23] UInt64.t'int self < Seq.length seq
  
  function view'2 (self : MutBorrow.t t_Vec'0) : Seq.seq t_T'0 =
    [%#smodel21] view'3 self.current
  
  predicate invariant'1 (self : MutBorrow.t t_T'0) =
    [%#sinvariant42] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate has_value'0 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq t_T'0) (out : t_T'0) =
    [%#sslice24] Seq.get seq (UInt64.t'int self) = out
  
  predicate resolve_elswhere'0 [@inline:trivial] (self : UInt64.t) (old' : Seq.seq t_T'0) (fin : Seq.seq t_T'0) =
    [%#sslice26] forall i : int . 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  let rec index_mut'0 (self:MutBorrow.t t_Vec'0) (index:UInt64.t) (return'  (ret:MutBorrow.t t_T'0))= {[@expl:index_mut 'self' type invariant] inv'4 self}
    {[@expl:index_mut requires] [%#svec9] in_bounds'0 index (view'2 self)}
    any
    [ return' (result:MutBorrow.t t_T'0)-> {inv'2 result}
      {[%#svec10] has_value'0 index (view'2 self) result.current}
      {[%#svec11] has_value'0 index (view'3 self.final) result.final}
      {[%#svec12] resolve_elswhere'0 index (view'2 self) (view'3 self.final)}
      {[%#svec13] Seq.length (view'3 self.final) = Seq.length (view'2 self)}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_1 : t_T'0)
  
  predicate resolve'4 (self : MutBorrow.t t_T'0) =
    [%#sresolve27] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_T'0) =
    resolve'4 _1
  
  predicate in_bounds'1 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq UInt64.t) =
    [%#sslice23] UInt64.t'int self < Seq.length seq
  
  function view'6 (self : t_Vec'1) : Seq.seq UInt64.t
  
  axiom view'6_spec : forall self : t_Vec'1 . [%#svec25] Seq.length (view'6 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'4 (self : t_Vec'1) : Seq.seq UInt64.t =
    [%#smodel28] view'6 self
  
  predicate has_value'1 [@inline:trivial] (self : UInt64.t) (seq : Seq.seq UInt64.t) (out : UInt64.t) =
    [%#sslice24] Seq.get seq (UInt64.t'int self) = out
  
  let rec index'0 (self:t_Vec'1) (index:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:index requires] [%#svec14] in_bounds'1 index (view'4 self)}
    any [ return' (result:UInt64.t)-> {[%#svec15] has_value'1 index (view'4 self) result} (! return' {result}) ] 
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'1) (ix : int) : UInt64.t =
    [%#sindex40] Seq.get (view'6 self) ix
  
  predicate invariant'4 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array50] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'3 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'6 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'6 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'1 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'5 (_1 : t_Sparse'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Sparse'0 [inv'5 x] . inv'5 x
  = (invariant'4 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'0 values
    end)
  
  predicate invariant'2 (self : MutBorrow.t t_Sparse'0) =
    [%#sinvariant42] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Sparse'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Sparse'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate resolve'5 (self : MutBorrow.t t_Sparse'0) =
    [%#sresolve27] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Sparse'0) =
    resolve'5 _1
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array29] UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i))) = i
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset int) (e : int) =
    [%#sfset43] Fset.mem e self
  
  function remove'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset51] Fset.remove e self
  
  function bounded_fset_len'0 [#"sparse_array.rs" 145 4 145 47] (s : Fset.fset int) (bnd : int) : ()
  
  axiom bounded_fset_len'0_def : forall s : Fset.fset int, bnd : int . ([%#ssparse_array44] forall x : int . contains'0 s x
   -> 0 <= x /\ x < bnd)
   -> ([%#ssparse_array45] bnd >= 0)
   -> bounded_fset_len'0 s bnd
  = ([%#ssparse_array48] if bnd > 0 then bounded_fset_len'0 (remove'0 s (bnd - 1)) (bnd - 1) else ())
  
  axiom bounded_fset_len'0_spec : forall s : Fset.fset int, bnd : int . ([%#ssparse_array44] forall x : int . contains'0 s x
   -> 0 <= x /\ x < bnd)  -> ([%#ssparse_array45] bnd >= 0)  -> ([%#ssparse_array46] Fset.cardinal s <= bnd)
  
  function insert'0 [@inline:trivial] (self : Fset.fset int) (e : int) : Fset.fset int =
    [%#sfset49] Fset.add e self
  
  function lemma_permutation_aux'0 [#"sparse_array.rs" 129 4 129 76] (self : t_Sparse'0) (seen : Fset.fset int) (i : int) (cur : int) : int
  
  
  axiom lemma_permutation_aux'0_def : forall self : t_Sparse'0, seen : Fset.fset int, i : int, cur : int . ([%#ssparse_array30] inv'5 self)
   -> ([%#ssparse_array31] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array32] 0 <= cur /\ cur < UInt64.t'int self.t_Sparse__size'0)
   -> ([%#ssparse_array33] forall k : int . contains'0 seen k
   -> 0 <= k
  /\ k < UInt64.t'int self.t_Sparse__size'0
  /\ (k = i \/ contains'0 seen (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 k))))
   -> ([%#ssparse_array34] i = cur
  \/ contains'0 seen i /\ contains'0 seen (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 cur)))
   -> ([%#ssparse_array35] not contains'0 seen cur)
   -> lemma_permutation_aux'0 self seen i cur
  = ([%#ssparse_array39] if UInt64.t'int (index_logic'1 self.t_Sparse__back'0 cur) = i then
    cur
  else
    let _ = bounded_fset_len'0 seen (UInt64.t'int self.t_Sparse__size'0) in lemma_permutation_aux'0 self (insert'0 seen cur) i (UInt64.t'int (index_logic'1 self.t_Sparse__back'0 cur))
  )
  
  axiom lemma_permutation_aux'0_spec : forall self : t_Sparse'0, seen : Fset.fset int, i : int, cur : int . ([%#ssparse_array30] inv'5 self)
   -> ([%#ssparse_array31] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array32] 0 <= cur /\ cur < UInt64.t'int self.t_Sparse__size'0)
   -> ([%#ssparse_array33] forall k : int . contains'0 seen k
   -> 0 <= k
  /\ k < UInt64.t'int self.t_Sparse__size'0
  /\ (k = i \/ contains'0 seen (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 k))))
   -> ([%#ssparse_array34] i = cur
  \/ contains'0 seen i /\ contains'0 seen (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 cur)))
   -> ([%#ssparse_array35] not contains'0 seen cur)
   -> ([%#ssparse_array36] 0 <= lemma_permutation_aux'0 self seen i cur
  /\ lemma_permutation_aux'0 self seen i cur < UInt64.t'int self.t_Sparse__size'0)
  && ([%#ssparse_array37] UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (lemma_permutation_aux'0 self seen i cur))
  = i)
  
  function lemma_permutation'0 [#"sparse_array.rs" 113 4 113 38] (self : t_Sparse'0) (i : int) : () =
    [%#ssparse_array20] let _ = lemma_permutation_aux'0 self (Fset.empty : Fset.fset int) i i in ()
  
  axiom lemma_permutation'0_spec : forall self : t_Sparse'0, i : int . ([%#ssparse_array16] inv'5 self)
   -> ([%#ssparse_array17] self.t_Sparse__n'0 = self.t_Sparse__size'0)
   -> ([%#ssparse_array18] 0 <= i /\ i < UInt64.t'int self.t_Sparse__size'0)  -> ([%#ssparse_array19] is_elt'0 self i)
  
  function view'5 (self : MutBorrow.t t_Vec'1) : Seq.seq UInt64.t =
    [%#smodel21] view'6 self.current
  
  predicate resolve_elswhere'1 [@inline:trivial] (self : UInt64.t) (old' : Seq.seq UInt64.t) (fin : Seq.seq UInt64.t) =
    [%#sslice26] forall i : int . 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  let rec index_mut'1 (self:MutBorrow.t t_Vec'1) (index:UInt64.t) (return'  (ret:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#svec9] in_bounds'1 index (view'5 self)}
    any
    [ return' (result:MutBorrow.t UInt64.t)-> {[%#svec10] has_value'1 index (view'5 self) result.current}
      {[%#svec11] has_value'1 index (view'6 self.final) result.final}
      {[%#svec12] resolve_elswhere'1 index (view'5 self) (view'6 self.final)}
      {[%#svec13] Seq.length (view'6 self.final) = Seq.length (view'5 self)}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t UInt64.t) =
    [%#sresolve27] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t UInt64.t) =
    resolve'6 _1
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : t_T'0 =
    [%#sindex40] Seq.get (view'3 self) ix
  
  function view'1 [#"sparse_array.rs" 38 4 38 33] (self : t_Sparse'0) : Seq.seq t_Option'0 =
    [%#ssparse_array22] Seq.create (UInt64.t'int self.t_Sparse__size'0) (fun (i : int) -> if is_elt'0 self i then
      C_Some'0 (index_logic'0 self.t_Sparse__values'0 i)
    else
      C_None'0
    )
  
  function view'0 (self : MutBorrow.t t_Sparse'0) : Seq.seq t_Option'0 =
    [%#smodel21] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec set'0[#"sparse_array.rs" 157 4 157 41] (self:MutBorrow.t t_Sparse'0) (i:UInt64.t) (v:t_T'0) (return'  (ret:()))= {[@expl:set 'self' type invariant] [%#ssparse_array3] inv'3 self}
    {[@expl:set 'v' type invariant] [%#ssparse_array4] inv'1 v}
    {[@expl:set requires] [%#ssparse_array5] UInt64.t'int i < Seq.length (view'0 self)}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = {inv'0 (self.current).t_Sparse__values'0}
        MutBorrow.borrow_final
          <t_Vec'0>
          {(self.current).t_Sparse__values'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 3}
          (fun (_ret':MutBorrow.t t_Vec'0) ->
             [ &_10 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_Sparse__values'0 = _ret'.final } } ] 
            s1)
      | s1 = index_mut'0 {_10} {i} (fun (_ret':MutBorrow.t t_T'0) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = {[@expl:type invariant] match _9 with
          | {current = x'0} -> inv'1 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _9 with
          | {current = x'1} -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &_9 <- { _9 with current = v } ] s3
      | s3 = {[@expl:type invariant] inv'2 _9} s4
      | s4 = -{resolve'1 _9}- s5
      | s5 = bb5 ]
    
    | bb5 = s0
      [ s0 = index'0 {(self.current).t_Sparse__idx'0} {i} (fun (_ret':UInt64.t) ->  [ &_13 <- _ret' ] s1) | s1 = bb6 ]
    
    | bb6 = s0
      [ s0 =  [ &index <- _13 ] s1
      | s1 =  [ &_16 <- UInt64.lt index (self.current).t_Sparse__n'0 ] s2
      | s2 = any [ br0 -> {_16 = false} (! bb11) | br1 -> {_16} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = index'0 {(self.current).t_Sparse__back'0} {index} (fun (_ret':UInt64.t) ->  [ &_21 <- _ret' ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_19 <- _21 = i ] s1 | s1 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ]  ] 
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'2 self}- s2 | s2 = bb16 ] 
    | bb10 = bb12
    | bb11 = bb12
    | bb12 = s0 [ s0 =  [ &_25 <- [%#ssparse_array0] () ] s1 | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = {[@expl:assertion] [%#ssparse_array1] UInt64.t'int (self.current).t_Sparse__n'0
        < UInt64.t'int (self.current).t_Sparse__size'0}
        s1
      | s1 = MutBorrow.borrow_final
          <t_Vec'1>
          {(self.current).t_Sparse__idx'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 4}
          (fun (_ret':MutBorrow.t t_Vec'1) ->
             [ &_31 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Sparse__idx'0 = _ret'.final } } ] 
            s2)
      | s2 = index_mut'1 {_31} {i} (fun (_ret':MutBorrow.t UInt64.t) ->  [ &_30 <- _ret' ] s3)
      | s3 = bb14 ]
    
    | bb14 = s0
      [ s0 =  [ &_30 <- { _30 with current = (self.current).t_Sparse__n'0 } ] s1
      | s1 = -{resolve'3 _30}- s2
      | s2 = MutBorrow.borrow_final
          <t_Vec'1>
          {(self.current).t_Sparse__back'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 5}
          (fun (_ret':MutBorrow.t t_Vec'1) ->
             [ &_35 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Sparse__back'0 = _ret'.final } } ] 
            s3)
      | s3 = index_mut'1 {_35} {(self.current).t_Sparse__n'0}
          (fun (_ret':MutBorrow.t UInt64.t) ->  [ &_34 <- _ret' ] s4)
      | s4 = bb15 ]
    
    | bb15 = s0
      [ s0 =  [ &_34 <- { _34 with current = i } ] s1
      | s1 = -{resolve'3 _34}- s2
      | s2 = UInt64.add {(self.current).t_Sparse__n'0} {[%#ssparse_array2] (1 : UInt64.t)}
          (fun (_ret':UInt64.t) ->  [ &self <- { self with current = { self.current with t_Sparse__n'0 = _ret' } } ] s3)
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb16 ]
    
    | bb16 = bb17
    | bb17 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Sparse'0 = self
    | & i : UInt64.t = i
    | & v : t_T'0 = v
    | & _9 : MutBorrow.t t_T'0 = Any.any_l ()
    | & _10 : MutBorrow.t t_Vec'0 = Any.any_l ()
    | & index : UInt64.t = Any.any_l ()
    | & _13 : UInt64.t = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _19 : bool = Any.any_l ()
    | & _21 : UInt64.t = Any.any_l ()
    | & _25 : () = Any.any_l ()
    | & _30 : MutBorrow.t UInt64.t = Any.any_l ()
    | & _31 : MutBorrow.t t_Vec'1 = Any.any_l ()
    | & _34 : MutBorrow.t UInt64.t = Any.any_l ()
    | & _35 : MutBorrow.t t_Vec'1 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:set ensures #0] [%#ssparse_array6] Seq.length (view'1 self.final)
      = Seq.length (view'0 self)}
      {[@expl:set ensures #1] [%#ssparse_array7] forall j : int . 0 <= j
      /\ j < Seq.length (view'0 self) /\ j <> UInt64.t'int i
       -> Seq.get (view'1 self.final) j = Seq.get (view'0 self) j}
      {[@expl:set ensures #2] [%#ssparse_array8] Seq.get (view'1 self.final) (UInt64.t'int i) = C_Some'0 v}
      (! return' {result}) ]

end
module M_sparse_array__create [#"sparse_array.rs" 179 0 179 56]
  let%span ssparse_array0 = "sparse_array.rs" 180 64 180 65
  let%span ssparse_array1 = "sparse_array.rs" 180 83 180 84
  let%span ssparse_array2 = "sparse_array.rs" 180 26 180 27
  let%span ssparse_array3 = "sparse_array.rs" 179 34 179 39
  let%span ssparse_array4 = "sparse_array.rs" 179 47 179 56
  let%span ssparse_array5 = "sparse_array.rs" 177 10 177 27
  let%span ssparse_array6 = "sparse_array.rs" 178 10 178 65
  let%span svec7 = "../../creusot-contracts/src/std/vec.rs" 186 22 186 41
  let%span svec8 = "../../creusot-contracts/src/std/vec.rs" 187 22 187 76
  let%span ssparse_array9 = "sparse_array.rs" 40 12 41 82
  let%span svec10 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex11 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span ssparse_array12 = "sparse_array.rs" 87 20 87 75
  let%span ssparse_array13 = "sparse_array.rs" 68 12 74 68
  let%span svec14 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq15 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed16 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate inv'0 (_1 : t_T'0)
  
  predicate invariant'3 (self : t_T'0) =
    [%#sboxed16] inv'0 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : Seq.seq t_T'0) =
    [%#sseq15] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'3 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Seq.seq t_T'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : t_Vec'0 . [%#svec10] Seq.length (view'1 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate invariant'1 (self : t_Vec'0) =
    [%#svec14] inv'3 (view'1 self)
  
  predicate inv'2 (_1 : t_Vec'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Vec'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : t_T'0 =
    [%#sindex11] Seq.get (view'1 self) ix
  
  let rec from_elem'0 (elem:t_T'0) (n:UInt64.t) (return'  (ret:t_Vec'0))= {[@expl:from_elem 'elem' type invariant] inv'0 elem}
    any
    [ return' (result:t_Vec'0)-> {inv'2 result}
      {[%#svec7] Seq.length (view'1 result) = UInt64.t'int n}
      {[%#svec8] forall i : int . 0 <= i /\ i < UInt64.t'int n  -> index_logic'0 result i = elem}
      (! return' {result}) ]
  
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  function view'2 (self : t_Vec'1) : Seq.seq UInt64.t
  
  axiom view'2_spec : forall self : t_Vec'1 . [%#svec10] Seq.length (view'2 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'1) (ix : int) : UInt64.t =
    [%#sindex11] Seq.get (view'2 self) ix
  
  let rec from_elem'1 (elem:UInt64.t) (n:UInt64.t) (return'  (ret:t_Vec'1))= any
    [ return' (result:t_Vec'1)-> {[%#svec7] Seq.length (view'2 result) = UInt64.t'int n}
      {[%#svec8] forall i : int . 0 <= i /\ i < UInt64.t'int n  -> index_logic'1 result i = elem}
      (! return' {result}) ]
  
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'0;
      t_Sparse__idx'0: t_Vec'1;
      t_Sparse__back'0: t_Vec'1 }
  
  predicate invariant'0 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array13] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'2 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'2 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'1 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'1 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'1 x] . inv'1 x
  = (invariant'0 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'2 values
    end)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array12] UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i))) = i
  
  function view'0 [#"sparse_array.rs" 38 4 38 33] (self : t_Sparse'0) : Seq.seq t_Option'0 =
    [%#ssparse_array9] Seq.create (UInt64.t'int self.t_Sparse__size'0) (fun (i : int) -> if is_elt'0 self i then
      C_Some'0 (index_logic'0 self.t_Sparse__values'0 i)
    else
      C_None'0
    )
  
  meta "compute_max_steps" 1000000
  
  let rec create'0[#"sparse_array.rs" 179 0 179 56] (sz:UInt64.t) (dummy:t_T'0) (return'  (ret:t_Sparse'0))= {[@expl:create 'dummy' type invariant] [%#ssparse_array3] inv'0 dummy}
    (! bb0
    [ bb0 = s0 [ s0 = from_elem'0 {dummy} {sz} (fun (_ret':t_Vec'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = from_elem'1 {[%#ssparse_array0] (0 : UInt64.t)} {sz} (fun (_ret':t_Vec'1) ->  [ &_9 <- _ret' ] s1)
      | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 = from_elem'1 {[%#ssparse_array1] (0 : UInt64.t)} {sz} (fun (_ret':t_Vec'1) ->  [ &_11 <- _ret' ] s1)
      | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 = 
        [ &_0 <- { t_Sparse__size'0 = sz;
                   t_Sparse__n'0 = ([%#ssparse_array2] (0 : UInt64.t));
                   t_Sparse__values'0 = _6;
                   t_Sparse__idx'0 = _9;
                   t_Sparse__back'0 = _11 } ]
        
        s1
      | s1 = bb4 ]
    
    | bb4 = bb5
    | bb5 = bb6
    | bb6 = return' {_0} ]
    )
    [ & _0 : t_Sparse'0 = Any.any_l ()
    | & sz : UInt64.t = sz
    | & dummy : t_T'0 = dummy
    | & _6 : t_Vec'0 = Any.any_l ()
    | & _9 : t_Vec'1 = Any.any_l ()
    | & _11 : t_Vec'1 = Any.any_l () ]
    
    [ return' (result:t_Sparse'0)-> {[@expl:create result type invariant] [%#ssparse_array4] inv'1 result}
      {[@expl:create ensures #0] [%#ssparse_array5] result.t_Sparse__size'0 = sz}
      {[@expl:create ensures #1] [%#ssparse_array6] forall i : int . 0 <= i /\ i < UInt64.t'int sz
       -> Seq.get (view'0 result) i = C_None'0}
      (! return' {result}) ]

end
module M_sparse_array__f [#"sparse_array.rs" 185 0 185 10]
  let%span ssparse_array0 = "sparse_array.rs" 186 18 186 19
  let%span ssparse_array1 = "sparse_array.rs" 187 23 187 25
  let%span ssparse_array2 = "sparse_array.rs" 188 23 188 25
  let%span ssparse_array3 = "sparse_array.rs" 189 22 189 23
  let%span ssparse_array4 = "sparse_array.rs" 190 22 190 23
  let%span ssparse_array5 = "sparse_array.rs" 191 18 191 40
  let%span ssparse_array6 = "sparse_array.rs" 193 10 193 11
  let%span ssparse_array7 = "sparse_array.rs" 193 13 193 14
  let%span ssparse_array8 = "sparse_array.rs" 194 10 194 11
  let%span ssparse_array9 = "sparse_array.rs" 194 13 194 14
  let%span ssparse_array10 = "sparse_array.rs" 195 14 195 15
  let%span ssparse_array11 = "sparse_array.rs" 196 14 196 15
  let%span ssparse_array12 = "sparse_array.rs" 197 18 200 5
  let%span ssparse_array13 = "sparse_array.rs" 201 18 204 5
  let%span ssparse_array14 = "sparse_array.rs" 206 14 206 15
  let%span ssparse_array15 = "sparse_array.rs" 207 14 207 15
  let%span ssparse_array16 = "sparse_array.rs" 208 18 208 40
  let%span ssparse_array17 = "sparse_array.rs" 210 14 210 15
  let%span ssparse_array18 = "sparse_array.rs" 211 14 211 15
  let%span ssparse_array19 = "sparse_array.rs" 212 18 212 40
  let%span ssparse_array20 = "sparse_array.rs" 214 14 214 15
  let%span ssparse_array21 = "sparse_array.rs" 215 14 215 15
  let%span ssparse_array22 = "sparse_array.rs" 216 18 216 40
  let%span ssparse_array23 = "sparse_array.rs" 179 47 179 56
  let%span ssparse_array24 = "sparse_array.rs" 177 10 177 27
  let%span ssparse_array25 = "sparse_array.rs" 178 10 178 65
  let%span ssparse_array26 = "sparse_array.rs" 101 16 101 20
  let%span ssparse_array27 = "sparse_array.rs" 92 15 92 31
  let%span ssparse_array28 = "sparse_array.rs" 93 14 96 5
  let%span ssparse_array29 = "sparse_array.rs" 97 14 100 5
  let%span ssparse_array30 = "sparse_array.rs" 157 20 157 24
  let%span ssparse_array31 = "sparse_array.rs" 153 15 153 31
  let%span ssparse_array32 = "sparse_array.rs" 154 14 154 43
  let%span ssparse_array33 = "sparse_array.rs" 155 14 155 93
  let%span ssparse_array34 = "sparse_array.rs" 156 14 156 37
  let%span smodel35 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span ssparse_array36 = "sparse_array.rs" 40 12 41 82
  let%span smodel37 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span ssparse_array38 = "sparse_array.rs" 87 20 87 75
  let%span sindex39 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span ssparse_array40 = "sparse_array.rs" 68 12 74 68
  let%span svec41 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sinvariant42 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sinvariant43 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'0;
      t_Sparse__idx'0: t_Vec'1;
      t_Sparse__back'0: t_Vec'1 }
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : t_Vec'0) : Seq.seq Int32.t
  
  axiom view'4_spec : forall self : t_Vec'0 . [%#svec41] Seq.length (view'4 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'5 (self : t_Vec'1) : Seq.seq UInt64.t
  
  axiom view'5_spec : forall self : t_Vec'1 . [%#svec41] Seq.length (view'5 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'1) (ix : int) : UInt64.t =
    [%#sindex39] Seq.get (view'5 self) ix
  
  predicate invariant'0 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array40] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'4 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'5 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'5 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'1 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'0 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> true
    end)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 Int32.t
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array38] UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i))) = i
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : Int32.t =
    [%#sindex39] Seq.get (view'4 self) ix
  
  function view'1 [#"sparse_array.rs" 38 4 38 33] (self : t_Sparse'0) : Seq.seq t_Option'1 =
    [%#ssparse_array36] Seq.create (UInt64.t'int self.t_Sparse__size'0) (fun (i : int) -> if is_elt'0 self i then
      C_Some'1 (index_logic'0 self.t_Sparse__values'0 i)
    else
      C_None'1
    )
  
  let rec create'0 (sz:UInt64.t) (dummy:Int32.t) (return'  (ret:t_Sparse'0))= any
    [ return' (result:t_Sparse'0)-> {[%#ssparse_array23] inv'0 result}
      {[%#ssparse_array24] result.t_Sparse__size'0 = sz}
      {[%#ssparse_array25] forall i : int . 0 <= i /\ i < UInt64.t'int sz  -> Seq.get (view'1 result) i = C_None'1}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  predicate invariant'1 (self : t_Sparse'0) =
    [%#sinvariant42] inv'0 self
  
  predicate inv'1 (_1 : t_Sparse'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Sparse'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function view'2 (self : t_Sparse'0) : Seq.seq t_Option'1 =
    [%#smodel35] view'1 self
  
  let rec get'0 (self:t_Sparse'0) (i:UInt64.t) (return'  (ret:t_Option'0))= {[@expl:get 'self' type invariant] [%#ssparse_array26] inv'1 self}
    {[@expl:get requires] [%#ssparse_array27] UInt64.t'int i < Seq.length (view'2 self)}
    any
    [ return' (result:t_Option'0)-> {[%#ssparse_array28] match result with
        | C_None'0 -> Seq.get (view'2 self) (UInt64.t'int i) = C_None'1
        | C_Some'0 x -> Seq.get (view'2 self) (UInt64.t'int i) = C_Some'1 x
        end}
      {[%#ssparse_array29] match Seq.get (view'2 self) (UInt64.t'int i) with
        | C_None'1 -> result = C_None'0
        | C_Some'1 _ -> true
        end}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : MutBorrow.t t_Sparse'0) =
    [%#sinvariant43] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Sparse'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Sparse'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  function view'3 (self : MutBorrow.t t_Sparse'0) : Seq.seq t_Option'1 =
    [%#smodel37] view'1 self.current
  
  let rec set'0 (self:MutBorrow.t t_Sparse'0) (i:UInt64.t) (v:Int32.t) (return'  (ret:()))= {[@expl:set 'self' type invariant] [%#ssparse_array30] inv'2 self}
    {[@expl:set requires] [%#ssparse_array31] UInt64.t'int i < Seq.length (view'3 self)}
    any
    [ return' (result:())-> {[%#ssparse_array32] Seq.length (view'1 self.final) = Seq.length (view'3 self)}
      {[%#ssparse_array33] forall j : int . 0 <= j /\ j < Seq.length (view'3 self) /\ j <> UInt64.t'int i
       -> Seq.get (view'1 self.final) j = Seq.get (view'3 self) j}
      {[%#ssparse_array34] Seq.get (view'1 self.final) (UInt64.t'int i) = C_Some'1 v}
      (! return' {result}) ]
  
  
  function view'0 (self : Int32.t) : int =
    [%#smodel35] Int32.to_int self
  
  meta "compute_max_steps" 1000000
  
  let rec f'0[#"sparse_array.rs" 185 0 185 10] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &default <- [%#ssparse_array0] (0 : Int32.t) ] s1
      | s1 = create'0 {[%#ssparse_array1] (10 : UInt64.t)} {default} (fun (_ret':t_Sparse'0) ->  [ &a <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = create'0 {[%#ssparse_array2] (20 : UInt64.t)} {default} (fun (_ret':t_Sparse'0) ->  [ &b <- _ret' ] s1)
      | s1 = bb2 ]
    
    | bb2 = s0
      [ s0 = get'0 {a} {[%#ssparse_array3] (5 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &x <- _ret' ] s1) | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 = get'0 {b} {[%#ssparse_array4] (7 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &y <- _ret' ] s1) | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#ssparse_array5] x = C_None'0 /\ y = C_None'0} s1
      | s1 = {inv'0 a}
        MutBorrow.borrow_mut <t_Sparse'0> {a}
          (fun (_ret':MutBorrow.t t_Sparse'0) ->  [ &_13 <- _ret' ] -{inv'0 _ret'.final}-  [ &a <- _ret'.final ] s2)
      | s2 = set'0 {_13} {[%#ssparse_array6] (5 : UInt64.t)} {[%#ssparse_array7] (1 : Int32.t)}
          (fun (_ret':()) ->  [ &_12 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = {inv'0 b}
        MutBorrow.borrow_mut <t_Sparse'0> {b}
          (fun (_ret':MutBorrow.t t_Sparse'0) ->  [ &_15 <- _ret' ] -{inv'0 _ret'.final}-  [ &b <- _ret'.final ] s1)
      | s1 = set'0 {_15} {[%#ssparse_array8] (7 : UInt64.t)} {[%#ssparse_array9] (2 : Int32.t)}
          (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0
      [ s0 = get'0 {a} {[%#ssparse_array10] (5 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_16 <- _ret' ] s1)
      | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &x <- _16 ] s1
      | s1 = get'0 {b} {[%#ssparse_array11] (7 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_18 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &y <- _18 ] s1
      | s1 = {[@expl:assertion] [%#ssparse_array12] match x with
          | C_None'0 -> false
          | C_Some'0 z -> view'0 z = 1
          end}
        s2
      | s2 = {[@expl:assertion] [%#ssparse_array13] match y with
          | C_None'0 -> false
          | C_Some'0 z -> view'0 z = 2
          end}
        s3
      | s3 = get'0 {a} {[%#ssparse_array14] (7 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_24 <- _ret' ] s4)
      | s4 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &x <- _24 ] s1
      | s1 = get'0 {b} {[%#ssparse_array15] (5 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_26 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = s0
      [ s0 =  [ &y <- _26 ] s1
      | s1 = {[@expl:assertion] [%#ssparse_array16] x = C_None'0 /\ y = C_None'0} s2
      | s2 = get'0 {a} {[%#ssparse_array17] (0 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_30 <- _ret' ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 =  [ &x <- _30 ] s1
      | s1 = get'0 {b} {[%#ssparse_array18] (0 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_32 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0
      [ s0 =  [ &y <- _32 ] s1
      | s1 = {[@expl:assertion] [%#ssparse_array19] x = C_None'0 /\ y = C_None'0} s2
      | s2 = get'0 {a} {[%#ssparse_array20] (9 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_36 <- _ret' ] s3)
      | s3 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &x <- _36 ] s1
      | s1 = get'0 {b} {[%#ssparse_array21] (9 : UInt64.t)} (fun (_ret':t_Option'0) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 =  [ &y <- _38 ] s1
      | s1 = {[@expl:assertion] [%#ssparse_array22] x = C_None'0 /\ y = C_None'0} s2
      | s2 = bb15 ]
    
    | bb15 = bb16
    | bb16 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & default : Int32.t = Any.any_l ()
    | & a : t_Sparse'0 = Any.any_l ()
    | & b : t_Sparse'0 = Any.any_l ()
    | & x : t_Option'0 = Any.any_l ()
    | & y : t_Option'0 = Any.any_l ()
    | & _12 : () = Any.any_l ()
    | & _13 : MutBorrow.t t_Sparse'0 = Any.any_l ()
    | & _14 : () = Any.any_l ()
    | & _15 : MutBorrow.t t_Sparse'0 = Any.any_l ()
    | & _16 : t_Option'0 = Any.any_l ()
    | & _18 : t_Option'0 = Any.any_l ()
    | & _24 : t_Option'0 = Any.any_l ()
    | & _26 : t_Option'0 = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _32 : t_Option'0 = Any.any_l ()
    | & _36 : t_Option'0 = Any.any_l ()
    | & _38 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_sparse_array__qyi1509881402265219485__resolve_coherence__refines [#"sparse_array.rs" 60 4 60 31] (* <Sparse<T> as creusot_contracts::Resolve> *)
  let%span ssparse_array0 = "sparse_array.rs" 60 4 60 31
  let%span ssparse_array1 = "sparse_array.rs" 51 12 51 72
  let%span ssparse_array2 = "sparse_array.rs" 40 12 41 82
  let%span svec3 = "../../creusot-contracts/src/std/vec.rs" 54 20 54 83
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span ssparse_array6 = "sparse_array.rs" 87 20 87 75
  let%span sindex7 = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span svec8 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span ssparse_array9 = "sparse_array.rs" 68 12 74 68
  let%span svec10 = "../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  let%span sseq11 = "../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed12 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use mach.int.Int
  use seq.Seq
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner'0; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  type t_Sparse'0  =
    { t_Sparse__size'0: UInt64.t;
      t_Sparse__n'0: UInt64.t;
      t_Sparse__values'0: t_Vec'0;
      t_Sparse__idx'0: t_Vec'1;
      t_Sparse__back'0: t_Vec'1 }
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'1 (self : t_Vec'1) : Seq.seq UInt64.t
  
  axiom view'1_spec : forall self : t_Vec'1 . [%#svec8] Seq.length (view'1 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate resolve'3 (_1 : UInt64.t) =
    true
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'1) (ix : int) : UInt64.t =
    [%#sindex7] Seq.get (view'1 self) ix
  
  predicate resolve'5 (self : t_Vec'1) =
    [%#svec3] forall i : int . 0 <= i /\ i < Seq.length (view'1 self)  -> resolve'3 (index_logic'1 self i)
  
  predicate resolve'1 (_1 : t_Vec'1) =
    resolve'5 _1
  
  type t_T'0
  
  function view'2 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : t_Vec'0 . [%#svec8] Seq.length (view'2 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate resolve'8 (_1 : t_T'0)
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : t_T'0 =
    [%#sindex7] Seq.get (view'2 self) ix
  
  predicate resolve'6 (self : t_Vec'0) =
    [%#svec3] forall i : int . 0 <= i /\ i < Seq.length (view'2 self)  -> resolve'8 (index_logic'0 self i)
  
  predicate resolve'2 (_1 : t_Vec'0) =
    resolve'6 _1
  
  predicate structural_resolve'0 (_1 : t_Sparse'0) =
    match _1 with
      | {t_Sparse__size'0 = x0 ; t_Sparse__n'0 = x1 ; t_Sparse__values'0 = x2 ; t_Sparse__idx'0 = x3 ; t_Sparse__back'0 = x4} -> resolve'1 x4
      /\ resolve'1 x3 /\ resolve'2 x2 /\ resolve'3 x1 /\ resolve'3 x0
      end
  
  predicate invariant'1 [#"sparse_array.rs" 66 4 66 30] (self : t_Sparse'0) =
    [%#ssparse_array9] UInt64.t'int self.t_Sparse__n'0 <= UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'2 self.t_Sparse__values'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__idx'0) = UInt64.t'int self.t_Sparse__size'0
    /\ Seq.length (view'1 self.t_Sparse__back'0) = UInt64.t'int self.t_Sparse__size'0
    /\ (forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__n'0
     -> (let j = index_logic'1 self.t_Sparse__back'0 i in 0 <= UInt64.t'int j
    /\ UInt64.t'int j < UInt64.t'int self.t_Sparse__size'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 (UInt64.t'int j)) = i))
  
  predicate inv'5 (_1 : t_T'0)
  
  predicate invariant'4 (self : t_T'0) =
    [%#sboxed12] inv'5 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  predicate invariant'3 (self : Seq.seq t_T'0) =
    [%#sseq11] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'3 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq t_T'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Vec'0) =
    [%#svec10] inv'3 (view'2 self)
  
  predicate inv'2 (_1 : t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Vec'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate inv'1 (_1 : t_Sparse'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Sparse'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Sparse__size'0 = size ; t_Sparse__n'0 = n ; t_Sparse__values'0 = values ; t_Sparse__idx'0 = idx ; t_Sparse__back'0 = back} -> inv'2 values
    end)
  
  predicate invariant'0 (self : t_Sparse'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 (_1 : t_Sparse'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Sparse'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate resolve'7 (self : t_Option'0) =
    [%#sresolve5] match self with
      | C_Some'0 x -> resolve'8 x
      | C_None'0 -> true
      end
  
  predicate resolve'4 (_1 : t_Option'0) =
    resolve'7 _1
  
  function is_elt'0 [#"sparse_array.rs" 86 4 86 36] (self : t_Sparse'0) (i : int) : bool =
    [%#ssparse_array6] UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i) < UInt64.t'int self.t_Sparse__n'0
    /\ UInt64.t'int (index_logic'1 self.t_Sparse__back'0 (UInt64.t'int (index_logic'1 self.t_Sparse__idx'0 i))) = i
  
  function view'0 [#"sparse_array.rs" 38 4 38 33] (self : t_Sparse'0) : Seq.seq t_Option'0 =
    [%#ssparse_array2] Seq.create (UInt64.t'int self.t_Sparse__size'0) (fun (i : int) -> if is_elt'0 self i then
      C_Some'0 (index_logic'0 self.t_Sparse__values'0 i)
    else
      C_None'0
    )
  
  predicate resolve'0 [#"sparse_array.rs" 49 4 49 28] (self : t_Sparse'0) =
    [%#ssparse_array1] forall i : int . 0 <= i /\ i < UInt64.t'int self.t_Sparse__size'0
     -> resolve'4 (Seq.get (view'0 self) i)
  
  goal refines : [%#ssparse_array0] forall self : t_Sparse'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ inv'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
