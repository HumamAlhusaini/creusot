module M_collections__roundtrip_hashmap_into_iter [#"collections.rs" 15 0 17 18]
  let%span scollections0 = "collections.rs" 18 18 18 31
  let%span scollections1 = "collections.rs" 20 14 20 30
  let%span scollections2 = "collections.rs" 23 8 26 80
  let%span scollections3 = "collections.rs" 28 20 28 87
  let%span scollections4 = "collections.rs" 29 20 29 69
  let%span scollections5 = "collections.rs" 14 10 14 24
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_map9 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 73 20 73 54
  let%span shash_map10 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span sfmap11 = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap14 = "../../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span shash_map15 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 199 20 199 24
  let%span shash_map16 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 205 20 205 33
  let%span shash_map17 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map18 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 78 14 78 45
  let%span shash_map19 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 79 27 79 29
  let%span shash_map20 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 83 15 83 32
  let%span shash_map21 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 84 15 84 32
  let%span shash_map22 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 85 14 85 42
  let%span shash_map23 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 87 8 87 104
  let%span sresolve24 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap25 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span smodel26 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfmap27 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap28 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap29 = "../../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap30 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap31 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap32 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap33 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap34 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap35 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap36 = "../../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sutil37 = "../../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil38 = "../../../creusot-contracts/src/util.rs" 56 10 56 28
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'0  =
    { t_HashMap__base'0: t_HashMap'1 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'1  =
    { _0'1: t_NonNull'0; _1'1: t_Layout'0; _2'0: () }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 tuple'1
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'2; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'1  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  predicate into_iter_pre'0 (self : t_HashMap'0) =
    [%#shash_map15] true
  
  type t_FMap'0
  
  function view'0 (self : t_HashMap'0) : t_FMap'0
  
  function view'2 (self : t_IntoIter'0) : t_FMap'0
  
  predicate into_iter_post'0 (self : t_HashMap'0) (res : t_IntoIter'0) =
    [%#shash_map16] view'0 self = view'2 res
  
  let rec into_iter'0 (self:t_HashMap'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter requires] [%#siter6] into_iter_pre'0 self}
    any [ return' (result:t_IntoIter'0)-> {[%#siter7] into_iter_post'0 self result} (! return' {result}) ] 
  
  predicate resolve'0 (_1 : t_IntoIter'0) =
    true
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap27] len'0 self >= 0
  
  predicate contains'0 (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq12] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function view'3 (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  axiom view'3_spec : forall self : t_FMap'0 . [%#sfmap35] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'3 m1 <> view'3 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1 =
    [%#sfmap28] Map.get (view'3 self) k
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0 =
    [%#sfmap11] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate produces'0 (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0) =
    [%#shash_map10] len'0 (view'2 self) = Seq.length visited + len'0 (view'2 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'2 self) (deep_model'0 k) = C_Some'0 v /\ get'0 (view'2 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'2 o) k = C_Some'0 v
     -> get'0 (view'2 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'2 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'2 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  function produces_trans'0 (a : t_IntoIter'0) (ab : Seq.seq tuple'0) (b : t_IntoIter'0) (bc : Seq.seq tuple'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_map23] let _ = () in ()
  
  axiom produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq tuple'0, b : t_IntoIter'0, bc : Seq.seq tuple'0, c : t_IntoIter'0 . ([%#shash_map20] produces'0 a ab b)
   -> ([%#shash_map21] produces'0 b bc c)  -> ([%#shash_map22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IntoIter'0) : () =
    [%#shash_map19] ()
  
  axiom produces_refl'0_spec : forall self : t_IntoIter'0 . [%#shash_map18] produces'0 self (Seq.empty : Seq.seq tuple'0) self
  
  predicate resolve'1 (self : MutBorrow.t t_IntoIter'0) =
    [%#sresolve24] self.final = self.current
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap32] view'3 self = view'3 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap30] ext_eq'0 self other  -> self = other)
  && ([%#sfmap31] (forall k : t_DeepModelTy'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function empty'0  : t_FMap'0
  
  axiom empty'0_spec : ([%#sfmap33] len'0 empty'0 = 0) && ([%#sfmap34] view'3 empty'0 = Const.const (C_None'1))
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap25] ext_eq'0 self empty'0
  
  function view'1 (self : MutBorrow.t t_IntoIter'0) : t_FMap'0 =
    [%#smodel26] view'2 self.current
  
  predicate completed'0 (self : MutBorrow.t t_IntoIter'0) =
    [%#shash_map9] resolve'1 self /\ is_empty'0 (view'1 self)
  
  predicate from_iter_post'0 (prod : Seq.seq tuple'0) (res : t_HashMap'0) =
    [%#shash_map17] forall k : t_DeepModelTy'0, v : t_V'0 . (get'0 (view'0 res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K'0 . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _0'0 = k1; _1'0 = v }
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._0'0 <> k))
  
  let rec collect'0 (self:t_IntoIter'0) (return'  (ret:t_HashMap'0))= any
    [ return' (result:t_HashMap'0)-> {[%#siter8] exists done' : MutBorrow.t t_IntoIter'0, prod : Seq.seq tuple'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : bool =
    [%#sfmap13] get_unsized'0 self k <> C_None'1
  
  function unwrap'0 (op : t_Option'1) : t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'1 . ([%#sutil37] op <> C_None'1)
   -> ([%#sutil38] C_Some'1 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap36] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap29] lookup_unsized'0 self k
  
  function index_logic'0 [@inline:trivial] (self : t_FMap'0) (key : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap14] lookup'0 self key
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_into_iter'0[#"collections.rs" 15 0 17 18] (xs:t_HashMap'0) (return'  (ret:t_HashMap'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &xs_snap <- [%#scollections0] xs ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = into_iter'0 {xs} (fun (_ret':t_IntoIter'0) ->  [ &it <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &it0 <- [%#scollections1] it ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = collect'0 {it} (fun (_ret':t_HashMap'0) ->  [ &r <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#scollections2] exists prod : Seq.seq tuple'0, it1 : MutBorrow.t t_IntoIter'0 . completed'0 it1
        /\ produces'0 it0 prod it1.current
        /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 r) k = C_Some'0 v
         -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 prod { _0'0 = k1; _1'0 = v }))}
        s1
      | s1 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:assertion] [%#scollections3] forall k : t_DeepModelTy'0 . contains'1 (view'0 r) k
        = contains'1 (view'0 xs_snap) k}
        s1
      | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#scollections4] forall k : t_DeepModelTy'0 . index_logic'0 (view'0 r) k
        = index_logic'0 (view'0 xs_snap) k}
        s1
      | s1 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return' {_0} ]
    )
    [ & _0 : t_HashMap'0 = Any.any_l ()
    | & xs : t_HashMap'0 = xs
    | & xs_snap : t_HashMap'0 = Any.any_l ()
    | & it : t_IntoIter'0 = Any.any_l ()
    | & it0 : t_IntoIter'0 = Any.any_l ()
    | & r : t_HashMap'0 = Any.any_l () ]
    
    [ return' (result:t_HashMap'0)-> {[@expl:roundtrip_hashmap_into_iter ensures] [%#scollections5] view'0 result
      = view'0 xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter [#"collections.rs" 34 0 34 97]
  let%span scollections0 = "collections.rs" 36 14 36 30
  let%span scollections1 = "collections.rs" 40 4 43 77
  let%span scollections2 = "collections.rs" 33 10 33 98
  let%span shash_map3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 28 30 28 46
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_map5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 125 20 125 54
  let%span shash_map6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span sfmap7 = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel8 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq9 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span shash_map11 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map12 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 130 14 130 45
  let%span shash_map13 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 131 27 131 29
  let%span shash_map14 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 135 15 135 32
  let%span shash_map15 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 136 15 136 32
  let%span shash_map16 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 137 14 137 42
  let%span shash_map17 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 139 8 139 104
  let%span sresolve18 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap19 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span smodel20 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfmap21 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap22 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap23 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap24 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap25 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap26 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap27 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap28 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'1  =
    { t_RawTable__table'1: t_RawTableInner'0; t_RawTable__alloc'1: (); t_RawTable__marker'1: () }
  
  type t_HashMap'3  =
    { t_HashMap__hash_builder'1: t_RandomState'0; t_HashMap__table'1: t_RawTable'1 }
  
  type t_HashMap'1  =
    { t_HashMap__base'1: t_HashMap'3 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'1  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_FMap'1
  
  function view'4 (self : t_HashMap'1) : t_FMap'1
  
  function view'1 (self : t_HashMap'1) : t_FMap'1 =
    [%#smodel10] view'4 self
  
  function view'2 (self : t_Iter'0) : t_FMap'1
  
  let rec iter'0 (self:t_HashMap'1) (return'  (ret:t_Iter'0))= any
    [ return' (result:t_Iter'0)-> {[%#shash_map3] view'1 self = view'2 result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'2  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'0  =
    { t_HashMap__base'0: t_HashMap'2 }
  
  predicate resolve'0 (_1 : t_Iter'0) =
    true
  
  type t_K'0
  
  type t_V'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: t_V'0 }
  
  function len'0 (self : t_FMap'1) : int
  
  axiom len'0_spec : forall self : t_FMap'1 . [%#sfmap21] len'0 self >= 0
  
  predicate contains'0 (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq9] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy'0
  
  type t_Option'2  =
    | C_None'0
    | C_Some'1 t_V'0
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V'0
  
  function view'6 (self : t_FMap'1) : Map.map t_DeepModelTy'0 t_Option'3
  
  axiom view'6_spec : forall self : t_FMap'1 . [%#sfmap28] forall m1 : t_FMap'1, m2 : t_FMap'1 . m1 <> m2
   -> view'6 m1 <> view'6 m2
  
  function get_unsized'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'3 =
    [%#sfmap22] Map.get (view'6 self) k
  
  function get'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'2 =
    [%#sfmap7] match get_unsized'1 self k with
      | C_None'3 -> C_None'0
      | C_Some'3 x -> C_Some'1 x
      end
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel8] deep_model'1 self
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq tuple'0) (o : t_Iter'0) =
    [%#shash_map6] len'0 (view'2 self) = Seq.length visited + len'0 (view'2 o)
    /\ (forall k : t_K'0, v : t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'1 (view'2 self) (deep_model'0 k) = C_Some'1 v /\ get'1 (view'2 o) (deep_model'0 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'2 o) k = C_Some'1 v
     -> get'1 (view'2 self) k = C_Some'1 v
    /\ not (exists k2 : t_K'0, v2 : t_V'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'2 self) k = C_Some'1 v
     -> (exists k2 : t_K'0 . deep_model'0 k2 = k /\ contains'0 visited { _0'0 = k2; _1'0 = v })
    \/ get'1 (view'2 o) k = C_Some'1 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq tuple'0) (b : t_Iter'0) (bc : Seq.seq tuple'0) (c : t_Iter'0) : ()
  
   =
    [%#shash_map17] let _ = () in ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq tuple'0, b : t_Iter'0, bc : Seq.seq tuple'0, c : t_Iter'0 . ([%#shash_map14] produces'0 a ab b)
   -> ([%#shash_map15] produces'0 b bc c)  -> ([%#shash_map16] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#shash_map13] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#shash_map12] produces'0 self (Seq.empty : Seq.seq tuple'0) self
  
  predicate resolve'1 (self : MutBorrow.t t_Iter'0) =
    [%#sresolve18] self.final = self.current
  
  function ext_eq'0 (self : t_FMap'1) (other : t_FMap'1) : bool =
    [%#sfmap25] view'6 self = view'6 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'1, other : t_FMap'1 . ([%#sfmap23] ext_eq'0 self other  -> self = other)
  && ([%#sfmap24] (forall k : t_DeepModelTy'0 . get_unsized'1 self k = get_unsized'1 other k)  -> ext_eq'0 self other)
  
  function empty'0  : t_FMap'1
  
  axiom empty'0_spec : ([%#sfmap26] len'0 empty'0 = 0) && ([%#sfmap27] view'6 empty'0 = Const.const (C_None'3))
  
  function is_empty'0 (self : t_FMap'1) : bool =
    [%#sfmap19] ext_eq'0 self empty'0
  
  function view'3 (self : MutBorrow.t t_Iter'0) : t_FMap'1 =
    [%#smodel20] view'2 self.current
  
  predicate completed'0 (self : MutBorrow.t t_Iter'0) =
    [%#shash_map5] resolve'1 self /\ is_empty'0 (view'3 self)
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'2
    | C_Some'0 t_V'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'2 t_V'0
  
  function view'5 (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  axiom view'5_spec : forall self : t_FMap'0 . [%#sfmap28] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'5 m1 <> view'5 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1 =
    [%#sfmap22] Map.get (view'5 self) k
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0 =
    [%#sfmap7] match get_unsized'0 self k with
      | C_None'1 -> C_None'2
      | C_Some'2 x -> C_Some'0 x
      end
  
  function view'0 (self : t_HashMap'0) : t_FMap'0
  
  predicate from_iter_post'0 (prod : Seq.seq tuple'0) (res : t_HashMap'0) =
    [%#shash_map11] forall k : t_DeepModelTy'0, v : t_V'0 . (get'0 (view'0 res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K'0 . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _0'0 = k1; _1'0 = v }
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._0'0 <> k))
  
  let rec collect'0 (self:t_Iter'0) (return'  (ret:t_HashMap'0))= any
    [ return' (result:t_HashMap'0)-> {[%#siter4] exists done' : MutBorrow.t t_Iter'0, prod : Seq.seq tuple'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter'0[#"collections.rs" 34 0 34 97] (xs:t_HashMap'1) (return'  (ret:t_HashMap'0))= (! bb0
    [ bb0 = s0 [ s0 = iter'0 {xs} (fun (_ret':t_Iter'0) ->  [ &it <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections0] it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {it} (fun (_ret':t_HashMap'0) ->  [ &r <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections1] exists prod : Seq.seq tuple'0, it1 : MutBorrow.t t_Iter'0 . completed'0 it1
        /\ produces'0 it0 prod it1.current
        /\ (forall k : t_DeepModelTy'0, v : t_V'0 . get'0 (view'0 r) k = C_Some'0 v
         -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 prod { _0'0 = k1; _1'0 = v }))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    )
    [ & _0 : t_HashMap'0 = Any.any_l ()
    | & xs : t_HashMap'1 = xs
    | & it : t_Iter'0 = Any.any_l ()
    | & it0 : t_Iter'0 = Any.any_l ()
    | & r : t_HashMap'0 = Any.any_l () ]
    
    [ return' (result:t_HashMap'0)-> {[@expl:roundtrip_hashmap_iter ensures] [%#scollections2] forall k : t_DeepModelTy'0, v : t_V'0 . (get'0 (view'0 result) k
      = C_Some'0 v)
      = (get'1 (view'1 xs) k = C_Some'1 v)}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter_mut [#"collections.rs" 50 0 52 24]
  let%span scollections0 = "collections.rs" 54 14 54 30
  let%span scollections1 = "collections.rs" 57 8 60 81
  let%span scollections2 = "collections.rs" 47 10 47 128
  let%span scollections3 = "collections.rs" 48 10 48 107
  let%span scollections4 = "collections.rs" 49 10 49 110
  let%span shash_map5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 31 30 31 57
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_map7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 177 20 177 54
  let%span shash_map8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span sfmap9 = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span smodel10 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq11 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span smodel12 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sfmap13 = "../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap14 = "../../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span shash_map15 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 233 20 235 112
  let%span shash_map16 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map17 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 182 14 182 45
  let%span shash_map18 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 183 27 183 29
  let%span shash_map19 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 187 15 187 32
  let%span shash_map20 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 188 15 188 32
  let%span shash_map21 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 189 14 189 42
  let%span shash_map22 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 191 8 191 104
  let%span sresolve23 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap24 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap25 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap26 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap27 = "../../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap28 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap29 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap30 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap31 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap32 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap33 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap34 = "../../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sutil35 = "../../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../../creusot-contracts/src/util.rs" 56 10 56 28
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'2  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'0  =
    { t_HashMap__base'0: t_HashMap'2 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_IterMut'1  =
    { t_IterMut__inner'0: t_RawIter'0; t_IterMut__marker'0: () }
  
  type t_IterMut'0  =
    { t_IterMut__base'0: t_IterMut'1 }
  
  type t_FMap'1
  
  type t_DeepModelTy'0
  
  type t_V'0
  
  type t_Option'3  =
    | C_None'2
    | C_Some'3 t_V'0
  
  function view'6 (self : t_FMap'1) : Map.map t_DeepModelTy'0 t_Option'3
  
  axiom view'6_spec : forall self : t_FMap'1 . [%#sfmap33] forall m1 : t_FMap'1, m2 : t_FMap'1 . m1 <> m2
   -> view'6 m1 <> view'6 m2
  
  function get_unsized'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'3 =
    [%#sfmap26] Map.get (view'6 self) k
  
  function contains'2 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : bool =
    [%#sfmap13] get_unsized'1 self k <> C_None'2
  
  function view'2 (self : t_HashMap'0) : t_FMap'1
  
  type t_FMap'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'2 (MutBorrow.t t_V'0)
  
  function view'5 (self : t_FMap'0) : Map.map t_DeepModelTy'0 t_Option'1
  
  axiom view'5_spec : forall self : t_FMap'0 . [%#sfmap33] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'5 m1 <> view'5 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'1 =
    [%#sfmap26] Map.get (view'5 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : bool =
    [%#sfmap13] get_unsized'0 self k <> C_None'1
  
  function view'4 (self : t_IterMut'0) : t_FMap'0
  
  function unwrap'1 (op : t_Option'3) : t_V'0
  
  axiom unwrap'1_spec : forall op : t_Option'3 . ([%#sutil35] op <> C_None'2)
   -> ([%#sutil36] C_Some'3 (unwrap'1 op) = op)
  
  function lookup_unsized'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap34] unwrap'1 (get_unsized'1 self k)
  
  function lookup'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap27] lookup_unsized'1 self k
  
  function index_logic'1 [@inline:trivial] (self : t_FMap'1) (key : t_DeepModelTy'0) : t_V'0 =
    [%#sfmap14] lookup'1 self key
  
  function unwrap'0 (op : t_Option'1) : MutBorrow.t t_V'0
  
  axiom unwrap'0_spec : forall op : t_Option'1 . ([%#sutil35] op <> C_None'1)
   -> ([%#sutil36] C_Some'2 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : MutBorrow.t t_V'0 =
    [%#sfmap34] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : MutBorrow.t t_V'0 =
    [%#sfmap27] lookup_unsized'0 self k
  
  function index_logic'0 [@inline:trivial] (self : t_FMap'0) (key : t_DeepModelTy'0) : MutBorrow.t t_V'0 =
    [%#sfmap14] lookup'0 self key
  
  predicate into_iter_post'0 (self : MutBorrow.t t_HashMap'0) (res : t_IterMut'0) =
    [%#shash_map15] forall k : t_DeepModelTy'0 . contains'2 (view'2 self.current) k = contains'2 (view'2 self.final) k
    /\ (forall k : t_DeepModelTy'0 . contains'2 (view'2 self.current) k = contains'1 (view'4 res) k)
    /\ (forall k : t_DeepModelTy'0 . contains'2 (view'2 self.current) k
     -> index_logic'1 (view'2 self.current) k = (index_logic'0 (view'4 res) k).current
    /\ index_logic'1 (view'2 self.final) k = (index_logic'0 (view'4 res) k).final)
  
  let rec iter_mut'0 (self:MutBorrow.t t_HashMap'0) (return'  (ret:t_IterMut'0))= any
    [ return' (result:t_IterMut'0)-> {[%#shash_map5] into_iter_post'0 self result} (! return' {result}) ]
  
  
  type t_RawTable'1  =
    { t_RawTable__table'1: t_RawTableInner'0; t_RawTable__alloc'1: (); t_RawTable__marker'1: () }
  
  type t_HashMap'3  =
    { t_HashMap__hash_builder'1: t_RandomState'0; t_HashMap__table'1: t_RawTable'1 }
  
  type t_HashMap'1  =
    { t_HashMap__base'1: t_HashMap'3 }
  
  predicate resolve'1 (_1 : t_IterMut'0) =
    true
  
  type t_K'0
  
  type tuple'0  =
    { _0'0: t_K'0; _1'0: MutBorrow.t t_V'0 }
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap25] len'0 self >= 0
  
  predicate contains'0 (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq11] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V'0)
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy'0) : t_Option'0 =
    [%#sfmap9] match get_unsized'0 self k with
      | C_None'1 -> C_None'0
      | C_Some'2 x -> C_Some'0 x
      end
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel10] deep_model'1 self
  
  predicate produces'0 (self : t_IterMut'0) (visited : Seq.seq tuple'0) (o : t_IterMut'0) =
    [%#shash_map8] len'0 (view'4 self) = Seq.length visited + len'0 (view'4 o)
    /\ (forall k : t_K'0, v : MutBorrow.t t_V'0 . contains'0 visited { _0'0 = k; _1'0 = v }
     -> get'0 (view'4 self) (deep_model'1 k) = C_Some'0 v /\ get'0 (view'4 o) (deep_model'1 k) = C_None'0)
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'4 o) k = C_Some'0 v
     -> get'0 (view'4 self) k = C_Some'0 v
    /\ not (exists k2 : t_K'0, v2 : MutBorrow.t t_V'0 . deep_model'0 k2 = k
    /\ contains'0 visited { _0'0 = k2; _1'0 = v2 }))
    /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'4 self) k = C_Some'0 v
     -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 visited { _0'0 = k1; _1'0 = v })
    \/ get'0 (view'4 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._0'0 = deep_model'0 (Seq.get visited i2)._0'0
     -> i1 = i2)
  
  function produces_trans'0 (a : t_IterMut'0) (ab : Seq.seq tuple'0) (b : t_IterMut'0) (bc : Seq.seq tuple'0) (c : t_IterMut'0) : ()
  
   =
    [%#shash_map22] let _ = () in ()
  
  axiom produces_trans'0_spec : forall a : t_IterMut'0, ab : Seq.seq tuple'0, b : t_IterMut'0, bc : Seq.seq tuple'0, c : t_IterMut'0 . ([%#shash_map19] produces'0 a ab b)
   -> ([%#shash_map20] produces'0 b bc c)  -> ([%#shash_map21] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IterMut'0) : () =
    [%#shash_map18] ()
  
  axiom produces_refl'0_spec : forall self : t_IterMut'0 . [%#shash_map17] produces'0 self (Seq.empty : Seq.seq tuple'0) self
  
  predicate resolve'2 (self : MutBorrow.t t_IterMut'0) =
    [%#sresolve23] self.final = self.current
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap30] view'5 self = view'5 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap28] ext_eq'0 self other  -> self = other)
  && ([%#sfmap29] (forall k : t_DeepModelTy'0 . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function empty'0  : t_FMap'0
  
  axiom empty'0_spec : ([%#sfmap31] len'0 empty'0 = 0) && ([%#sfmap32] view'5 empty'0 = Const.const (C_None'1))
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap24] ext_eq'0 self empty'0
  
  function view'3 (self : MutBorrow.t t_IterMut'0) : t_FMap'0 =
    [%#smodel12] view'4 self.current
  
  predicate completed'0 (self : MutBorrow.t t_IterMut'0) =
    [%#shash_map7] resolve'2 self /\ is_empty'0 (view'3 self)
  
  function view'0 (self : t_HashMap'1) : t_FMap'0
  
  predicate from_iter_post'0 (prod : Seq.seq tuple'0) (res : t_HashMap'1) =
    [%#shash_map16] forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . (get'0 (view'0 res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K'0 . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _0'0 = k1; _1'0 = v }
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._0'0 <> k))
  
  let rec collect'0 (self:t_IterMut'0) (return'  (ret:t_HashMap'1))= any
    [ return' (result:t_HashMap'1)-> {[%#siter6] exists done' : MutBorrow.t t_IterMut'0, prod : Seq.seq tuple'0 . resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t t_HashMap'0) =
    [%#sresolve23] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_HashMap'0) =
    resolve'3 _1
  
  type t_Option'2  =
    | C_None'3
    | C_Some'1 t_V'0
  
  function get'1 [@inline:trivial] (self : t_FMap'1) (k : t_DeepModelTy'0) : t_Option'2 =
    [%#sfmap9] match get_unsized'1 self k with
      | C_None'2 -> C_None'3
      | C_Some'3 x -> C_Some'1 x
      end
  
  function view'1 (self : MutBorrow.t t_HashMap'0) : t_FMap'1 =
    [%#smodel12] view'2 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter_mut'0[#"collections.rs" 50 0 52 24] (xs:MutBorrow.t t_HashMap'0) (return'  (ret:t_HashMap'1))= (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_HashMap'0> {xs.current} {MutBorrow.get_id xs}
          (fun (_ret':MutBorrow.t t_HashMap'0) ->  [ &_6 <- _ret' ]  [ &xs <- { xs with current = _ret'.final } ] s1)
      | s1 = iter_mut'0 {_6} (fun (_ret':t_IterMut'0) ->  [ &it <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections0] it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {it} (fun (_ret':t_HashMap'1) ->  [ &r <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections1] exists prod : Seq.seq tuple'0, it1 : MutBorrow.t t_IterMut'0 . completed'0 it1
        /\ produces'0 it0 prod it1.current
        /\ (forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 r) k = C_Some'0 v
         -> (exists k1 : t_K'0 . deep_model'0 k1 = k /\ contains'0 prod { _0'0 = k1; _1'0 = v }))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = -{resolve'0 xs}- s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : t_HashMap'1 = Any.any_l ()
    | & xs : MutBorrow.t t_HashMap'0 = xs
    | & it : t_IterMut'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_HashMap'0 = Any.any_l ()
    | & it0 : t_IterMut'0 = Any.any_l ()
    | & r : t_HashMap'1 = Any.any_l () ]
    
    [ return' (result:t_HashMap'1)-> {[@expl:roundtrip_hashmap_iter_mut ensures #0] [%#scollections2] forall k : t_DeepModelTy'0, v : MutBorrow.t t_V'0 . get'0 (view'0 result) k
      = C_Some'0 v  -> get'1 (view'1 xs) k = C_Some'1 (v.current) /\ get'1 (view'2 xs.final) k = C_Some'1 (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] [%#scollections3] forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'1 xs) k
      = C_Some'1 v  -> contains'1 (view'0 result) k /\ (index_logic'0 (view'0 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] [%#scollections4] forall k : t_DeepModelTy'0, v : t_V'0 . get'1 (view'2 xs.final) k
      = C_Some'1 v  -> contains'1 (view'0 result) k /\ (index_logic'0 (view'0 result) k).final = v}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_into_iter [#"collections.rs" 66 0 66 90]
  let%span scollections0 = "collections.rs" 65 10 65 24
  let%span siter1 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter2 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_set4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 166 20 166 24
  let%span shash_set5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 172 20 172 33
  let%span shash_set6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 105 20 105 38
  let%span shash_set7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 99 8 99 38
  let%span shash_set8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span shash_set9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 110 14 110 45
  let%span shash_set10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 111 27 111 29
  let%span shash_set11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 115 15 115 32
  let%span shash_set12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 116 15 116 32
  let%span shash_set13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 117 14 117 42
  let%span shash_set14 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 119 8 119 43
  let%span smodel15 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set16 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset17 = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq18 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span shash_set19 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set20 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set21 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set22 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sseq23 = "../../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq24 = "../../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_AlignmentEnum'0  =
    | C_qy95zAlign1Shl0'0
    | C_qy95zAlign1Shl1'0
    | C_qy95zAlign1Shl2'0
    | C_qy95zAlign1Shl3'0
    | C_qy95zAlign1Shl4'0
    | C_qy95zAlign1Shl5'0
    | C_qy95zAlign1Shl6'0
    | C_qy95zAlign1Shl7'0
    | C_qy95zAlign1Shl8'0
    | C_qy95zAlign1Shl9'0
    | C_qy95zAlign1Shl10'0
    | C_qy95zAlign1Shl11'0
    | C_qy95zAlign1Shl12'0
    | C_qy95zAlign1Shl13'0
    | C_qy95zAlign1Shl14'0
    | C_qy95zAlign1Shl15'0
    | C_qy95zAlign1Shl16'0
    | C_qy95zAlign1Shl17'0
    | C_qy95zAlign1Shl18'0
    | C_qy95zAlign1Shl19'0
    | C_qy95zAlign1Shl20'0
    | C_qy95zAlign1Shl21'0
    | C_qy95zAlign1Shl22'0
    | C_qy95zAlign1Shl23'0
    | C_qy95zAlign1Shl24'0
    | C_qy95zAlign1Shl25'0
    | C_qy95zAlign1Shl26'0
    | C_qy95zAlign1Shl27'0
    | C_qy95zAlign1Shl28'0
    | C_qy95zAlign1Shl29'0
    | C_qy95zAlign1Shl30'0
    | C_qy95zAlign1Shl31'0
    | C_qy95zAlign1Shl32'0
    | C_qy95zAlign1Shl33'0
    | C_qy95zAlign1Shl34'0
    | C_qy95zAlign1Shl35'0
    | C_qy95zAlign1Shl36'0
    | C_qy95zAlign1Shl37'0
    | C_qy95zAlign1Shl38'0
    | C_qy95zAlign1Shl39'0
    | C_qy95zAlign1Shl40'0
    | C_qy95zAlign1Shl41'0
    | C_qy95zAlign1Shl42'0
    | C_qy95zAlign1Shl43'0
    | C_qy95zAlign1Shl44'0
    | C_qy95zAlign1Shl45'0
    | C_qy95zAlign1Shl46'0
    | C_qy95zAlign1Shl47'0
    | C_qy95zAlign1Shl48'0
    | C_qy95zAlign1Shl49'0
    | C_qy95zAlign1Shl50'0
    | C_qy95zAlign1Shl51'0
    | C_qy95zAlign1Shl52'0
    | C_qy95zAlign1Shl53'0
    | C_qy95zAlign1Shl54'0
    | C_qy95zAlign1Shl55'0
    | C_qy95zAlign1Shl56'0
    | C_qy95zAlign1Shl57'0
    | C_qy95zAlign1Shl58'0
    | C_qy95zAlign1Shl59'0
    | C_qy95zAlign1Shl60'0
    | C_qy95zAlign1Shl61'0
    | C_qy95zAlign1Shl62'0
    | C_qy95zAlign1Shl63'0
  
  type t_Alignment'0  =
    { t_Alignment__0'0: t_AlignmentEnum'0 }
  
  type t_Layout'0  =
    { t_Layout__size'0: UInt64.t; t_Layout__align'0: t_Alignment'0 }
  
  type tuple'0  =
    { _0'0: t_NonNull'0; _1'0: t_Layout'0; _2'0: () }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple'0
  
  type t_RawIntoIter'0  =
    { t_RawIntoIter__iter'0: t_RawIter'0; t_RawIntoIter__allocation'0: t_Option'0; t_RawIntoIter__marker'0: () }
  
  type t_IntoIter'2  =
    { t_IntoIter__inner'0: t_RawIntoIter'0 }
  
  type t_IntoIter'1  =
    { t_IntoIter__iter'0: t_IntoIter'2 }
  
  type t_IntoIter'0  =
    { t_IntoIter__base'0: t_IntoIter'1 }
  
  predicate into_iter_pre'0 (self : t_HashSet'0) =
    [%#shash_set4] true
  
  type t_DeepModelTy'0
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_IntoIter'0) : Fset.fset t_DeepModelTy'0
  
  predicate into_iter_post'0 (self : t_HashSet'0) (res : t_IntoIter'0) =
    [%#shash_set5] view'0 self = view'1 res
  
  let rec into_iter'0 (self:t_HashSet'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter requires] [%#siter1] into_iter_pre'0 self}
    any [ return' (result:t_IntoIter'0)-> {[%#siter2] into_iter_post'0 self result} (! return' {result}) ] 
  
  predicate resolve'0 (_1 : t_IntoIter'0) =
    true
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset17] Fset.mem e self
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq18] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_IntoIter'0) (visited : Seq.seq t_T'0) (end' : t_IntoIter'0) =
    [%#shash_set16] Fset.cardinal (view'1 start) = Seq.length visited + Fset.cardinal (view'1 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'1 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'1 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'1 start) (deep_model'0 x) /\ not contains'0 (view'1 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'1 end') x
     -> contains'0 (view'1 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  function concat_contains'0  : () =
    [%#sseq24] ()
  
  axiom concat_contains'0_spec : [%#sseq23] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_set22] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq t_T'0, b : t_IntoIter'0, bc : Seq.seq t_T'0, c : t_IntoIter'0 . ([%#shash_set19] set_produces'0 a ab b)
   -> ([%#shash_set20] set_produces'0 b bc c)  -> ([%#shash_set21] set_produces'0 a (Seq.(++) ab bc) c)
  
  predicate produces'0 (self : t_IntoIter'0) (visited : Seq.seq t_T'0) (o : t_IntoIter'0) =
    [%#shash_set7] set_produces'0 self visited o
  
  function produces_trans'0 (a : t_IntoIter'0) (ab : Seq.seq t_T'0) (b : t_IntoIter'0) (bc : Seq.seq t_T'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_set14] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'0_spec : forall a : t_IntoIter'0, ab : Seq.seq t_T'0, b : t_IntoIter'0, bc : Seq.seq t_T'0, c : t_IntoIter'0 . ([%#shash_set11] produces'0 a ab b)
   -> ([%#shash_set12] produces'0 b bc c)  -> ([%#shash_set13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IntoIter'0) : () =
    [%#shash_set10] ()
  
  axiom produces_refl'0_spec : forall self : t_IntoIter'0 . [%#shash_set9] produces'0 self (Seq.empty : Seq.seq t_T'0) self
  
  function view'2 (self : MutBorrow.t t_IntoIter'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel15] view'1 self.current
  
  predicate completed'0 (self : MutBorrow.t t_IntoIter'0) =
    [%#shash_set6] Fset.is_empty (view'2 self)
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set8] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_IntoIter'0) (return'  (ret:t_HashSet'0))= any
    [ return' (result:t_HashSet'0)-> {[%#siter3] exists done' : MutBorrow.t t_IntoIter'0, prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_into_iter'0[#"collections.rs" 66 0 66 90] (xs:t_HashSet'0) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter'0 {xs} (fun (_ret':t_IntoIter'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {_3} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : t_HashSet'0 = Any.any_l () | & xs : t_HashSet'0 = xs | & _3 : t_IntoIter'0 = Any.any_l () ] 
    [ return' (result:t_HashSet'0)-> {[@expl:roundtrip_hashset_into_iter ensures] [%#scollections0] view'0 result
      = view'0 xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_iter [#"collections.rs" 71 0 71 87]
  let%span scollections0 = "collections.rs" 70 10 70 24
  let%span shash_set1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 24 30 24 46
  let%span siter2 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span smodel3 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span shash_set4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 144 20 144 38
  let%span shash_set5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 138 8 138 38
  let%span shash_set6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span shash_set7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 149 14 149 45
  let%span shash_set8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 150 27 150 29
  let%span shash_set9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 154 15 154 32
  let%span shash_set10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 155 15 155 32
  let%span shash_set11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 156 14 156 42
  let%span shash_set12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 158 8 158 43
  let%span smodel13 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set14 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span sfset15 = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smodel16 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span shash_set18 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set19 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set20 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set21 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sseq22 = "../../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq23 = "../../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'1  =
    { t_RawTable__table'1: t_RawTableInner'0; t_RawTable__alloc'1: (); t_RawTable__marker'1: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'1: t_RandomState'0; t_HashMap__table'1: t_RawTable'1 }
  
  type t_HashSet'3  =
    { t_HashSet__map'1: t_HashMap'1 }
  
  type t_HashSet'1  =
    { t_HashSet__base'1: t_HashSet'3 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_DeepModelTy'0
  
  function view'3 (self : t_HashSet'1) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_HashSet'1) : Fset.fset t_DeepModelTy'0 =
    [%#smodel3] view'3 self
  
  function view'2 (self : t_Iter'0) : Fset.fset t_DeepModelTy'0
  
  let rec iter'0 (self:t_HashSet'1) (return'  (ret:t_Iter'0))= any
    [ return' (result:t_Iter'0)-> {[%#shash_set1] view'1 self = view'2 result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'2  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'2 }
  
  predicate resolve'0 (_1 : t_Iter'0) =
    true
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset15] Fset.mem e self
  
  function deep_model'1 (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel16] deep_model'1 self
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_Iter'0) (visited : Seq.seq t_T'0) (end' : t_Iter'0) =
    [%#shash_set14] Fset.cardinal (view'2 start) = Seq.length visited + Fset.cardinal (view'2 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 start) x
     -> (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1) \/ contains'0 (view'2 end') x)
    /\ (forall x : t_T'0 . contains'1 visited x
     -> contains'0 (view'2 start) (deep_model'0 x) /\ not contains'0 (view'2 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 end') x
     -> contains'0 (view'2 start) x /\ not (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  function concat_contains'0  : () =
    [%#sseq23] ()
  
  axiom concat_contains'0_spec : [%#sseq22] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'1 (Seq.(++) a b) x
  = contains'1 a x
  \/ contains'1 b x
  
  function set_produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
  
   =
    [%#shash_set21] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#shash_set18] set_produces'0 a ab b)
   -> ([%#shash_set19] set_produces'0 b bc c)  -> ([%#shash_set20] set_produces'0 a (Seq.(++) ab bc) c)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq t_T'0) (o : t_Iter'0) =
    [%#shash_set5] set_produces'0 self visited o
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
   =
    [%#shash_set12] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#shash_set9] produces'0 a ab b)
   -> ([%#shash_set10] produces'0 b bc c)  -> ([%#shash_set11] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#shash_set8] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#shash_set7] produces'0 self (Seq.empty : Seq.seq t_T'0) self
  
  function view'4 (self : MutBorrow.t t_Iter'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel13] view'2 self.current
  
  predicate completed'0 (self : MutBorrow.t t_Iter'0) =
    [%#shash_set4] Fset.is_empty (view'4 self)
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set6] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_Iter'0) (return'  (ret:t_HashSet'0))= any
    [ return' (result:t_HashSet'0)-> {[%#siter2] exists done' : MutBorrow.t t_Iter'0, prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_iter'0[#"collections.rs" 71 0 71 87] (xs:t_HashSet'1) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = iter'0 {xs} (fun (_ret':t_Iter'0) ->  [ &_3 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = collect'0 {_3} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_HashSet'0 = Any.any_l () | & xs : t_HashSet'1 = xs | & _3 : t_Iter'0 = Any.any_l () ] 
    [ return' (result:t_HashSet'0)-> {[@expl:roundtrip_hashset_iter ensures] [%#scollections0] view'0 result
      = view'1 xs}
      (! return' {result}) ]

end
module M_collections__hashset_intersection [#"collections.rs" 76 0 79 15]
  let%span scollections0 = "collections.rs" 75 10 75 42
  let%span shash_set1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 32 30 32 67
  let%span siter2 = "../../../creusot-contracts/src/std/iter.rs" 143 26 143 47
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span scopied5 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span scopied6 = "../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 105
  let%span scopied7 = "../../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span shash_set8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span scopied9 = "../../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied10 = "../../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied11 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied12 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied13 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span shash_set14 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 230 20 230 56
  let%span shash_set15 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 38
  let%span sfset16 = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span shash_set18 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 235 14 235 45
  let%span shash_set19 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 236 27 236 29
  let%span shash_set20 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 240 15 240 32
  let%span shash_set21 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 241 15 241 32
  let%span shash_set22 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 242 14 242 42
  let%span shash_set23 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 244 8 244 43
  let%span sresolve24 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel25 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set26 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set27 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set28 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set29 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set30 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span smodel31 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq32 = "../../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq33 = "../../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_Intersection'0  =
    { t_Intersection__iter'0: t_Iter'0; t_Intersection__other'0: t_HashSet'0 }
  
  type t_DeepModelTy'0
  
  function view'2 (self : t_Intersection'0) : Fset.fset t_DeepModelTy'0
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel4] view'0 self
  
  let rec intersection'0 (self:t_HashSet'0) (other:t_HashSet'0) (return'  (ret:t_Intersection'0))= any
    [ return' (result:t_Intersection'0)-> {[%#shash_set1] view'2 result = Fset.inter (view'1 self) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied'0  =
    { t_Copied__it'0: t_Intersection'0 }
  
  predicate inv'0 (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Intersection'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Intersection'0 [inv'1 x] . inv'1 x = true
  
  function iter'0 (self : t_Copied'0) : t_Intersection'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied5] inv'0 self  -> inv'1 (iter'0 self)
  
  let rec copied'0 (self:t_Intersection'0) (return'  (ret:t_Copied'0))= any
    [ return' (result:t_Copied'0)-> {[%#siter2] iter'0 result = self} (! return' {result}) ]
  
  
  predicate resolve'2 (_1 : t_Intersection'0) =
    true
  
  predicate resolve'1 (self : t_Copied'0) =
    [%#scopied9] resolve'2 (iter'0 self)
  
  predicate resolve'0 (_1 : t_Copied'0) =
    resolve'1 _1
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset16] Fset.mem e self
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'1 (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel31] deep_model'0 self
  
  predicate contains'2 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_Intersection'0) (visited : Seq.seq t_T'0) (end' : t_Intersection'0) =
    [%#shash_set26] Fset.cardinal (view'2 start) = Seq.length visited + Fset.cardinal (view'2 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 start) x
     -> (exists x1 : t_T'0 . deep_model'1 x1 = x /\ contains'2 visited x1) \/ contains'0 (view'2 end') x)
    /\ (forall x : t_T'0 . contains'2 visited x
     -> contains'0 (view'2 start) (deep_model'1 x) /\ not contains'0 (view'2 end') (deep_model'1 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 end') x
     -> contains'0 (view'2 start) x /\ not (exists x1 : t_T'0 . deep_model'1 x1 = x /\ contains'2 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'1 (Seq.get visited i) = deep_model'1 (Seq.get visited j)
     -> i = j)
  
  function concat_contains'0  : () =
    [%#sseq33] ()
  
  axiom concat_contains'0_spec : [%#sseq32] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'2 (Seq.(++) a b) x
  = contains'2 a x
  \/ contains'2 b x
  
  function set_produces_trans'0 (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
   =
    [%#shash_set30] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Intersection'0, ab : Seq.seq t_T'0, b : t_Intersection'0, bc : Seq.seq t_T'0, c : t_Intersection'0 . ([%#shash_set27] set_produces'0 a ab b)
   -> ([%#shash_set28] set_produces'0 b bc c)  -> ([%#shash_set29] set_produces'0 a (Seq.(++) ab bc) c)
  
  predicate produces'1 (self : t_Intersection'0) (visited : Seq.seq t_T'0) (o : t_Intersection'0) =
    [%#shash_set15] set_produces'0 self visited o
  
  function produces_trans'1 (a : t_Intersection'0) (ab : Seq.seq t_T'0) (b : t_Intersection'0) (bc : Seq.seq t_T'0) (c : t_Intersection'0) : ()
  
   =
    [%#shash_set23] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'1_spec : forall a : t_Intersection'0, ab : Seq.seq t_T'0, b : t_Intersection'0, bc : Seq.seq t_T'0, c : t_Intersection'0 . ([%#shash_set20] produces'1 a ab b)
   -> ([%#shash_set21] produces'1 b bc c)  -> ([%#shash_set22] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Intersection'0) : () =
    [%#shash_set19] ()
  
  axiom produces_refl'1_spec : forall self : t_Intersection'0 . [%#shash_set18] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate produces'0 (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0) =
    [%#scopied7] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a : t_Copied'0) (ab : Seq.seq t_T'0) (b : t_Copied'0) (bc : Seq.seq t_T'0) (c : t_Copied'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Copied'0, ab : Seq.seq t_T'0, b : t_Copied'0, bc : Seq.seq t_T'0, c : t_Copied'0 . ([%#scopied11] produces'0 a ab b)
   -> ([%#scopied12] produces'0 b bc c)  -> ([%#scopied13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Copied'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Copied'0 . [%#scopied10] produces'0 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate resolve'3 (self : MutBorrow.t t_Intersection'0) =
    [%#sresolve24] self.final = self.current
  
  function view'3 (self : MutBorrow.t t_Intersection'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel25] view'2 self.current
  
  predicate completed'1 (self : MutBorrow.t t_Intersection'0) =
    [%#shash_set14] resolve'3 self /\ Fset.is_empty (view'3 self)
  
  predicate completed'0 (self : MutBorrow.t t_Copied'0) =
    [%#scopied6] exists inner : MutBorrow.t t_Intersection'0 . inner.current = iter'0 self.current
    /\ inner.final = iter'0 self.final /\ completed'1 inner
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set8] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_Copied'0) (return'  (ret:t_HashSet'0))= any
    [ return' (result:t_HashSet'0)-> {[%#siter3] exists done' : MutBorrow.t t_Copied'0, prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_intersection'0[#"collections.rs" 76 0 79 15] (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = intersection'0 {xs} {ys} (fun (_ret':t_Intersection'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied'0 {_5} (fun (_ret':t_Copied'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {_4} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = return' {_0} ]
    )
    [ & _0 : t_HashSet'0 = Any.any_l ()
    | & xs : t_HashSet'0 = xs
    | & ys : t_HashSet'0 = ys
    | & _4 : t_Copied'0 = Any.any_l ()
    | & _5 : t_Intersection'0 = Any.any_l () ]
    
    [ return' (result:t_HashSet'0)-> {[@expl:hashset_intersection ensures] [%#scollections0] view'0 result
      = Fset.inter (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
module M_collections__hashset_difference [#"collections.rs" 84 0 87 15]
  let%span scollections0 = "collections.rs" 83 10 83 40
  let%span shash_set1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 35 30 35 65
  let%span siter2 = "../../../creusot-contracts/src/std/iter.rs" 143 26 143 47
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span smodel4 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span scopied5 = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span scopied6 = "../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 105
  let%span scopied7 = "../../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span shash_set8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span scopied9 = "../../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied10 = "../../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied11 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied12 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied13 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  let%span shash_set14 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 258 20 258 56
  let%span shash_set15 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 252 8 252 38
  let%span sfset16 = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sseq17 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span shash_set18 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 263 14 263 45
  let%span shash_set19 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 264 27 264 29
  let%span shash_set20 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 268 15 268 32
  let%span shash_set21 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 269 15 269 32
  let%span shash_set22 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 270 14 270 42
  let%span shash_set23 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 272 8 272 43
  let%span sresolve24 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel25 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set26 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set27 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set28 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set29 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set30 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span smodel31 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sseq32 = "../../../creusot-contracts/src/logic/seq.rs" 378 14 379 65
  let%span sseq33 = "../../../creusot-contracts/src/logic/seq.rs" 383 4 384 5
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_RandomState'0  =
    { t_RandomState__k0'0: UInt64.t; t_RandomState__k1'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner'0  =
    { t_RawTableInner__bucket_mask'0: UInt64.t;
      t_RawTableInner__ctrl'0: t_NonNull'0;
      t_RawTableInner__growth_left'0: UInt64.t;
      t_RawTableInner__items'0: UInt64.t }
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner'0; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState'0; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'0  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  type t_BitMask'0  =
    { t_BitMask__0'0: UInt16.t }
  
  type t_BitMaskIter'0  =
    { t_BitMaskIter__0'0: t_BitMask'0 }
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Bucket'0  =
    { t_Bucket__ptr'0: t_NonNull'1 }
  
  type t_RawIterRange'0  =
    { t_RawIterRange__current_group'0: t_BitMaskIter'0;
      t_RawIterRange__data'0: t_Bucket'0;
      t_RawIterRange__next_ctrl'0: Opaque.ptr;
      t_RawIterRange__end'0: Opaque.ptr }
  
  type t_RawIter'0  =
    { t_RawIter__iter'0: t_RawIterRange'0; t_RawIter__items'0: UInt64.t }
  
  type t_Iter'2  =
    { t_Iter__inner'0: t_RawIter'0; t_Iter__marker'0: () }
  
  type t_Keys'0  =
    { t_Keys__inner'0: t_Iter'2 }
  
  type t_Iter'1  =
    { t_Iter__iter'0: t_Keys'0 }
  
  type t_Iter'0  =
    { t_Iter__base'0: t_Iter'1 }
  
  type t_Difference'0  =
    { t_Difference__iter'0: t_Iter'0; t_Difference__other'0: t_HashSet'0 }
  
  type t_DeepModelTy'0
  
  function view'2 (self : t_Difference'0) : Fset.fset t_DeepModelTy'0
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0
  
  function view'1 (self : t_HashSet'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel4] view'0 self
  
  let rec difference'0 (self:t_HashSet'0) (other:t_HashSet'0) (return'  (ret:t_Difference'0))= any
    [ return' (result:t_Difference'0)-> {[%#shash_set1] view'2 result = Fset.diff (view'1 self) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied'0  =
    { t_Copied__it'0: t_Difference'0 }
  
  predicate inv'0 (_1 : t_Copied'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Copied'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Difference'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Difference'0 [inv'1 x] . inv'1 x = true
  
  function iter'0 (self : t_Copied'0) : t_Difference'0
  
  axiom iter'0_spec : forall self : t_Copied'0 . [%#scopied5] inv'0 self  -> inv'1 (iter'0 self)
  
  let rec copied'0 (self:t_Difference'0) (return'  (ret:t_Copied'0))= any
    [ return' (result:t_Copied'0)-> {[%#siter2] iter'0 result = self} (! return' {result}) ]
  
  
  predicate resolve'2 (_1 : t_Difference'0) =
    true
  
  predicate resolve'1 (self : t_Copied'0) =
    [%#scopied9] resolve'2 (iter'0 self)
  
  predicate resolve'0 (_1 : t_Copied'0) =
    resolve'1 _1
  
  type t_T'0
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_DeepModelTy'0) (e : t_DeepModelTy'0) =
    [%#sfset16] Fset.mem e self
  
  function deep_model'0 (self : t_T'0) : t_DeepModelTy'0
  
  function deep_model'1 (self : t_T'0) : t_DeepModelTy'0 =
    [%#smodel31] deep_model'0 self
  
  predicate contains'2 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces'0 (start : t_Difference'0) (visited : Seq.seq t_T'0) (end' : t_Difference'0) =
    [%#shash_set26] Fset.cardinal (view'2 start) = Seq.length visited + Fset.cardinal (view'2 end')
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 start) x
     -> (exists x1 : t_T'0 . deep_model'1 x1 = x /\ contains'2 visited x1) \/ contains'0 (view'2 end') x)
    /\ (forall x : t_T'0 . contains'2 visited x
     -> contains'0 (view'2 start) (deep_model'1 x) /\ not contains'0 (view'2 end') (deep_model'1 x))
    /\ (forall x : t_DeepModelTy'0 . contains'0 (view'2 end') x
     -> contains'0 (view'2 start) x /\ not (exists x1 : t_T'0 . deep_model'1 x1 = x /\ contains'2 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'1 (Seq.get visited i) = deep_model'1 (Seq.get visited j)
     -> i = j)
  
  function concat_contains'0  : () =
    [%#sseq33] ()
  
  axiom concat_contains'0_spec : [%#sseq32] forall a : Seq.seq t_T'0, b : Seq.seq t_T'0, x : t_T'0 . contains'2 (Seq.(++) a b) x
  = contains'2 a x
  \/ contains'2 b x
  
  function set_produces_trans'0 (a : t_Difference'0) (ab : Seq.seq t_T'0) (b : t_Difference'0) (bc : Seq.seq t_T'0) (c : t_Difference'0) : ()
  
   =
    [%#shash_set30] let _ = concat_contains'0 in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans'0_spec : forall a : t_Difference'0, ab : Seq.seq t_T'0, b : t_Difference'0, bc : Seq.seq t_T'0, c : t_Difference'0 . ([%#shash_set27] set_produces'0 a ab b)
   -> ([%#shash_set28] set_produces'0 b bc c)  -> ([%#shash_set29] set_produces'0 a (Seq.(++) ab bc) c)
  
  predicate produces'1 (self : t_Difference'0) (visited : Seq.seq t_T'0) (o : t_Difference'0) =
    [%#shash_set15] set_produces'0 self visited o
  
  function produces_trans'1 (a : t_Difference'0) (ab : Seq.seq t_T'0) (b : t_Difference'0) (bc : Seq.seq t_T'0) (c : t_Difference'0) : ()
  
   =
    [%#shash_set23] let _ = set_produces_trans'0 a ab b bc c in ()
  
  axiom produces_trans'1_spec : forall a : t_Difference'0, ab : Seq.seq t_T'0, b : t_Difference'0, bc : Seq.seq t_T'0, c : t_Difference'0 . ([%#shash_set20] produces'1 a ab b)
   -> ([%#shash_set21] produces'1 b bc c)  -> ([%#shash_set22] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Difference'0) : () =
    [%#shash_set19] ()
  
  axiom produces_refl'1_spec : forall self : t_Difference'0 . [%#shash_set18] produces'1 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate produces'0 (self : t_Copied'0) (visited : Seq.seq t_T'0) (o : t_Copied'0) =
    [%#scopied7] exists s : Seq.seq t_T'0 . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a : t_Copied'0) (ab : Seq.seq t_T'0) (b : t_Copied'0) (bc : Seq.seq t_T'0) (c : t_Copied'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Copied'0, ab : Seq.seq t_T'0, b : t_Copied'0, bc : Seq.seq t_T'0, c : t_Copied'0 . ([%#scopied11] produces'0 a ab b)
   -> ([%#scopied12] produces'0 b bc c)  -> ([%#scopied13] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Copied'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Copied'0 . [%#scopied10] produces'0 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate resolve'3 (self : MutBorrow.t t_Difference'0) =
    [%#sresolve24] self.final = self.current
  
  function view'3 (self : MutBorrow.t t_Difference'0) : Fset.fset t_DeepModelTy'0 =
    [%#smodel25] view'2 self.current
  
  predicate completed'1 (self : MutBorrow.t t_Difference'0) =
    [%#shash_set14] resolve'3 self /\ Fset.is_empty (view'3 self)
  
  predicate completed'0 (self : MutBorrow.t t_Copied'0) =
    [%#scopied6] exists inner : MutBorrow.t t_Difference'0 . inner.current = iter'0 self.current
    /\ inner.final = iter'0 self.final /\ completed'1 inner
  
  predicate contains'1 (self : Seq.seq t_T'0) (x : t_T'0) =
    [%#sseq17] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post'0 (prod : Seq.seq t_T'0) (res : t_HashSet'0) =
    [%#shash_set8] forall x : t_DeepModelTy'0 . contains'0 (view'0 res) x
    = (exists x1 : t_T'0 . deep_model'0 x1 = x /\ contains'1 prod x1)
  
  let rec collect'0 (self:t_Copied'0) (return'  (ret:t_HashSet'0))= any
    [ return' (result:t_HashSet'0)-> {[%#siter3] exists done' : MutBorrow.t t_Copied'0, prod : Seq.seq t_T'0 . resolve'0 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_difference'0[#"collections.rs" 84 0 87 15] (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (ret:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = difference'0 {xs} {ys} (fun (_ret':t_Difference'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied'0 {_5} (fun (_ret':t_Copied'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect'0 {_4} (fun (_ret':t_HashSet'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = return' {_0} ]
    )
    [ & _0 : t_HashSet'0 = Any.any_l ()
    | & xs : t_HashSet'0 = xs
    | & ys : t_HashSet'0 = ys
    | & _4 : t_Copied'0 = Any.any_l ()
    | & _5 : t_Difference'0 = Any.any_l () ]
    
    [ return' (result:t_HashSet'0)-> {[@expl:hashset_difference ensures] [%#scollections0] view'0 result
      = Fset.diff (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
