module M_integer_ops__test_bitwise_ops [#"integer_ops.rs" 5 0 5 25]
  let%span sinteger_ops0 = "integer_ops.rs" 7 31 7 44
  let%span sinteger_ops1 = "integer_ops.rs" 7 15 7 28
  let%span sinteger_ops2 = "integer_ops.rs" 7 46 7 59
  let%span sinteger_ops3 = "integer_ops.rs" 8 31 8 44
  let%span sinteger_ops4 = "integer_ops.rs" 8 15 8 28
  let%span sinteger_ops5 = "integer_ops.rs" 8 46 8 59
  let%span sinteger_ops6 = "integer_ops.rs" 9 42 9 66
  let%span sinteger_ops7 = "integer_ops.rs" 9 15 9 39
  let%span sinteger_ops8 = "integer_ops.rs" 9 68 9 92
  let%span sinteger_ops9 = "integer_ops.rs" 10 42 10 66
  let%span sinteger_ops10 = "integer_ops.rs" 10 15 10 39
  let%span sinteger_ops11 = "integer_ops.rs" 10 68 10 92
  let%span sinteger_ops12 = "integer_ops.rs" 11 31 11 44
  let%span sinteger_ops13 = "integer_ops.rs" 11 15 11 28
  let%span sinteger_ops14 = "integer_ops.rs" 11 46 11 59
  let%span sinteger_ops15 = "integer_ops.rs" 12 31 12 44
  let%span sinteger_ops16 = "integer_ops.rs" 12 15 12 28
  let%span sinteger_ops17 = "integer_ops.rs" 12 46 12 59
  let%span sinteger_ops18 = "integer_ops.rs" 13 39 13 60
  let%span sinteger_ops19 = "integer_ops.rs" 13 15 13 36
  let%span sinteger_ops20 = "integer_ops.rs" 13 62 13 83
  let%span sinteger_ops21 = "integer_ops.rs" 14 39 14 60
  let%span sinteger_ops22 = "integer_ops.rs" 14 15 14 36
  let%span sinteger_ops23 = "integer_ops.rs" 14 62 14 83
  let%span sinteger_ops24 = "integer_ops.rs" 15 42 15 66
  let%span sinteger_ops25 = "integer_ops.rs" 15 15 15 39
  let%span sinteger_ops26 = "integer_ops.rs" 15 68 15 92
  let%span sinteger_ops27 = "integer_ops.rs" 16 42 16 66
  let%span sinteger_ops28 = "integer_ops.rs" 16 15 16 39
  let%span sinteger_ops29 = "integer_ops.rs" 16 68 16 92
  let%span sinteger_ops30 = "integer_ops.rs" 17 34 17 50
  let%span sinteger_ops31 = "integer_ops.rs" 17 15 17 31
  let%span sinteger_ops32 = "integer_ops.rs" 17 52 17 68
  let%span sinteger_ops33 = "integer_ops.rs" 18 34 18 50
  let%span sinteger_ops34 = "integer_ops.rs" 18 15 18 31
  let%span sinteger_ops35 = "integer_ops.rs" 18 52 18 68
  let%span sinteger_ops36 = "integer_ops.rs" 21 31 21 44
  let%span sinteger_ops37 = "integer_ops.rs" 21 15 21 28
  let%span sinteger_ops38 = "integer_ops.rs" 21 46 21 59
  let%span sinteger_ops39 = "integer_ops.rs" 22 31 22 44
  let%span sinteger_ops40 = "integer_ops.rs" 22 15 22 28
  let%span sinteger_ops41 = "integer_ops.rs" 22 46 22 59
  let%span sinteger_ops42 = "integer_ops.rs" 23 42 23 66
  let%span sinteger_ops43 = "integer_ops.rs" 23 15 23 39
  let%span sinteger_ops44 = "integer_ops.rs" 23 68 23 92
  let%span sinteger_ops45 = "integer_ops.rs" 24 42 24 66
  let%span sinteger_ops46 = "integer_ops.rs" 24 15 24 39
  let%span sinteger_ops47 = "integer_ops.rs" 24 68 24 92
  let%span sinteger_ops48 = "integer_ops.rs" 25 31 25 44
  let%span sinteger_ops49 = "integer_ops.rs" 25 15 25 28
  let%span sinteger_ops50 = "integer_ops.rs" 25 46 25 59
  let%span sinteger_ops51 = "integer_ops.rs" 26 31 26 44
  let%span sinteger_ops52 = "integer_ops.rs" 26 15 26 28
  let%span sinteger_ops53 = "integer_ops.rs" 26 46 26 59
  let%span sinteger_ops54 = "integer_ops.rs" 27 39 27 60
  let%span sinteger_ops55 = "integer_ops.rs" 27 15 27 36
  let%span sinteger_ops56 = "integer_ops.rs" 27 62 27 83
  let%span sinteger_ops57 = "integer_ops.rs" 28 39 28 60
  let%span sinteger_ops58 = "integer_ops.rs" 28 15 28 36
  let%span sinteger_ops59 = "integer_ops.rs" 28 62 28 83
  let%span sinteger_ops60 = "integer_ops.rs" 29 42 29 66
  let%span sinteger_ops61 = "integer_ops.rs" 29 15 29 39
  let%span sinteger_ops62 = "integer_ops.rs" 29 68 29 92
  let%span sinteger_ops63 = "integer_ops.rs" 30 42 30 66
  let%span sinteger_ops64 = "integer_ops.rs" 30 15 30 39
  let%span sinteger_ops65 = "integer_ops.rs" 30 68 30 92
  let%span sinteger_ops66 = "integer_ops.rs" 31 34 31 50
  let%span sinteger_ops67 = "integer_ops.rs" 31 15 31 31
  let%span sinteger_ops68 = "integer_ops.rs" 31 52 31 68
  let%span sinteger_ops69 = "integer_ops.rs" 32 34 32 50
  let%span sinteger_ops70 = "integer_ops.rs" 32 15 32 31
  let%span sinteger_ops71 = "integer_ops.rs" 32 52 32 68
  let%span sinteger_ops72 = "integer_ops.rs" 35 31 35 44
  let%span sinteger_ops73 = "integer_ops.rs" 35 15 35 28
  let%span sinteger_ops74 = "integer_ops.rs" 35 46 35 59
  let%span sinteger_ops75 = "integer_ops.rs" 36 31 36 44
  let%span sinteger_ops76 = "integer_ops.rs" 36 15 36 28
  let%span sinteger_ops77 = "integer_ops.rs" 36 46 36 59
  let%span sinteger_ops78 = "integer_ops.rs" 37 42 37 66
  let%span sinteger_ops79 = "integer_ops.rs" 37 15 37 39
  let%span sinteger_ops80 = "integer_ops.rs" 37 68 37 92
  let%span sinteger_ops81 = "integer_ops.rs" 38 42 38 66
  let%span sinteger_ops82 = "integer_ops.rs" 38 15 38 39
  let%span sinteger_ops83 = "integer_ops.rs" 38 68 38 92
  let%span sinteger_ops84 = "integer_ops.rs" 39 31 39 44
  let%span sinteger_ops85 = "integer_ops.rs" 39 15 39 28
  let%span sinteger_ops86 = "integer_ops.rs" 39 46 39 59
  let%span sinteger_ops87 = "integer_ops.rs" 40 31 40 44
  let%span sinteger_ops88 = "integer_ops.rs" 40 15 40 28
  let%span sinteger_ops89 = "integer_ops.rs" 40 46 40 54
  let%span sinteger_ops90 = "integer_ops.rs" 41 39 41 60
  let%span sinteger_ops91 = "integer_ops.rs" 41 15 41 36
  let%span sinteger_ops92 = "integer_ops.rs" 41 62 41 83
  let%span sinteger_ops93 = "integer_ops.rs" 42 39 42 60
  let%span sinteger_ops94 = "integer_ops.rs" 42 15 42 36
  let%span sinteger_ops95 = "integer_ops.rs" 42 62 42 82
  let%span sinteger_ops96 = "integer_ops.rs" 43 42 43 66
  let%span sinteger_ops97 = "integer_ops.rs" 43 15 43 39
  let%span sinteger_ops98 = "integer_ops.rs" 43 68 43 92
  let%span sinteger_ops99 = "integer_ops.rs" 44 42 44 66
  let%span sinteger_ops100 = "integer_ops.rs" 44 15 44 39
  let%span sinteger_ops101 = "integer_ops.rs" 44 68 44 92
  let%span sinteger_ops102 = "integer_ops.rs" 45 34 45 50
  let%span sinteger_ops103 = "integer_ops.rs" 45 15 45 31
  let%span sinteger_ops104 = "integer_ops.rs" 45 52 45 68
  let%span sinteger_ops105 = "integer_ops.rs" 46 34 46 50
  let%span sinteger_ops106 = "integer_ops.rs" 46 15 46 31
  let%span sinteger_ops107 = "integer_ops.rs" 46 52 46 68
  let%span sinteger_ops108 = "integer_ops.rs" 49 16 49 29
  let%span sinteger_ops109 = "integer_ops.rs" 49 31 49 44
  let%span sinteger_ops110 = "integer_ops.rs" 50 16 50 29
  let%span sinteger_ops111 = "integer_ops.rs" 50 31 50 37
  let%span sinteger_ops112 = "integer_ops.rs" 51 16 51 40
  let%span sinteger_ops113 = "integer_ops.rs" 51 42 51 66
  let%span sinteger_ops114 = "integer_ops.rs" 52 16 52 40
  let%span sinteger_ops115 = "integer_ops.rs" 52 42 52 51
  let%span sinteger_ops116 = "integer_ops.rs" 53 16 53 29
  let%span sinteger_ops117 = "integer_ops.rs" 53 31 53 44
  let%span sinteger_ops118 = "integer_ops.rs" 54 16 54 29
  let%span sinteger_ops119 = "integer_ops.rs" 54 31 54 45
  let%span sinteger_ops120 = "integer_ops.rs" 55 16 55 37
  let%span sinteger_ops121 = "integer_ops.rs" 55 39 55 60
  let%span sinteger_ops122 = "integer_ops.rs" 56 16 56 37
  let%span sinteger_ops123 = "integer_ops.rs" 56 39 56 62
  let%span sinteger_ops124 = "integer_ops.rs" 57 16 57 40
  let%span sinteger_ops125 = "integer_ops.rs" 57 42 57 80
  let%span sinteger_ops126 = "integer_ops.rs" 58 16 58 40
  let%span sinteger_ops127 = "integer_ops.rs" 58 42 58 69
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  let rec promoted91__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_and ([%#sinteger_ops1] (240 : UInt8BW.t)) ([%#sinteger_ops0] (60 : UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted90__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (48 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  use creusot.int.Int8BW
  
  let rec promoted89__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_and ([%#sinteger_ops4] (113 : Int8BW.t)) ([%#sinteger_ops3] (61 : Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted88__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops5] (49 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  use creusot.int.UInt16BW
  
  let rec promoted87__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt16BW.bw_and ([%#sinteger_ops7] (42225 : UInt16BW.t)) ([%#sinteger_ops6] (21565 : UInt16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted86__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops8] (1073 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  use creusot.int.Int16BW
  
  let rec promoted85__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int16BW.bw_and ([%#sinteger_ops10] (13553 : Int16BW.t)) ([%#sinteger_ops9] (21565 : Int16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int16BW.t = Any.any_l () | & _1 : Int16BW.t = Any.any_l () ] 
    [ return' (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted84__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops11] (5169 : Int16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16BW.t = Any.any_l () ]  [ return' (result:Int16BW.t)-> return' {result} ] 
  
  use creusot.int.UInt32BW
  
  let rec promoted83__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt32BW.bw_and ([%#sinteger_ops13] (3221225475 : UInt32BW.t)) ([%#sinteger_ops12] (1073840130 : UInt32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted82__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops14] (1073741826 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  use creusot.int.Int32BW
  
  let rec promoted81__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int32BW.bw_and ([%#sinteger_ops16] (1073741839 : Int32BW.t)) ([%#sinteger_ops15] (1073745665 : Int32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int32BW.t = Any.any_l () | & _1 : Int32BW.t = Any.any_l () ] 
    [ return' (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted80__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops17] (1073741825 : Int32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32BW.t = Any.any_l () ]  [ return' (result:Int32BW.t)-> return' {result} ] 
  
  use creusot.int.UInt64BW
  
  let rec promoted79__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_and ([%#sinteger_ops19] (13835321938072829955 : UInt64BW.t)) ([%#sinteger_ops18] (9223838229784952833 : UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted78__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops20] (9223547958715219969 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  use creusot.int.Int64BW
  
  let rec promoted77__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int64BW.bw_and ([%#sinteger_ops22] (4611686018437454224 : Int64BW.t)) ([%#sinteger_ops21] (5226577450909599872 : Int64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted76__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops23] (4611686018436335744 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  use creusot.int.UInt128BW
  
  let rec promoted75__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt128BW.bw_and ([%#sinteger_ops25] (4514840875923203424259 : UInt128BW.t)) ([%#sinteger_ops24] (3108276842612989624321 : UInt128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted74__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops26] (2960702599752243478529 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  use creusot.int.Int128BW
  
  let rec promoted73__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int128BW.bw_and ([%#sinteger_ops28] (4514840875923203424259 : Int128BW.t)) ([%#sinteger_ops27] (3108276842612989624321 : Int128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () | & _1 : Int128BW.t = Any.any_l () ] 
    [ return' (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted72__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops29] (2960702599752243478529 : Int128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128BW.t = Any.any_l () ]  [ return' (result:Int128BW.t)-> return' {result} ] 
  
  let rec promoted71__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.bw_and ([%#sinteger_ops31] (240 : UInt64BW.t)) ([%#sinteger_ops30] (60 : UInt64BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted70__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops32] (48 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted69__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_and ([%#sinteger_ops34] (113 : Int64BW.t)) ([%#sinteger_ops33] (61 : Int64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted68__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops35] (49 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted67__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_or ([%#sinteger_ops37] (240 : UInt8BW.t)) ([%#sinteger_ops36] (60 : UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted66__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops38] (252 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted65__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_or ([%#sinteger_ops40] (113 : Int8BW.t)) ([%#sinteger_ops39] (61 : Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted64__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops41] (125 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted63__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt16BW.bw_or ([%#sinteger_ops43] (42225 : UInt16BW.t)) ([%#sinteger_ops42] (21565 : UInt16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted62__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops44] (62717 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted61__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int16BW.bw_or ([%#sinteger_ops46] (13553 : Int16BW.t)) ([%#sinteger_ops45] (21565 : Int16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int16BW.t = Any.any_l () | & _1 : Int16BW.t = Any.any_l () ] 
    [ return' (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted60__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops47] (29949 : Int16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16BW.t = Any.any_l () ]  [ return' (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted59__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt32BW.bw_or ([%#sinteger_ops49] (3221225475 : UInt32BW.t)) ([%#sinteger_ops48] (1073840130 : UInt32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted58__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops50] (3221323779 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted57__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int32BW.bw_or ([%#sinteger_ops52] (1073741839 : Int32BW.t)) ([%#sinteger_ops51] (1073745665 : Int32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int32BW.t = Any.any_l () | & _1 : Int32BW.t = Any.any_l () ] 
    [ return' (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted56__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops53] (1073745679 : Int32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32BW.t = Any.any_l () ]  [ return' (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted55__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_or ([%#sinteger_ops55] (13835321938072829955 : UInt64BW.t)) ([%#sinteger_ops54] (9223838229784952833 : UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted54__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops56] (13835612209142562819 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted53__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int64BW.bw_or ([%#sinteger_ops58] (4611686018437454224 : Int64BW.t)) ([%#sinteger_ops57] (5226577450909599872 : Int64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted52__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops59] (5226577450910718352 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted51__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt128BW.bw_or ([%#sinteger_ops61] (4514840875923203424259 : UInt128BW.t)) ([%#sinteger_ops60] (3108276842612989624321 : UInt128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted50__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops62] (4662415118783949570051 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted49__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int128BW.bw_or ([%#sinteger_ops64] (4514840875923203424259 : Int128BW.t)) ([%#sinteger_ops63] (3108276842612989624321 : Int128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () | & _1 : Int128BW.t = Any.any_l () ] 
    [ return' (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted48__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops65] (4662415118783949570051 : Int128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128BW.t = Any.any_l () ]  [ return' (result:Int128BW.t)-> return' {result} ] 
  
  let rec promoted47__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.bw_or ([%#sinteger_ops67] (240 : UInt64BW.t)) ([%#sinteger_ops66] (60 : UInt64BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted46__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops68] (252 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted45__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_or ([%#sinteger_ops70] (113 : Int64BW.t)) ([%#sinteger_ops69] (61 : Int64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted44__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops71] (125 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted43__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_xor ([%#sinteger_ops73] (240 : UInt8BW.t)) ([%#sinteger_ops72] (60 : UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted42__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops74] (204 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted41__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_xor ([%#sinteger_ops76] (113 : Int8BW.t)) ([%#sinteger_ops75] (61 : Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted40__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops77] (76 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted39__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt16BW.bw_xor ([%#sinteger_ops79] (42225 : UInt16BW.t)) ([%#sinteger_ops78] (21565 : UInt16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted38__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops80] (61644 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted37__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int16BW.bw_xor ([%#sinteger_ops82] (13553 : Int16BW.t)) ([%#sinteger_ops81] (21565 : Int16BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int16BW.t = Any.any_l () | & _1 : Int16BW.t = Any.any_l () ] 
    [ return' (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted36__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops83] (24780 : Int16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16BW.t = Any.any_l () ]  [ return' (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted35__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt32BW.bw_xor ([%#sinteger_ops85] (3221225475 : UInt32BW.t)) ([%#sinteger_ops84] (1073840130 : UInt32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted34__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops86] (2147581953 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted33__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int32BW.bw_xor ([%#sinteger_ops88] (1073741839 : Int32BW.t)) ([%#sinteger_ops87] (1073745665 : Int32BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int32BW.t = Any.any_l () | & _1 : Int32BW.t = Any.any_l () ] 
    [ return' (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted32__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops89] (3854 : Int32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32BW.t = Any.any_l () ]  [ return' (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted31__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_xor ([%#sinteger_ops91] (13835321938072829955 : UInt64BW.t)) ([%#sinteger_ops90] (9223838229784952833 : UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted30__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops92] (4612064250427342850 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted29__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int64BW.bw_xor ([%#sinteger_ops94] (4611686018437454224 : Int64BW.t)) ([%#sinteger_ops93] (5226577450909599872 : Int64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted28__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops95] (614891432474382608 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted27__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt128BW.bw_xor ([%#sinteger_ops97] (4514840875923203424259 : UInt128BW.t)) ([%#sinteger_ops96] (3108276842612989624321 : UInt128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted26__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops98] (1701712519031706091522 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted25__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- Int128BW.bw_xor ([%#sinteger_ops100] (4514840875923203424259 : Int128BW.t)) ([%#sinteger_ops99] (3108276842612989624321 : Int128BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () | & _1 : Int128BW.t = Any.any_l () ] 
    [ return' (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted24__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops101] (1701712519031706091522 : Int128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128BW.t = Any.any_l () ]  [ return' (result:Int128BW.t)-> return' {result} ] 
  
  let rec promoted23__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = 
        [ &_1 <- UInt64BW.bw_xor ([%#sinteger_ops103] (240 : UInt64BW.t)) ([%#sinteger_ops102] (60 : UInt64BW.t)) ]
        
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted22__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops104] (204 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted21__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_xor ([%#sinteger_ops106] (113 : Int64BW.t)) ([%#sinteger_ops105] (61 : Int64BW.t)) ] 
        s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted20__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops107] (76 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted19__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.bw_not ([%#sinteger_ops108] (240 : UInt8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted18__test_bitwise_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops109] (15 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted17__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.bw_not ([%#sinteger_ops110] (113 : Int8BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted16__test_bitwise_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops111] (142 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted15__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16BW.bw_not ([%#sinteger_ops112] (42225 : UInt16BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted14__test_bitwise_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops113] (23310 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted13__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.bw_not ([%#sinteger_ops114] (13553 : Int16BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int16BW.t = Any.any_l () | & _1 : Int16BW.t = Any.any_l () ] 
    [ return' (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted12__test_bitwise_ops'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops115] (51982 : Int16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16BW.t = Any.any_l () ]  [ return' (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted11__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32BW.bw_not ([%#sinteger_ops116] (3221225475 : UInt32BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted10__test_bitwise_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops117] (1073741820 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted9__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32BW.bw_not ([%#sinteger_ops118] (1073741839 : Int32BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int32BW.t = Any.any_l () | & _1 : Int32BW.t = Any.any_l () ] 
    [ return' (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted8__test_bitwise_ops'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops119] (3221225456 : Int32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32BW.t = Any.any_l () ]  [ return' (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted7__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.bw_not ([%#sinteger_ops120] (13835321938072829955 : UInt64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted6__test_bitwise_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops121] (4611422135636721660 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted5__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.bw_not ([%#sinteger_ops122] (4611686018437454224 : Int64BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted4__test_bitwise_ops'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops123] (13835058055272097391 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted3__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128BW.bw_not ([%#sinteger_ops124] (4514840875923203424259 : UInt128BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_bitwise_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops125] (340282366920938458948533731508564787196 : UInt128BW.t) ] s1
      | s1 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted1__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128BW.bw_not ([%#sinteger_ops126] (4514840875923203424259 : Int128BW.t)) ] s1
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () | & _1 : Int128BW.t = Any.any_l () ] 
    [ return' (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_bitwise_ops'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_0 <- [%#sinteger_ops127] (340282366920938458948533731508564787196 : Int128BW.t) ] s1
      | s1 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () ]  [ return' (result:Int128BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_bitwise_ops'0[#"integer_ops.rs" 5 0 5 25] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted91__test_bitwise_ops'0 (fun (pr91:UInt8BW.t) ->  [ &_1012 <- pr91 ] s1)
      | s1 = promoted90__test_bitwise_ops'0 (fun (pr90:UInt8BW.t) ->  [ &_1011 <- pr90 ] s2)
      | s2 =  [ &_2 <- (_1012, _1011) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _2 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _2 in r'1 ] s5
      | s5 =  [ &_9 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_9 = false} (! bb2) | br1 -> {_9} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted89__test_bitwise_ops'0 (fun (pr89:Int8BW.t) ->  [ &_1010 <- pr89 ] s1)
      | s1 = promoted88__test_bitwise_ops'0 (fun (pr88:Int8BW.t) ->  [ &_1009 <- pr88 ] s2)
      | s2 =  [ &_22 <- (_1010, _1009) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _22 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _22 in r'1 ] s5
      | s5 =  [ &_29 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_29 = false} (! bb4) | br1 -> {_29} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = promoted87__test_bitwise_ops'0 (fun (pr87:UInt16BW.t) ->  [ &_1008 <- pr87 ] s1)
      | s1 = promoted86__test_bitwise_ops'0 (fun (pr86:UInt16BW.t) ->  [ &_1007 <- pr86 ] s2)
      | s2 =  [ &_42 <- (_1008, _1007) ] s3
      | s3 =  [ &left_val2 <- let (r'0, _) = _42 in r'0 ] s4
      | s4 =  [ &right_val2 <- let (_, r'1) = _42 in r'1 ] s5
      | s5 =  [ &_49 <- left_val2 = right_val2 ] s6
      | s6 = any [ br0 -> {_49 = false} (! bb6) | br1 -> {_49} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = promoted85__test_bitwise_ops'0 (fun (pr85:Int16BW.t) ->  [ &_1006 <- pr85 ] s1)
      | s1 = promoted84__test_bitwise_ops'0 (fun (pr84:Int16BW.t) ->  [ &_1005 <- pr84 ] s2)
      | s2 =  [ &_62 <- (_1006, _1005) ] s3
      | s3 =  [ &left_val3 <- let (r'0, _) = _62 in r'0 ] s4
      | s4 =  [ &right_val3 <- let (_, r'1) = _62 in r'1 ] s5
      | s5 =  [ &_69 <- left_val3 = right_val3 ] s6
      | s6 = any [ br0 -> {_69 = false} (! bb8) | br1 -> {_69} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = promoted83__test_bitwise_ops'0 (fun (pr83:UInt32BW.t) ->  [ &_1004 <- pr83 ] s1)
      | s1 = promoted82__test_bitwise_ops'0 (fun (pr82:UInt32BW.t) ->  [ &_1003 <- pr82 ] s2)
      | s2 =  [ &_82 <- (_1004, _1003) ] s3
      | s3 =  [ &left_val4 <- let (r'0, _) = _82 in r'0 ] s4
      | s4 =  [ &right_val4 <- let (_, r'1) = _82 in r'1 ] s5
      | s5 =  [ &_89 <- left_val4 = right_val4 ] s6
      | s6 = any [ br0 -> {_89 = false} (! bb10) | br1 -> {_89} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = promoted81__test_bitwise_ops'0 (fun (pr81:Int32BW.t) ->  [ &_1002 <- pr81 ] s1)
      | s1 = promoted80__test_bitwise_ops'0 (fun (pr80:Int32BW.t) ->  [ &_1001 <- pr80 ] s2)
      | s2 =  [ &_102 <- (_1002, _1001) ] s3
      | s3 =  [ &left_val5 <- let (r'0, _) = _102 in r'0 ] s4
      | s4 =  [ &right_val5 <- let (_, r'1) = _102 in r'1 ] s5
      | s5 =  [ &_109 <- left_val5 = right_val5 ] s6
      | s6 = any [ br0 -> {_109 = false} (! bb12) | br1 -> {_109} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 = promoted79__test_bitwise_ops'0 (fun (pr79:UInt64BW.t) ->  [ &_1000 <- pr79 ] s1)
      | s1 = promoted78__test_bitwise_ops'0 (fun (pr78:UInt64BW.t) ->  [ &_999 <- pr78 ] s2)
      | s2 =  [ &_122 <- (_1000, _999) ] s3
      | s3 =  [ &left_val6 <- let (r'0, _) = _122 in r'0 ] s4
      | s4 =  [ &right_val6 <- let (_, r'1) = _122 in r'1 ] s5
      | s5 =  [ &_129 <- left_val6 = right_val6 ] s6
      | s6 = any [ br0 -> {_129 = false} (! bb14) | br1 -> {_129} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = promoted77__test_bitwise_ops'0 (fun (pr77:Int64BW.t) ->  [ &_998 <- pr77 ] s1)
      | s1 = promoted76__test_bitwise_ops'0 (fun (pr76:Int64BW.t) ->  [ &_997 <- pr76 ] s2)
      | s2 =  [ &_142 <- (_998, _997) ] s3
      | s3 =  [ &left_val7 <- let (r'0, _) = _142 in r'0 ] s4
      | s4 =  [ &right_val7 <- let (_, r'1) = _142 in r'1 ] s5
      | s5 =  [ &_149 <- left_val7 = right_val7 ] s6
      | s6 = any [ br0 -> {_149 = false} (! bb16) | br1 -> {_149} (! bb15) ]  ]
    
    | bb15 = s0
      [ s0 = promoted75__test_bitwise_ops'0 (fun (pr75:UInt128BW.t) ->  [ &_996 <- pr75 ] s1)
      | s1 = promoted74__test_bitwise_ops'0 (fun (pr74:UInt128BW.t) ->  [ &_995 <- pr74 ] s2)
      | s2 =  [ &_162 <- (_996, _995) ] s3
      | s3 =  [ &left_val8 <- let (r'0, _) = _162 in r'0 ] s4
      | s4 =  [ &right_val8 <- let (_, r'1) = _162 in r'1 ] s5
      | s5 =  [ &_169 <- left_val8 = right_val8 ] s6
      | s6 = any [ br0 -> {_169 = false} (! bb18) | br1 -> {_169} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = promoted73__test_bitwise_ops'0 (fun (pr73:Int128BW.t) ->  [ &_994 <- pr73 ] s1)
      | s1 = promoted72__test_bitwise_ops'0 (fun (pr72:Int128BW.t) ->  [ &_993 <- pr72 ] s2)
      | s2 =  [ &_182 <- (_994, _993) ] s3
      | s3 =  [ &left_val9 <- let (r'0, _) = _182 in r'0 ] s4
      | s4 =  [ &right_val9 <- let (_, r'1) = _182 in r'1 ] s5
      | s5 =  [ &_189 <- left_val9 = right_val9 ] s6
      | s6 = any [ br0 -> {_189 = false} (! bb20) | br1 -> {_189} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = promoted71__test_bitwise_ops'0 (fun (pr71:UInt64BW.t) ->  [ &_992 <- pr71 ] s1)
      | s1 = promoted70__test_bitwise_ops'0 (fun (pr70:UInt64BW.t) ->  [ &_991 <- pr70 ] s2)
      | s2 =  [ &_202 <- (_992, _991) ] s3
      | s3 =  [ &left_val10 <- let (r'0, _) = _202 in r'0 ] s4
      | s4 =  [ &right_val10 <- let (_, r'1) = _202 in r'1 ] s5
      | s5 =  [ &_209 <- left_val10 = right_val10 ] s6
      | s6 = any [ br0 -> {_209 = false} (! bb22) | br1 -> {_209} (! bb21) ]  ]
    
    | bb21 = s0
      [ s0 = promoted69__test_bitwise_ops'0 (fun (pr69:Int64BW.t) ->  [ &_990 <- pr69 ] s1)
      | s1 = promoted68__test_bitwise_ops'0 (fun (pr68:Int64BW.t) ->  [ &_989 <- pr68 ] s2)
      | s2 =  [ &_222 <- (_990, _989) ] s3
      | s3 =  [ &left_val11 <- let (r'0, _) = _222 in r'0 ] s4
      | s4 =  [ &right_val11 <- let (_, r'1) = _222 in r'1 ] s5
      | s5 =  [ &_229 <- left_val11 = right_val11 ] s6
      | s6 = any [ br0 -> {_229 = false} (! bb24) | br1 -> {_229} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = promoted67__test_bitwise_ops'0 (fun (pr67:UInt8BW.t) ->  [ &_988 <- pr67 ] s1)
      | s1 = promoted66__test_bitwise_ops'0 (fun (pr66:UInt8BW.t) ->  [ &_987 <- pr66 ] s2)
      | s2 =  [ &_242 <- (_988, _987) ] s3
      | s3 =  [ &left_val12 <- let (r'0, _) = _242 in r'0 ] s4
      | s4 =  [ &right_val12 <- let (_, r'1) = _242 in r'1 ] s5
      | s5 =  [ &_249 <- left_val12 = right_val12 ] s6
      | s6 = any [ br0 -> {_249 = false} (! bb26) | br1 -> {_249} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = promoted65__test_bitwise_ops'0 (fun (pr65:Int8BW.t) ->  [ &_986 <- pr65 ] s1)
      | s1 = promoted64__test_bitwise_ops'0 (fun (pr64:Int8BW.t) ->  [ &_985 <- pr64 ] s2)
      | s2 =  [ &_262 <- (_986, _985) ] s3
      | s3 =  [ &left_val13 <- let (r'0, _) = _262 in r'0 ] s4
      | s4 =  [ &right_val13 <- let (_, r'1) = _262 in r'1 ] s5
      | s5 =  [ &_269 <- left_val13 = right_val13 ] s6
      | s6 = any [ br0 -> {_269 = false} (! bb28) | br1 -> {_269} (! bb27) ]  ]
    
    | bb27 = s0
      [ s0 = promoted63__test_bitwise_ops'0 (fun (pr63:UInt16BW.t) ->  [ &_984 <- pr63 ] s1)
      | s1 = promoted62__test_bitwise_ops'0 (fun (pr62:UInt16BW.t) ->  [ &_983 <- pr62 ] s2)
      | s2 =  [ &_282 <- (_984, _983) ] s3
      | s3 =  [ &left_val14 <- let (r'0, _) = _282 in r'0 ] s4
      | s4 =  [ &right_val14 <- let (_, r'1) = _282 in r'1 ] s5
      | s5 =  [ &_289 <- left_val14 = right_val14 ] s6
      | s6 = any [ br0 -> {_289 = false} (! bb30) | br1 -> {_289} (! bb29) ]  ]
    
    | bb29 = s0
      [ s0 = promoted61__test_bitwise_ops'0 (fun (pr61:Int16BW.t) ->  [ &_982 <- pr61 ] s1)
      | s1 = promoted60__test_bitwise_ops'0 (fun (pr60:Int16BW.t) ->  [ &_981 <- pr60 ] s2)
      | s2 =  [ &_302 <- (_982, _981) ] s3
      | s3 =  [ &left_val15 <- let (r'0, _) = _302 in r'0 ] s4
      | s4 =  [ &right_val15 <- let (_, r'1) = _302 in r'1 ] s5
      | s5 =  [ &_309 <- left_val15 = right_val15 ] s6
      | s6 = any [ br0 -> {_309 = false} (! bb32) | br1 -> {_309} (! bb31) ]  ]
    
    | bb31 = s0
      [ s0 = promoted59__test_bitwise_ops'0 (fun (pr59:UInt32BW.t) ->  [ &_980 <- pr59 ] s1)
      | s1 = promoted58__test_bitwise_ops'0 (fun (pr58:UInt32BW.t) ->  [ &_979 <- pr58 ] s2)
      | s2 =  [ &_322 <- (_980, _979) ] s3
      | s3 =  [ &left_val16 <- let (r'0, _) = _322 in r'0 ] s4
      | s4 =  [ &right_val16 <- let (_, r'1) = _322 in r'1 ] s5
      | s5 =  [ &_329 <- left_val16 = right_val16 ] s6
      | s6 = any [ br0 -> {_329 = false} (! bb34) | br1 -> {_329} (! bb33) ]  ]
    
    | bb33 = s0
      [ s0 = promoted57__test_bitwise_ops'0 (fun (pr57:Int32BW.t) ->  [ &_978 <- pr57 ] s1)
      | s1 = promoted56__test_bitwise_ops'0 (fun (pr56:Int32BW.t) ->  [ &_977 <- pr56 ] s2)
      | s2 =  [ &_342 <- (_978, _977) ] s3
      | s3 =  [ &left_val17 <- let (r'0, _) = _342 in r'0 ] s4
      | s4 =  [ &right_val17 <- let (_, r'1) = _342 in r'1 ] s5
      | s5 =  [ &_349 <- left_val17 = right_val17 ] s6
      | s6 = any [ br0 -> {_349 = false} (! bb36) | br1 -> {_349} (! bb35) ]  ]
    
    | bb35 = s0
      [ s0 = promoted55__test_bitwise_ops'0 (fun (pr55:UInt64BW.t) ->  [ &_976 <- pr55 ] s1)
      | s1 = promoted54__test_bitwise_ops'0 (fun (pr54:UInt64BW.t) ->  [ &_975 <- pr54 ] s2)
      | s2 =  [ &_362 <- (_976, _975) ] s3
      | s3 =  [ &left_val18 <- let (r'0, _) = _362 in r'0 ] s4
      | s4 =  [ &right_val18 <- let (_, r'1) = _362 in r'1 ] s5
      | s5 =  [ &_369 <- left_val18 = right_val18 ] s6
      | s6 = any [ br0 -> {_369 = false} (! bb38) | br1 -> {_369} (! bb37) ]  ]
    
    | bb37 = s0
      [ s0 = promoted53__test_bitwise_ops'0 (fun (pr53:Int64BW.t) ->  [ &_974 <- pr53 ] s1)
      | s1 = promoted52__test_bitwise_ops'0 (fun (pr52:Int64BW.t) ->  [ &_973 <- pr52 ] s2)
      | s2 =  [ &_382 <- (_974, _973) ] s3
      | s3 =  [ &left_val19 <- let (r'0, _) = _382 in r'0 ] s4
      | s4 =  [ &right_val19 <- let (_, r'1) = _382 in r'1 ] s5
      | s5 =  [ &_389 <- left_val19 = right_val19 ] s6
      | s6 = any [ br0 -> {_389 = false} (! bb40) | br1 -> {_389} (! bb39) ]  ]
    
    | bb39 = s0
      [ s0 = promoted51__test_bitwise_ops'0 (fun (pr51:UInt128BW.t) ->  [ &_972 <- pr51 ] s1)
      | s1 = promoted50__test_bitwise_ops'0 (fun (pr50:UInt128BW.t) ->  [ &_971 <- pr50 ] s2)
      | s2 =  [ &_402 <- (_972, _971) ] s3
      | s3 =  [ &left_val20 <- let (r'0, _) = _402 in r'0 ] s4
      | s4 =  [ &right_val20 <- let (_, r'1) = _402 in r'1 ] s5
      | s5 =  [ &_409 <- left_val20 = right_val20 ] s6
      | s6 = any [ br0 -> {_409 = false} (! bb42) | br1 -> {_409} (! bb41) ]  ]
    
    | bb41 = s0
      [ s0 = promoted49__test_bitwise_ops'0 (fun (pr49:Int128BW.t) ->  [ &_970 <- pr49 ] s1)
      | s1 = promoted48__test_bitwise_ops'0 (fun (pr48:Int128BW.t) ->  [ &_969 <- pr48 ] s2)
      | s2 =  [ &_422 <- (_970, _969) ] s3
      | s3 =  [ &left_val21 <- let (r'0, _) = _422 in r'0 ] s4
      | s4 =  [ &right_val21 <- let (_, r'1) = _422 in r'1 ] s5
      | s5 =  [ &_429 <- left_val21 = right_val21 ] s6
      | s6 = any [ br0 -> {_429 = false} (! bb44) | br1 -> {_429} (! bb43) ]  ]
    
    | bb43 = s0
      [ s0 = promoted47__test_bitwise_ops'0 (fun (pr47:UInt64BW.t) ->  [ &_968 <- pr47 ] s1)
      | s1 = promoted46__test_bitwise_ops'0 (fun (pr46:UInt64BW.t) ->  [ &_967 <- pr46 ] s2)
      | s2 =  [ &_442 <- (_968, _967) ] s3
      | s3 =  [ &left_val22 <- let (r'0, _) = _442 in r'0 ] s4
      | s4 =  [ &right_val22 <- let (_, r'1) = _442 in r'1 ] s5
      | s5 =  [ &_449 <- left_val22 = right_val22 ] s6
      | s6 = any [ br0 -> {_449 = false} (! bb46) | br1 -> {_449} (! bb45) ]  ]
    
    | bb45 = s0
      [ s0 = promoted45__test_bitwise_ops'0 (fun (pr45:Int64BW.t) ->  [ &_966 <- pr45 ] s1)
      | s1 = promoted44__test_bitwise_ops'0 (fun (pr44:Int64BW.t) ->  [ &_965 <- pr44 ] s2)
      | s2 =  [ &_462 <- (_966, _965) ] s3
      | s3 =  [ &left_val23 <- let (r'0, _) = _462 in r'0 ] s4
      | s4 =  [ &right_val23 <- let (_, r'1) = _462 in r'1 ] s5
      | s5 =  [ &_469 <- left_val23 = right_val23 ] s6
      | s6 = any [ br0 -> {_469 = false} (! bb48) | br1 -> {_469} (! bb47) ]  ]
    
    | bb47 = s0
      [ s0 = promoted43__test_bitwise_ops'0 (fun (pr43:UInt8BW.t) ->  [ &_964 <- pr43 ] s1)
      | s1 = promoted42__test_bitwise_ops'0 (fun (pr42:UInt8BW.t) ->  [ &_963 <- pr42 ] s2)
      | s2 =  [ &_482 <- (_964, _963) ] s3
      | s3 =  [ &left_val24 <- let (r'0, _) = _482 in r'0 ] s4
      | s4 =  [ &right_val24 <- let (_, r'1) = _482 in r'1 ] s5
      | s5 =  [ &_489 <- left_val24 = right_val24 ] s6
      | s6 = any [ br0 -> {_489 = false} (! bb50) | br1 -> {_489} (! bb49) ]  ]
    
    | bb49 = s0
      [ s0 = promoted41__test_bitwise_ops'0 (fun (pr41:Int8BW.t) ->  [ &_962 <- pr41 ] s1)
      | s1 = promoted40__test_bitwise_ops'0 (fun (pr40:Int8BW.t) ->  [ &_961 <- pr40 ] s2)
      | s2 =  [ &_502 <- (_962, _961) ] s3
      | s3 =  [ &left_val25 <- let (r'0, _) = _502 in r'0 ] s4
      | s4 =  [ &right_val25 <- let (_, r'1) = _502 in r'1 ] s5
      | s5 =  [ &_509 <- left_val25 = right_val25 ] s6
      | s6 = any [ br0 -> {_509 = false} (! bb52) | br1 -> {_509} (! bb51) ]  ]
    
    | bb51 = s0
      [ s0 = promoted39__test_bitwise_ops'0 (fun (pr39:UInt16BW.t) ->  [ &_960 <- pr39 ] s1)
      | s1 = promoted38__test_bitwise_ops'0 (fun (pr38:UInt16BW.t) ->  [ &_959 <- pr38 ] s2)
      | s2 =  [ &_522 <- (_960, _959) ] s3
      | s3 =  [ &left_val26 <- let (r'0, _) = _522 in r'0 ] s4
      | s4 =  [ &right_val26 <- let (_, r'1) = _522 in r'1 ] s5
      | s5 =  [ &_529 <- left_val26 = right_val26 ] s6
      | s6 = any [ br0 -> {_529 = false} (! bb54) | br1 -> {_529} (! bb53) ]  ]
    
    | bb53 = s0
      [ s0 = promoted37__test_bitwise_ops'0 (fun (pr37:Int16BW.t) ->  [ &_958 <- pr37 ] s1)
      | s1 = promoted36__test_bitwise_ops'0 (fun (pr36:Int16BW.t) ->  [ &_957 <- pr36 ] s2)
      | s2 =  [ &_542 <- (_958, _957) ] s3
      | s3 =  [ &left_val27 <- let (r'0, _) = _542 in r'0 ] s4
      | s4 =  [ &right_val27 <- let (_, r'1) = _542 in r'1 ] s5
      | s5 =  [ &_549 <- left_val27 = right_val27 ] s6
      | s6 = any [ br0 -> {_549 = false} (! bb56) | br1 -> {_549} (! bb55) ]  ]
    
    | bb55 = s0
      [ s0 = promoted35__test_bitwise_ops'0 (fun (pr35:UInt32BW.t) ->  [ &_956 <- pr35 ] s1)
      | s1 = promoted34__test_bitwise_ops'0 (fun (pr34:UInt32BW.t) ->  [ &_955 <- pr34 ] s2)
      | s2 =  [ &_562 <- (_956, _955) ] s3
      | s3 =  [ &left_val28 <- let (r'0, _) = _562 in r'0 ] s4
      | s4 =  [ &right_val28 <- let (_, r'1) = _562 in r'1 ] s5
      | s5 =  [ &_569 <- left_val28 = right_val28 ] s6
      | s6 = any [ br0 -> {_569 = false} (! bb58) | br1 -> {_569} (! bb57) ]  ]
    
    | bb57 = s0
      [ s0 = promoted33__test_bitwise_ops'0 (fun (pr33:Int32BW.t) ->  [ &_954 <- pr33 ] s1)
      | s1 = promoted32__test_bitwise_ops'0 (fun (pr32:Int32BW.t) ->  [ &_953 <- pr32 ] s2)
      | s2 =  [ &_582 <- (_954, _953) ] s3
      | s3 =  [ &left_val29 <- let (r'0, _) = _582 in r'0 ] s4
      | s4 =  [ &right_val29 <- let (_, r'1) = _582 in r'1 ] s5
      | s5 =  [ &_589 <- left_val29 = right_val29 ] s6
      | s6 = any [ br0 -> {_589 = false} (! bb60) | br1 -> {_589} (! bb59) ]  ]
    
    | bb59 = s0
      [ s0 = promoted31__test_bitwise_ops'0 (fun (pr31:UInt64BW.t) ->  [ &_952 <- pr31 ] s1)
      | s1 = promoted30__test_bitwise_ops'0 (fun (pr30:UInt64BW.t) ->  [ &_951 <- pr30 ] s2)
      | s2 =  [ &_602 <- (_952, _951) ] s3
      | s3 =  [ &left_val30 <- let (r'0, _) = _602 in r'0 ] s4
      | s4 =  [ &right_val30 <- let (_, r'1) = _602 in r'1 ] s5
      | s5 =  [ &_609 <- left_val30 = right_val30 ] s6
      | s6 = any [ br0 -> {_609 = false} (! bb62) | br1 -> {_609} (! bb61) ]  ]
    
    | bb61 = s0
      [ s0 = promoted29__test_bitwise_ops'0 (fun (pr29:Int64BW.t) ->  [ &_950 <- pr29 ] s1)
      | s1 = promoted28__test_bitwise_ops'0 (fun (pr28:Int64BW.t) ->  [ &_949 <- pr28 ] s2)
      | s2 =  [ &_622 <- (_950, _949) ] s3
      | s3 =  [ &left_val31 <- let (r'0, _) = _622 in r'0 ] s4
      | s4 =  [ &right_val31 <- let (_, r'1) = _622 in r'1 ] s5
      | s5 =  [ &_629 <- left_val31 = right_val31 ] s6
      | s6 = any [ br0 -> {_629 = false} (! bb64) | br1 -> {_629} (! bb63) ]  ]
    
    | bb63 = s0
      [ s0 = promoted27__test_bitwise_ops'0 (fun (pr27:UInt128BW.t) ->  [ &_948 <- pr27 ] s1)
      | s1 = promoted26__test_bitwise_ops'0 (fun (pr26:UInt128BW.t) ->  [ &_947 <- pr26 ] s2)
      | s2 =  [ &_642 <- (_948, _947) ] s3
      | s3 =  [ &left_val32 <- let (r'0, _) = _642 in r'0 ] s4
      | s4 =  [ &right_val32 <- let (_, r'1) = _642 in r'1 ] s5
      | s5 =  [ &_649 <- left_val32 = right_val32 ] s6
      | s6 = any [ br0 -> {_649 = false} (! bb66) | br1 -> {_649} (! bb65) ]  ]
    
    | bb65 = s0
      [ s0 = promoted25__test_bitwise_ops'0 (fun (pr25:Int128BW.t) ->  [ &_946 <- pr25 ] s1)
      | s1 = promoted24__test_bitwise_ops'0 (fun (pr24:Int128BW.t) ->  [ &_945 <- pr24 ] s2)
      | s2 =  [ &_662 <- (_946, _945) ] s3
      | s3 =  [ &left_val33 <- let (r'0, _) = _662 in r'0 ] s4
      | s4 =  [ &right_val33 <- let (_, r'1) = _662 in r'1 ] s5
      | s5 =  [ &_669 <- left_val33 = right_val33 ] s6
      | s6 = any [ br0 -> {_669 = false} (! bb68) | br1 -> {_669} (! bb67) ]  ]
    
    | bb67 = s0
      [ s0 = promoted23__test_bitwise_ops'0 (fun (pr23:UInt64BW.t) ->  [ &_944 <- pr23 ] s1)
      | s1 = promoted22__test_bitwise_ops'0 (fun (pr22:UInt64BW.t) ->  [ &_943 <- pr22 ] s2)
      | s2 =  [ &_682 <- (_944, _943) ] s3
      | s3 =  [ &left_val34 <- let (r'0, _) = _682 in r'0 ] s4
      | s4 =  [ &right_val34 <- let (_, r'1) = _682 in r'1 ] s5
      | s5 =  [ &_689 <- left_val34 = right_val34 ] s6
      | s6 = any [ br0 -> {_689 = false} (! bb70) | br1 -> {_689} (! bb69) ]  ]
    
    | bb69 = s0
      [ s0 = promoted21__test_bitwise_ops'0 (fun (pr21:Int64BW.t) ->  [ &_942 <- pr21 ] s1)
      | s1 = promoted20__test_bitwise_ops'0 (fun (pr20:Int64BW.t) ->  [ &_941 <- pr20 ] s2)
      | s2 =  [ &_702 <- (_942, _941) ] s3
      | s3 =  [ &left_val35 <- let (r'0, _) = _702 in r'0 ] s4
      | s4 =  [ &right_val35 <- let (_, r'1) = _702 in r'1 ] s5
      | s5 =  [ &_709 <- left_val35 = right_val35 ] s6
      | s6 = any [ br0 -> {_709 = false} (! bb72) | br1 -> {_709} (! bb71) ]  ]
    
    | bb71 = s0
      [ s0 = promoted19__test_bitwise_ops'0 (fun (pr19:UInt8BW.t) ->  [ &_940 <- pr19 ] s1)
      | s1 = promoted18__test_bitwise_ops'0 (fun (pr18:UInt8BW.t) ->  [ &_939 <- pr18 ] s2)
      | s2 =  [ &_722 <- (_940, _939) ] s3
      | s3 =  [ &left_val36 <- let (r'0, _) = _722 in r'0 ] s4
      | s4 =  [ &right_val36 <- let (_, r'1) = _722 in r'1 ] s5
      | s5 =  [ &_729 <- left_val36 = right_val36 ] s6
      | s6 = any [ br0 -> {_729 = false} (! bb74) | br1 -> {_729} (! bb73) ]  ]
    
    | bb73 = s0
      [ s0 = promoted17__test_bitwise_ops'0 (fun (pr17:Int8BW.t) ->  [ &_938 <- pr17 ] s1)
      | s1 = promoted16__test_bitwise_ops'0 (fun (pr16:Int8BW.t) ->  [ &_937 <- pr16 ] s2)
      | s2 =  [ &_742 <- (_938, _937) ] s3
      | s3 =  [ &left_val37 <- let (r'0, _) = _742 in r'0 ] s4
      | s4 =  [ &right_val37 <- let (_, r'1) = _742 in r'1 ] s5
      | s5 =  [ &_749 <- left_val37 = right_val37 ] s6
      | s6 = any [ br0 -> {_749 = false} (! bb76) | br1 -> {_749} (! bb75) ]  ]
    
    | bb75 = s0
      [ s0 = promoted15__test_bitwise_ops'0 (fun (pr15:UInt16BW.t) ->  [ &_936 <- pr15 ] s1)
      | s1 = promoted14__test_bitwise_ops'0 (fun (pr14:UInt16BW.t) ->  [ &_935 <- pr14 ] s2)
      | s2 =  [ &_762 <- (_936, _935) ] s3
      | s3 =  [ &left_val38 <- let (r'0, _) = _762 in r'0 ] s4
      | s4 =  [ &right_val38 <- let (_, r'1) = _762 in r'1 ] s5
      | s5 =  [ &_769 <- left_val38 = right_val38 ] s6
      | s6 = any [ br0 -> {_769 = false} (! bb78) | br1 -> {_769} (! bb77) ]  ]
    
    | bb77 = s0
      [ s0 = promoted13__test_bitwise_ops'0 (fun (pr13:Int16BW.t) ->  [ &_934 <- pr13 ] s1)
      | s1 = promoted12__test_bitwise_ops'0 (fun (pr12:Int16BW.t) ->  [ &_933 <- pr12 ] s2)
      | s2 =  [ &_782 <- (_934, _933) ] s3
      | s3 =  [ &left_val39 <- let (r'0, _) = _782 in r'0 ] s4
      | s4 =  [ &right_val39 <- let (_, r'1) = _782 in r'1 ] s5
      | s5 =  [ &_789 <- left_val39 = right_val39 ] s6
      | s6 = any [ br0 -> {_789 = false} (! bb80) | br1 -> {_789} (! bb79) ]  ]
    
    | bb79 = s0
      [ s0 = promoted11__test_bitwise_ops'0 (fun (pr11:UInt32BW.t) ->  [ &_932 <- pr11 ] s1)
      | s1 = promoted10__test_bitwise_ops'0 (fun (pr10:UInt32BW.t) ->  [ &_931 <- pr10 ] s2)
      | s2 =  [ &_802 <- (_932, _931) ] s3
      | s3 =  [ &left_val40 <- let (r'0, _) = _802 in r'0 ] s4
      | s4 =  [ &right_val40 <- let (_, r'1) = _802 in r'1 ] s5
      | s5 =  [ &_809 <- left_val40 = right_val40 ] s6
      | s6 = any [ br0 -> {_809 = false} (! bb82) | br1 -> {_809} (! bb81) ]  ]
    
    | bb81 = s0
      [ s0 = promoted9__test_bitwise_ops'0 (fun (pr9:Int32BW.t) ->  [ &_930 <- pr9 ] s1)
      | s1 = promoted8__test_bitwise_ops'0 (fun (pr8:Int32BW.t) ->  [ &_929 <- pr8 ] s2)
      | s2 =  [ &_822 <- (_930, _929) ] s3
      | s3 =  [ &left_val41 <- let (r'0, _) = _822 in r'0 ] s4
      | s4 =  [ &right_val41 <- let (_, r'1) = _822 in r'1 ] s5
      | s5 =  [ &_829 <- left_val41 = right_val41 ] s6
      | s6 = any [ br0 -> {_829 = false} (! bb84) | br1 -> {_829} (! bb83) ]  ]
    
    | bb83 = s0
      [ s0 = promoted7__test_bitwise_ops'0 (fun (pr7:UInt64BW.t) ->  [ &_928 <- pr7 ] s1)
      | s1 = promoted6__test_bitwise_ops'0 (fun (pr6:UInt64BW.t) ->  [ &_927 <- pr6 ] s2)
      | s2 =  [ &_842 <- (_928, _927) ] s3
      | s3 =  [ &left_val42 <- let (r'0, _) = _842 in r'0 ] s4
      | s4 =  [ &right_val42 <- let (_, r'1) = _842 in r'1 ] s5
      | s5 =  [ &_849 <- left_val42 = right_val42 ] s6
      | s6 = any [ br0 -> {_849 = false} (! bb86) | br1 -> {_849} (! bb85) ]  ]
    
    | bb85 = s0
      [ s0 = promoted5__test_bitwise_ops'0 (fun (pr5:Int64BW.t) ->  [ &_926 <- pr5 ] s1)
      | s1 = promoted4__test_bitwise_ops'0 (fun (pr4:Int64BW.t) ->  [ &_925 <- pr4 ] s2)
      | s2 =  [ &_862 <- (_926, _925) ] s3
      | s3 =  [ &left_val43 <- let (r'0, _) = _862 in r'0 ] s4
      | s4 =  [ &right_val43 <- let (_, r'1) = _862 in r'1 ] s5
      | s5 =  [ &_869 <- left_val43 = right_val43 ] s6
      | s6 = any [ br0 -> {_869 = false} (! bb88) | br1 -> {_869} (! bb87) ]  ]
    
    | bb87 = s0
      [ s0 = promoted3__test_bitwise_ops'0 (fun (pr3:UInt128BW.t) ->  [ &_924 <- pr3 ] s1)
      | s1 = promoted2__test_bitwise_ops'0 (fun (pr2:UInt128BW.t) ->  [ &_923 <- pr2 ] s2)
      | s2 =  [ &_882 <- (_924, _923) ] s3
      | s3 =  [ &left_val44 <- let (r'0, _) = _882 in r'0 ] s4
      | s4 =  [ &right_val44 <- let (_, r'1) = _882 in r'1 ] s5
      | s5 =  [ &_889 <- left_val44 = right_val44 ] s6
      | s6 = any [ br0 -> {_889 = false} (! bb90) | br1 -> {_889} (! bb89) ]  ]
    
    | bb89 = s0
      [ s0 = promoted1__test_bitwise_ops'0 (fun (pr1:Int128BW.t) ->  [ &_922 <- pr1 ] s1)
      | s1 = promoted0__test_bitwise_ops'0 (fun (pr0:Int128BW.t) ->  [ &_921 <- pr0 ] s2)
      | s2 =  [ &_902 <- (_922, _921) ] s3
      | s3 =  [ &left_val45 <- let (r'0, _) = _902 in r'0 ] s4
      | s4 =  [ &right_val45 <- let (_, r'1) = _902 in r'1 ] s5
      | s5 =  [ &_909 <- left_val45 = right_val45 ] s6
      | s6 = any [ br0 -> {_909 = false} (! bb92) | br1 -> {_909} (! bb91) ]  ]
    
    | bb91 = return' {_0}
    | bb92 = s0
      [ s0 =  [ &kind45 <- C_Eq'0 ] s1
      | s1 =  [ &_917 <- left_val45 ] s2
      | s2 =  [ &_919 <- right_val45 ] s3
      | s3 = {false} any ]
    
    | bb90 = s0
      [ s0 =  [ &kind44 <- C_Eq'0 ] s1
      | s1 =  [ &_897 <- left_val44 ] s2
      | s2 =  [ &_899 <- right_val44 ] s3
      | s3 = {false} any ]
    
    | bb88 = s0
      [ s0 =  [ &kind43 <- C_Eq'0 ] s1
      | s1 =  [ &_877 <- left_val43 ] s2
      | s2 =  [ &_879 <- right_val43 ] s3
      | s3 = {false} any ]
    
    | bb86 = s0
      [ s0 =  [ &kind42 <- C_Eq'0 ] s1
      | s1 =  [ &_857 <- left_val42 ] s2
      | s2 =  [ &_859 <- right_val42 ] s3
      | s3 = {false} any ]
    
    | bb84 = s0
      [ s0 =  [ &kind41 <- C_Eq'0 ] s1
      | s1 =  [ &_837 <- left_val41 ] s2
      | s2 =  [ &_839 <- right_val41 ] s3
      | s3 = {false} any ]
    
    | bb82 = s0
      [ s0 =  [ &kind40 <- C_Eq'0 ] s1
      | s1 =  [ &_817 <- left_val40 ] s2
      | s2 =  [ &_819 <- right_val40 ] s3
      | s3 = {false} any ]
    
    | bb80 = s0
      [ s0 =  [ &kind39 <- C_Eq'0 ] s1
      | s1 =  [ &_797 <- left_val39 ] s2
      | s2 =  [ &_799 <- right_val39 ] s3
      | s3 = {false} any ]
    
    | bb78 = s0
      [ s0 =  [ &kind38 <- C_Eq'0 ] s1
      | s1 =  [ &_777 <- left_val38 ] s2
      | s2 =  [ &_779 <- right_val38 ] s3
      | s3 = {false} any ]
    
    | bb76 = s0
      [ s0 =  [ &kind37 <- C_Eq'0 ] s1
      | s1 =  [ &_757 <- left_val37 ] s2
      | s2 =  [ &_759 <- right_val37 ] s3
      | s3 = {false} any ]
    
    | bb74 = s0
      [ s0 =  [ &kind36 <- C_Eq'0 ] s1
      | s1 =  [ &_737 <- left_val36 ] s2
      | s2 =  [ &_739 <- right_val36 ] s3
      | s3 = {false} any ]
    
    | bb72 = s0
      [ s0 =  [ &kind35 <- C_Eq'0 ] s1
      | s1 =  [ &_717 <- left_val35 ] s2
      | s2 =  [ &_719 <- right_val35 ] s3
      | s3 = {false} any ]
    
    | bb70 = s0
      [ s0 =  [ &kind34 <- C_Eq'0 ] s1
      | s1 =  [ &_697 <- left_val34 ] s2
      | s2 =  [ &_699 <- right_val34 ] s3
      | s3 = {false} any ]
    
    | bb68 = s0
      [ s0 =  [ &kind33 <- C_Eq'0 ] s1
      | s1 =  [ &_677 <- left_val33 ] s2
      | s2 =  [ &_679 <- right_val33 ] s3
      | s3 = {false} any ]
    
    | bb66 = s0
      [ s0 =  [ &kind32 <- C_Eq'0 ] s1
      | s1 =  [ &_657 <- left_val32 ] s2
      | s2 =  [ &_659 <- right_val32 ] s3
      | s3 = {false} any ]
    
    | bb64 = s0
      [ s0 =  [ &kind31 <- C_Eq'0 ] s1
      | s1 =  [ &_637 <- left_val31 ] s2
      | s2 =  [ &_639 <- right_val31 ] s3
      | s3 = {false} any ]
    
    | bb62 = s0
      [ s0 =  [ &kind30 <- C_Eq'0 ] s1
      | s1 =  [ &_617 <- left_val30 ] s2
      | s2 =  [ &_619 <- right_val30 ] s3
      | s3 = {false} any ]
    
    | bb60 = s0
      [ s0 =  [ &kind29 <- C_Eq'0 ] s1
      | s1 =  [ &_597 <- left_val29 ] s2
      | s2 =  [ &_599 <- right_val29 ] s3
      | s3 = {false} any ]
    
    | bb58 = s0
      [ s0 =  [ &kind28 <- C_Eq'0 ] s1
      | s1 =  [ &_577 <- left_val28 ] s2
      | s2 =  [ &_579 <- right_val28 ] s3
      | s3 = {false} any ]
    
    | bb56 = s0
      [ s0 =  [ &kind27 <- C_Eq'0 ] s1
      | s1 =  [ &_557 <- left_val27 ] s2
      | s2 =  [ &_559 <- right_val27 ] s3
      | s3 = {false} any ]
    
    | bb54 = s0
      [ s0 =  [ &kind26 <- C_Eq'0 ] s1
      | s1 =  [ &_537 <- left_val26 ] s2
      | s2 =  [ &_539 <- right_val26 ] s3
      | s3 = {false} any ]
    
    | bb52 = s0
      [ s0 =  [ &kind25 <- C_Eq'0 ] s1
      | s1 =  [ &_517 <- left_val25 ] s2
      | s2 =  [ &_519 <- right_val25 ] s3
      | s3 = {false} any ]
    
    | bb50 = s0
      [ s0 =  [ &kind24 <- C_Eq'0 ] s1
      | s1 =  [ &_497 <- left_val24 ] s2
      | s2 =  [ &_499 <- right_val24 ] s3
      | s3 = {false} any ]
    
    | bb48 = s0
      [ s0 =  [ &kind23 <- C_Eq'0 ] s1
      | s1 =  [ &_477 <- left_val23 ] s2
      | s2 =  [ &_479 <- right_val23 ] s3
      | s3 = {false} any ]
    
    | bb46 = s0
      [ s0 =  [ &kind22 <- C_Eq'0 ] s1
      | s1 =  [ &_457 <- left_val22 ] s2
      | s2 =  [ &_459 <- right_val22 ] s3
      | s3 = {false} any ]
    
    | bb44 = s0
      [ s0 =  [ &kind21 <- C_Eq'0 ] s1
      | s1 =  [ &_437 <- left_val21 ] s2
      | s2 =  [ &_439 <- right_val21 ] s3
      | s3 = {false} any ]
    
    | bb42 = s0
      [ s0 =  [ &kind20 <- C_Eq'0 ] s1
      | s1 =  [ &_417 <- left_val20 ] s2
      | s2 =  [ &_419 <- right_val20 ] s3
      | s3 = {false} any ]
    
    | bb40 = s0
      [ s0 =  [ &kind19 <- C_Eq'0 ] s1
      | s1 =  [ &_397 <- left_val19 ] s2
      | s2 =  [ &_399 <- right_val19 ] s3
      | s3 = {false} any ]
    
    | bb38 = s0
      [ s0 =  [ &kind18 <- C_Eq'0 ] s1
      | s1 =  [ &_377 <- left_val18 ] s2
      | s2 =  [ &_379 <- right_val18 ] s3
      | s3 = {false} any ]
    
    | bb36 = s0
      [ s0 =  [ &kind17 <- C_Eq'0 ] s1
      | s1 =  [ &_357 <- left_val17 ] s2
      | s2 =  [ &_359 <- right_val17 ] s3
      | s3 = {false} any ]
    
    | bb34 = s0
      [ s0 =  [ &kind16 <- C_Eq'0 ] s1
      | s1 =  [ &_337 <- left_val16 ] s2
      | s2 =  [ &_339 <- right_val16 ] s3
      | s3 = {false} any ]
    
    | bb32 = s0
      [ s0 =  [ &kind15 <- C_Eq'0 ] s1
      | s1 =  [ &_317 <- left_val15 ] s2
      | s2 =  [ &_319 <- right_val15 ] s3
      | s3 = {false} any ]
    
    | bb30 = s0
      [ s0 =  [ &kind14 <- C_Eq'0 ] s1
      | s1 =  [ &_297 <- left_val14 ] s2
      | s2 =  [ &_299 <- right_val14 ] s3
      | s3 = {false} any ]
    
    | bb28 = s0
      [ s0 =  [ &kind13 <- C_Eq'0 ] s1
      | s1 =  [ &_277 <- left_val13 ] s2
      | s2 =  [ &_279 <- right_val13 ] s3
      | s3 = {false} any ]
    
    | bb26 = s0
      [ s0 =  [ &kind12 <- C_Eq'0 ] s1
      | s1 =  [ &_257 <- left_val12 ] s2
      | s2 =  [ &_259 <- right_val12 ] s3
      | s3 = {false} any ]
    
    | bb24 = s0
      [ s0 =  [ &kind11 <- C_Eq'0 ] s1
      | s1 =  [ &_237 <- left_val11 ] s2
      | s2 =  [ &_239 <- right_val11 ] s3
      | s3 = {false} any ]
    
    | bb22 = s0
      [ s0 =  [ &kind10 <- C_Eq'0 ] s1
      | s1 =  [ &_217 <- left_val10 ] s2
      | s2 =  [ &_219 <- right_val10 ] s3
      | s3 = {false} any ]
    
    | bb20 = s0
      [ s0 =  [ &kind9 <- C_Eq'0 ] s1
      | s1 =  [ &_197 <- left_val9 ] s2
      | s2 =  [ &_199 <- right_val9 ] s3
      | s3 = {false} any ]
    
    | bb18 = s0
      [ s0 =  [ &kind8 <- C_Eq'0 ] s1
      | s1 =  [ &_177 <- left_val8 ] s2
      | s2 =  [ &_179 <- right_val8 ] s3
      | s3 = {false} any ]
    
    | bb16 = s0
      [ s0 =  [ &kind7 <- C_Eq'0 ] s1
      | s1 =  [ &_157 <- left_val7 ] s2
      | s2 =  [ &_159 <- right_val7 ] s3
      | s3 = {false} any ]
    
    | bb14 = s0
      [ s0 =  [ &kind6 <- C_Eq'0 ] s1
      | s1 =  [ &_137 <- left_val6 ] s2
      | s2 =  [ &_139 <- right_val6 ] s3
      | s3 = {false} any ]
    
    | bb12 = s0
      [ s0 =  [ &kind5 <- C_Eq'0 ] s1
      | s1 =  [ &_117 <- left_val5 ] s2
      | s2 =  [ &_119 <- right_val5 ] s3
      | s3 = {false} any ]
    
    | bb10 = s0
      [ s0 =  [ &kind4 <- C_Eq'0 ] s1
      | s1 =  [ &_97 <- left_val4 ] s2
      | s2 =  [ &_99 <- right_val4 ] s3
      | s3 = {false} any ]
    
    | bb8 = s0
      [ s0 =  [ &kind3 <- C_Eq'0 ] s1
      | s1 =  [ &_77 <- left_val3 ] s2
      | s2 =  [ &_79 <- right_val3 ] s3
      | s3 = {false} any ]
    
    | bb6 = s0
      [ s0 =  [ &kind2 <- C_Eq'0 ] s1
      | s1 =  [ &_57 <- left_val2 ] s2
      | s2 =  [ &_59 <- right_val2 ] s3
      | s3 = {false} any ]
    
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_37 <- left_val1 ] s2
      | s2 =  [ &_39 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_17 <- left_val ] s2
      | s2 =  [ &_19 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : () = Any.any_l ()
    | & _2 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val : UInt8BW.t = Any.any_l ()
    | & right_val : UInt8BW.t = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _17 : UInt8BW.t = Any.any_l ()
    | & _19 : UInt8BW.t = Any.any_l ()
    | & _22 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val1 : Int8BW.t = Any.any_l ()
    | & right_val1 : Int8BW.t = Any.any_l ()
    | & _29 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _37 : Int8BW.t = Any.any_l ()
    | & _39 : Int8BW.t = Any.any_l ()
    | & _42 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val2 : UInt16BW.t = Any.any_l ()
    | & right_val2 : UInt16BW.t = Any.any_l ()
    | & _49 : bool = Any.any_l ()
    | & kind2 : t_AssertKind'0 = Any.any_l ()
    | & _57 : UInt16BW.t = Any.any_l ()
    | & _59 : UInt16BW.t = Any.any_l ()
    | & _62 : (Int16BW.t, Int16BW.t) = Any.any_l ()
    | & left_val3 : Int16BW.t = Any.any_l ()
    | & right_val3 : Int16BW.t = Any.any_l ()
    | & _69 : bool = Any.any_l ()
    | & kind3 : t_AssertKind'0 = Any.any_l ()
    | & _77 : Int16BW.t = Any.any_l ()
    | & _79 : Int16BW.t = Any.any_l ()
    | & _82 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val4 : UInt32BW.t = Any.any_l ()
    | & right_val4 : UInt32BW.t = Any.any_l ()
    | & _89 : bool = Any.any_l ()
    | & kind4 : t_AssertKind'0 = Any.any_l ()
    | & _97 : UInt32BW.t = Any.any_l ()
    | & _99 : UInt32BW.t = Any.any_l ()
    | & _102 : (Int32BW.t, Int32BW.t) = Any.any_l ()
    | & left_val5 : Int32BW.t = Any.any_l ()
    | & right_val5 : Int32BW.t = Any.any_l ()
    | & _109 : bool = Any.any_l ()
    | & kind5 : t_AssertKind'0 = Any.any_l ()
    | & _117 : Int32BW.t = Any.any_l ()
    | & _119 : Int32BW.t = Any.any_l ()
    | & _122 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val6 : UInt64BW.t = Any.any_l ()
    | & right_val6 : UInt64BW.t = Any.any_l ()
    | & _129 : bool = Any.any_l ()
    | & kind6 : t_AssertKind'0 = Any.any_l ()
    | & _137 : UInt64BW.t = Any.any_l ()
    | & _139 : UInt64BW.t = Any.any_l ()
    | & _142 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val7 : Int64BW.t = Any.any_l ()
    | & right_val7 : Int64BW.t = Any.any_l ()
    | & _149 : bool = Any.any_l ()
    | & kind7 : t_AssertKind'0 = Any.any_l ()
    | & _157 : Int64BW.t = Any.any_l ()
    | & _159 : Int64BW.t = Any.any_l ()
    | & _162 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val8 : UInt128BW.t = Any.any_l ()
    | & right_val8 : UInt128BW.t = Any.any_l ()
    | & _169 : bool = Any.any_l ()
    | & kind8 : t_AssertKind'0 = Any.any_l ()
    | & _177 : UInt128BW.t = Any.any_l ()
    | & _179 : UInt128BW.t = Any.any_l ()
    | & _182 : (Int128BW.t, Int128BW.t) = Any.any_l ()
    | & left_val9 : Int128BW.t = Any.any_l ()
    | & right_val9 : Int128BW.t = Any.any_l ()
    | & _189 : bool = Any.any_l ()
    | & kind9 : t_AssertKind'0 = Any.any_l ()
    | & _197 : Int128BW.t = Any.any_l ()
    | & _199 : Int128BW.t = Any.any_l ()
    | & _202 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val10 : UInt64BW.t = Any.any_l ()
    | & right_val10 : UInt64BW.t = Any.any_l ()
    | & _209 : bool = Any.any_l ()
    | & kind10 : t_AssertKind'0 = Any.any_l ()
    | & _217 : UInt64BW.t = Any.any_l ()
    | & _219 : UInt64BW.t = Any.any_l ()
    | & _222 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val11 : Int64BW.t = Any.any_l ()
    | & right_val11 : Int64BW.t = Any.any_l ()
    | & _229 : bool = Any.any_l ()
    | & kind11 : t_AssertKind'0 = Any.any_l ()
    | & _237 : Int64BW.t = Any.any_l ()
    | & _239 : Int64BW.t = Any.any_l ()
    | & _242 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val12 : UInt8BW.t = Any.any_l ()
    | & right_val12 : UInt8BW.t = Any.any_l ()
    | & _249 : bool = Any.any_l ()
    | & kind12 : t_AssertKind'0 = Any.any_l ()
    | & _257 : UInt8BW.t = Any.any_l ()
    | & _259 : UInt8BW.t = Any.any_l ()
    | & _262 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val13 : Int8BW.t = Any.any_l ()
    | & right_val13 : Int8BW.t = Any.any_l ()
    | & _269 : bool = Any.any_l ()
    | & kind13 : t_AssertKind'0 = Any.any_l ()
    | & _277 : Int8BW.t = Any.any_l ()
    | & _279 : Int8BW.t = Any.any_l ()
    | & _282 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val14 : UInt16BW.t = Any.any_l ()
    | & right_val14 : UInt16BW.t = Any.any_l ()
    | & _289 : bool = Any.any_l ()
    | & kind14 : t_AssertKind'0 = Any.any_l ()
    | & _297 : UInt16BW.t = Any.any_l ()
    | & _299 : UInt16BW.t = Any.any_l ()
    | & _302 : (Int16BW.t, Int16BW.t) = Any.any_l ()
    | & left_val15 : Int16BW.t = Any.any_l ()
    | & right_val15 : Int16BW.t = Any.any_l ()
    | & _309 : bool = Any.any_l ()
    | & kind15 : t_AssertKind'0 = Any.any_l ()
    | & _317 : Int16BW.t = Any.any_l ()
    | & _319 : Int16BW.t = Any.any_l ()
    | & _322 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val16 : UInt32BW.t = Any.any_l ()
    | & right_val16 : UInt32BW.t = Any.any_l ()
    | & _329 : bool = Any.any_l ()
    | & kind16 : t_AssertKind'0 = Any.any_l ()
    | & _337 : UInt32BW.t = Any.any_l ()
    | & _339 : UInt32BW.t = Any.any_l ()
    | & _342 : (Int32BW.t, Int32BW.t) = Any.any_l ()
    | & left_val17 : Int32BW.t = Any.any_l ()
    | & right_val17 : Int32BW.t = Any.any_l ()
    | & _349 : bool = Any.any_l ()
    | & kind17 : t_AssertKind'0 = Any.any_l ()
    | & _357 : Int32BW.t = Any.any_l ()
    | & _359 : Int32BW.t = Any.any_l ()
    | & _362 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val18 : UInt64BW.t = Any.any_l ()
    | & right_val18 : UInt64BW.t = Any.any_l ()
    | & _369 : bool = Any.any_l ()
    | & kind18 : t_AssertKind'0 = Any.any_l ()
    | & _377 : UInt64BW.t = Any.any_l ()
    | & _379 : UInt64BW.t = Any.any_l ()
    | & _382 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val19 : Int64BW.t = Any.any_l ()
    | & right_val19 : Int64BW.t = Any.any_l ()
    | & _389 : bool = Any.any_l ()
    | & kind19 : t_AssertKind'0 = Any.any_l ()
    | & _397 : Int64BW.t = Any.any_l ()
    | & _399 : Int64BW.t = Any.any_l ()
    | & _402 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val20 : UInt128BW.t = Any.any_l ()
    | & right_val20 : UInt128BW.t = Any.any_l ()
    | & _409 : bool = Any.any_l ()
    | & kind20 : t_AssertKind'0 = Any.any_l ()
    | & _417 : UInt128BW.t = Any.any_l ()
    | & _419 : UInt128BW.t = Any.any_l ()
    | & _422 : (Int128BW.t, Int128BW.t) = Any.any_l ()
    | & left_val21 : Int128BW.t = Any.any_l ()
    | & right_val21 : Int128BW.t = Any.any_l ()
    | & _429 : bool = Any.any_l ()
    | & kind21 : t_AssertKind'0 = Any.any_l ()
    | & _437 : Int128BW.t = Any.any_l ()
    | & _439 : Int128BW.t = Any.any_l ()
    | & _442 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val22 : UInt64BW.t = Any.any_l ()
    | & right_val22 : UInt64BW.t = Any.any_l ()
    | & _449 : bool = Any.any_l ()
    | & kind22 : t_AssertKind'0 = Any.any_l ()
    | & _457 : UInt64BW.t = Any.any_l ()
    | & _459 : UInt64BW.t = Any.any_l ()
    | & _462 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val23 : Int64BW.t = Any.any_l ()
    | & right_val23 : Int64BW.t = Any.any_l ()
    | & _469 : bool = Any.any_l ()
    | & kind23 : t_AssertKind'0 = Any.any_l ()
    | & _477 : Int64BW.t = Any.any_l ()
    | & _479 : Int64BW.t = Any.any_l ()
    | & _482 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val24 : UInt8BW.t = Any.any_l ()
    | & right_val24 : UInt8BW.t = Any.any_l ()
    | & _489 : bool = Any.any_l ()
    | & kind24 : t_AssertKind'0 = Any.any_l ()
    | & _497 : UInt8BW.t = Any.any_l ()
    | & _499 : UInt8BW.t = Any.any_l ()
    | & _502 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val25 : Int8BW.t = Any.any_l ()
    | & right_val25 : Int8BW.t = Any.any_l ()
    | & _509 : bool = Any.any_l ()
    | & kind25 : t_AssertKind'0 = Any.any_l ()
    | & _517 : Int8BW.t = Any.any_l ()
    | & _519 : Int8BW.t = Any.any_l ()
    | & _522 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val26 : UInt16BW.t = Any.any_l ()
    | & right_val26 : UInt16BW.t = Any.any_l ()
    | & _529 : bool = Any.any_l ()
    | & kind26 : t_AssertKind'0 = Any.any_l ()
    | & _537 : UInt16BW.t = Any.any_l ()
    | & _539 : UInt16BW.t = Any.any_l ()
    | & _542 : (Int16BW.t, Int16BW.t) = Any.any_l ()
    | & left_val27 : Int16BW.t = Any.any_l ()
    | & right_val27 : Int16BW.t = Any.any_l ()
    | & _549 : bool = Any.any_l ()
    | & kind27 : t_AssertKind'0 = Any.any_l ()
    | & _557 : Int16BW.t = Any.any_l ()
    | & _559 : Int16BW.t = Any.any_l ()
    | & _562 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val28 : UInt32BW.t = Any.any_l ()
    | & right_val28 : UInt32BW.t = Any.any_l ()
    | & _569 : bool = Any.any_l ()
    | & kind28 : t_AssertKind'0 = Any.any_l ()
    | & _577 : UInt32BW.t = Any.any_l ()
    | & _579 : UInt32BW.t = Any.any_l ()
    | & _582 : (Int32BW.t, Int32BW.t) = Any.any_l ()
    | & left_val29 : Int32BW.t = Any.any_l ()
    | & right_val29 : Int32BW.t = Any.any_l ()
    | & _589 : bool = Any.any_l ()
    | & kind29 : t_AssertKind'0 = Any.any_l ()
    | & _597 : Int32BW.t = Any.any_l ()
    | & _599 : Int32BW.t = Any.any_l ()
    | & _602 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val30 : UInt64BW.t = Any.any_l ()
    | & right_val30 : UInt64BW.t = Any.any_l ()
    | & _609 : bool = Any.any_l ()
    | & kind30 : t_AssertKind'0 = Any.any_l ()
    | & _617 : UInt64BW.t = Any.any_l ()
    | & _619 : UInt64BW.t = Any.any_l ()
    | & _622 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val31 : Int64BW.t = Any.any_l ()
    | & right_val31 : Int64BW.t = Any.any_l ()
    | & _629 : bool = Any.any_l ()
    | & kind31 : t_AssertKind'0 = Any.any_l ()
    | & _637 : Int64BW.t = Any.any_l ()
    | & _639 : Int64BW.t = Any.any_l ()
    | & _642 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val32 : UInt128BW.t = Any.any_l ()
    | & right_val32 : UInt128BW.t = Any.any_l ()
    | & _649 : bool = Any.any_l ()
    | & kind32 : t_AssertKind'0 = Any.any_l ()
    | & _657 : UInt128BW.t = Any.any_l ()
    | & _659 : UInt128BW.t = Any.any_l ()
    | & _662 : (Int128BW.t, Int128BW.t) = Any.any_l ()
    | & left_val33 : Int128BW.t = Any.any_l ()
    | & right_val33 : Int128BW.t = Any.any_l ()
    | & _669 : bool = Any.any_l ()
    | & kind33 : t_AssertKind'0 = Any.any_l ()
    | & _677 : Int128BW.t = Any.any_l ()
    | & _679 : Int128BW.t = Any.any_l ()
    | & _682 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val34 : UInt64BW.t = Any.any_l ()
    | & right_val34 : UInt64BW.t = Any.any_l ()
    | & _689 : bool = Any.any_l ()
    | & kind34 : t_AssertKind'0 = Any.any_l ()
    | & _697 : UInt64BW.t = Any.any_l ()
    | & _699 : UInt64BW.t = Any.any_l ()
    | & _702 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val35 : Int64BW.t = Any.any_l ()
    | & right_val35 : Int64BW.t = Any.any_l ()
    | & _709 : bool = Any.any_l ()
    | & kind35 : t_AssertKind'0 = Any.any_l ()
    | & _717 : Int64BW.t = Any.any_l ()
    | & _719 : Int64BW.t = Any.any_l ()
    | & _722 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val36 : UInt8BW.t = Any.any_l ()
    | & right_val36 : UInt8BW.t = Any.any_l ()
    | & _729 : bool = Any.any_l ()
    | & kind36 : t_AssertKind'0 = Any.any_l ()
    | & _737 : UInt8BW.t = Any.any_l ()
    | & _739 : UInt8BW.t = Any.any_l ()
    | & _742 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val37 : Int8BW.t = Any.any_l ()
    | & right_val37 : Int8BW.t = Any.any_l ()
    | & _749 : bool = Any.any_l ()
    | & kind37 : t_AssertKind'0 = Any.any_l ()
    | & _757 : Int8BW.t = Any.any_l ()
    | & _759 : Int8BW.t = Any.any_l ()
    | & _762 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val38 : UInt16BW.t = Any.any_l ()
    | & right_val38 : UInt16BW.t = Any.any_l ()
    | & _769 : bool = Any.any_l ()
    | & kind38 : t_AssertKind'0 = Any.any_l ()
    | & _777 : UInt16BW.t = Any.any_l ()
    | & _779 : UInt16BW.t = Any.any_l ()
    | & _782 : (Int16BW.t, Int16BW.t) = Any.any_l ()
    | & left_val39 : Int16BW.t = Any.any_l ()
    | & right_val39 : Int16BW.t = Any.any_l ()
    | & _789 : bool = Any.any_l ()
    | & kind39 : t_AssertKind'0 = Any.any_l ()
    | & _797 : Int16BW.t = Any.any_l ()
    | & _799 : Int16BW.t = Any.any_l ()
    | & _802 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val40 : UInt32BW.t = Any.any_l ()
    | & right_val40 : UInt32BW.t = Any.any_l ()
    | & _809 : bool = Any.any_l ()
    | & kind40 : t_AssertKind'0 = Any.any_l ()
    | & _817 : UInt32BW.t = Any.any_l ()
    | & _819 : UInt32BW.t = Any.any_l ()
    | & _822 : (Int32BW.t, Int32BW.t) = Any.any_l ()
    | & left_val41 : Int32BW.t = Any.any_l ()
    | & right_val41 : Int32BW.t = Any.any_l ()
    | & _829 : bool = Any.any_l ()
    | & kind41 : t_AssertKind'0 = Any.any_l ()
    | & _837 : Int32BW.t = Any.any_l ()
    | & _839 : Int32BW.t = Any.any_l ()
    | & _842 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val42 : UInt64BW.t = Any.any_l ()
    | & right_val42 : UInt64BW.t = Any.any_l ()
    | & _849 : bool = Any.any_l ()
    | & kind42 : t_AssertKind'0 = Any.any_l ()
    | & _857 : UInt64BW.t = Any.any_l ()
    | & _859 : UInt64BW.t = Any.any_l ()
    | & _862 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val43 : Int64BW.t = Any.any_l ()
    | & right_val43 : Int64BW.t = Any.any_l ()
    | & _869 : bool = Any.any_l ()
    | & kind43 : t_AssertKind'0 = Any.any_l ()
    | & _877 : Int64BW.t = Any.any_l ()
    | & _879 : Int64BW.t = Any.any_l ()
    | & _882 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val44 : UInt128BW.t = Any.any_l ()
    | & right_val44 : UInt128BW.t = Any.any_l ()
    | & _889 : bool = Any.any_l ()
    | & kind44 : t_AssertKind'0 = Any.any_l ()
    | & _897 : UInt128BW.t = Any.any_l ()
    | & _899 : UInt128BW.t = Any.any_l ()
    | & _902 : (Int128BW.t, Int128BW.t) = Any.any_l ()
    | & left_val45 : Int128BW.t = Any.any_l ()
    | & right_val45 : Int128BW.t = Any.any_l ()
    | & _909 : bool = Any.any_l ()
    | & kind45 : t_AssertKind'0 = Any.any_l ()
    | & _917 : Int128BW.t = Any.any_l ()
    | & _919 : Int128BW.t = Any.any_l ()
    | & _921 : Int128BW.t = Any.any_l ()
    | & _922 : Int128BW.t = Any.any_l ()
    | & _923 : UInt128BW.t = Any.any_l ()
    | & _924 : UInt128BW.t = Any.any_l ()
    | & _925 : Int64BW.t = Any.any_l ()
    | & _926 : Int64BW.t = Any.any_l ()
    | & _927 : UInt64BW.t = Any.any_l ()
    | & _928 : UInt64BW.t = Any.any_l ()
    | & _929 : Int32BW.t = Any.any_l ()
    | & _930 : Int32BW.t = Any.any_l ()
    | & _931 : UInt32BW.t = Any.any_l ()
    | & _932 : UInt32BW.t = Any.any_l ()
    | & _933 : Int16BW.t = Any.any_l ()
    | & _934 : Int16BW.t = Any.any_l ()
    | & _935 : UInt16BW.t = Any.any_l ()
    | & _936 : UInt16BW.t = Any.any_l ()
    | & _937 : Int8BW.t = Any.any_l ()
    | & _938 : Int8BW.t = Any.any_l ()
    | & _939 : UInt8BW.t = Any.any_l ()
    | & _940 : UInt8BW.t = Any.any_l ()
    | & _941 : Int64BW.t = Any.any_l ()
    | & _942 : Int64BW.t = Any.any_l ()
    | & _943 : UInt64BW.t = Any.any_l ()
    | & _944 : UInt64BW.t = Any.any_l ()
    | & _945 : Int128BW.t = Any.any_l ()
    | & _946 : Int128BW.t = Any.any_l ()
    | & _947 : UInt128BW.t = Any.any_l ()
    | & _948 : UInt128BW.t = Any.any_l ()
    | & _949 : Int64BW.t = Any.any_l ()
    | & _950 : Int64BW.t = Any.any_l ()
    | & _951 : UInt64BW.t = Any.any_l ()
    | & _952 : UInt64BW.t = Any.any_l ()
    | & _953 : Int32BW.t = Any.any_l ()
    | & _954 : Int32BW.t = Any.any_l ()
    | & _955 : UInt32BW.t = Any.any_l ()
    | & _956 : UInt32BW.t = Any.any_l ()
    | & _957 : Int16BW.t = Any.any_l ()
    | & _958 : Int16BW.t = Any.any_l ()
    | & _959 : UInt16BW.t = Any.any_l ()
    | & _960 : UInt16BW.t = Any.any_l ()
    | & _961 : Int8BW.t = Any.any_l ()
    | & _962 : Int8BW.t = Any.any_l ()
    | & _963 : UInt8BW.t = Any.any_l ()
    | & _964 : UInt8BW.t = Any.any_l ()
    | & _965 : Int64BW.t = Any.any_l ()
    | & _966 : Int64BW.t = Any.any_l ()
    | & _967 : UInt64BW.t = Any.any_l ()
    | & _968 : UInt64BW.t = Any.any_l ()
    | & _969 : Int128BW.t = Any.any_l ()
    | & _970 : Int128BW.t = Any.any_l ()
    | & _971 : UInt128BW.t = Any.any_l ()
    | & _972 : UInt128BW.t = Any.any_l ()
    | & _973 : Int64BW.t = Any.any_l ()
    | & _974 : Int64BW.t = Any.any_l ()
    | & _975 : UInt64BW.t = Any.any_l ()
    | & _976 : UInt64BW.t = Any.any_l ()
    | & _977 : Int32BW.t = Any.any_l ()
    | & _978 : Int32BW.t = Any.any_l ()
    | & _979 : UInt32BW.t = Any.any_l ()
    | & _980 : UInt32BW.t = Any.any_l ()
    | & _981 : Int16BW.t = Any.any_l ()
    | & _982 : Int16BW.t = Any.any_l ()
    | & _983 : UInt16BW.t = Any.any_l ()
    | & _984 : UInt16BW.t = Any.any_l ()
    | & _985 : Int8BW.t = Any.any_l ()
    | & _986 : Int8BW.t = Any.any_l ()
    | & _987 : UInt8BW.t = Any.any_l ()
    | & _988 : UInt8BW.t = Any.any_l ()
    | & _989 : Int64BW.t = Any.any_l ()
    | & _990 : Int64BW.t = Any.any_l ()
    | & _991 : UInt64BW.t = Any.any_l ()
    | & _992 : UInt64BW.t = Any.any_l ()
    | & _993 : Int128BW.t = Any.any_l ()
    | & _994 : Int128BW.t = Any.any_l ()
    | & _995 : UInt128BW.t = Any.any_l ()
    | & _996 : UInt128BW.t = Any.any_l ()
    | & _997 : Int64BW.t = Any.any_l ()
    | & _998 : Int64BW.t = Any.any_l ()
    | & _999 : UInt64BW.t = Any.any_l ()
    | & _1000 : UInt64BW.t = Any.any_l ()
    | & _1001 : Int32BW.t = Any.any_l ()
    | & _1002 : Int32BW.t = Any.any_l ()
    | & _1003 : UInt32BW.t = Any.any_l ()
    | & _1004 : UInt32BW.t = Any.any_l ()
    | & _1005 : Int16BW.t = Any.any_l ()
    | & _1006 : Int16BW.t = Any.any_l ()
    | & _1007 : UInt16BW.t = Any.any_l ()
    | & _1008 : UInt16BW.t = Any.any_l ()
    | & _1009 : Int8BW.t = Any.any_l ()
    | & _1010 : Int8BW.t = Any.any_l ()
    | & _1011 : UInt8BW.t = Any.any_l ()
    | & _1012 : UInt8BW.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_integer_ops__test_shift_ops [#"integer_ops.rs" 62 0 62 23]
  let%span sinteger_ops0 = "integer_ops.rs" 64 32 64 33
  let%span sinteger_ops1 = "integer_ops.rs" 64 15 64 28
  let%span sinteger_ops2 = "integer_ops.rs" 64 35 64 48
  let%span sinteger_ops3 = "integer_ops.rs" 65 32 65 33
  let%span sinteger_ops4 = "integer_ops.rs" 65 15 65 28
  let%span sinteger_ops5 = "integer_ops.rs" 65 35 65 48
  let%span sinteger_ops6 = "integer_ops.rs" 66 43 66 44
  let%span sinteger_ops7 = "integer_ops.rs" 66 15 66 39
  let%span sinteger_ops8 = "integer_ops.rs" 66 46 66 70
  let%span sinteger_ops9 = "integer_ops.rs" 67 32 67 33
  let%span sinteger_ops10 = "integer_ops.rs" 67 15 67 28
  let%span sinteger_ops11 = "integer_ops.rs" 67 35 67 41
  let%span sinteger_ops12 = "integer_ops.rs" 68 40 68 41
  let%span sinteger_ops13 = "integer_ops.rs" 68 15 68 36
  let%span sinteger_ops14 = "integer_ops.rs" 68 43 68 58
  let%span sinteger_ops15 = "integer_ops.rs" 69 43 69 44
  let%span sinteger_ops16 = "integer_ops.rs" 69 15 69 39
  let%span sinteger_ops17 = "integer_ops.rs" 69 46 69 67
  let%span sinteger_ops18 = "integer_ops.rs" 70 35 70 36
  let%span sinteger_ops19 = "integer_ops.rs" 70 15 70 31
  let%span sinteger_ops20 = "integer_ops.rs" 70 38 70 57
  let%span sinteger_ops21 = "integer_ops.rs" 73 32 73 33
  let%span sinteger_ops22 = "integer_ops.rs" 73 15 73 28
  let%span sinteger_ops23 = "integer_ops.rs" 73 35 73 48
  let%span sinteger_ops24 = "integer_ops.rs" 74 15 74 28
  let%span sinteger_ops25 = "integer_ops.rs" 74 38 74 39
  let%span sinteger_ops26 = "integer_ops.rs" 74 41 74 54
  let%span sinteger_ops27 = "integer_ops.rs" 75 43 75 44
  let%span sinteger_ops28 = "integer_ops.rs" 75 15 75 39
  let%span sinteger_ops29 = "integer_ops.rs" 75 46 75 70
  let%span sinteger_ops30 = "integer_ops.rs" 76 32 76 34
  let%span sinteger_ops31 = "integer_ops.rs" 76 15 76 28
  let%span sinteger_ops32 = "integer_ops.rs" 76 36 76 43
  let%span sinteger_ops33 = "integer_ops.rs" 77 40 77 42
  let%span sinteger_ops34 = "integer_ops.rs" 77 15 77 36
  let%span sinteger_ops35 = "integer_ops.rs" 77 44 77 58
  let%span sinteger_ops36 = "integer_ops.rs" 78 28 78 31
  let%span sinteger_ops37 = "integer_ops.rs" 78 15 78 24
  let%span sinteger_ops38 = "integer_ops.rs" 78 33 78 40
  let%span sinteger_ops39 = "integer_ops.rs" 79 35 79 36
  let%span sinteger_ops40 = "integer_ops.rs" 79 15 79 31
  let%span sinteger_ops41 = "integer_ops.rs" 79 38 79 54
  
  use creusot.int.UInt8BW
  
  use creusot.int.Int32BW
  
  use creusot.prelude.Any
  
  let rec promoted27__test_shift_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shl {[%#sinteger_ops1] (240 : UInt8BW.t)} {Int32BW.to_int ([%#sinteger_ops0] (2 : Int32BW.t))}
          (fun (_ret':UInt8BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted26__test_shift_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (192 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  use creusot.int.Int8BW
  
  let rec promoted25__test_shift_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 = Int8BW.shl {[%#sinteger_ops4] (105 : Int8BW.t)} {Int32BW.to_int ([%#sinteger_ops3] (3 : Int32BW.t))}
          (fun (_ret':Int8BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted24__test_shift_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops5] (72 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  use creusot.int.UInt16BW
  
  let rec promoted23__test_shift_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shl {[%#sinteger_ops7] (65535 : UInt16BW.t)} {Int32BW.to_int ([%#sinteger_ops6] (3 : Int32BW.t))}
          (fun (_ret':UInt16BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted22__test_shift_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops8] (65528 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  use creusot.int.UInt32BW
  
  let rec promoted21__test_shift_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shl
          {[%#sinteger_ops10] (3221225475 : UInt32BW.t)}
          {Int32BW.to_int ([%#sinteger_ops9] (2 : Int32BW.t))}
          (fun (_ret':UInt32BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted20__test_shift_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops11] (12 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  use creusot.int.UInt64BW
  
  let rec promoted19__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl
          {[%#sinteger_ops13] (13835321938072829955 : UInt64BW.t)}
          {Int32BW.to_int ([%#sinteger_ops12] (4 : Int32BW.t))}
          (fun (_ret':UInt64BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted18__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops14] (4222124650659888 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  use creusot.int.UInt128BW
  
  let rec promoted17__test_shift_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shl
          {[%#sinteger_ops16] (4514840875923203424259 : UInt128BW.t)}
          {Int32BW.to_int ([%#sinteger_ops15] (3 : Int32BW.t))}
          (fun (_ret':UInt128BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted16__test_shift_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops17] (36118727007385627394072 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted15__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shl {[%#sinteger_ops19] (240 : UInt64BW.t)} {Int32BW.to_int ([%#sinteger_ops18] (2 : Int32BW.t))}
          (fun (_ret':UInt64BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted14__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops20] (960 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted13__test_shift_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt8BW.shr {[%#sinteger_ops22] (240 : UInt8BW.t)} {Int32BW.to_int ([%#sinteger_ops21] (2 : Int32BW.t))}
          (fun (_ret':UInt8BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted12__test_shift_ops'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops23] (60 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted11__test_shift_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 = Int8BW.of_BV256 {UInt8BW.to_BV256 ([%#sinteger_ops24] (240 : UInt8BW.t))}
          (fun (_ret_from:Int8BW.t) ->  [ &_2 <- _ret_from ] s1)
      | s1 = Int8BW.shr {_2} {Int32BW.to_int ([%#sinteger_ops25] (2 : Int32BW.t))}
          (fun (_ret':Int8BW.t) ->  [ &_1 <- _ret' ] s2)
      | s2 =  [ &_0 <- _1 ] s3
      | s3 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () | & _2 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted10__test_shift_ops'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 = Int8BW.of_BV256 {UInt8BW.to_BV256 ([%#sinteger_ops26] (252 : UInt8BW.t))}
          (fun (_ret_from:Int8BW.t) ->  [ &_1 <- _ret_from ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted9__test_shift_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt16BW.shr
          {[%#sinteger_ops28] (65535 : UInt16BW.t)}
          {Int32BW.to_int ([%#sinteger_ops27] (6 : Int32BW.t))}
          (fun (_ret':UInt16BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted8__test_shift_ops'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops29] (1023 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted7__test_shift_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt32BW.shr
          {[%#sinteger_ops31] (3221225475 : UInt32BW.t)}
          {Int32BW.to_int ([%#sinteger_ops30] (14 : Int32BW.t))}
          (fun (_ret':UInt32BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted6__test_shift_ops'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops32] (196608 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted5__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shr
          {[%#sinteger_ops34] (13835321938072829955 : UInt64BW.t)}
          {Int32BW.to_int ([%#sinteger_ops33] (18 : Int32BW.t))}
          (fun (_ret':UInt64BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted4__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops35] (52777564766208 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted3__test_shift_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt128BW.shr
          {[%#sinteger_ops37] (340282366920938463463374607431768211455 : UInt128BW.t)}
          {Int32BW.to_int ([%#sinteger_ops36] (110 : Int32BW.t))}
          (fun (_ret':UInt128BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_shift_ops'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops38] (262143 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted1__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 = UInt64BW.shr {[%#sinteger_ops40] (240 : UInt64BW.t)} {Int32BW.to_int ([%#sinteger_ops39] (2 : Int32BW.t))}
          (fun (_ret':UInt64BW.t) ->  [ &_1 <- _ret' ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_shift_ops'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops41] (60 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_shift_ops'0[#"integer_ops.rs" 62 0 62 23] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted27__test_shift_ops'0 (fun (pr27:UInt8BW.t) ->  [ &_309 <- pr27 ] s1)
      | s1 = promoted26__test_shift_ops'0 (fun (pr26:UInt8BW.t) ->  [ &_308 <- pr26 ] s2)
      | s2 =  [ &_2 <- (_309, _308) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _2 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _2 in r'1 ] s5
      | s5 =  [ &_9 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_9 = false} (! bb2) | br1 -> {_9} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted25__test_shift_ops'0 (fun (pr25:Int8BW.t) ->  [ &_307 <- pr25 ] s1)
      | s1 = promoted24__test_shift_ops'0 (fun (pr24:Int8BW.t) ->  [ &_306 <- pr24 ] s2)
      | s2 =  [ &_22 <- (_307, _306) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _22 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _22 in r'1 ] s5
      | s5 =  [ &_29 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_29 = false} (! bb4) | br1 -> {_29} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = promoted23__test_shift_ops'0 (fun (pr23:UInt16BW.t) ->  [ &_305 <- pr23 ] s1)
      | s1 = promoted22__test_shift_ops'0 (fun (pr22:UInt16BW.t) ->  [ &_304 <- pr22 ] s2)
      | s2 =  [ &_42 <- (_305, _304) ] s3
      | s3 =  [ &left_val2 <- let (r'0, _) = _42 in r'0 ] s4
      | s4 =  [ &right_val2 <- let (_, r'1) = _42 in r'1 ] s5
      | s5 =  [ &_49 <- left_val2 = right_val2 ] s6
      | s6 = any [ br0 -> {_49 = false} (! bb6) | br1 -> {_49} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = promoted21__test_shift_ops'0 (fun (pr21:UInt32BW.t) ->  [ &_303 <- pr21 ] s1)
      | s1 = promoted20__test_shift_ops'0 (fun (pr20:UInt32BW.t) ->  [ &_302 <- pr20 ] s2)
      | s2 =  [ &_62 <- (_303, _302) ] s3
      | s3 =  [ &left_val3 <- let (r'0, _) = _62 in r'0 ] s4
      | s4 =  [ &right_val3 <- let (_, r'1) = _62 in r'1 ] s5
      | s5 =  [ &_69 <- left_val3 = right_val3 ] s6
      | s6 = any [ br0 -> {_69 = false} (! bb8) | br1 -> {_69} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = promoted19__test_shift_ops'0 (fun (pr19:UInt64BW.t) ->  [ &_301 <- pr19 ] s1)
      | s1 = promoted18__test_shift_ops'0 (fun (pr18:UInt64BW.t) ->  [ &_300 <- pr18 ] s2)
      | s2 =  [ &_82 <- (_301, _300) ] s3
      | s3 =  [ &left_val4 <- let (r'0, _) = _82 in r'0 ] s4
      | s4 =  [ &right_val4 <- let (_, r'1) = _82 in r'1 ] s5
      | s5 =  [ &_89 <- left_val4 = right_val4 ] s6
      | s6 = any [ br0 -> {_89 = false} (! bb10) | br1 -> {_89} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = promoted17__test_shift_ops'0 (fun (pr17:UInt128BW.t) ->  [ &_299 <- pr17 ] s1)
      | s1 = promoted16__test_shift_ops'0 (fun (pr16:UInt128BW.t) ->  [ &_298 <- pr16 ] s2)
      | s2 =  [ &_102 <- (_299, _298) ] s3
      | s3 =  [ &left_val5 <- let (r'0, _) = _102 in r'0 ] s4
      | s4 =  [ &right_val5 <- let (_, r'1) = _102 in r'1 ] s5
      | s5 =  [ &_109 <- left_val5 = right_val5 ] s6
      | s6 = any [ br0 -> {_109 = false} (! bb12) | br1 -> {_109} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 = promoted15__test_shift_ops'0 (fun (pr15:UInt64BW.t) ->  [ &_297 <- pr15 ] s1)
      | s1 = promoted14__test_shift_ops'0 (fun (pr14:UInt64BW.t) ->  [ &_296 <- pr14 ] s2)
      | s2 =  [ &_122 <- (_297, _296) ] s3
      | s3 =  [ &left_val6 <- let (r'0, _) = _122 in r'0 ] s4
      | s4 =  [ &right_val6 <- let (_, r'1) = _122 in r'1 ] s5
      | s5 =  [ &_129 <- left_val6 = right_val6 ] s6
      | s6 = any [ br0 -> {_129 = false} (! bb14) | br1 -> {_129} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = promoted13__test_shift_ops'0 (fun (pr13:UInt8BW.t) ->  [ &_295 <- pr13 ] s1)
      | s1 = promoted12__test_shift_ops'0 (fun (pr12:UInt8BW.t) ->  [ &_294 <- pr12 ] s2)
      | s2 =  [ &_142 <- (_295, _294) ] s3
      | s3 =  [ &left_val7 <- let (r'0, _) = _142 in r'0 ] s4
      | s4 =  [ &right_val7 <- let (_, r'1) = _142 in r'1 ] s5
      | s5 =  [ &_149 <- left_val7 = right_val7 ] s6
      | s6 = any [ br0 -> {_149 = false} (! bb16) | br1 -> {_149} (! bb15) ]  ]
    
    | bb15 = s0
      [ s0 = promoted11__test_shift_ops'0 (fun (pr11:Int8BW.t) ->  [ &_293 <- pr11 ] s1)
      | s1 = promoted10__test_shift_ops'0 (fun (pr10:Int8BW.t) ->  [ &_292 <- pr10 ] s2)
      | s2 =  [ &_162 <- (_293, _292) ] s3
      | s3 =  [ &left_val8 <- let (r'0, _) = _162 in r'0 ] s4
      | s4 =  [ &right_val8 <- let (_, r'1) = _162 in r'1 ] s5
      | s5 =  [ &_170 <- left_val8 = right_val8 ] s6
      | s6 = any [ br0 -> {_170 = false} (! bb18) | br1 -> {_170} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = promoted9__test_shift_ops'0 (fun (pr9:UInt16BW.t) ->  [ &_291 <- pr9 ] s1)
      | s1 = promoted8__test_shift_ops'0 (fun (pr8:UInt16BW.t) ->  [ &_290 <- pr8 ] s2)
      | s2 =  [ &_183 <- (_291, _290) ] s3
      | s3 =  [ &left_val9 <- let (r'0, _) = _183 in r'0 ] s4
      | s4 =  [ &right_val9 <- let (_, r'1) = _183 in r'1 ] s5
      | s5 =  [ &_190 <- left_val9 = right_val9 ] s6
      | s6 = any [ br0 -> {_190 = false} (! bb20) | br1 -> {_190} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = promoted7__test_shift_ops'0 (fun (pr7:UInt32BW.t) ->  [ &_289 <- pr7 ] s1)
      | s1 = promoted6__test_shift_ops'0 (fun (pr6:UInt32BW.t) ->  [ &_288 <- pr6 ] s2)
      | s2 =  [ &_203 <- (_289, _288) ] s3
      | s3 =  [ &left_val10 <- let (r'0, _) = _203 in r'0 ] s4
      | s4 =  [ &right_val10 <- let (_, r'1) = _203 in r'1 ] s5
      | s5 =  [ &_210 <- left_val10 = right_val10 ] s6
      | s6 = any [ br0 -> {_210 = false} (! bb22) | br1 -> {_210} (! bb21) ]  ]
    
    | bb21 = s0
      [ s0 = promoted5__test_shift_ops'0 (fun (pr5:UInt64BW.t) ->  [ &_287 <- pr5 ] s1)
      | s1 = promoted4__test_shift_ops'0 (fun (pr4:UInt64BW.t) ->  [ &_286 <- pr4 ] s2)
      | s2 =  [ &_223 <- (_287, _286) ] s3
      | s3 =  [ &left_val11 <- let (r'0, _) = _223 in r'0 ] s4
      | s4 =  [ &right_val11 <- let (_, r'1) = _223 in r'1 ] s5
      | s5 =  [ &_230 <- left_val11 = right_val11 ] s6
      | s6 = any [ br0 -> {_230 = false} (! bb24) | br1 -> {_230} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = promoted3__test_shift_ops'0 (fun (pr3:UInt128BW.t) ->  [ &_285 <- pr3 ] s1)
      | s1 = promoted2__test_shift_ops'0 (fun (pr2:UInt128BW.t) ->  [ &_284 <- pr2 ] s2)
      | s2 =  [ &_243 <- (_285, _284) ] s3
      | s3 =  [ &left_val12 <- let (r'0, _) = _243 in r'0 ] s4
      | s4 =  [ &right_val12 <- let (_, r'1) = _243 in r'1 ] s5
      | s5 =  [ &_250 <- left_val12 = right_val12 ] s6
      | s6 = any [ br0 -> {_250 = false} (! bb26) | br1 -> {_250} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 = promoted1__test_shift_ops'0 (fun (pr1:UInt64BW.t) ->  [ &_283 <- pr1 ] s1)
      | s1 = promoted0__test_shift_ops'0 (fun (pr0:UInt64BW.t) ->  [ &_282 <- pr0 ] s2)
      | s2 =  [ &_263 <- (_283, _282) ] s3
      | s3 =  [ &left_val13 <- let (r'0, _) = _263 in r'0 ] s4
      | s4 =  [ &right_val13 <- let (_, r'1) = _263 in r'1 ] s5
      | s5 =  [ &_270 <- left_val13 = right_val13 ] s6
      | s6 = any [ br0 -> {_270 = false} (! bb28) | br1 -> {_270} (! bb27) ]  ]
    
    | bb27 = return' {_0}
    | bb28 = s0
      [ s0 =  [ &kind13 <- C_Eq'0 ] s1
      | s1 =  [ &_278 <- left_val13 ] s2
      | s2 =  [ &_280 <- right_val13 ] s3
      | s3 = {false} any ]
    
    | bb26 = s0
      [ s0 =  [ &kind12 <- C_Eq'0 ] s1
      | s1 =  [ &_258 <- left_val12 ] s2
      | s2 =  [ &_260 <- right_val12 ] s3
      | s3 = {false} any ]
    
    | bb24 = s0
      [ s0 =  [ &kind11 <- C_Eq'0 ] s1
      | s1 =  [ &_238 <- left_val11 ] s2
      | s2 =  [ &_240 <- right_val11 ] s3
      | s3 = {false} any ]
    
    | bb22 = s0
      [ s0 =  [ &kind10 <- C_Eq'0 ] s1
      | s1 =  [ &_218 <- left_val10 ] s2
      | s2 =  [ &_220 <- right_val10 ] s3
      | s3 = {false} any ]
    
    | bb20 = s0
      [ s0 =  [ &kind9 <- C_Eq'0 ] s1
      | s1 =  [ &_198 <- left_val9 ] s2
      | s2 =  [ &_200 <- right_val9 ] s3
      | s3 = {false} any ]
    
    | bb18 = s0
      [ s0 =  [ &kind8 <- C_Eq'0 ] s1
      | s1 =  [ &_178 <- left_val8 ] s2
      | s2 =  [ &_180 <- right_val8 ] s3
      | s3 = {false} any ]
    
    | bb16 = s0
      [ s0 =  [ &kind7 <- C_Eq'0 ] s1
      | s1 =  [ &_157 <- left_val7 ] s2
      | s2 =  [ &_159 <- right_val7 ] s3
      | s3 = {false} any ]
    
    | bb14 = s0
      [ s0 =  [ &kind6 <- C_Eq'0 ] s1
      | s1 =  [ &_137 <- left_val6 ] s2
      | s2 =  [ &_139 <- right_val6 ] s3
      | s3 = {false} any ]
    
    | bb12 = s0
      [ s0 =  [ &kind5 <- C_Eq'0 ] s1
      | s1 =  [ &_117 <- left_val5 ] s2
      | s2 =  [ &_119 <- right_val5 ] s3
      | s3 = {false} any ]
    
    | bb10 = s0
      [ s0 =  [ &kind4 <- C_Eq'0 ] s1
      | s1 =  [ &_97 <- left_val4 ] s2
      | s2 =  [ &_99 <- right_val4 ] s3
      | s3 = {false} any ]
    
    | bb8 = s0
      [ s0 =  [ &kind3 <- C_Eq'0 ] s1
      | s1 =  [ &_77 <- left_val3 ] s2
      | s2 =  [ &_79 <- right_val3 ] s3
      | s3 = {false} any ]
    
    | bb6 = s0
      [ s0 =  [ &kind2 <- C_Eq'0 ] s1
      | s1 =  [ &_57 <- left_val2 ] s2
      | s2 =  [ &_59 <- right_val2 ] s3
      | s3 = {false} any ]
    
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_37 <- left_val1 ] s2
      | s2 =  [ &_39 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_17 <- left_val ] s2
      | s2 =  [ &_19 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : () = Any.any_l ()
    | & _2 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val : UInt8BW.t = Any.any_l ()
    | & right_val : UInt8BW.t = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _17 : UInt8BW.t = Any.any_l ()
    | & _19 : UInt8BW.t = Any.any_l ()
    | & _22 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val1 : Int8BW.t = Any.any_l ()
    | & right_val1 : Int8BW.t = Any.any_l ()
    | & _29 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _37 : Int8BW.t = Any.any_l ()
    | & _39 : Int8BW.t = Any.any_l ()
    | & _42 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val2 : UInt16BW.t = Any.any_l ()
    | & right_val2 : UInt16BW.t = Any.any_l ()
    | & _49 : bool = Any.any_l ()
    | & kind2 : t_AssertKind'0 = Any.any_l ()
    | & _57 : UInt16BW.t = Any.any_l ()
    | & _59 : UInt16BW.t = Any.any_l ()
    | & _62 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val3 : UInt32BW.t = Any.any_l ()
    | & right_val3 : UInt32BW.t = Any.any_l ()
    | & _69 : bool = Any.any_l ()
    | & kind3 : t_AssertKind'0 = Any.any_l ()
    | & _77 : UInt32BW.t = Any.any_l ()
    | & _79 : UInt32BW.t = Any.any_l ()
    | & _82 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val4 : UInt64BW.t = Any.any_l ()
    | & right_val4 : UInt64BW.t = Any.any_l ()
    | & _89 : bool = Any.any_l ()
    | & kind4 : t_AssertKind'0 = Any.any_l ()
    | & _97 : UInt64BW.t = Any.any_l ()
    | & _99 : UInt64BW.t = Any.any_l ()
    | & _102 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val5 : UInt128BW.t = Any.any_l ()
    | & right_val5 : UInt128BW.t = Any.any_l ()
    | & _109 : bool = Any.any_l ()
    | & kind5 : t_AssertKind'0 = Any.any_l ()
    | & _117 : UInt128BW.t = Any.any_l ()
    | & _119 : UInt128BW.t = Any.any_l ()
    | & _122 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val6 : UInt64BW.t = Any.any_l ()
    | & right_val6 : UInt64BW.t = Any.any_l ()
    | & _129 : bool = Any.any_l ()
    | & kind6 : t_AssertKind'0 = Any.any_l ()
    | & _137 : UInt64BW.t = Any.any_l ()
    | & _139 : UInt64BW.t = Any.any_l ()
    | & _142 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val7 : UInt8BW.t = Any.any_l ()
    | & right_val7 : UInt8BW.t = Any.any_l ()
    | & _149 : bool = Any.any_l ()
    | & kind7 : t_AssertKind'0 = Any.any_l ()
    | & _157 : UInt8BW.t = Any.any_l ()
    | & _159 : UInt8BW.t = Any.any_l ()
    | & _162 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val8 : Int8BW.t = Any.any_l ()
    | & right_val8 : Int8BW.t = Any.any_l ()
    | & _170 : bool = Any.any_l ()
    | & kind8 : t_AssertKind'0 = Any.any_l ()
    | & _178 : Int8BW.t = Any.any_l ()
    | & _180 : Int8BW.t = Any.any_l ()
    | & _183 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val9 : UInt16BW.t = Any.any_l ()
    | & right_val9 : UInt16BW.t = Any.any_l ()
    | & _190 : bool = Any.any_l ()
    | & kind9 : t_AssertKind'0 = Any.any_l ()
    | & _198 : UInt16BW.t = Any.any_l ()
    | & _200 : UInt16BW.t = Any.any_l ()
    | & _203 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val10 : UInt32BW.t = Any.any_l ()
    | & right_val10 : UInt32BW.t = Any.any_l ()
    | & _210 : bool = Any.any_l ()
    | & kind10 : t_AssertKind'0 = Any.any_l ()
    | & _218 : UInt32BW.t = Any.any_l ()
    | & _220 : UInt32BW.t = Any.any_l ()
    | & _223 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val11 : UInt64BW.t = Any.any_l ()
    | & right_val11 : UInt64BW.t = Any.any_l ()
    | & _230 : bool = Any.any_l ()
    | & kind11 : t_AssertKind'0 = Any.any_l ()
    | & _238 : UInt64BW.t = Any.any_l ()
    | & _240 : UInt64BW.t = Any.any_l ()
    | & _243 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val12 : UInt128BW.t = Any.any_l ()
    | & right_val12 : UInt128BW.t = Any.any_l ()
    | & _250 : bool = Any.any_l ()
    | & kind12 : t_AssertKind'0 = Any.any_l ()
    | & _258 : UInt128BW.t = Any.any_l ()
    | & _260 : UInt128BW.t = Any.any_l ()
    | & _263 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val13 : UInt64BW.t = Any.any_l ()
    | & right_val13 : UInt64BW.t = Any.any_l ()
    | & _270 : bool = Any.any_l ()
    | & kind13 : t_AssertKind'0 = Any.any_l ()
    | & _278 : UInt64BW.t = Any.any_l ()
    | & _280 : UInt64BW.t = Any.any_l ()
    | & _282 : UInt64BW.t = Any.any_l ()
    | & _283 : UInt64BW.t = Any.any_l ()
    | & _284 : UInt128BW.t = Any.any_l ()
    | & _285 : UInt128BW.t = Any.any_l ()
    | & _286 : UInt64BW.t = Any.any_l ()
    | & _287 : UInt64BW.t = Any.any_l ()
    | & _288 : UInt32BW.t = Any.any_l ()
    | & _289 : UInt32BW.t = Any.any_l ()
    | & _290 : UInt16BW.t = Any.any_l ()
    | & _291 : UInt16BW.t = Any.any_l ()
    | & _292 : Int8BW.t = Any.any_l ()
    | & _293 : Int8BW.t = Any.any_l ()
    | & _294 : UInt8BW.t = Any.any_l ()
    | & _295 : UInt8BW.t = Any.any_l ()
    | & _296 : UInt64BW.t = Any.any_l ()
    | & _297 : UInt64BW.t = Any.any_l ()
    | & _298 : UInt128BW.t = Any.any_l ()
    | & _299 : UInt128BW.t = Any.any_l ()
    | & _300 : UInt64BW.t = Any.any_l ()
    | & _301 : UInt64BW.t = Any.any_l ()
    | & _302 : UInt32BW.t = Any.any_l ()
    | & _303 : UInt32BW.t = Any.any_l ()
    | & _304 : UInt16BW.t = Any.any_l ()
    | & _305 : UInt16BW.t = Any.any_l ()
    | & _306 : Int8BW.t = Any.any_l ()
    | & _307 : Int8BW.t = Any.any_l ()
    | & _308 : UInt8BW.t = Any.any_l ()
    | & _309 : UInt8BW.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_integer_ops__u8__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:UInt8.t) (r:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:test_add requires] [%#sinteger_ops0] UInt8.t'int l
    + UInt8.t'int r
    >= UInt8.t'int (v_MIN'0 : UInt8.t)
    /\ UInt8.t'int l + UInt8.t'int r <= UInt8.t'int (v_MAX'0 : UInt8.t)}
    (! bb0 [ bb0 = s0 [ s0 = UInt8.add {l} {r} (fun (_ret':UInt8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : UInt8.t = Any.any_l () | & l : UInt8.t = l | & r : UInt8.t = r ]
    
    [ return' (result:UInt8.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] UInt8.t'int result
      = UInt8.t'int l + UInt8.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8BW.t = (0 : UInt8BW.t)
  
  constant v_MAX'0 : UInt8BW.t = (255 : UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (ret:UInt8BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] UInt8BW.t'int l
    + UInt8BW.t'int r
    >= UInt8BW.t'int (v_MIN'0 : UInt8BW.t)
    /\ UInt8BW.t'int l + UInt8BW.t'int r <= UInt8BW.t'int (v_MAX'0 : UInt8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.add {l} {r} (fun (_ret':UInt8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt8BW.t = Any.any_l () | & l : UInt8BW.t = l | & r : UInt8BW.t = r ] 
    [ return' (result:UInt8BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] UInt8BW.t'int result
      = UInt8BW.t'int l + UInt8BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:UInt8.t) (r:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:test_sub requires] [%#sinteger_ops0] UInt8.t'int l
    - UInt8.t'int r
    >= UInt8.t'int (v_MIN'0 : UInt8.t)
    /\ UInt8.t'int l - UInt8.t'int r <= UInt8.t'int (v_MAX'0 : UInt8.t)}
    (! bb0 [ bb0 = s0 [ s0 = UInt8.sub {l} {r} (fun (_ret':UInt8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : UInt8.t = Any.any_l () | & l : UInt8.t = l | & r : UInt8.t = r ]
    
    [ return' (result:UInt8.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] UInt8.t'int result
      = UInt8.t'int l - UInt8.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8BW.t = (0 : UInt8BW.t)
  
  constant v_MAX'0 : UInt8BW.t = (255 : UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (ret:UInt8BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] UInt8BW.t'int l
    - UInt8BW.t'int r
    >= UInt8BW.t'int (v_MIN'0 : UInt8BW.t)
    /\ UInt8BW.t'int l - UInt8BW.t'int r <= UInt8BW.t'int (v_MAX'0 : UInt8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.sub {l} {r} (fun (_ret':UInt8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt8BW.t = Any.any_l () | & l : UInt8BW.t = l | & r : UInt8BW.t = r ] 
    [ return' (result:UInt8BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] UInt8BW.t'int result
      = UInt8BW.t'int l - UInt8BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:UInt8.t) (r:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:test_mul requires] [%#sinteger_ops0] UInt8.t'int l
    * UInt8.t'int r
    >= UInt8.t'int (v_MIN'0 : UInt8.t)
    /\ UInt8.t'int l * UInt8.t'int r <= UInt8.t'int (v_MAX'0 : UInt8.t)}
    (! bb0 [ bb0 = s0 [ s0 = UInt8.mul {l} {r} (fun (_ret':UInt8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : UInt8.t = Any.any_l () | & l : UInt8.t = l | & r : UInt8.t = r ]
    
    [ return' (result:UInt8.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] UInt8.t'int result
      = UInt8.t'int l * UInt8.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8BW.t = (0 : UInt8BW.t)
  
  constant v_MAX'0 : UInt8BW.t = (255 : UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (ret:UInt8BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] UInt8BW.t'int l
    * UInt8BW.t'int r
    >= UInt8BW.t'int (v_MIN'0 : UInt8BW.t)
    /\ UInt8BW.t'int l * UInt8BW.t'int r <= UInt8BW.t'int (v_MAX'0 : UInt8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt8BW.mul {l} {r} (fun (_ret':UInt8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt8BW.t = Any.any_l () | & l : UInt8BW.t = l | & r : UInt8BW.t = r ] 
    [ return' (result:UInt8BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] UInt8BW.t'int result
      = UInt8BW.t'int l * UInt8BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8.t = (0 : UInt8.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt8.t = (255 : UInt8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:UInt8.t) (r:UInt8.t) (return'  (ret:UInt8.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] UInt8.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (UInt8.t'int l) (UInt8.t'int r)
    >= UInt8.t'int (v_MIN'0 : UInt8.t)
    /\ Int.div (UInt8.t'int l) (UInt8.t'int r) <= UInt8.t'int (v_MAX'0 : UInt8.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt8.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt8.div {l} {_7} (fun (_ret':UInt8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt8.t = Any.any_l ()
    | & l : UInt8.t = l
    | & r : UInt8.t = r
    | & _7 : UInt8.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt8.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] UInt8.t'int result
      = Int.div (UInt8.t'int l) (UInt8.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt8BW.t = (0 : UInt8BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt8BW.t = (255 : UInt8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:UInt8BW.t) (r:UInt8BW.t) (return'  (ret:UInt8BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] UInt8BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (UInt8BW.t'int l) (UInt8BW.t'int r)
    >= UInt8BW.t'int (v_MIN'0 : UInt8BW.t)
    /\ Int.div (UInt8BW.t'int l) (UInt8BW.t'int r) <= UInt8BW.t'int (v_MAX'0 : UInt8BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt8BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt8BW.div {l} {_7} (fun (_ret':UInt8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt8BW.t = Any.any_l ()
    | & l : UInt8BW.t = l
    | & r : UInt8BW.t = r
    | & _7 : UInt8BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt8BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] UInt8BW.t'int result
      = Int.div (UInt8BW.t'int l) (UInt8BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:UInt8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8.t = Any.any_l () | & _1 : UInt8.t = Any.any_l () ]  [ return' (result:UInt8.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool'0 (return'  (ret:UInt8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt8.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8.t = Any.any_l () ]  [ return' (result:UInt8.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:UInt8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8.t = Any.any_l () | & _1 : UInt8.t = Any.any_l () ]  [ return' (result:UInt8.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool'0 (return'  (ret:UInt8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt8.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8.t = Any.any_l () ]  [ return' (result:UInt8.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:UInt8.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:UInt8.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:UInt8.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:UInt8.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:UInt8.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt8.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt8.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt8.t, UInt8.t) = Any.any_l ()
    | & left_val : UInt8.t = Any.any_l ()
    | & right_val : UInt8.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt8.t = Any.any_l ()
    | & _21 : UInt8.t = Any.any_l ()
    | & _24 : (UInt8.t, UInt8.t) = Any.any_l ()
    | & left_val1 : UInt8.t = Any.any_l ()
    | & right_val1 : UInt8.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt8.t = Any.any_l ()
    | & _41 : UInt8.t = Any.any_l ()
    | & _44 : UInt8.t = Any.any_l ()
    | & _45 : UInt8.t = Any.any_l ()
    | & _46 : UInt8.t = Any.any_l ()
    | & _47 : UInt8.t = Any.any_l () ]
    
    [ return' (result:UInt8.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = UInt8.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt8BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt8BW.t = Any.any_l () | & _1 : UInt8BW.t = Any.any_l () ] 
    [ return' (result:UInt8BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:UInt8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt8BW.t = Any.any_l () ]  [ return' (result:UInt8BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:UInt8BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:UInt8BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:UInt8BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:UInt8BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:UInt8BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt8BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt8BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val : UInt8BW.t = Any.any_l ()
    | & right_val : UInt8BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt8BW.t = Any.any_l ()
    | & _21 : UInt8BW.t = Any.any_l ()
    | & _24 : (UInt8BW.t, UInt8BW.t) = Any.any_l ()
    | & left_val1 : UInt8BW.t = Any.any_l ()
    | & right_val1 : UInt8BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt8BW.t = Any.any_l ()
    | & _41 : UInt8BW.t = Any.any_l ()
    | & _44 : UInt8BW.t = Any.any_l ()
    | & _45 : UInt8BW.t = Any.any_l ()
    | & _46 : UInt8BW.t = Any.any_l ()
    | & _47 : UInt8BW.t = Any.any_l () ]
    
    [ return' (result:UInt8BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = UInt8BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u8__test_to_char [#"integer_ops.rs" 170 4 170 25]
  let%span sinteger_ops0 = "integer_ops.rs" 171 20 171 24
  let%span sinteger_ops1 = "integer_ops.rs" 171 41 171 44
  
  use creusot.prelude.Char
  
  use creusot.int.UInt8
  
  use creusot.prelude.Any
  
  let rec promoted1__test_to_char'0 (return'  (ret:Char.t))= bb0
    [ bb0 = s0
      [ s0 = Char.of_int {UInt8.t'int ([%#sinteger_ops0] (97 : UInt8.t))}
          (fun (_ret_from:Char.t) ->  [ &_1 <- _ret_from ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Char.t = Any.any_l () | & _1 : Char.t = Any.any_l () ]  [ return' (result:Char.t)-> return' {result} ] 
  
  let rec promoted0__test_to_char'0 (return'  (ret:Char.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops1] Char.of_int 97 ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Char.t = Any.any_l () ]  [ return' (result:Char.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_to_char'0[#"integer_ops.rs" 170 4 170 25] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted1__test_to_char'0 (fun (pr1:Char.t) ->  [ &_23 <- pr1 ] s1)
      | s1 = promoted0__test_to_char'0 (fun (pr0:Char.t) ->  [ &_22 <- pr0 ] s2)
      | s2 =  [ &_2 <- (_23, _22) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _2 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _2 in r'1 ] s5
      | s5 =  [ &_10 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_10 = false} (! bb2) | br1 -> {_10} (! bb1) ]  ]
    
    | bb1 = return' {_0}
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_18 <- left_val ] s2
      | s2 =  [ &_20 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : () = Any.any_l ()
    | & _2 : (Char.t, Char.t) = Any.any_l ()
    | & left_val : Char.t = Any.any_l ()
    | & right_val : Char.t = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _18 : Char.t = Any.any_l ()
    | & _20 : Char.t = Any.any_l ()
    | & _22 : Char.t = Any.any_l ()
    | & _23 : Char.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_integer_ops__u8__test_to_char_bw [#"integer_ops.rs" 176 4 176 28]
  let%span sinteger_ops0 = "integer_ops.rs" 177 20 177 24
  let%span sinteger_ops1 = "integer_ops.rs" 177 41 177 44
  
  use creusot.prelude.Char
  
  use creusot.int.UInt8BW
  
  use creusot.prelude.Any
  
  let rec promoted1__test_to_char_bw'0 (return'  (ret:Char.t))= bb0
    [ bb0 = s0
      [ s0 = Char.of_BV256 {UInt8BW.to_BV256 ([%#sinteger_ops0] (255 : UInt8BW.t))}
          (fun (_ret_from:Char.t) ->  [ &_1 <- _ret_from ] s1)
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return' {_0} ]
     ]
     [ & _0 : Char.t = Any.any_l () | & _1 : Char.t = Any.any_l () ]  [ return' (result:Char.t)-> return' {result} ] 
  
  let rec promoted0__test_to_char_bw'0 (return'  (ret:Char.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops1] Char.of_int 255 ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Char.t = Any.any_l () ]  [ return' (result:Char.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_to_char_bw'0[#"integer_ops.rs" 176 4 176 28] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted1__test_to_char_bw'0 (fun (pr1:Char.t) ->  [ &_23 <- pr1 ] s1)
      | s1 = promoted0__test_to_char_bw'0 (fun (pr0:Char.t) ->  [ &_22 <- pr0 ] s2)
      | s2 =  [ &_2 <- (_23, _22) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _2 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _2 in r'1 ] s5
      | s5 =  [ &_10 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_10 = false} (! bb2) | br1 -> {_10} (! bb1) ]  ]
    
    | bb1 = return' {_0}
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_18 <- left_val ] s2
      | s2 =  [ &_20 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : () = Any.any_l ()
    | & _2 : (Char.t, Char.t) = Any.any_l ()
    | & left_val : Char.t = Any.any_l ()
    | & right_val : Char.t = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _18 : Char.t = Any.any_l ()
    | & _20 : Char.t = Any.any_l ()
    | & _22 : Char.t = Any.any_l ()
    | & _23 : Char.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_integer_ops__i8__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int8
  
  use creusot.prelude.Any
  
  use creusot.int.Int8
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:Int8.t) (r:Int8.t) (return'  (ret:Int8.t))= {[@expl:test_add requires] [%#sinteger_ops0] Int8.to_int l
    + Int8.to_int r
    >= Int8.to_int (v_MIN'0 : Int8.t)
    /\ Int8.to_int l + Int8.to_int r <= Int8.to_int (v_MAX'0 : Int8.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int8.add {l} {r} (fun (_ret':Int8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int8.t = Any.any_l () | & l : Int8.t = l | & r : Int8.t = r ]
    
    [ return' (result:Int8.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] Int8.to_int result
      = Int8.to_int l + Int8.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int8BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8BW.t = (128 : Int8BW.t)
  
  constant v_MAX'0 : Int8BW.t = (127 : Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (ret:Int8BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] Int8BW.to_int l
    + Int8BW.to_int r
    >= Int8BW.to_int (v_MIN'0 : Int8BW.t)
    /\ Int8BW.to_int l + Int8BW.to_int r <= Int8BW.to_int (v_MAX'0 : Int8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.add {l} {r} (fun (_ret':Int8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int8BW.t = Any.any_l () | & l : Int8BW.t = l | & r : Int8BW.t = r ] 
    [ return' (result:Int8BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] Int8BW.to_int result
      = Int8BW.to_int l + Int8BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int8
  
  use creusot.prelude.Any
  
  use creusot.int.Int8
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:Int8.t) (r:Int8.t) (return'  (ret:Int8.t))= {[@expl:test_sub requires] [%#sinteger_ops0] Int8.to_int l
    - Int8.to_int r
    >= Int8.to_int (v_MIN'0 : Int8.t)
    /\ Int8.to_int l - Int8.to_int r <= Int8.to_int (v_MAX'0 : Int8.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int8.sub {l} {r} (fun (_ret':Int8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int8.t = Any.any_l () | & l : Int8.t = l | & r : Int8.t = r ]
    
    [ return' (result:Int8.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] Int8.to_int result
      = Int8.to_int l - Int8.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int8BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8BW.t = (128 : Int8BW.t)
  
  constant v_MAX'0 : Int8BW.t = (127 : Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (ret:Int8BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] Int8BW.to_int l
    - Int8BW.to_int r
    >= Int8BW.to_int (v_MIN'0 : Int8BW.t)
    /\ Int8BW.to_int l - Int8BW.to_int r <= Int8BW.to_int (v_MAX'0 : Int8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.sub {l} {r} (fun (_ret':Int8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int8BW.t = Any.any_l () | & l : Int8BW.t = l | & r : Int8BW.t = r ] 
    [ return' (result:Int8BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] Int8BW.to_int result
      = Int8BW.to_int l - Int8BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int8
  
  use creusot.prelude.Any
  
  use creusot.int.Int8
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:Int8.t) (r:Int8.t) (return'  (ret:Int8.t))= {[@expl:test_mul requires] [%#sinteger_ops0] Int8.to_int l
    * Int8.to_int r
    >= Int8.to_int (v_MIN'0 : Int8.t)
    /\ Int8.to_int l * Int8.to_int r <= Int8.to_int (v_MAX'0 : Int8.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int8.mul {l} {r} (fun (_ret':Int8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int8.t = Any.any_l () | & l : Int8.t = l | & r : Int8.t = r ]
    
    [ return' (result:Int8.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] Int8.to_int result
      = Int8.to_int l * Int8.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int8BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8BW.t = (128 : Int8BW.t)
  
  constant v_MAX'0 : Int8BW.t = (127 : Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (ret:Int8BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] Int8BW.to_int l
    * Int8BW.to_int r
    >= Int8BW.to_int (v_MIN'0 : Int8BW.t)
    /\ Int8BW.to_int l * Int8BW.to_int r <= Int8BW.to_int (v_MAX'0 : Int8BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int8BW.mul {l} {r} (fun (_ret':Int8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int8BW.t = Any.any_l () | & l : Int8BW.t = l | & r : Int8BW.t = r ] 
    [ return' (result:Int8BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] Int8BW.to_int result
      = Int8BW.to_int l * Int8BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int8
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int8
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8.t = (-128 : Int8.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int8.t = (127 : Int8.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:Int8.t) (r:Int8.t) (return'  (ret:Int8.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] Int8.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (Int8.to_int l) (Int8.to_int r)
    >= Int8.to_int (v_MIN'0 : Int8.t)
    /\ Int.div (Int8.to_int l) (Int8.to_int r) <= Int8.to_int (v_MAX'0 : Int8.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int8.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (-1 : Int8.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (-128 : Int8.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int8.div {_6} {_7} (fun (_ret':Int8.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int8.t = Any.any_l ()
    | & l : Int8.t = l
    | & r : Int8.t = r
    | & _6 : Int8.t = Any.any_l ()
    | & _7 : Int8.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int8.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] Int8.to_int result
      = Int.div (Int8.to_int l) (Int8.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int8BW
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int8BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int8BW.t = (128 : Int8BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int8BW.t = (127 : Int8BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:Int8BW.t) (r:Int8BW.t) (return'  (ret:Int8BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] Int8BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (Int8BW.to_int l) (Int8BW.to_int r)
    >= Int8BW.to_int (v_MIN'0 : Int8BW.t)
    /\ Int.div (Int8BW.to_int l) (Int8BW.to_int r) <= Int8BW.to_int (v_MAX'0 : Int8BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int8BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (255 : Int8BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (128 : Int8BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int8BW.div {_6} {_7} (fun (_ret':Int8BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int8BW.t = Any.any_l ()
    | & l : Int8BW.t = l
    | & r : Int8BW.t = r
    | & _6 : Int8BW.t = Any.any_l ()
    | & _7 : Int8BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int8BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] Int8BW.to_int result
      = Int.div (Int8BW.to_int l) (Int8BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int8
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:Int8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int8.t = Any.any_l () | & _1 : Int8.t = Any.any_l () ]  [ return' (result:Int8.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool'0 (return'  (ret:Int8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int8.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8.t = Any.any_l () ]  [ return' (result:Int8.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:Int8.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int8.t = Any.any_l () | & _1 : Int8.t = Any.any_l () ]  [ return' (result:Int8.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool'0 (return'  (ret:Int8.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int8.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8.t = Any.any_l () ]  [ return' (result:Int8.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:Int8.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:Int8.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:Int8.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:Int8.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:Int8.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int8.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int8.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int8.t, Int8.t) = Any.any_l ()
    | & left_val : Int8.t = Any.any_l ()
    | & right_val : Int8.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int8.t = Any.any_l ()
    | & _21 : Int8.t = Any.any_l ()
    | & _24 : (Int8.t, Int8.t) = Any.any_l ()
    | & left_val1 : Int8.t = Any.any_l ()
    | & right_val1 : Int8.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int8.t = Any.any_l ()
    | & _41 : Int8.t = Any.any_l ()
    | & _44 : Int8.t = Any.any_l ()
    | & _45 : Int8.t = Any.any_l ()
    | & _46 : Int8.t = Any.any_l ()
    | & _47 : Int8.t = Any.any_l () ]
    
    [ return' (result:Int8.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = Int8.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i8__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int8BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int8BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int8BW.t = Any.any_l () | & _1 : Int8BW.t = Any.any_l () ] 
    [ return' (result:Int8BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:Int8BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int8BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int8BW.t = Any.any_l () ]  [ return' (result:Int8BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:Int8BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:Int8BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:Int8BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:Int8BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:Int8BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int8BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int8BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val : Int8BW.t = Any.any_l ()
    | & right_val : Int8BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int8BW.t = Any.any_l ()
    | & _21 : Int8BW.t = Any.any_l ()
    | & _24 : (Int8BW.t, Int8BW.t) = Any.any_l ()
    | & left_val1 : Int8BW.t = Any.any_l ()
    | & right_val1 : Int8BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int8BW.t = Any.any_l ()
    | & _41 : Int8BW.t = Any.any_l ()
    | & _44 : Int8BW.t = Any.any_l ()
    | & _45 : Int8BW.t = Any.any_l ()
    | & _46 : Int8BW.t = Any.any_l ()
    | & _47 : Int8BW.t = Any.any_l () ]
    
    [ return' (result:Int8BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = Int8BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt16
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16.t = (0 : UInt16.t)
  
  constant v_MAX'0 : UInt16.t = (65535 : UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:UInt16.t) (r:UInt16.t) (return'  (ret:UInt16.t))= {[@expl:test_add requires] [%#sinteger_ops0] UInt16.t'int l
    + UInt16.t'int r
    >= UInt16.t'int (v_MIN'0 : UInt16.t)
    /\ UInt16.t'int l + UInt16.t'int r <= UInt16.t'int (v_MAX'0 : UInt16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.add {l} {r} (fun (_ret':UInt16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt16.t = Any.any_l () | & l : UInt16.t = l | & r : UInt16.t = r ] 
    [ return' (result:UInt16.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] UInt16.t'int result
      = UInt16.t'int l + UInt16.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt16BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16BW.t = (0 : UInt16BW.t)
  
  constant v_MAX'0 : UInt16BW.t = (65535 : UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (ret:UInt16BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] UInt16BW.t'int l
    + UInt16BW.t'int r
    >= UInt16BW.t'int (v_MIN'0 : UInt16BW.t)
    /\ UInt16BW.t'int l + UInt16BW.t'int r <= UInt16BW.t'int (v_MAX'0 : UInt16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.add {l} {r} (fun (_ret':UInt16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt16BW.t = Any.any_l () | & l : UInt16BW.t = l | & r : UInt16BW.t = r ] 
    [ return' (result:UInt16BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] UInt16BW.t'int result
      = UInt16BW.t'int l + UInt16BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt16
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16.t = (0 : UInt16.t)
  
  constant v_MAX'0 : UInt16.t = (65535 : UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:UInt16.t) (r:UInt16.t) (return'  (ret:UInt16.t))= {[@expl:test_sub requires] [%#sinteger_ops0] UInt16.t'int l
    - UInt16.t'int r
    >= UInt16.t'int (v_MIN'0 : UInt16.t)
    /\ UInt16.t'int l - UInt16.t'int r <= UInt16.t'int (v_MAX'0 : UInt16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.sub {l} {r} (fun (_ret':UInt16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt16.t = Any.any_l () | & l : UInt16.t = l | & r : UInt16.t = r ] 
    [ return' (result:UInt16.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] UInt16.t'int result
      = UInt16.t'int l - UInt16.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt16BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16BW.t = (0 : UInt16BW.t)
  
  constant v_MAX'0 : UInt16BW.t = (65535 : UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (ret:UInt16BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] UInt16BW.t'int l
    - UInt16BW.t'int r
    >= UInt16BW.t'int (v_MIN'0 : UInt16BW.t)
    /\ UInt16BW.t'int l - UInt16BW.t'int r <= UInt16BW.t'int (v_MAX'0 : UInt16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.sub {l} {r} (fun (_ret':UInt16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt16BW.t = Any.any_l () | & l : UInt16BW.t = l | & r : UInt16BW.t = r ] 
    [ return' (result:UInt16BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] UInt16BW.t'int result
      = UInt16BW.t'int l - UInt16BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt16
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16.t = (0 : UInt16.t)
  
  constant v_MAX'0 : UInt16.t = (65535 : UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:UInt16.t) (r:UInt16.t) (return'  (ret:UInt16.t))= {[@expl:test_mul requires] [%#sinteger_ops0] UInt16.t'int l
    * UInt16.t'int r
    >= UInt16.t'int (v_MIN'0 : UInt16.t)
    /\ UInt16.t'int l * UInt16.t'int r <= UInt16.t'int (v_MAX'0 : UInt16.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16.mul {l} {r} (fun (_ret':UInt16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt16.t = Any.any_l () | & l : UInt16.t = l | & r : UInt16.t = r ] 
    [ return' (result:UInt16.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] UInt16.t'int result
      = UInt16.t'int l * UInt16.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt16BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16BW.t = (0 : UInt16BW.t)
  
  constant v_MAX'0 : UInt16BW.t = (65535 : UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (ret:UInt16BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] UInt16BW.t'int l
    * UInt16BW.t'int r
    >= UInt16BW.t'int (v_MIN'0 : UInt16BW.t)
    /\ UInt16BW.t'int l * UInt16BW.t'int r <= UInt16BW.t'int (v_MAX'0 : UInt16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt16BW.mul {l} {r} (fun (_ret':UInt16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt16BW.t = Any.any_l () | & l : UInt16BW.t = l | & r : UInt16BW.t = r ] 
    [ return' (result:UInt16BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] UInt16BW.t'int result
      = UInt16BW.t'int l * UInt16BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt16
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16.t = (0 : UInt16.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt16.t = (65535 : UInt16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:UInt16.t) (r:UInt16.t) (return'  (ret:UInt16.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] UInt16.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (UInt16.t'int l) (UInt16.t'int r)
    >= UInt16.t'int (v_MIN'0 : UInt16.t)
    /\ Int.div (UInt16.t'int l) (UInt16.t'int r) <= UInt16.t'int (v_MAX'0 : UInt16.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt16.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt16.div {l} {_7} (fun (_ret':UInt16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt16.t = Any.any_l ()
    | & l : UInt16.t = l
    | & r : UInt16.t = r
    | & _7 : UInt16.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt16.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] UInt16.t'int result
      = Int.div (UInt16.t'int l) (UInt16.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt16BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt16BW.t = (0 : UInt16BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt16BW.t = (65535 : UInt16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:UInt16BW.t) (r:UInt16BW.t) (return'  (ret:UInt16BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] UInt16BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (UInt16BW.t'int l) (UInt16BW.t'int r)
    >= UInt16BW.t'int (v_MIN'0 : UInt16BW.t)
    /\ Int.div (UInt16BW.t'int l) (UInt16BW.t'int r) <= UInt16BW.t'int (v_MAX'0 : UInt16BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt16BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt16BW.div {l} {_7} (fun (_ret':UInt16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt16BW.t = Any.any_l ()
    | & l : UInt16BW.t = l
    | & r : UInt16BW.t = r
    | & _7 : UInt16BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt16BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] UInt16BW.t'int result
      = Int.div (UInt16BW.t'int l) (UInt16BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt16
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:UInt16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16.t = Any.any_l () | & _1 : UInt16.t = Any.any_l () ] 
    [ return' (result:UInt16.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool'0 (return'  (ret:UInt16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt16.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16.t = Any.any_l () ]  [ return' (result:UInt16.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:UInt16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16.t = Any.any_l () | & _1 : UInt16.t = Any.any_l () ] 
    [ return' (result:UInt16.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool'0 (return'  (ret:UInt16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt16.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16.t = Any.any_l () ]  [ return' (result:UInt16.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:UInt16.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:UInt16.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:UInt16.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:UInt16.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:UInt16.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt16.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt16.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt16.t, UInt16.t) = Any.any_l ()
    | & left_val : UInt16.t = Any.any_l ()
    | & right_val : UInt16.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt16.t = Any.any_l ()
    | & _21 : UInt16.t = Any.any_l ()
    | & _24 : (UInt16.t, UInt16.t) = Any.any_l ()
    | & left_val1 : UInt16.t = Any.any_l ()
    | & right_val1 : UInt16.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt16.t = Any.any_l ()
    | & _41 : UInt16.t = Any.any_l ()
    | & _44 : UInt16.t = Any.any_l ()
    | & _45 : UInt16.t = Any.any_l ()
    | & _46 : UInt16.t = Any.any_l ()
    | & _47 : UInt16.t = Any.any_l () ]
    
    [ return' (result:UInt16.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = UInt16.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u16__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt16BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt16BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt16BW.t = Any.any_l () | & _1 : UInt16BW.t = Any.any_l () ] 
    [ return' (result:UInt16BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:UInt16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt16BW.t = Any.any_l () ]  [ return' (result:UInt16BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:UInt16BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:UInt16BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:UInt16BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:UInt16BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:UInt16BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt16BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt16BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val : UInt16BW.t = Any.any_l ()
    | & right_val : UInt16BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt16BW.t = Any.any_l ()
    | & _21 : UInt16BW.t = Any.any_l ()
    | & _24 : (UInt16BW.t, UInt16BW.t) = Any.any_l ()
    | & left_val1 : UInt16BW.t = Any.any_l ()
    | & right_val1 : UInt16BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt16BW.t = Any.any_l ()
    | & _41 : UInt16BW.t = Any.any_l ()
    | & _44 : UInt16BW.t = Any.any_l ()
    | & _45 : UInt16BW.t = Any.any_l ()
    | & _46 : UInt16BW.t = Any.any_l ()
    | & _47 : UInt16BW.t = Any.any_l () ]
    
    [ return' (result:UInt16BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = UInt16BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int16
  
  use creusot.prelude.Any
  
  use creusot.int.Int16
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16.t = (-32768 : Int16.t)
  
  constant v_MAX'0 : Int16.t = (32767 : Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:Int16.t) (r:Int16.t) (return'  (ret:Int16.t))= {[@expl:test_add requires] [%#sinteger_ops0] Int16.to_int l
    + Int16.to_int r
    >= Int16.to_int (v_MIN'0 : Int16.t)
    /\ Int16.to_int l + Int16.to_int r <= Int16.to_int (v_MAX'0 : Int16.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int16.add {l} {r} (fun (_ret':Int16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int16.t = Any.any_l () | & l : Int16.t = l | & r : Int16.t = r ]
    
    [ return' (result:Int16.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] Int16.to_int result
      = Int16.to_int l + Int16.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int16BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16BW.t = (32768 : Int16BW.t)
  
  constant v_MAX'0 : Int16BW.t = (32767 : Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (ret:Int16BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] Int16BW.to_int l
    + Int16BW.to_int r
    >= Int16BW.to_int (v_MIN'0 : Int16BW.t)
    /\ Int16BW.to_int l + Int16BW.to_int r <= Int16BW.to_int (v_MAX'0 : Int16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.add {l} {r} (fun (_ret':Int16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int16BW.t = Any.any_l () | & l : Int16BW.t = l | & r : Int16BW.t = r ] 
    [ return' (result:Int16BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] Int16BW.to_int result
      = Int16BW.to_int l + Int16BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int16
  
  use creusot.prelude.Any
  
  use creusot.int.Int16
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16.t = (-32768 : Int16.t)
  
  constant v_MAX'0 : Int16.t = (32767 : Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:Int16.t) (r:Int16.t) (return'  (ret:Int16.t))= {[@expl:test_sub requires] [%#sinteger_ops0] Int16.to_int l
    - Int16.to_int r
    >= Int16.to_int (v_MIN'0 : Int16.t)
    /\ Int16.to_int l - Int16.to_int r <= Int16.to_int (v_MAX'0 : Int16.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int16.sub {l} {r} (fun (_ret':Int16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int16.t = Any.any_l () | & l : Int16.t = l | & r : Int16.t = r ]
    
    [ return' (result:Int16.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] Int16.to_int result
      = Int16.to_int l - Int16.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int16BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16BW.t = (32768 : Int16BW.t)
  
  constant v_MAX'0 : Int16BW.t = (32767 : Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (ret:Int16BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] Int16BW.to_int l
    - Int16BW.to_int r
    >= Int16BW.to_int (v_MIN'0 : Int16BW.t)
    /\ Int16BW.to_int l - Int16BW.to_int r <= Int16BW.to_int (v_MAX'0 : Int16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.sub {l} {r} (fun (_ret':Int16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int16BW.t = Any.any_l () | & l : Int16BW.t = l | & r : Int16BW.t = r ] 
    [ return' (result:Int16BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] Int16BW.to_int result
      = Int16BW.to_int l - Int16BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int16
  
  use creusot.prelude.Any
  
  use creusot.int.Int16
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16.t = (-32768 : Int16.t)
  
  constant v_MAX'0 : Int16.t = (32767 : Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:Int16.t) (r:Int16.t) (return'  (ret:Int16.t))= {[@expl:test_mul requires] [%#sinteger_ops0] Int16.to_int l
    * Int16.to_int r
    >= Int16.to_int (v_MIN'0 : Int16.t)
    /\ Int16.to_int l * Int16.to_int r <= Int16.to_int (v_MAX'0 : Int16.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int16.mul {l} {r} (fun (_ret':Int16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int16.t = Any.any_l () | & l : Int16.t = l | & r : Int16.t = r ]
    
    [ return' (result:Int16.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] Int16.to_int result
      = Int16.to_int l * Int16.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int16BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16BW.t = (32768 : Int16BW.t)
  
  constant v_MAX'0 : Int16BW.t = (32767 : Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (ret:Int16BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] Int16BW.to_int l
    * Int16BW.to_int r
    >= Int16BW.to_int (v_MIN'0 : Int16BW.t)
    /\ Int16BW.to_int l * Int16BW.to_int r <= Int16BW.to_int (v_MAX'0 : Int16BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int16BW.mul {l} {r} (fun (_ret':Int16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int16BW.t = Any.any_l () | & l : Int16BW.t = l | & r : Int16BW.t = r ] 
    [ return' (result:Int16BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] Int16BW.to_int result
      = Int16BW.to_int l * Int16BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int16
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int16
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16.t = (-32768 : Int16.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int16.t = (32767 : Int16.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:Int16.t) (r:Int16.t) (return'  (ret:Int16.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] Int16.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (Int16.to_int l) (Int16.to_int r)
    >= Int16.to_int (v_MIN'0 : Int16.t)
    /\ Int.div (Int16.to_int l) (Int16.to_int r) <= Int16.to_int (v_MAX'0 : Int16.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int16.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (-1 : Int16.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (-32768 : Int16.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int16.div {_6} {_7} (fun (_ret':Int16.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int16.t = Any.any_l ()
    | & l : Int16.t = l
    | & r : Int16.t = r
    | & _6 : Int16.t = Any.any_l ()
    | & _7 : Int16.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int16.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] Int16.to_int result
      = Int.div (Int16.to_int l) (Int16.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int16BW
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int16BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int16BW.t = (32768 : Int16BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int16BW.t = (32767 : Int16BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:Int16BW.t) (r:Int16BW.t) (return'  (ret:Int16BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] Int16BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (Int16BW.to_int l) (Int16BW.to_int r)
    >= Int16BW.to_int (v_MIN'0 : Int16BW.t)
    /\ Int.div (Int16BW.to_int l) (Int16BW.to_int r) <= Int16BW.to_int (v_MAX'0 : Int16BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int16BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (65535 : Int16BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (32768 : Int16BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int16BW.div {_6} {_7} (fun (_ret':Int16BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int16BW.t = Any.any_l ()
    | & l : Int16BW.t = l
    | & r : Int16BW.t = r
    | & _6 : Int16BW.t = Any.any_l ()
    | & _7 : Int16BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int16BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] Int16BW.to_int result
      = Int.div (Int16BW.to_int l) (Int16BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int16
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:Int16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int16.t = Any.any_l () | & _1 : Int16.t = Any.any_l () ]  [ return' (result:Int16.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool'0 (return'  (ret:Int16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int16.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16.t = Any.any_l () ]  [ return' (result:Int16.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:Int16.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int16.t = Any.any_l () | & _1 : Int16.t = Any.any_l () ]  [ return' (result:Int16.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool'0 (return'  (ret:Int16.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int16.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16.t = Any.any_l () ]  [ return' (result:Int16.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:Int16.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:Int16.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:Int16.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:Int16.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:Int16.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int16.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int16.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int16.t, Int16.t) = Any.any_l ()
    | & left_val : Int16.t = Any.any_l ()
    | & right_val : Int16.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int16.t = Any.any_l ()
    | & _21 : Int16.t = Any.any_l ()
    | & _24 : (Int16.t, Int16.t) = Any.any_l ()
    | & left_val1 : Int16.t = Any.any_l ()
    | & right_val1 : Int16.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int16.t = Any.any_l ()
    | & _41 : Int16.t = Any.any_l ()
    | & _44 : Int16.t = Any.any_l ()
    | & _45 : Int16.t = Any.any_l ()
    | & _46 : Int16.t = Any.any_l ()
    | & _47 : Int16.t = Any.any_l () ]
    
    [ return' (result:Int16.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = Int16.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i16__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int16BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int16BW.t = Any.any_l () | & _1 : Int16BW.t = Any.any_l () ] 
    [ return' (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16BW.t = Any.any_l () ]  [ return' (result:Int16BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int16BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int16BW.t = Any.any_l () | & _1 : Int16BW.t = Any.any_l () ] 
    [ return' (result:Int16BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:Int16BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int16BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int16BW.t = Any.any_l () ]  [ return' (result:Int16BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:Int16BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:Int16BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:Int16BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:Int16BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:Int16BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int16BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int16BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int16BW.t, Int16BW.t) = Any.any_l ()
    | & left_val : Int16BW.t = Any.any_l ()
    | & right_val : Int16BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int16BW.t = Any.any_l ()
    | & _21 : Int16BW.t = Any.any_l ()
    | & _24 : (Int16BW.t, Int16BW.t) = Any.any_l ()
    | & left_val1 : Int16BW.t = Any.any_l ()
    | & right_val1 : Int16BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int16BW.t = Any.any_l ()
    | & _41 : Int16BW.t = Any.any_l ()
    | & _44 : Int16BW.t = Any.any_l ()
    | & _45 : Int16BW.t = Any.any_l ()
    | & _46 : Int16BW.t = Any.any_l ()
    | & _47 : Int16BW.t = Any.any_l () ]
    
    [ return' (result:Int16BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = Int16BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt32
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32.t = (0 : UInt32.t)
  
  constant v_MAX'0 : UInt32.t = (4294967295 : UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:UInt32.t) (r:UInt32.t) (return'  (ret:UInt32.t))= {[@expl:test_add requires] [%#sinteger_ops0] UInt32.t'int l
    + UInt32.t'int r
    >= UInt32.t'int (v_MIN'0 : UInt32.t)
    /\ UInt32.t'int l + UInt32.t'int r <= UInt32.t'int (v_MAX'0 : UInt32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.add {l} {r} (fun (_ret':UInt32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt32.t = Any.any_l () | & l : UInt32.t = l | & r : UInt32.t = r ] 
    [ return' (result:UInt32.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] UInt32.t'int result
      = UInt32.t'int l + UInt32.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt32BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32BW.t = (0 : UInt32BW.t)
  
  constant v_MAX'0 : UInt32BW.t = (4294967295 : UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (ret:UInt32BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] UInt32BW.t'int l
    + UInt32BW.t'int r
    >= UInt32BW.t'int (v_MIN'0 : UInt32BW.t)
    /\ UInt32BW.t'int l + UInt32BW.t'int r <= UInt32BW.t'int (v_MAX'0 : UInt32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.add {l} {r} (fun (_ret':UInt32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt32BW.t = Any.any_l () | & l : UInt32BW.t = l | & r : UInt32BW.t = r ] 
    [ return' (result:UInt32BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] UInt32BW.t'int result
      = UInt32BW.t'int l + UInt32BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt32
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32.t = (0 : UInt32.t)
  
  constant v_MAX'0 : UInt32.t = (4294967295 : UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:UInt32.t) (r:UInt32.t) (return'  (ret:UInt32.t))= {[@expl:test_sub requires] [%#sinteger_ops0] UInt32.t'int l
    - UInt32.t'int r
    >= UInt32.t'int (v_MIN'0 : UInt32.t)
    /\ UInt32.t'int l - UInt32.t'int r <= UInt32.t'int (v_MAX'0 : UInt32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.sub {l} {r} (fun (_ret':UInt32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt32.t = Any.any_l () | & l : UInt32.t = l | & r : UInt32.t = r ] 
    [ return' (result:UInt32.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] UInt32.t'int result
      = UInt32.t'int l - UInt32.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt32BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32BW.t = (0 : UInt32BW.t)
  
  constant v_MAX'0 : UInt32BW.t = (4294967295 : UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (ret:UInt32BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] UInt32BW.t'int l
    - UInt32BW.t'int r
    >= UInt32BW.t'int (v_MIN'0 : UInt32BW.t)
    /\ UInt32BW.t'int l - UInt32BW.t'int r <= UInt32BW.t'int (v_MAX'0 : UInt32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.sub {l} {r} (fun (_ret':UInt32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt32BW.t = Any.any_l () | & l : UInt32BW.t = l | & r : UInt32BW.t = r ] 
    [ return' (result:UInt32BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] UInt32BW.t'int result
      = UInt32BW.t'int l - UInt32BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt32
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32.t = (0 : UInt32.t)
  
  constant v_MAX'0 : UInt32.t = (4294967295 : UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:UInt32.t) (r:UInt32.t) (return'  (ret:UInt32.t))= {[@expl:test_mul requires] [%#sinteger_ops0] UInt32.t'int l
    * UInt32.t'int r
    >= UInt32.t'int (v_MIN'0 : UInt32.t)
    /\ UInt32.t'int l * UInt32.t'int r <= UInt32.t'int (v_MAX'0 : UInt32.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32.mul {l} {r} (fun (_ret':UInt32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt32.t = Any.any_l () | & l : UInt32.t = l | & r : UInt32.t = r ] 
    [ return' (result:UInt32.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] UInt32.t'int result
      = UInt32.t'int l * UInt32.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt32BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32BW.t = (0 : UInt32BW.t)
  
  constant v_MAX'0 : UInt32BW.t = (4294967295 : UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (ret:UInt32BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] UInt32BW.t'int l
    * UInt32BW.t'int r
    >= UInt32BW.t'int (v_MIN'0 : UInt32BW.t)
    /\ UInt32BW.t'int l * UInt32BW.t'int r <= UInt32BW.t'int (v_MAX'0 : UInt32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt32BW.mul {l} {r} (fun (_ret':UInt32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt32BW.t = Any.any_l () | & l : UInt32BW.t = l | & r : UInt32BW.t = r ] 
    [ return' (result:UInt32BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] UInt32BW.t'int result
      = UInt32BW.t'int l * UInt32BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt32
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32.t = (0 : UInt32.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt32.t = (4294967295 : UInt32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:UInt32.t) (r:UInt32.t) (return'  (ret:UInt32.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] UInt32.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (UInt32.t'int l) (UInt32.t'int r)
    >= UInt32.t'int (v_MIN'0 : UInt32.t)
    /\ Int.div (UInt32.t'int l) (UInt32.t'int r) <= UInt32.t'int (v_MAX'0 : UInt32.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt32.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt32.div {l} {_7} (fun (_ret':UInt32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt32.t = Any.any_l ()
    | & l : UInt32.t = l
    | & r : UInt32.t = r
    | & _7 : UInt32.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt32.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] UInt32.t'int result
      = Int.div (UInt32.t'int l) (UInt32.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt32BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt32BW.t = (0 : UInt32BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt32BW.t = (4294967295 : UInt32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:UInt32BW.t) (r:UInt32BW.t) (return'  (ret:UInt32BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] UInt32BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (UInt32BW.t'int l) (UInt32BW.t'int r)
    >= UInt32BW.t'int (v_MIN'0 : UInt32BW.t)
    /\ Int.div (UInt32BW.t'int l) (UInt32BW.t'int r) <= UInt32BW.t'int (v_MAX'0 : UInt32BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt32BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt32BW.div {l} {_7} (fun (_ret':UInt32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt32BW.t = Any.any_l ()
    | & l : UInt32BW.t = l
    | & r : UInt32BW.t = r
    | & _7 : UInt32BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt32BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] UInt32BW.t'int result
      = Int.div (UInt32BW.t'int l) (UInt32BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt32
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:UInt32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32.t = Any.any_l () | & _1 : UInt32.t = Any.any_l () ] 
    [ return' (result:UInt32.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool'0 (return'  (ret:UInt32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32.t = Any.any_l () ]  [ return' (result:UInt32.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:UInt32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32.t = Any.any_l () | & _1 : UInt32.t = Any.any_l () ] 
    [ return' (result:UInt32.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool'0 (return'  (ret:UInt32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32.t = Any.any_l () ]  [ return' (result:UInt32.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:UInt32.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:UInt32.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:UInt32.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:UInt32.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:UInt32.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt32.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt32.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt32.t, UInt32.t) = Any.any_l ()
    | & left_val : UInt32.t = Any.any_l ()
    | & right_val : UInt32.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt32.t = Any.any_l ()
    | & _21 : UInt32.t = Any.any_l ()
    | & _24 : (UInt32.t, UInt32.t) = Any.any_l ()
    | & left_val1 : UInt32.t = Any.any_l ()
    | & right_val1 : UInt32.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt32.t = Any.any_l ()
    | & _41 : UInt32.t = Any.any_l ()
    | & _44 : UInt32.t = Any.any_l ()
    | & _45 : UInt32.t = Any.any_l ()
    | & _46 : UInt32.t = Any.any_l ()
    | & _47 : UInt32.t = Any.any_l () ]
    
    [ return' (result:UInt32.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = UInt32.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u32__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt32BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt32BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt32BW.t = Any.any_l () | & _1 : UInt32BW.t = Any.any_l () ] 
    [ return' (result:UInt32BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:UInt32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt32BW.t = Any.any_l () ]  [ return' (result:UInt32BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:UInt32BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:UInt32BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:UInt32BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:UInt32BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:UInt32BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt32BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt32BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val : UInt32BW.t = Any.any_l ()
    | & right_val : UInt32BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt32BW.t = Any.any_l ()
    | & _21 : UInt32BW.t = Any.any_l ()
    | & _24 : (UInt32BW.t, UInt32BW.t) = Any.any_l ()
    | & left_val1 : UInt32BW.t = Any.any_l ()
    | & right_val1 : UInt32BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt32BW.t = Any.any_l ()
    | & _41 : UInt32BW.t = Any.any_l ()
    | & _44 : UInt32BW.t = Any.any_l ()
    | & _45 : UInt32BW.t = Any.any_l ()
    | & _46 : UInt32BW.t = Any.any_l ()
    | & _47 : UInt32BW.t = Any.any_l () ]
    
    [ return' (result:UInt32BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = UInt32BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int32
  
  use creusot.prelude.Any
  
  use creusot.int.Int32
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32.t = (-2147483648 : Int32.t)
  
  constant v_MAX'0 : Int32.t = (2147483647 : Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:Int32.t) (r:Int32.t) (return'  (ret:Int32.t))= {[@expl:test_add requires] [%#sinteger_ops0] Int32.to_int l
    + Int32.to_int r
    >= Int32.to_int (v_MIN'0 : Int32.t)
    /\ Int32.to_int l + Int32.to_int r <= Int32.to_int (v_MAX'0 : Int32.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int32.add {l} {r} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int32.t = Any.any_l () | & l : Int32.t = l | & r : Int32.t = r ]
    
    [ return' (result:Int32.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] Int32.to_int result
      = Int32.to_int l + Int32.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int32BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32BW.t = (2147483648 : Int32BW.t)
  
  constant v_MAX'0 : Int32BW.t = (2147483647 : Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (ret:Int32BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] Int32BW.to_int l
    + Int32BW.to_int r
    >= Int32BW.to_int (v_MIN'0 : Int32BW.t)
    /\ Int32BW.to_int l + Int32BW.to_int r <= Int32BW.to_int (v_MAX'0 : Int32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.add {l} {r} (fun (_ret':Int32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int32BW.t = Any.any_l () | & l : Int32BW.t = l | & r : Int32BW.t = r ] 
    [ return' (result:Int32BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] Int32BW.to_int result
      = Int32BW.to_int l + Int32BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int32
  
  use creusot.prelude.Any
  
  use creusot.int.Int32
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32.t = (-2147483648 : Int32.t)
  
  constant v_MAX'0 : Int32.t = (2147483647 : Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:Int32.t) (r:Int32.t) (return'  (ret:Int32.t))= {[@expl:test_sub requires] [%#sinteger_ops0] Int32.to_int l
    - Int32.to_int r
    >= Int32.to_int (v_MIN'0 : Int32.t)
    /\ Int32.to_int l - Int32.to_int r <= Int32.to_int (v_MAX'0 : Int32.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int32.sub {l} {r} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int32.t = Any.any_l () | & l : Int32.t = l | & r : Int32.t = r ]
    
    [ return' (result:Int32.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] Int32.to_int result
      = Int32.to_int l - Int32.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int32BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32BW.t = (2147483648 : Int32BW.t)
  
  constant v_MAX'0 : Int32BW.t = (2147483647 : Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (ret:Int32BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] Int32BW.to_int l
    - Int32BW.to_int r
    >= Int32BW.to_int (v_MIN'0 : Int32BW.t)
    /\ Int32BW.to_int l - Int32BW.to_int r <= Int32BW.to_int (v_MAX'0 : Int32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.sub {l} {r} (fun (_ret':Int32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int32BW.t = Any.any_l () | & l : Int32BW.t = l | & r : Int32BW.t = r ] 
    [ return' (result:Int32BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] Int32BW.to_int result
      = Int32BW.to_int l - Int32BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int32
  
  use creusot.prelude.Any
  
  use creusot.int.Int32
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32.t = (-2147483648 : Int32.t)
  
  constant v_MAX'0 : Int32.t = (2147483647 : Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:Int32.t) (r:Int32.t) (return'  (ret:Int32.t))= {[@expl:test_mul requires] [%#sinteger_ops0] Int32.to_int l
    * Int32.to_int r
    >= Int32.to_int (v_MIN'0 : Int32.t)
    /\ Int32.to_int l * Int32.to_int r <= Int32.to_int (v_MAX'0 : Int32.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int32.mul {l} {r} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int32.t = Any.any_l () | & l : Int32.t = l | & r : Int32.t = r ]
    
    [ return' (result:Int32.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] Int32.to_int result
      = Int32.to_int l * Int32.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int32BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32BW.t = (2147483648 : Int32BW.t)
  
  constant v_MAX'0 : Int32BW.t = (2147483647 : Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (ret:Int32BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] Int32BW.to_int l
    * Int32BW.to_int r
    >= Int32BW.to_int (v_MIN'0 : Int32BW.t)
    /\ Int32BW.to_int l * Int32BW.to_int r <= Int32BW.to_int (v_MAX'0 : Int32BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int32BW.mul {l} {r} (fun (_ret':Int32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int32BW.t = Any.any_l () | & l : Int32BW.t = l | & r : Int32BW.t = r ] 
    [ return' (result:Int32BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] Int32BW.to_int result
      = Int32BW.to_int l * Int32BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int32
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int32
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32.t = (-2147483648 : Int32.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int32.t = (2147483647 : Int32.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:Int32.t) (r:Int32.t) (return'  (ret:Int32.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] Int32.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (Int32.to_int l) (Int32.to_int r)
    >= Int32.to_int (v_MIN'0 : Int32.t)
    /\ Int.div (Int32.to_int l) (Int32.to_int r) <= Int32.to_int (v_MAX'0 : Int32.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int32.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (-1 : Int32.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (-2147483648 : Int32.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int32.div {_6} {_7} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int32.t = Any.any_l ()
    | & l : Int32.t = l
    | & r : Int32.t = r
    | & _6 : Int32.t = Any.any_l ()
    | & _7 : Int32.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int32.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] Int32.to_int result
      = Int.div (Int32.to_int l) (Int32.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int32BW
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int32BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int32BW.t = (2147483648 : Int32BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int32BW.t = (2147483647 : Int32BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:Int32BW.t) (r:Int32BW.t) (return'  (ret:Int32BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] Int32BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (Int32BW.to_int l) (Int32BW.to_int r)
    >= Int32BW.to_int (v_MIN'0 : Int32BW.t)
    /\ Int.div (Int32BW.to_int l) (Int32BW.to_int r) <= Int32BW.to_int (v_MAX'0 : Int32BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int32BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (4294967295 : Int32BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (2147483648 : Int32BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int32BW.div {_6} {_7} (fun (_ret':Int32BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int32BW.t = Any.any_l ()
    | & l : Int32BW.t = l
    | & r : Int32BW.t = r
    | & _6 : Int32BW.t = Any.any_l ()
    | & _7 : Int32BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int32BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] Int32BW.to_int result
      = Int.div (Int32BW.to_int l) (Int32BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int32
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:Int32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int32.t = Any.any_l () | & _1 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool'0 (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:Int32.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int32.t = Any.any_l () | & _1 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool'0 (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:Int32.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:Int32.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:Int32.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:Int32.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:Int32.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int32.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int32.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int32.t, Int32.t) = Any.any_l ()
    | & left_val : Int32.t = Any.any_l ()
    | & right_val : Int32.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int32.t = Any.any_l ()
    | & _21 : Int32.t = Any.any_l ()
    | & _24 : (Int32.t, Int32.t) = Any.any_l ()
    | & left_val1 : Int32.t = Any.any_l ()
    | & right_val1 : Int32.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int32.t = Any.any_l ()
    | & _41 : Int32.t = Any.any_l ()
    | & _44 : Int32.t = Any.any_l ()
    | & _45 : Int32.t = Any.any_l ()
    | & _46 : Int32.t = Any.any_l ()
    | & _47 : Int32.t = Any.any_l () ]
    
    [ return' (result:Int32.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = Int32.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i32__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int32BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int32BW.t = Any.any_l () | & _1 : Int32BW.t = Any.any_l () ] 
    [ return' (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32BW.t = Any.any_l () ]  [ return' (result:Int32BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int32BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int32BW.t = Any.any_l () | & _1 : Int32BW.t = Any.any_l () ] 
    [ return' (result:Int32BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:Int32BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int32BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32BW.t = Any.any_l () ]  [ return' (result:Int32BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:Int32BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:Int32BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:Int32BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:Int32BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:Int32BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int32BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int32BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int32BW.t, Int32BW.t) = Any.any_l ()
    | & left_val : Int32BW.t = Any.any_l ()
    | & right_val : Int32BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int32BW.t = Any.any_l ()
    | & _21 : Int32BW.t = Any.any_l ()
    | & _24 : (Int32BW.t, Int32BW.t) = Any.any_l ()
    | & left_val1 : Int32BW.t = Any.any_l ()
    | & right_val1 : Int32BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int32BW.t = Any.any_l ()
    | & _41 : Int32BW.t = Any.any_l ()
    | & _44 : Int32BW.t = Any.any_l ()
    | & _45 : Int32BW.t = Any.any_l ()
    | & _46 : Int32BW.t = Any.any_l ()
    | & _47 : Int32BW.t = Any.any_l () ]
    
    [ return' (result:Int32BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = Int32BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_add requires] [%#sinteger_ops0] UInt64.t'int l
    + UInt64.t'int r
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ UInt64.t'int l + UInt64.t'int r <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {l} {r} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & l : UInt64.t = l | & r : UInt64.t = r ] 
    [ return' (result:UInt64.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] UInt64.t'int result
      = UInt64.t'int l + UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] UInt64BW.t'int l
    + UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ UInt64BW.t'int l + UInt64BW.t'int r <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.add {l} {r} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64BW.t = Any.any_l () | & l : UInt64BW.t = l | & r : UInt64BW.t = r ] 
    [ return' (result:UInt64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] UInt64BW.t'int result
      = UInt64BW.t'int l + UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_sub requires] [%#sinteger_ops0] UInt64.t'int l
    - UInt64.t'int r
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ UInt64.t'int l - UInt64.t'int r <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.sub {l} {r} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & l : UInt64.t = l | & r : UInt64.t = r ] 
    [ return' (result:UInt64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] UInt64.t'int result
      = UInt64.t'int l - UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] UInt64BW.t'int l
    - UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ UInt64BW.t'int l - UInt64BW.t'int r <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.sub {l} {r} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64BW.t = Any.any_l () | & l : UInt64BW.t = l | & r : UInt64BW.t = r ] 
    [ return' (result:UInt64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] UInt64BW.t'int result
      = UInt64BW.t'int l - UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_mul requires] [%#sinteger_ops0] UInt64.t'int l
    * UInt64.t'int r
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ UInt64.t'int l * UInt64.t'int r <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.mul {l} {r} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & l : UInt64.t = l | & r : UInt64.t = r ] 
    [ return' (result:UInt64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] UInt64.t'int result
      = UInt64.t'int l * UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] UInt64BW.t'int l
    * UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ UInt64BW.t'int l * UInt64BW.t'int r <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.mul {l} {r} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64BW.t = Any.any_l () | & l : UInt64BW.t = l | & r : UInt64BW.t = r ] 
    [ return' (result:UInt64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] UInt64BW.t'int result
      = UInt64BW.t'int l * UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] UInt64.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (UInt64.t'int l) (UInt64.t'int r)
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ Int.div (UInt64.t'int l) (UInt64.t'int r) <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt64.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64.div {l} {_7} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & l : UInt64.t = l
    | & r : UInt64.t = r
    | & _7 : UInt64.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] UInt64.t'int result
      = Int.div (UInt64.t'int l) (UInt64.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] UInt64BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt64BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64BW.div {l} {_7} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64BW.t = Any.any_l ()
    | & l : UInt64BW.t = l
    | & r : UInt64BW.t = r
    | & _7 : UInt64BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] UInt64BW.t'int result
      = Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64.t = Any.any_l () | & _1 : UInt64.t = Any.any_l () ] 
    [ return' (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64.t = Any.any_l () ]  [ return' (result:UInt64.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64.t = Any.any_l () | & _1 : UInt64.t = Any.any_l () ] 
    [ return' (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64.t = Any.any_l () ]  [ return' (result:UInt64.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:UInt64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:UInt64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:UInt64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:UInt64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt64.t, UInt64.t) = Any.any_l ()
    | & left_val : UInt64.t = Any.any_l ()
    | & right_val : UInt64.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt64.t = Any.any_l ()
    | & _21 : UInt64.t = Any.any_l ()
    | & _24 : (UInt64.t, UInt64.t) = Any.any_l ()
    | & left_val1 : UInt64.t = Any.any_l ()
    | & right_val1 : UInt64.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt64.t = Any.any_l ()
    | & _41 : UInt64.t = Any.any_l ()
    | & _44 : UInt64.t = Any.any_l ()
    | & _45 : UInt64.t = Any.any_l ()
    | & _46 : UInt64.t = Any.any_l ()
    | & _47 : UInt64.t = Any.any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = UInt64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u64__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:UInt64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:UInt64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:UInt64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:UInt64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:UInt64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt64BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val : UInt64BW.t = Any.any_l ()
    | & right_val : UInt64BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt64BW.t = Any.any_l ()
    | & _21 : UInt64BW.t = Any.any_l ()
    | & _24 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val1 : UInt64BW.t = Any.any_l ()
    | & right_val1 : UInt64BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt64BW.t = Any.any_l ()
    | & _41 : UInt64BW.t = Any.any_l ()
    | & _44 : UInt64BW.t = Any.any_l ()
    | & _45 : UInt64BW.t = Any.any_l ()
    | & _46 : UInt64BW.t = Any.any_l ()
    | & _47 : UInt64BW.t = Any.any_l () ]
    
    [ return' (result:UInt64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = UInt64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_add requires] [%#sinteger_ops0] Int64.to_int l
    + Int64.to_int r
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int64.to_int l + Int64.to_int r <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int64.add {l} {r} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int64.t = Any.any_l () | & l : Int64.t = l | & r : Int64.t = r ]
    
    [ return' (result:Int64.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] Int64.to_int result
      = Int64.to_int l + Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] Int64BW.to_int l
    + Int64BW.to_int r
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int64BW.to_int l + Int64BW.to_int r <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.add {l} {r} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int64BW.t = Any.any_l () | & l : Int64BW.t = l | & r : Int64BW.t = r ] 
    [ return' (result:Int64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] Int64BW.to_int result
      = Int64BW.to_int l + Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_sub requires] [%#sinteger_ops0] Int64.to_int l
    - Int64.to_int r
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int64.to_int l - Int64.to_int r <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int64.sub {l} {r} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int64.t = Any.any_l () | & l : Int64.t = l | & r : Int64.t = r ]
    
    [ return' (result:Int64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] Int64.to_int result
      = Int64.to_int l - Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] Int64BW.to_int l
    - Int64BW.to_int r
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int64BW.to_int l - Int64BW.to_int r <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.sub {l} {r} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int64BW.t = Any.any_l () | & l : Int64BW.t = l | & r : Int64BW.t = r ] 
    [ return' (result:Int64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] Int64BW.to_int result
      = Int64BW.to_int l - Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_mul requires] [%#sinteger_ops0] Int64.to_int l
    * Int64.to_int r
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int64.to_int l * Int64.to_int r <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int64.mul {l} {r} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int64.t = Any.any_l () | & l : Int64.t = l | & r : Int64.t = r ]
    
    [ return' (result:Int64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] Int64.to_int result
      = Int64.to_int l * Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] Int64BW.to_int l
    * Int64BW.to_int r
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int64BW.to_int l * Int64BW.to_int r <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.mul {l} {r} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int64BW.t = Any.any_l () | & l : Int64BW.t = l | & r : Int64BW.t = r ] 
    [ return' (result:Int64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] Int64BW.to_int result
      = Int64BW.to_int l * Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] Int64.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (Int64.to_int l) (Int64.to_int r)
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int.div (Int64.to_int l) (Int64.to_int r) <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int64.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (-1 : Int64.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (-9223372036854775808 : Int64.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64.div {_6} {_7} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int64.t = Any.any_l ()
    | & l : Int64.t = l
    | & r : Int64.t = r
    | & _6 : Int64.t = Any.any_l ()
    | & _7 : Int64.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int64.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] Int64.to_int result
      = Int.div (Int64.to_int l) (Int64.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] Int64BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (Int64BW.to_int l) (Int64BW.to_int r)
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int.div (Int64BW.to_int l) (Int64BW.to_int r) <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int64BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (18446744073709551615 : Int64BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (9223372036854775808 : Int64BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64BW.div {_6} {_7} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int64BW.t = Any.any_l ()
    | & l : Int64BW.t = l
    | & r : Int64BW.t = r
    | & _6 : Int64BW.t = Any.any_l ()
    | & _7 : Int64BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] Int64BW.to_int result
      = Int.div (Int64BW.to_int l) (Int64BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64.t = Any.any_l () | & _1 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64.t = Any.any_l () | & _1 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:Int64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:Int64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:Int64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:Int64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:Int64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int64.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int64.t, Int64.t) = Any.any_l ()
    | & left_val : Int64.t = Any.any_l ()
    | & right_val : Int64.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int64.t = Any.any_l ()
    | & _21 : Int64.t = Any.any_l ()
    | & _24 : (Int64.t, Int64.t) = Any.any_l ()
    | & left_val1 : Int64.t = Any.any_l ()
    | & right_val1 : Int64.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int64.t = Any.any_l ()
    | & _41 : Int64.t = Any.any_l ()
    | & _44 : Int64.t = Any.any_l ()
    | & _45 : Int64.t = Any.any_l ()
    | & _46 : Int64.t = Any.any_l ()
    | & _47 : Int64.t = Any.any_l () ]
    
    [ return' (result:Int64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = Int64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i64__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:Int64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:Int64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:Int64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:Int64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:Int64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int64BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val : Int64BW.t = Any.any_l ()
    | & right_val : Int64BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int64BW.t = Any.any_l ()
    | & _21 : Int64BW.t = Any.any_l ()
    | & _24 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val1 : Int64BW.t = Any.any_l ()
    | & right_val1 : Int64BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int64BW.t = Any.any_l ()
    | & _41 : Int64BW.t = Any.any_l ()
    | & _44 : Int64BW.t = Any.any_l ()
    | & _45 : Int64BW.t = Any.any_l ()
    | & _46 : Int64BW.t = Any.any_l ()
    | & _47 : Int64BW.t = Any.any_l () ]
    
    [ return' (result:Int64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = Int64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt128
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128.t = (0 : UInt128.t)
  
  constant v_MAX'0 : UInt128.t = (340282366920938463463374607431768211455 : UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:UInt128.t) (r:UInt128.t) (return'  (ret:UInt128.t))= {[@expl:test_add requires] [%#sinteger_ops0] UInt128.t'int l
    + UInt128.t'int r
    >= UInt128.t'int (v_MIN'0 : UInt128.t)
    /\ UInt128.t'int l + UInt128.t'int r <= UInt128.t'int (v_MAX'0 : UInt128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.add {l} {r} (fun (_ret':UInt128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt128.t = Any.any_l () | & l : UInt128.t = l | & r : UInt128.t = r ] 
    [ return' (result:UInt128.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] UInt128.t'int result
      = UInt128.t'int l + UInt128.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt128BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128BW.t = (0 : UInt128BW.t)
  
  constant v_MAX'0 : UInt128BW.t = (340282366920938463463374607431768211455 : UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (ret:UInt128BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] UInt128BW.t'int l
    + UInt128BW.t'int r
    >= UInt128BW.t'int (v_MIN'0 : UInt128BW.t)
    /\ UInt128BW.t'int l + UInt128BW.t'int r <= UInt128BW.t'int (v_MAX'0 : UInt128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128BW.add {l} {r} (fun (_ret':UInt128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt128BW.t = Any.any_l () | & l : UInt128BW.t = l | & r : UInt128BW.t = r ] 
    [ return' (result:UInt128BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] UInt128BW.t'int result
      = UInt128BW.t'int l + UInt128BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt128
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128.t = (0 : UInt128.t)
  
  constant v_MAX'0 : UInt128.t = (340282366920938463463374607431768211455 : UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:UInt128.t) (r:UInt128.t) (return'  (ret:UInt128.t))= {[@expl:test_sub requires] [%#sinteger_ops0] UInt128.t'int l
    - UInt128.t'int r
    >= UInt128.t'int (v_MIN'0 : UInt128.t)
    /\ UInt128.t'int l - UInt128.t'int r <= UInt128.t'int (v_MAX'0 : UInt128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.sub {l} {r} (fun (_ret':UInt128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt128.t = Any.any_l () | & l : UInt128.t = l | & r : UInt128.t = r ] 
    [ return' (result:UInt128.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] UInt128.t'int result
      = UInt128.t'int l - UInt128.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt128BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128BW.t = (0 : UInt128BW.t)
  
  constant v_MAX'0 : UInt128BW.t = (340282366920938463463374607431768211455 : UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (ret:UInt128BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] UInt128BW.t'int l
    - UInt128BW.t'int r
    >= UInt128BW.t'int (v_MIN'0 : UInt128BW.t)
    /\ UInt128BW.t'int l - UInt128BW.t'int r <= UInt128BW.t'int (v_MAX'0 : UInt128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128BW.sub {l} {r} (fun (_ret':UInt128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt128BW.t = Any.any_l () | & l : UInt128BW.t = l | & r : UInt128BW.t = r ] 
    [ return' (result:UInt128BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] UInt128BW.t'int result
      = UInt128BW.t'int l - UInt128BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt128
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128.t = (0 : UInt128.t)
  
  constant v_MAX'0 : UInt128.t = (340282366920938463463374607431768211455 : UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:UInt128.t) (r:UInt128.t) (return'  (ret:UInt128.t))= {[@expl:test_mul requires] [%#sinteger_ops0] UInt128.t'int l
    * UInt128.t'int r
    >= UInt128.t'int (v_MIN'0 : UInt128.t)
    /\ UInt128.t'int l * UInt128.t'int r <= UInt128.t'int (v_MAX'0 : UInt128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128.mul {l} {r} (fun (_ret':UInt128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt128.t = Any.any_l () | & l : UInt128.t = l | & r : UInt128.t = r ] 
    [ return' (result:UInt128.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] UInt128.t'int result
      = UInt128.t'int l * UInt128.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt128BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128BW.t = (0 : UInt128BW.t)
  
  constant v_MAX'0 : UInt128BW.t = (340282366920938463463374607431768211455 : UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (ret:UInt128BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] UInt128BW.t'int l
    * UInt128BW.t'int r
    >= UInt128BW.t'int (v_MIN'0 : UInt128BW.t)
    /\ UInt128BW.t'int l * UInt128BW.t'int r <= UInt128BW.t'int (v_MAX'0 : UInt128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt128BW.mul {l} {r} (fun (_ret':UInt128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt128BW.t = Any.any_l () | & l : UInt128BW.t = l | & r : UInt128BW.t = r ] 
    [ return' (result:UInt128BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] UInt128BW.t'int result
      = UInt128BW.t'int l * UInt128BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt128
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128.t = (0 : UInt128.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt128.t = (340282366920938463463374607431768211455 : UInt128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:UInt128.t) (r:UInt128.t) (return'  (ret:UInt128.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] UInt128.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (UInt128.t'int l) (UInt128.t'int r)
    >= UInt128.t'int (v_MIN'0 : UInt128.t)
    /\ Int.div (UInt128.t'int l) (UInt128.t'int r) <= UInt128.t'int (v_MAX'0 : UInt128.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt128.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt128.div {l} {_7} (fun (_ret':UInt128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt128.t = Any.any_l ()
    | & l : UInt128.t = l
    | & r : UInt128.t = r
    | & _7 : UInt128.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt128.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] UInt128.t'int result
      = Int.div (UInt128.t'int l) (UInt128.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt128BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt128BW.t = (0 : UInt128BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt128BW.t = (340282366920938463463374607431768211455 : UInt128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:UInt128BW.t) (r:UInt128BW.t) (return'  (ret:UInt128BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] UInt128BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (UInt128BW.t'int l) (UInt128BW.t'int r)
    >= UInt128BW.t'int (v_MIN'0 : UInt128BW.t)
    /\ Int.div (UInt128BW.t'int l) (UInt128BW.t'int r) <= UInt128BW.t'int (v_MAX'0 : UInt128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt128BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt128BW.div {l} {_7} (fun (_ret':UInt128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt128BW.t = Any.any_l ()
    | & l : UInt128BW.t = l
    | & r : UInt128BW.t = r
    | & _7 : UInt128BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt128BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] UInt128BW.t'int result
      = Int.div (UInt128BW.t'int l) (UInt128BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt128
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:UInt128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128.t = Any.any_l () | & _1 : UInt128.t = Any.any_l () ] 
    [ return' (result:UInt128.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool'0 (return'  (ret:UInt128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt128.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128.t = Any.any_l () ]  [ return' (result:UInt128.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:UInt128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128.t = Any.any_l () | & _1 : UInt128.t = Any.any_l () ] 
    [ return' (result:UInt128.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool'0 (return'  (ret:UInt128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt128.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128.t = Any.any_l () ]  [ return' (result:UInt128.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:UInt128.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:UInt128.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:UInt128.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:UInt128.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:UInt128.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt128.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt128.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt128.t, UInt128.t) = Any.any_l ()
    | & left_val : UInt128.t = Any.any_l ()
    | & right_val : UInt128.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt128.t = Any.any_l ()
    | & _21 : UInt128.t = Any.any_l ()
    | & _24 : (UInt128.t, UInt128.t) = Any.any_l ()
    | & left_val1 : UInt128.t = Any.any_l ()
    | & right_val1 : UInt128.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt128.t = Any.any_l ()
    | & _41 : UInt128.t = Any.any_l ()
    | & _44 : UInt128.t = Any.any_l ()
    | & _45 : UInt128.t = Any.any_l ()
    | & _46 : UInt128.t = Any.any_l ()
    | & _47 : UInt128.t = Any.any_l () ]
    
    [ return' (result:UInt128.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = UInt128.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__u128__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt128BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt128BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt128BW.t = Any.any_l () | & _1 : UInt128BW.t = Any.any_l () ] 
    [ return' (result:UInt128BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:UInt128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt128BW.t = Any.any_l () ]  [ return' (result:UInt128BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:UInt128BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:UInt128BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:UInt128BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:UInt128BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:UInt128BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt128BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt128BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val : UInt128BW.t = Any.any_l ()
    | & right_val : UInt128BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt128BW.t = Any.any_l ()
    | & _21 : UInt128BW.t = Any.any_l ()
    | & _24 : (UInt128BW.t, UInt128BW.t) = Any.any_l ()
    | & left_val1 : UInt128BW.t = Any.any_l ()
    | & right_val1 : UInt128BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt128BW.t = Any.any_l ()
    | & _41 : UInt128BW.t = Any.any_l ()
    | & _44 : UInt128BW.t = Any.any_l ()
    | & _45 : UInt128BW.t = Any.any_l ()
    | & _46 : UInt128BW.t = Any.any_l ()
    | & _47 : UInt128BW.t = Any.any_l () ]
    
    [ return' (result:UInt128BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = UInt128BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int128
  
  use creusot.prelude.Any
  
  use creusot.int.Int128
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128.t = (-170141183460469231731687303715884105728 : Int128.t)
  
  constant v_MAX'0 : Int128.t = (170141183460469231731687303715884105727 : Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:Int128.t) (r:Int128.t) (return'  (ret:Int128.t))= {[@expl:test_add requires] [%#sinteger_ops0] Int128.to_int l
    + Int128.to_int r
    >= Int128.to_int (v_MIN'0 : Int128.t)
    /\ Int128.to_int l + Int128.to_int r <= Int128.to_int (v_MAX'0 : Int128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.add {l} {r} (fun (_ret':Int128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int128.t = Any.any_l () | & l : Int128.t = l | & r : Int128.t = r ] 
    [ return' (result:Int128.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] Int128.to_int result
      = Int128.to_int l + Int128.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int128BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128BW.t = (170141183460469231731687303715884105728 : Int128BW.t)
  
  constant v_MAX'0 : Int128BW.t = (170141183460469231731687303715884105727 : Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (ret:Int128BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] Int128BW.to_int l
    + Int128BW.to_int r
    >= Int128BW.to_int (v_MIN'0 : Int128BW.t)
    /\ Int128BW.to_int l + Int128BW.to_int r <= Int128BW.to_int (v_MAX'0 : Int128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.add {l} {r} (fun (_ret':Int128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int128BW.t = Any.any_l () | & l : Int128BW.t = l | & r : Int128BW.t = r ] 
    [ return' (result:Int128BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] Int128BW.to_int result
      = Int128BW.to_int l + Int128BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int128
  
  use creusot.prelude.Any
  
  use creusot.int.Int128
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128.t = (-170141183460469231731687303715884105728 : Int128.t)
  
  constant v_MAX'0 : Int128.t = (170141183460469231731687303715884105727 : Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:Int128.t) (r:Int128.t) (return'  (ret:Int128.t))= {[@expl:test_sub requires] [%#sinteger_ops0] Int128.to_int l
    - Int128.to_int r
    >= Int128.to_int (v_MIN'0 : Int128.t)
    /\ Int128.to_int l - Int128.to_int r <= Int128.to_int (v_MAX'0 : Int128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.sub {l} {r} (fun (_ret':Int128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int128.t = Any.any_l () | & l : Int128.t = l | & r : Int128.t = r ] 
    [ return' (result:Int128.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] Int128.to_int result
      = Int128.to_int l - Int128.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int128BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128BW.t = (170141183460469231731687303715884105728 : Int128BW.t)
  
  constant v_MAX'0 : Int128BW.t = (170141183460469231731687303715884105727 : Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (ret:Int128BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] Int128BW.to_int l
    - Int128BW.to_int r
    >= Int128BW.to_int (v_MIN'0 : Int128BW.t)
    /\ Int128BW.to_int l - Int128BW.to_int r <= Int128BW.to_int (v_MAX'0 : Int128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.sub {l} {r} (fun (_ret':Int128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int128BW.t = Any.any_l () | & l : Int128BW.t = l | & r : Int128BW.t = r ] 
    [ return' (result:Int128BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] Int128BW.to_int result
      = Int128BW.to_int l - Int128BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int128
  
  use creusot.prelude.Any
  
  use creusot.int.Int128
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128.t = (-170141183460469231731687303715884105728 : Int128.t)
  
  constant v_MAX'0 : Int128.t = (170141183460469231731687303715884105727 : Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:Int128.t) (r:Int128.t) (return'  (ret:Int128.t))= {[@expl:test_mul requires] [%#sinteger_ops0] Int128.to_int l
    * Int128.to_int r
    >= Int128.to_int (v_MIN'0 : Int128.t)
    /\ Int128.to_int l * Int128.to_int r <= Int128.to_int (v_MAX'0 : Int128.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128.mul {l} {r} (fun (_ret':Int128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int128.t = Any.any_l () | & l : Int128.t = l | & r : Int128.t = r ] 
    [ return' (result:Int128.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] Int128.to_int result
      = Int128.to_int l * Int128.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int128BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128BW.t = (170141183460469231731687303715884105728 : Int128BW.t)
  
  constant v_MAX'0 : Int128BW.t = (170141183460469231731687303715884105727 : Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (ret:Int128BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] Int128BW.to_int l
    * Int128BW.to_int r
    >= Int128BW.to_int (v_MIN'0 : Int128BW.t)
    /\ Int128BW.to_int l * Int128BW.to_int r <= Int128BW.to_int (v_MAX'0 : Int128BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int128BW.mul {l} {r} (fun (_ret':Int128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int128BW.t = Any.any_l () | & l : Int128BW.t = l | & r : Int128BW.t = r ] 
    [ return' (result:Int128BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] Int128BW.to_int result
      = Int128BW.to_int l * Int128BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int128
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int128
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128.t = (-170141183460469231731687303715884105728 : Int128.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int128.t = (170141183460469231731687303715884105727 : Int128.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:Int128.t) (r:Int128.t) (return'  (ret:Int128.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] Int128.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (Int128.to_int l) (Int128.to_int r)
    >= Int128.to_int (v_MIN'0 : Int128.t)
    /\ Int.div (Int128.to_int l) (Int128.to_int r) <= Int128.to_int (v_MAX'0 : Int128.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int128.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (-1 : Int128.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (-170141183460469231731687303715884105728 : Int128.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int128.div {_6} {_7} (fun (_ret':Int128.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int128.t = Any.any_l ()
    | & l : Int128.t = l
    | & r : Int128.t = r
    | & _6 : Int128.t = Any.any_l ()
    | & _7 : Int128.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int128.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] Int128.to_int result
      = Int.div (Int128.to_int l) (Int128.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int128BW
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int128BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int128BW.t = (170141183460469231731687303715884105728 : Int128BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int128BW.t = (170141183460469231731687303715884105727 : Int128BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:Int128BW.t) (r:Int128BW.t) (return'  (ret:Int128BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] Int128BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (Int128BW.to_int l) (Int128BW.to_int r)
    >= Int128BW.to_int (v_MIN'0 : Int128BW.t)
    /\ Int.div (Int128BW.to_int l) (Int128BW.to_int r) <= Int128BW.to_int (v_MAX'0 : Int128BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int128BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (340282366920938463463374607431768211455 : Int128BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (170141183460469231731687303715884105728 : Int128BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int128BW.div {_6} {_7} (fun (_ret':Int128BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int128BW.t = Any.any_l ()
    | & l : Int128BW.t = l
    | & r : Int128BW.t = r
    | & _6 : Int128BW.t = Any.any_l ()
    | & _7 : Int128BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int128BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] Int128BW.to_int result
      = Int.div (Int128BW.to_int l) (Int128BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int128
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:Int128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int128.t = Any.any_l () | & _1 : Int128.t = Any.any_l () ] 
    [ return' (result:Int128.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool'0 (return'  (ret:Int128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int128.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128.t = Any.any_l () ]  [ return' (result:Int128.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:Int128.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int128.t = Any.any_l () | & _1 : Int128.t = Any.any_l () ] 
    [ return' (result:Int128.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool'0 (return'  (ret:Int128.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int128.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128.t = Any.any_l () ]  [ return' (result:Int128.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:Int128.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:Int128.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:Int128.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:Int128.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:Int128.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int128.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int128.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int128.t, Int128.t) = Any.any_l ()
    | & left_val : Int128.t = Any.any_l ()
    | & right_val : Int128.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int128.t = Any.any_l ()
    | & _21 : Int128.t = Any.any_l ()
    | & _24 : (Int128.t, Int128.t) = Any.any_l ()
    | & left_val1 : Int128.t = Any.any_l ()
    | & right_val1 : Int128.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int128.t = Any.any_l ()
    | & _41 : Int128.t = Any.any_l ()
    | & _44 : Int128.t = Any.any_l ()
    | & _45 : Int128.t = Any.any_l ()
    | & _46 : Int128.t = Any.any_l ()
    | & _47 : Int128.t = Any.any_l () ]
    
    [ return' (result:Int128.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = Int128.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__i128__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int128BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () | & _1 : Int128BW.t = Any.any_l () ] 
    [ return' (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128BW.t = Any.any_l () ]  [ return' (result:Int128BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int128BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int128BW.t = Any.any_l () | & _1 : Int128BW.t = Any.any_l () ] 
    [ return' (result:Int128BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:Int128BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int128BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int128BW.t = Any.any_l () ]  [ return' (result:Int128BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:Int128BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:Int128BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:Int128BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:Int128BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:Int128BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int128BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int128BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int128BW.t, Int128BW.t) = Any.any_l ()
    | & left_val : Int128BW.t = Any.any_l ()
    | & right_val : Int128BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int128BW.t = Any.any_l ()
    | & _21 : Int128BW.t = Any.any_l ()
    | & _24 : (Int128BW.t, Int128BW.t) = Any.any_l ()
    | & left_val1 : Int128BW.t = Any.any_l ()
    | & right_val1 : Int128BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int128BW.t = Any.any_l ()
    | & _41 : Int128BW.t = Any.any_l ()
    | & _44 : Int128BW.t = Any.any_l ()
    | & _45 : Int128BW.t = Any.any_l ()
    | & _46 : Int128BW.t = Any.any_l ()
    | & _47 : Int128BW.t = Any.any_l () ]
    
    [ return' (result:Int128BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = Int128BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_add requires] [%#sinteger_ops0] UInt64.t'int l
    + UInt64.t'int r
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ UInt64.t'int l + UInt64.t'int r <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.add {l} {r} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & l : UInt64.t = l | & r : UInt64.t = r ] 
    [ return' (result:UInt64.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] UInt64.t'int result
      = UInt64.t'int l + UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] UInt64BW.t'int l
    + UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ UInt64BW.t'int l + UInt64BW.t'int r <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.add {l} {r} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64BW.t = Any.any_l () | & l : UInt64BW.t = l | & r : UInt64BW.t = r ] 
    [ return' (result:UInt64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] UInt64BW.t'int result
      = UInt64BW.t'int l + UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_sub requires] [%#sinteger_ops0] UInt64.t'int l
    - UInt64.t'int r
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ UInt64.t'int l - UInt64.t'int r <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.sub {l} {r} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & l : UInt64.t = l | & r : UInt64.t = r ] 
    [ return' (result:UInt64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] UInt64.t'int result
      = UInt64.t'int l - UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] UInt64BW.t'int l
    - UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ UInt64BW.t'int l - UInt64BW.t'int r <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.sub {l} {r} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64BW.t = Any.any_l () | & l : UInt64BW.t = l | & r : UInt64BW.t = r ] 
    [ return' (result:UInt64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] UInt64BW.t'int result
      = UInt64BW.t'int l - UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_mul requires] [%#sinteger_ops0] UInt64.t'int l
    * UInt64.t'int r
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ UInt64.t'int l * UInt64.t'int r <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64.mul {l} {r} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & l : UInt64.t = l | & r : UInt64.t = r ] 
    [ return' (result:UInt64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] UInt64.t'int result
      = UInt64.t'int l * UInt64.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] UInt64BW.t'int l
    * UInt64BW.t'int r
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ UInt64BW.t'int l * UInt64BW.t'int r <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = UInt64BW.mul {l} {r} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : UInt64BW.t = Any.any_l () | & l : UInt64BW.t = l | & r : UInt64BW.t = r ] 
    [ return' (result:UInt64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] UInt64BW.t'int result
      = UInt64BW.t'int l * UInt64BW.t'int r}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64.t = (0 : UInt64.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:UInt64.t) (r:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] UInt64.t'int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (UInt64.t'int l) (UInt64.t'int r)
    >= UInt64.t'int (v_MIN'0 : UInt64.t)
    /\ Int.div (UInt64.t'int l) (UInt64.t'int r) <= UInt64.t'int (v_MAX'0 : UInt64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt64.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64.div {l} {_7} (fun (_ret':UInt64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & l : UInt64.t = l
    | & r : UInt64.t = r
    | & _7 : UInt64.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] UInt64.t'int result
      = Int.div (UInt64.t'int l) (UInt64.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  use creusot.int.UInt64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : UInt64BW.t = (0 : UInt64BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : UInt64BW.t = (18446744073709551615 : UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:UInt64BW.t) (r:UInt64BW.t) (return'  (ret:UInt64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] UInt64BW.t'int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)
    >= UInt64BW.t'int (v_MIN'0 : UInt64BW.t)
    /\ Int.div (UInt64BW.t'int l) (UInt64BW.t'int r) <= UInt64BW.t'int (v_MAX'0 : UInt64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- r ] s1
      | s1 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : UInt64BW.t)) ] s2
      | s2 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s3
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = UInt64BW.div {l} {_7} (fun (_ret':UInt64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64BW.t = Any.any_l ()
    | & l : UInt64BW.t = l
    | & r : UInt64BW.t = r
    | & _7 : UInt64BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l () ]
    
    [ return' (result:UInt64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] UInt64BW.t'int result
      = Int.div (UInt64BW.t'int l) (UInt64BW.t'int r)}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.UInt64
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64.t = Any.any_l () | & _1 : UInt64.t = Any.any_l () ] 
    [ return' (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64.t = Any.any_l () ]  [ return' (result:UInt64.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64.t = Any.any_l () | & _1 : UInt64.t = Any.any_l () ] 
    [ return' (result:UInt64.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool'0 (return'  (ret:UInt64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64.t = Any.any_l () ]  [ return' (result:UInt64.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:UInt64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:UInt64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:UInt64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:UInt64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt64.t, UInt64.t) = Any.any_l ()
    | & left_val : UInt64.t = Any.any_l ()
    | & right_val : UInt64.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt64.t = Any.any_l ()
    | & _21 : UInt64.t = Any.any_l ()
    | & _24 : (UInt64.t, UInt64.t) = Any.any_l ()
    | & left_val1 : UInt64.t = Any.any_l ()
    | & right_val1 : UInt64.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt64.t = Any.any_l ()
    | & _41 : UInt64.t = Any.any_l ()
    | & _44 : UInt64.t = Any.any_l ()
    | & _45 : UInt64.t = Any.any_l ()
    | & _46 : UInt64.t = Any.any_l ()
    | & _47 : UInt64.t = Any.any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = UInt64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__usize__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.UInt64BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- UInt64BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : UInt64BW.t = Any.any_l () | & _1 : UInt64BW.t = Any.any_l () ] 
    [ return' (result:UInt64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:UInt64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : UInt64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : UInt64BW.t = Any.any_l () ]  [ return' (result:UInt64BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:UInt64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:UInt64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:UInt64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:UInt64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:UInt64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- UInt64BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : UInt64BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val : UInt64BW.t = Any.any_l ()
    | & right_val : UInt64BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : UInt64BW.t = Any.any_l ()
    | & _21 : UInt64BW.t = Any.any_l ()
    | & _24 : (UInt64BW.t, UInt64BW.t) = Any.any_l ()
    | & left_val1 : UInt64BW.t = Any.any_l ()
    | & right_val1 : UInt64BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : UInt64BW.t = Any.any_l ()
    | & _41 : UInt64BW.t = Any.any_l ()
    | & _44 : UInt64BW.t = Any.any_l ()
    | & _45 : UInt64BW.t = Any.any_l ()
    | & _46 : UInt64BW.t = Any.any_l ()
    | & _47 : UInt64BW.t = Any.any_l () ]
    
    [ return' (result:UInt64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = UInt64BW.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_add [#"integer_ops.rs" 84 30 87 11]
  let%span sinteger_ops0 = "integer_ops.rs" 84 19 84 61
  let%span sinteger_ops1 = "integer_ops.rs" 85 18 85 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add'0[#"integer_ops.rs" 84 30 87 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_add requires] [%#sinteger_ops0] Int64.to_int l
    + Int64.to_int r
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int64.to_int l + Int64.to_int r <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int64.add {l} {r} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int64.t = Any.any_l () | & l : Int64.t = l | & r : Int64.t = r ]
    
    [ return' (result:Int64.t)-> {[@expl:test_add ensures] [%#sinteger_ops1] Int64.to_int result
      = Int64.to_int l + Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_add_bw [#"integer_ops.rs" 84 30 95 11]
  let%span sinteger_ops0 = "integer_ops.rs" 91 19 91 61
  let%span sinteger_ops1 = "integer_ops.rs" 92 18 92 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_add_bw'0[#"integer_ops.rs" 84 30 95 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_add_bw requires] [%#sinteger_ops0] Int64BW.to_int l
    + Int64BW.to_int r
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int64BW.to_int l + Int64BW.to_int r <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.add {l} {r} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int64BW.t = Any.any_l () | & l : Int64BW.t = l | & r : Int64BW.t = r ] 
    [ return' (result:Int64BW.t)-> {[@expl:test_add_bw ensures] [%#sinteger_ops1] Int64BW.to_int result
      = Int64BW.to_int l + Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_sub [#"integer_ops.rs" 84 30 102 11]
  let%span sinteger_ops0 = "integer_ops.rs" 99 19 99 61
  let%span sinteger_ops1 = "integer_ops.rs" 100 18 100 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub'0[#"integer_ops.rs" 84 30 102 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_sub requires] [%#sinteger_ops0] Int64.to_int l
    - Int64.to_int r
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int64.to_int l - Int64.to_int r <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int64.sub {l} {r} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int64.t = Any.any_l () | & l : Int64.t = l | & r : Int64.t = r ]
    
    [ return' (result:Int64.t)-> {[@expl:test_sub ensures] [%#sinteger_ops1] Int64.to_int result
      = Int64.to_int l - Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_sub_bw [#"integer_ops.rs" 84 30 110 11]
  let%span sinteger_ops0 = "integer_ops.rs" 106 19 106 61
  let%span sinteger_ops1 = "integer_ops.rs" 107 18 107 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_sub_bw'0[#"integer_ops.rs" 84 30 110 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_sub_bw requires] [%#sinteger_ops0] Int64BW.to_int l
    - Int64BW.to_int r
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int64BW.to_int l - Int64BW.to_int r <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.sub {l} {r} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int64BW.t = Any.any_l () | & l : Int64BW.t = l | & r : Int64BW.t = r ] 
    [ return' (result:Int64BW.t)-> {[@expl:test_sub_bw ensures] [%#sinteger_ops1] Int64BW.to_int result
      = Int64BW.to_int l - Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_mul [#"integer_ops.rs" 84 30 117 11]
  let%span sinteger_ops0 = "integer_ops.rs" 114 19 114 61
  let%span sinteger_ops1 = "integer_ops.rs" 115 18 115 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul'0[#"integer_ops.rs" 84 30 117 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_mul requires] [%#sinteger_ops0] Int64.to_int l
    * Int64.to_int r
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int64.to_int l * Int64.to_int r <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0 [ bb0 = s0 [ s0 = Int64.mul {l} {r} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ] )
    [ & _0 : Int64.t = Any.any_l () | & l : Int64.t = l | & r : Int64.t = r ]
    
    [ return' (result:Int64.t)-> {[@expl:test_mul ensures] [%#sinteger_ops1] Int64.to_int result
      = Int64.to_int l * Int64.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_mul_bw [#"integer_ops.rs" 84 30 125 11]
  let%span sinteger_ops0 = "integer_ops.rs" 121 19 121 61
  let%span sinteger_ops1 = "integer_ops.rs" 122 18 122 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_mul_bw'0[#"integer_ops.rs" 84 30 125 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_mul_bw requires] [%#sinteger_ops0] Int64BW.to_int l
    * Int64BW.to_int r
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int64BW.to_int l * Int64BW.to_int r <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0 [ s0 = Int64BW.mul {l} {r} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    ) [ & _0 : Int64BW.t = Any.any_l () | & l : Int64BW.t = l | & r : Int64BW.t = r ] 
    [ return' (result:Int64BW.t)-> {[@expl:test_mul_bw ensures] [%#sinteger_ops1] Int64BW.to_int result
      = Int64BW.to_int l * Int64BW.to_int r}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_div [#"integer_ops.rs" 84 30 133 11]
  let%span sinteger_ops0 = "integer_ops.rs" 134 12 134 17
  let%span sinteger_ops1 = "integer_ops.rs" 129 19 129 26
  let%span sinteger_ops2 = "integer_ops.rs" 130 19 130 61
  let%span sinteger_ops3 = "integer_ops.rs" 131 18 131 36
  
  use creusot.int.Int64
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int64
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64.t = (-9223372036854775808 : Int64.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int64.t = (9223372036854775807 : Int64.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div'0[#"integer_ops.rs" 84 30 133 11] (l:Int64.t) (r:Int64.t) (return'  (ret:Int64.t))= {[@expl:test_div requires #0] [%#sinteger_ops1] Int64.to_int r
    <> 0}
    {[@expl:test_div requires #1] [%#sinteger_ops2] Int.div (Int64.to_int l) (Int64.to_int r)
    >= Int64.to_int (v_MIN'0 : Int64.t)
    /\ Int.div (Int64.to_int l) (Int64.to_int r) <= Int64.to_int (v_MAX'0 : Int64.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int64.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (-1 : Int64.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (-9223372036854775808 : Int64.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64.div {_6} {_7} (fun (_ret':Int64.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int64.t = Any.any_l ()
    | & l : Int64.t = l
    | & r : Int64.t = r
    | & _6 : Int64.t = Any.any_l ()
    | & _7 : Int64.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int64.t)-> {[@expl:test_div ensures] [%#sinteger_ops3] Int64.to_int result
      = Int.div (Int64.to_int l) (Int64.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_div_bw [#"integer_ops.rs" 84 30 142 11]
  let%span sinteger_ops0 = "integer_ops.rs" 143 12 143 17
  let%span sinteger_ops1 = "integer_ops.rs" 137 19 137 26
  let%span sinteger_ops2 = "integer_ops.rs" 138 19 138 61
  let%span sinteger_ops3 = "integer_ops.rs" 139 18 139 36
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Bool
  
  use creusot.prelude.Any
  
  use creusot.int.Int64BW
  
  use mach.int.Int
  
  constant v_MIN'0 : Int64BW.t = (9223372036854775808 : Int64BW.t)
  
  use mach.int.Int
  
  constant v_MAX'0 : Int64BW.t = (9223372036854775807 : Int64BW.t)
  
  meta "compute_max_steps" 1000000
  
  let rec test_div_bw'0[#"integer_ops.rs" 84 30 142 11] (l:Int64BW.t) (r:Int64BW.t) (return'  (ret:Int64BW.t))= {[@expl:test_div_bw requires #0] [%#sinteger_ops1] Int64BW.to_int r
    <> 0}
    {[@expl:test_div_bw requires #1] [%#sinteger_ops2] Int.div (Int64BW.to_int l) (Int64BW.to_int r)
    >= Int64BW.to_int (v_MIN'0 : Int64BW.t)
    /\ Int.div (Int64BW.to_int l) (Int64BW.to_int r) <= Int64BW.to_int (v_MAX'0 : Int64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_6 <- l ] s1
      | s1 =  [ &_7 <- r ] s2
      | s2 =  [ &_8 <- _7 = ([%#sinteger_ops0] (0 : Int64BW.t)) ] s3
      | s3 = {[@expl:division by zero] [%#sinteger_ops0] not _8} s4
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_9 <- _7 = ([%#sinteger_ops0] (18446744073709551615 : Int64BW.t)) ] s1
      | s1 =  [ &_10 <- _6 = ([%#sinteger_ops0] (9223372036854775808 : Int64BW.t)) ] s2
      | s2 =  [ &_11 <- Bool.bw_and _9 _10 ] s3
      | s3 = {[@expl:Div overflow] [%#sinteger_ops0] not _11} s4
      | s4 = bb2 ]
    
    | bb2 = s0 [ s0 = Int64BW.div {_6} {_7} (fun (_ret':Int64BW.t) ->  [ &_0 <- _ret' ] s1) | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int64BW.t = Any.any_l ()
    | & l : Int64BW.t = l
    | & r : Int64BW.t = r
    | & _6 : Int64BW.t = Any.any_l ()
    | & _7 : Int64BW.t = Any.any_l ()
    | & _8 : bool = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : bool = Any.any_l () ]
    
    [ return' (result:Int64BW.t)-> {[@expl:test_div_bw ensures] [%#sinteger_ops3] Int64BW.to_int result
      = Int.div (Int64BW.to_int l) (Int64BW.to_int r)}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_from_bool [#"integer_ops.rs" 84 30 148 11]
  let%span sinteger_ops0 = "integer_ops.rs" 146 18 146 35
  let%span sinteger_ops1 = "integer_ops.rs" 149 23 149 27
  let%span sinteger_ops2 = "integer_ops.rs" 149 35 149 36
  let%span sinteger_ops3 = "integer_ops.rs" 150 23 150 28
  let%span sinteger_ops4 = "integer_ops.rs" 150 36 150 37
  
  use creusot.int.Int64
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64.t = Any.any_l () | & _1 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  let rec promoted2__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64.t = Any.any_l () | & _1 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  let rec promoted0__test_from_bool'0 (return'  (ret:Int64.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int64.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64.t = Any.any_l () ]  [ return' (result:Int64.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool'0[#"integer_ops.rs" 84 30 148 11] (b:bool) (return'  (ret:Int64.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool'0 (fun (pr3:Int64.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool'0 (fun (pr2:Int64.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool'0 (fun (pr1:Int64.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool'0 (fun (pr0:Int64.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int64.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int64.t, Int64.t) = Any.any_l ()
    | & left_val : Int64.t = Any.any_l ()
    | & right_val : Int64.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int64.t = Any.any_l ()
    | & _21 : Int64.t = Any.any_l ()
    | & _24 : (Int64.t, Int64.t) = Any.any_l ()
    | & left_val1 : Int64.t = Any.any_l ()
    | & right_val1 : Int64.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int64.t = Any.any_l ()
    | & _41 : Int64.t = Any.any_l ()
    | & _44 : Int64.t = Any.any_l ()
    | & _45 : Int64.t = Any.any_l ()
    | & _46 : Int64.t = Any.any_l ()
    | & _47 : Int64.t = Any.any_l () ]
    
    [ return' (result:Int64.t)-> {[@expl:test_from_bool ensures] [%#sinteger_ops0] result = Int64.of_bool b}
      (! return' {result}) ]

end
module M_integer_ops__isize__test_from_bool_bw [#"integer_ops.rs" 84 30 157 11]
  let%span sinteger_ops0 = "integer_ops.rs" 154 18 154 35
  let%span sinteger_ops1 = "integer_ops.rs" 158 23 158 27
  let%span sinteger_ops2 = "integer_ops.rs" 158 35 158 36
  let%span sinteger_ops3 = "integer_ops.rs" 159 23 159 28
  let%span sinteger_ops4 = "integer_ops.rs" 159 36 159 37
  
  use creusot.int.Int64BW
  
  use creusot.prelude.Any
  
  let rec promoted3__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops1] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted2__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops2] (1 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  let rec promoted1__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- Int64BW.of_bool ([%#sinteger_ops3] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : Int64BW.t = Any.any_l () | & _1 : Int64BW.t = Any.any_l () ] 
    [ return' (result:Int64BW.t)-> return' {result} ]
  
  
  let rec promoted0__test_from_bool_bw'0 (return'  (ret:Int64BW.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sinteger_ops4] (0 : Int64BW.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int64BW.t = Any.any_l () ]  [ return' (result:Int64BW.t)-> return' {result} ] 
  
  type t_AssertKind'0  =
    | C_Eq'0
    | C_Ne'0
    | C_Match'0
  
  meta "compute_max_steps" 1000000
  
  let rec test_from_bool_bw'0[#"integer_ops.rs" 84 30 157 11] (b:bool) (return'  (ret:Int64BW.t))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_from_bool_bw'0 (fun (pr3:Int64BW.t) ->  [ &_47 <- pr3 ] s1)
      | s1 = promoted2__test_from_bool_bw'0 (fun (pr2:Int64BW.t) ->  [ &_46 <- pr2 ] s2)
      | s2 =  [ &_4 <- (_47, _46) ] s3
      | s3 =  [ &left_val <- let (r'0, _) = _4 in r'0 ] s4
      | s4 =  [ &right_val <- let (_, r'1) = _4 in r'1 ] s5
      | s5 =  [ &_11 <- left_val = right_val ] s6
      | s6 = any [ br0 -> {_11 = false} (! bb2) | br1 -> {_11} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = promoted1__test_from_bool_bw'0 (fun (pr1:Int64BW.t) ->  [ &_45 <- pr1 ] s1)
      | s1 = promoted0__test_from_bool_bw'0 (fun (pr0:Int64BW.t) ->  [ &_44 <- pr0 ] s2)
      | s2 =  [ &_24 <- (_45, _44) ] s3
      | s3 =  [ &left_val1 <- let (r'0, _) = _24 in r'0 ] s4
      | s4 =  [ &right_val1 <- let (_, r'1) = _24 in r'1 ] s5
      | s5 =  [ &_31 <- left_val1 = right_val1 ] s6
      | s6 = any [ br0 -> {_31 = false} (! bb4) | br1 -> {_31} (! bb3) ]  ]
    
    | bb3 = s0 [ s0 =  [ &_0 <- Int64BW.of_bool b ] s1 | s1 = return' {_0} ] 
    | bb4 = s0
      [ s0 =  [ &kind1 <- C_Eq'0 ] s1
      | s1 =  [ &_39 <- left_val1 ] s2
      | s2 =  [ &_41 <- right_val1 ] s3
      | s3 = {false} any ]
    
    | bb2 = s0
      [ s0 =  [ &kind <- C_Eq'0 ] s1
      | s1 =  [ &_19 <- left_val ] s2
      | s2 =  [ &_21 <- right_val ] s3
      | s3 = {false} any ]
     ]
    )
    [ & _0 : Int64BW.t = Any.any_l ()
    | & b : bool = b
    | & _4 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val : Int64BW.t = Any.any_l ()
    | & right_val : Int64BW.t = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & kind : t_AssertKind'0 = Any.any_l ()
    | & _19 : Int64BW.t = Any.any_l ()
    | & _21 : Int64BW.t = Any.any_l ()
    | & _24 : (Int64BW.t, Int64BW.t) = Any.any_l ()
    | & left_val1 : Int64BW.t = Any.any_l ()
    | & right_val1 : Int64BW.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & kind1 : t_AssertKind'0 = Any.any_l ()
    | & _39 : Int64BW.t = Any.any_l ()
    | & _41 : Int64BW.t = Any.any_l ()
    | & _44 : Int64BW.t = Any.any_l ()
    | & _45 : Int64BW.t = Any.any_l ()
    | & _46 : Int64BW.t = Any.any_l ()
    | & _47 : Int64BW.t = Any.any_l () ]
    
    [ return' (result:Int64BW.t)-> {[@expl:test_from_bool_bw ensures] [%#sinteger_ops0] result = Int64BW.of_bool b}
      (! return' {result}) ]

end
