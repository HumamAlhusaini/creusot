module M_03_std_iterators__slice_iter [#"03_std_iterators.rs" 7 0 7 42]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 8 16 8 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 10 4 10 7
  let%span s03_std_iterators2 = "03_std_iterators.rs" 10 4 10 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 9 16 9 36
  let%span s03_std_iterators4 = "03_std_iterators.rs" 10 4 10 7
  let%span s03_std_iterators5 = "03_std_iterators.rs" 10 4 10 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 11 13 11 14
  let%span s03_std_iterators7 = "03_std_iterators.rs" 7 21 7 26
  let%span s03_std_iterators8 = "03_std_iterators.rs" 5 11 5 30
  let%span s03_std_iterators9 = "03_std_iterators.rs" 6 10 6 33
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 303 18 303 33
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span sslice13 = "../../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span smodel15 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span siter16 = "../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter17 = "../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sslice18 = "../../../creusot-contracts/src/std/slice.rs" 425 14 425 45
  let%span sslice19 = "../../../creusot-contracts/src/std/slice.rs" 426 27 426 29
  let%span sslice20 = "../../../creusot-contracts/src/std/slice.rs" 430 15 430 32
  let%span sslice21 = "../../../creusot-contracts/src/std/slice.rs" 431 15 431 32
  let%span sslice22 = "../../../creusot-contracts/src/std/slice.rs" 432 14 432 42
  let%span sslice23 = "../../../creusot-contracts/src/std/slice.rs" 433 91 433 93
  let%span sslice24 = "../../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice25 = "../../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span sslice26 = "../../../creusot-contracts/src/std/slice.rs" 412 20 412 61
  let%span sresolve27 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sslice28 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice29 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sindex30 = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sseq31 = "../../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span smodel32 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sinvariant33 = "../../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed34 = "../../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sslice35 = "../../../creusot-contracts/src/std/slice.rs" 17 20 17 30
  
  use creusot.int.UInt64
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  use creusot.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate inv'7 (_1 : t_T'0)
  
  predicate invariant'6 (self : t_T'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'9 (_1 : t_T'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_T'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  use seq.Seq
  
  predicate invariant'5 (self : Seq.seq t_T'0) =
    [%#sseq31] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'8 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_T'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.slice.Slice64
  
  function view'2 (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : Slice64.slice t_T'0 . ([%#sslice28] Seq.length (view'2 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice29] view'2 self = Slice64.id self)
  
  predicate invariant'4 (self : Slice64.slice t_T'0) =
    [%#sslice35] inv'8 (view'2 self)
  
  predicate inv'6 (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'1 (self : Slice64.slice t_T'0) =
    [%#sinvariant33] inv'6 self
  
  predicate inv'2 (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function view'1 (self : t_Iter'0) : Slice64.slice t_T'0
  
  let rec iter'0 (self:Slice64.slice t_T'0) (return'  (ret:t_Iter'0))= {[@expl:iter 'self' type invariant] inv'2 self}
    any [ return' (result:t_Iter'0)-> {[%#sslice10] view'1 result = self} (! return' {result}) ] 
  
  predicate inv'0 (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Iter'0) =
    [%#siter16] true
  
  predicate into_iter_post'0 (self : t_Iter'0) (res : t_Iter'0) =
    [%#siter17] self = res
  
  let rec into_iter'0 (self:t_Iter'0) (return'  (ret:t_Iter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter11] into_iter_pre'0 self}
    any [ return' (result:t_Iter'0)-> {inv'0 result} {[%#siter12] into_iter_post'0 self result} (! return' {result}) ] 
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function view'0 (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel15] view'2 self
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Slice64.slice t_T'0) (ix : int) : t_T'0 =
    [%#sindex30] Seq.get (view'2 self) ix
  
  function to_ref_seq'0 (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice24] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'0 self))
  && ([%#sslice25] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0) =
    [%#sslice13] to_ref_seq'0 (view'1 self) = Seq.(++) visited (to_ref_seq'0 (view'1 tl))
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
   =
    [%#sslice23] ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#sslice20] produces'0 a ab b)
   -> ([%#sslice21] produces'0 b bc c)  -> ([%#sslice22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#sslice19] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#sslice18] produces'0 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate invariant'3 (self : t_T'0) =
    [%#sinvariant33] inv'7 self
  
  predicate inv'5 (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_T'0) =
    [%#sboxed34] inv'5 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  use seq.Seq
  
  predicate invariant'0 (self : Seq.seq t_T'0) =
    [%#sseq31] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'1 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use creusot.prelude.MutBorrow
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate resolve'1 (self : MutBorrow.t t_Iter'0) =
    [%#sresolve27] self.final = self.current
  
  function view'3 (self : MutBorrow.t t_Iter'0) : Slice64.slice t_T'0 =
    [%#smodel32] view'1 self.current
  
  use seq.Seq
  
  predicate completed'0 (self : MutBorrow.t t_Iter'0) =
    [%#sslice26] resolve'1 self /\ view'2 (view'3 self) = (Seq.empty : Seq.seq t_T'0)
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_Iter'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {inv'3 result}
      {[%#siter14] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_1 : MutBorrow.t t_Iter'0) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec slice_iter'0[#"03_std_iterators.rs" 7 0 7 42] (slice:Slice64.slice t_T'0) (return'  (ret:UInt64.t))= {[@expl:slice_iter 'slice' type invariant] [%#s03_std_iterators7] inv'2 slice}
    {[@expl:slice_iter requires] [%#s03_std_iterators8] Seq.length (view'0 slice) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : UInt64.t) ] s1
      | s1 = iter'0 {slice} (fun (_ret':t_Iter'0) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = into_iter'0 {_7} (fun (_ret':t_Iter'0) ->  [ &iter <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators1] iter ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators2] Seq.empty : Seq.seq t_T'0 ] s1 | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] [%#s03_std_iterators4] inv'1 produced}
        {[@expl:for invariant] [%#s03_std_iterators4] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators4] produces'0 iter_old produced iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] UInt64.t'int i = Seq.length produced}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = MutBorrow.borrow_mut <t_Iter'0> {iter}
              (fun (_ret':MutBorrow.t t_Iter'0) ->  [ &_21 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Iter'0> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret':MutBorrow.t t_Iter'0) ->
                 [ &_20 <- _ret' ] 
                 [ &_21 <- { _21 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_20} (fun (_ret':t_Option'0) ->  [ &_19 <- _ret' ] s3)
          | s3 = bb7 ]
        
        | bb7 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = any [ br0 -> {_19 = C_None'0} (! bb10) | br1 (x0:t_T'0)-> {_19 = C_Some'0 x0} (! bb9) ]  ]
        
        | bb9 = bb11
        | bb11 = s0
          [ s0 = v_Some'0 {_19} (fun (r0'0:t_T'0) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 =  [ &_24 <- [%#s03_std_iterators5] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb12 ]
        
        | bb12 = s0
          [ s0 =  [ &produced <- _24 ] s1
          | s1 = UInt64.add {i} {[%#s03_std_iterators6] (1 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &i <- _ret' ] s2)
          | s2 = bb5 ]
         ]
       ]
    
    | bb10 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & slice : Slice64.slice t_T'0 = slice
    | & i : UInt64.t = Any.any_l ()
    | & iter : t_Iter'0 = Any.any_l ()
    | & _7 : t_Iter'0 = Any.any_l ()
    | & iter_old : t_Iter'0 = Any.any_l ()
    | & produced : Seq.seq t_T'0 = Any.any_l ()
    | & _19 : t_Option'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Iter'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Iter'0 = Any.any_l ()
    | & __creusot_proc_iter_elem : t_T'0 = Any.any_l ()
    | & _24 : Seq.seq t_T'0 = Any.any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:slice_iter ensures] [%#s03_std_iterators9] UInt64.t'int result
      = Seq.length (view'0 slice)}
      (! return' {result}) ]

end
module M_03_std_iterators__vec_iter [#"03_std_iterators.rs" 18 0 18 41]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 19 16 19 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 21 4 21 7
  let%span s03_std_iterators2 = "03_std_iterators.rs" 21 4 21 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 20 16 20 36
  let%span s03_std_iterators4 = "03_std_iterators.rs" 21 4 21 7
  let%span s03_std_iterators5 = "03_std_iterators.rs" 21 4 21 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 22 13 22 14
  let%span s03_std_iterators7 = "03_std_iterators.rs" 18 19 18 22
  let%span s03_std_iterators8 = "03_std_iterators.rs" 16 11 16 28
  let%span s03_std_iterators9 = "03_std_iterators.rs" 17 10 17 31
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span sslice12 = "../../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span smodel14 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span svec15 = "../../../creusot-contracts/src/std/vec.rs" 213 20 213 24
  let%span svec16 = "../../../creusot-contracts/src/std/vec.rs" 219 20 219 34
  let%span sslice17 = "../../../creusot-contracts/src/std/slice.rs" 425 14 425 45
  let%span sslice18 = "../../../creusot-contracts/src/std/slice.rs" 426 27 426 29
  let%span sslice19 = "../../../creusot-contracts/src/std/slice.rs" 430 15 430 32
  let%span sslice20 = "../../../creusot-contracts/src/std/slice.rs" 431 15 431 32
  let%span sslice21 = "../../../creusot-contracts/src/std/slice.rs" 432 14 432 42
  let%span sslice22 = "../../../creusot-contracts/src/std/slice.rs" 433 91 433 93
  let%span sslice23 = "../../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice24 = "../../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span sslice25 = "../../../creusot-contracts/src/std/slice.rs" 412 20 412 61
  let%span sresolve26 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span svec27 = "../../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex28 = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sseq29 = "../../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sslice30 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice31 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span smodel32 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sinvariant33 = "../../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed34 = "../../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span svec35 = "../../../creusot-contracts/src/std/vec.rs" 71 20 71 41
  
  use creusot.int.UInt64
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'1; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  type t_T'0
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate inv'7 (_1 : t_T'0)
  
  predicate invariant'6 (self : t_T'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'9 (_1 : t_T'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_T'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  use seq.Seq
  
  predicate invariant'5 (self : Seq.seq t_T'0) =
    [%#sseq29] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'8 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_T'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : t_Vec'0) : Seq.seq t_T'0
  
  axiom view'2_spec : forall self : t_Vec'0 . [%#svec27] Seq.length (view'2 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  predicate invariant'4 (self : t_Vec'0) =
    [%#svec35] inv'8 (view'2 self)
  
  predicate inv'6 (_1 : t_Vec'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Vec'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'1 (self : t_Vec'0) =
    [%#sinvariant33] inv'6 self
  
  predicate inv'2 (_1 : t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Vec'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate into_iter_pre'0 (self : t_Vec'0) =
    [%#svec15] true
  
  function view'0 (self : t_Vec'0) : Seq.seq t_T'0 =
    [%#smodel14] view'2 self
  
  use creusot.slice.Slice64
  
  use creusot.slice.Slice64
  
  function view'4 (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'4_spec : forall self : Slice64.slice t_T'0 . ([%#sslice30] Seq.length (view'4 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice31] view'4 self = Slice64.id self)
  
  function view'3 (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel14] view'4 self
  
  function view'1 (self : t_Iter'0) : Slice64.slice t_T'0
  
  predicate into_iter_post'0 (self : t_Vec'0) (res : t_Iter'0) =
    [%#svec16] view'0 self = view'3 (view'1 res)
  
  let rec into_iter'0 (self:t_Vec'0) (return'  (ret:t_Iter'0))= {[@expl:into_iter 'self' type invariant] inv'2 self}
    {[@expl:into_iter requires] [%#siter10] into_iter_pre'0 self}
    any [ return' (result:t_Iter'0)-> {[%#siter11] into_iter_post'0 self result} (! return' {result}) ] 
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Slice64.slice t_T'0) (ix : int) : t_T'0 =
    [%#sindex28] Seq.get (view'4 self) ix
  
  function to_ref_seq'0 (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice t_T'0 . ([%#sslice23] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'3 self))
  && ([%#sslice24] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq t_T'0) (tl : t_Iter'0) =
    [%#sslice12] to_ref_seq'0 (view'1 self) = Seq.(++) visited (to_ref_seq'0 (view'1 tl))
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq t_T'0) (b : t_Iter'0) (bc : Seq.seq t_T'0) (c : t_Iter'0) : ()
   =
    [%#sslice22] ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq t_T'0, b : t_Iter'0, bc : Seq.seq t_T'0, c : t_Iter'0 . ([%#sslice19] produces'0 a ab b)
   -> ([%#sslice20] produces'0 b bc c)  -> ([%#sslice21] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#sslice18] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#sslice17] produces'0 self (Seq.empty : Seq.seq t_T'0) self
  
  predicate inv'0 (_1 : t_Iter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter'0 [inv'0 x] . inv'0 x = true
  
  predicate invariant'3 (self : t_T'0) =
    [%#sinvariant33] inv'7 self
  
  predicate inv'5 (_1 : t_T'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_T'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_T'0) =
    [%#sboxed34] inv'5 self
  
  predicate inv'4 (_1 : t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  use seq.Seq
  
  predicate invariant'0 (self : Seq.seq t_T'0) =
    [%#sseq29] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'4 (Seq.get self i)
  
  predicate inv'1 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq t_T'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  use creusot.prelude.MutBorrow
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_T'0
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate resolve'1 (self : MutBorrow.t t_Iter'0) =
    [%#sresolve26] self.final = self.current
  
  function view'5 (self : MutBorrow.t t_Iter'0) : Slice64.slice t_T'0 =
    [%#smodel32] view'1 self.current
  
  use seq.Seq
  
  predicate completed'0 (self : MutBorrow.t t_Iter'0) =
    [%#sslice25] resolve'1 self /\ view'4 (view'5 self) = (Seq.empty : Seq.seq t_T'0)
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_Iter'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {inv'3 result}
      {[%#siter13] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_1 : MutBorrow.t t_Iter'0) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_T'0))= any
    [ good (field_0:t_T'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_T'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec vec_iter'0[#"03_std_iterators.rs" 18 0 18 41] (vec:t_Vec'0) (return'  (ret:UInt64.t))= {[@expl:vec_iter 'vec' type invariant] [%#s03_std_iterators7] inv'2 vec}
    {[@expl:vec_iter requires] [%#s03_std_iterators8] Seq.length (view'0 vec) < 1000}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : UInt64.t) ] s1
      | s1 = into_iter'0 {vec} (fun (_ret':t_Iter'0) ->  [ &iter <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators1] iter ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators2] Seq.empty : Seq.seq t_T'0 ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] [%#s03_std_iterators4] inv'1 produced}
        {[@expl:for invariant] [%#s03_std_iterators4] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators4] produces'0 iter_old produced iter}
        {[@expl:loop invariant] [%#s03_std_iterators3] UInt64.t'int i = Seq.length produced}
        (! s0) [ s0 = bb5 ] 
        [ bb5 = s0
          [ s0 = MutBorrow.borrow_mut <t_Iter'0> {iter}
              (fun (_ret':MutBorrow.t t_Iter'0) ->  [ &_20 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Iter'0> {_20.current} {MutBorrow.get_id _20}
              (fun (_ret':MutBorrow.t t_Iter'0) ->
                 [ &_19 <- _ret' ] 
                 [ &_20 <- { _20 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_19} (fun (_ret':t_Option'0) ->  [ &_18 <- _ret' ] s3)
          | s3 = bb6 ]
        
        | bb6 = s0
          [ s0 = -{resolve'0 _20}- s1
          | s1 = any [ br0 -> {_18 = C_None'0} (! bb9) | br1 (x0:t_T'0)-> {_18 = C_Some'0 x0} (! bb8) ]  ]
        
        | bb8 = bb10
        | bb10 = s0
          [ s0 = v_Some'0 {_18} (fun (r0'0:t_T'0) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 =  [ &_23 <- [%#s03_std_iterators5] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb11 ]
        
        | bb11 = s0
          [ s0 =  [ &produced <- _23 ] s1
          | s1 = UInt64.add {i} {[%#s03_std_iterators6] (1 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
         ]
       ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & vec : t_Vec'0 = vec
    | & i : UInt64.t = Any.any_l ()
    | & iter : t_Iter'0 = Any.any_l ()
    | & iter_old : t_Iter'0 = Any.any_l ()
    | & produced : Seq.seq t_T'0 = Any.any_l ()
    | & _18 : t_Option'0 = Any.any_l ()
    | & _19 : MutBorrow.t t_Iter'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Iter'0 = Any.any_l ()
    | & __creusot_proc_iter_elem : t_T'0 = Any.any_l ()
    | & _23 : Seq.seq t_T'0 = Any.any_l () ]
    
    [ return' (result:UInt64.t)-> {[@expl:vec_iter ensures] [%#s03_std_iterators9] UInt64.t'int result
      = Seq.length (view'0 vec)}
      (! return' {result}) ]

end
module M_03_std_iterators__all_zero [#"03_std_iterators.rs" 29 0 29 35]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 31 4 31 7
  let%span s03_std_iterators1 = "03_std_iterators.rs" 31 4 31 7
  let%span s03_std_iterators2 = "03_std_iterators.rs" 30 16 30 85
  let%span s03_std_iterators3 = "03_std_iterators.rs" 31 4 31 7
  let%span s03_std_iterators4 = "03_std_iterators.rs" 31 4 31 7
  let%span s03_std_iterators5 = "03_std_iterators.rs" 32 13 32 14
  let%span s03_std_iterators6 = "03_std_iterators.rs" 27 10 27 33
  let%span s03_std_iterators7 = "03_std_iterators.rs" 28 10 28 64
  let%span svec8 = "../../../creusot-contracts/src/std/vec.rs" 181 26 181 42
  let%span svec9 = "../../../creusot-contracts/src/std/vec.rs" 182 26 182 48
  let%span sslice10 = "../../../creusot-contracts/src/std/slice.rs" 307 18 307 33
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span sindex13 = "../../../creusot-contracts/src/logic/ops/index.rs" 96 8 96 33
  let%span sslice14 = "../../../creusot-contracts/src/std/slice.rs" 473 12 473 66
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span svec16 = "../../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span smodel17 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sindex18 = "../../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sslice19 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice20 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sslice21 = "../../../creusot-contracts/src/std/slice.rs" 441 14 441 50
  let%span siter22 = "../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sresolve24 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sslice25 = "../../../creusot-contracts/src/std/slice.rs" 479 14 479 45
  let%span sslice26 = "../../../creusot-contracts/src/std/slice.rs" 480 27 480 29
  let%span sslice27 = "../../../creusot-contracts/src/std/slice.rs" 484 15 484 32
  let%span sslice28 = "../../../creusot-contracts/src/std/slice.rs" 485 15 485 32
  let%span sslice29 = "../../../creusot-contracts/src/std/slice.rs" 486 14 486 42
  let%span sslice30 = "../../../creusot-contracts/src/std/slice.rs" 487 91 487 93
  let%span sslice31 = "../../../creusot-contracts/src/std/slice.rs" 88 14 88 41
  let%span sslice32 = "../../../creusot-contracts/src/std/slice.rs" 89 14 89 84
  let%span sslice33 = "../../../creusot-contracts/src/std/slice.rs" 466 20 466 61
  let%span sslice34 = "../../../creusot-contracts/src/std/slice.rs" 451 20 451 36
  let%span sindex35 = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  
  use creusot.prelude.MutBorrow
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'1; t_Unique__qy95zmarker'0: () }
  
  use creusot.int.UInt64
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  use creusot.slice.Slice64
  
  predicate inv'2 (_1 : MutBorrow.t t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Vec'0 [inv'2 x] . inv'2 x = true
  
  predicate inv'3 (_1 : MutBorrow.t (Slice64.slice UInt64.t))
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t (Slice64.slice UInt64.t) [inv'3 x] . inv'3 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'3 (self : Slice64.slice UInt64.t) : Seq.seq UInt64.t
  
  axiom view'3_spec : forall self : Slice64.slice UInt64.t . ([%#sslice19] Seq.length (view'3 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice20] view'3 self = Slice64.id self)
  
  function view'2 (self : MutBorrow.t (Slice64.slice UInt64.t)) : Seq.seq UInt64.t =
    [%#smodel17] view'3 self.current
  
  function view'0 (self : t_Vec'0) : Seq.seq UInt64.t
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec16] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'1 (self : MutBorrow.t t_Vec'0) : Seq.seq UInt64.t =
    [%#smodel17] view'0 self.current
  
  let rec deref_mut'0 (self:MutBorrow.t t_Vec'0) (return'  (ret:MutBorrow.t (Slice64.slice UInt64.t)))= {[@expl:deref_mut 'self' type invariant] inv'2 self}
    any
    [ return' (result:MutBorrow.t (Slice64.slice UInt64.t))-> {inv'3 result}
      {[%#svec8] view'2 result = view'1 self}
      {[%#svec9] view'3 result.final = view'0 self.final}
      (! return' {result}) ]
  
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_IterMut'0  =
    { t_IterMut__ptr'0: t_NonNull'0; t_IterMut__end_or_len'0: Opaque.ptr; t_IterMut__qy95zmarker'0: () }
  
  function view'4 (self : t_IterMut'0) : MutBorrow.t (Slice64.slice UInt64.t)
  
  axiom view'4_spec : forall self : t_IterMut'0 . [%#sslice21] Seq.length (view'3 (view'4 self).final)
  = Seq.length (view'3 (view'4 self).current)
  
  let rec iter_mut'0 (self:MutBorrow.t (Slice64.slice UInt64.t)) (return'  (ret:t_IterMut'0))= {[@expl:iter_mut 'self' type invariant] inv'3 self}
    any [ return' (result:t_IterMut'0)-> {[%#sslice10] view'4 result = self} (! return' {result}) ] 
  
  predicate inv'0 (_1 : t_IterMut'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_IterMut'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_IterMut'0) =
    [%#siter22] true
  
  predicate into_iter_post'0 (self : t_IterMut'0) (res : t_IterMut'0) =
    [%#siter23] self = res
  
  let rec into_iter'0 (self:t_IterMut'0) (return'  (ret:t_IterMut'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter11] into_iter_pre'0 self}
    any
    [ return' (result:t_IterMut'0)-> {inv'0 result} {[%#siter12] into_iter_post'0 self result} (! return' {result}) ]
  
  
  predicate resolve'5 (self : MutBorrow.t (Slice64.slice UInt64.t)) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t (Slice64.slice UInt64.t)) =
    resolve'5 _1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Seq.seq (MutBorrow.t UInt64.t)) (ix : int) : MutBorrow.t UInt64.t =
    [%#sindex13] Seq.get self ix
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'2 [@inline:trivial] (self : Slice64.slice UInt64.t) (ix : int) : UInt64.t =
    [%#sindex35] Seq.get (view'3 self) ix
  
  function to_mut_seq'0 (self : MutBorrow.t (Slice64.slice UInt64.t)) : Seq.seq (MutBorrow.t UInt64.t)
  
  axiom to_mut_seq'0_spec : forall self : MutBorrow.t (Slice64.slice UInt64.t) . ([%#sslice31] Seq.length (to_mut_seq'0 self)
  = Seq.length (view'2 self))
  && ([%#sslice32] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq'0 self)
   -> Seq.get (to_mut_seq'0 self) i
  = MutBorrow.borrow_logic (index_logic'2 self.current i) (index_logic'2 self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i))
  
  predicate produces'0 (self : t_IterMut'0) (visited : Seq.seq (MutBorrow.t UInt64.t)) (tl : t_IterMut'0) =
    [%#sslice14] to_mut_seq'0 (view'4 self) = Seq.(++) visited (to_mut_seq'0 (view'4 tl))
  
  function produces_trans'0 (a : t_IterMut'0) (ab : Seq.seq (MutBorrow.t UInt64.t)) (b : t_IterMut'0) (bc : Seq.seq (MutBorrow.t UInt64.t)) (c : t_IterMut'0) : ()
  
   =
    [%#sslice30] ()
  
  axiom produces_trans'0_spec : forall a : t_IterMut'0, ab : Seq.seq (MutBorrow.t UInt64.t), b : t_IterMut'0, bc : Seq.seq (MutBorrow.t UInt64.t), c : t_IterMut'0 . ([%#sslice27] produces'0 a ab b)
   -> ([%#sslice28] produces'0 b bc c)  -> ([%#sslice29] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_IterMut'0) : () =
    [%#sslice26] ()
  
  axiom produces_refl'0_spec : forall self : t_IterMut'0 . [%#sslice25] produces'0 self (Seq.empty : Seq.seq (MutBorrow.t UInt64.t)) self
  
  predicate inv'1 (_1 : Seq.seq (MutBorrow.t UInt64.t))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (MutBorrow.t UInt64.t) [inv'1 x] . inv'1 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t UInt64.t)
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x = true
  
  predicate resolve'6 (self : MutBorrow.t t_IterMut'0) =
    [%#sresolve24] self.final = self.current
  
  function view'5 (self : MutBorrow.t t_IterMut'0) : MutBorrow.t (Slice64.slice UInt64.t) =
    [%#smodel17] view'4 self.current
  
  use seq.Seq
  
  predicate completed'0 (self : MutBorrow.t t_IterMut'0) =
    [%#sslice33] resolve'6 self /\ view'3 (view'5 self).current = (Seq.empty : Seq.seq UInt64.t)
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_IterMut'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {inv'4 result}
      {[%#siter15] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'1 (_1 : MutBorrow.t t_IterMut'0) =
    resolve'6 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:MutBorrow.t UInt64.t))= any
    [ good (field_0:MutBorrow.t UInt64.t)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t UInt64.t [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate resolve'7 (self : MutBorrow.t UInt64.t) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t UInt64.t) =
    resolve'7 _1
  
  predicate resolve'8 (self : t_IterMut'0) =
    [%#sslice34] (view'4 self).current = (view'4 self).final
  
  predicate resolve'3 (_1 : t_IterMut'0) =
    resolve'8 _1
  
  predicate resolve'9 (self : MutBorrow.t t_Vec'0) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'4 (_1 : MutBorrow.t t_Vec'0) =
    resolve'9 _1
  
  use creusot.prelude.Any
  
  function index_logic'1 [@inline:trivial] (self : t_Vec'0) (ix : int) : UInt64.t =
    [%#sindex18] Seq.get (view'0 self) ix
  
  meta "compute_max_steps" 1000000
  
  let rec all_zero'0[#"03_std_iterators.rs" 29 0 29 35] (v:MutBorrow.t t_Vec'0) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Vec'0> {v.current} {MutBorrow.get_id v}
          (fun (_ret':MutBorrow.t t_Vec'0) ->  [ &_8 <- _ret' ]  [ &v <- { v with current = _ret'.final } ] s1)
      | s1 = deref_mut'0 {_8} (fun (_ret':MutBorrow.t (Slice64.slice UInt64.t)) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice UInt64.t> {_7.current} {MutBorrow.get_id _7}
          (fun (_ret':MutBorrow.t (Slice64.slice UInt64.t)) ->
             [ &_6 <- _ret' ] 
             [ &_7 <- { _7 with current = _ret'.final } ] 
            s1)
      | s1 = iter_mut'0 {_6} (fun (_ret':t_IterMut'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = into_iter'0 {_5} (fun (_ret':t_IterMut'0) ->  [ &iter <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = -{resolve'0 _7}- s1 | s1 =  [ &iter_old <- [%#s03_std_iterators0] iter ] s2 | s2 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &produced <- [%#s03_std_iterators1] Seq.empty : Seq.seq (MutBorrow.t UInt64.t) ] s1 | s1 = bb5 ]
    
    | bb5 = bb6
    | bb6 = bb6
      [ bb6 = {[@expl:for invariant] [%#s03_std_iterators3] inv'1 produced}
        {[@expl:for invariant] [%#s03_std_iterators3] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators3] produces'0 iter_old produced iter}
        {[@expl:loop invariant] [%#s03_std_iterators2] forall i : int . 0 <= i /\ i < Seq.length produced
         -> UInt64.t'int (index_logic'0 produced i).final = 0}
        (! s0) [ s0 = bb7 ] 
        [ bb7 = s0
          [ s0 = MutBorrow.borrow_mut <t_IterMut'0> {iter}
              (fun (_ret':MutBorrow.t t_IterMut'0) ->  [ &_21 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = MutBorrow.borrow_final <t_IterMut'0> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret':MutBorrow.t t_IterMut'0) ->
                 [ &_20 <- _ret' ] 
                 [ &_21 <- { _21 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_20} (fun (_ret':t_Option'0) ->  [ &_19 <- _ret' ] s3)
          | s3 = bb8 ]
        
        | bb8 = s0
          [ s0 = -{resolve'1 _21}- s1
          | s1 = any
            [ br0 -> {_19 = C_None'0} (! bb11) | br1 (x0:MutBorrow.t UInt64.t)-> {_19 = C_Some'0 x0} (! bb10) ]
           ]
        
        | bb10 = bb12
        | bb12 = s0
          [ s0 = v_Some'0 {_19} (fun (r0'0:MutBorrow.t UInt64.t) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 =  [ &_24 <- [%#s03_std_iterators4] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb13 ]
        
        | bb13 = s0
          [ s0 =  [ &produced <- _24 ] s1
          | s1 =  [ &x <- __creusot_proc_iter_elem ] s2
          | s2 =  [ &x <- { x with current = ([%#s03_std_iterators5] (0 : UInt64.t)) } ] s3
          | s3 = -{resolve'2 x}- s4
          | s4 = bb6 ]
         ]
       ]
    
    | bb11 = s0 [ s0 = -{resolve'3 iter}- s1 | s1 = -{resolve'4 v}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & v : MutBorrow.t t_Vec'0 = v
    | & iter : t_IterMut'0 = Any.any_l ()
    | & _5 : t_IterMut'0 = Any.any_l ()
    | & _6 : MutBorrow.t (Slice64.slice UInt64.t) = Any.any_l ()
    | & _7 : MutBorrow.t (Slice64.slice UInt64.t) = Any.any_l ()
    | & _8 : MutBorrow.t t_Vec'0 = Any.any_l ()
    | & iter_old : t_IterMut'0 = Any.any_l ()
    | & produced : Seq.seq (MutBorrow.t UInt64.t) = Any.any_l ()
    | & _19 : t_Option'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_IterMut'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_IterMut'0 = Any.any_l ()
    | & __creusot_proc_iter_elem : MutBorrow.t UInt64.t = Any.any_l ()
    | & _24 : Seq.seq (MutBorrow.t UInt64.t) = Any.any_l ()
    | & x : MutBorrow.t UInt64.t = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:all_zero ensures #0] [%#s03_std_iterators6] Seq.length (view'0 v.final)
      = Seq.length (view'1 v)}
      {[@expl:all_zero ensures #1] [%#s03_std_iterators7] forall i : int . 0 <= i /\ i < Seq.length (view'1 v)
       -> UInt64.t'int (index_logic'1 v.final i) = 0}
      (! return' {result}) ]

end
module M_03_std_iterators__skip_take [#"03_std_iterators.rs" 36 0 36 48]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 39 20 39 31
  let%span s03_std_iterators1 = "03_std_iterators.rs" 36 30 36 34
  let%span siter2 = "../../../creusot-contracts/src/std/iter.rs" 133 26 133 67
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 129 26 129 67
  let%span siter4 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span stake5 = "../../../creusot-contracts/src/std/iter/take.rs" 17 14 17 39
  let%span stake6 = "../../../creusot-contracts/src/std/iter/take.rs" 31 14 31 50
  let%span sskip7 = "../../../creusot-contracts/src/std/iter/skip.rs" 14 14 14 39
  let%span sskip8 = "../../../creusot-contracts/src/std/iter/skip.rs" 21 14 21 50
  let%span sskip9 = "../../../creusot-contracts/src/std/iter/skip.rs" 48 12 54 39
  let%span sskip10 = "../../../creusot-contracts/src/std/iter/skip.rs" 62 12 67 74
  let%span sskip11 = "../../../creusot-contracts/src/std/iter/skip.rs" 32 12 32 33
  let%span sresolve12 = "../../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sskip13 = "../../../creusot-contracts/src/std/iter/skip.rs" 73 14 73 45
  let%span sskip14 = "../../../creusot-contracts/src/std/iter/skip.rs" 78 15 78 32
  let%span sskip15 = "../../../creusot-contracts/src/std/iter/skip.rs" 79 15 79 32
  let%span sskip16 = "../../../creusot-contracts/src/std/iter/skip.rs" 80 14 80 42
  let%span stake17 = "../../../creusot-contracts/src/std/iter/take.rs" 65 12 65 88
  let%span stake18 = "../../../creusot-contracts/src/std/iter/take.rs" 56 12 57 92
  let%span sinvariant19 = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span stake20 = "../../../creusot-contracts/src/std/iter/take.rs" 71 14 71 45
  let%span stake21 = "../../../creusot-contracts/src/std/iter/take.rs" 76 15 76 32
  let%span stake22 = "../../../creusot-contracts/src/std/iter/take.rs" 77 15 77 32
  let%span stake23 = "../../../creusot-contracts/src/std/iter/take.rs" 78 14 78 42
  let%span stake24 = "../../../creusot-contracts/src/std/iter/take.rs" 24 14 24 68
  let%span stake25 = "../../../creusot-contracts/src/std/iter/take.rs" 41 8 41 29
  let%span siter26 = "../../../creusot-contracts/src/std/iter.rs" 42 14 42 45
  let%span siter27 = "../../../creusot-contracts/src/std/iter.rs" 46 15 46 32
  let%span siter28 = "../../../creusot-contracts/src/std/iter.rs" 47 15 47 32
  let%span siter29 = "../../../creusot-contracts/src/std/iter.rs" 48 14 48 42
  let%span sresolve30 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  type t_I'0
  
  use creusot.int.UInt64
  
  type t_Take'0  =
    { t_Take__iter'0: t_I'0; t_Take__n'0: UInt64.t }
  
  predicate inv'2 (_1 : t_I'0)
  
  predicate inv'3 (_1 : t_Take'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Take'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Take__iter'0 = iter ; t_Take__n'0 = n} -> inv'2 iter
    end
  
  function iter'0 (self : t_Take'0) : t_I'0
  
  axiom iter'0_spec : forall self : t_Take'0 . [%#stake5] inv'3 self  -> inv'2 (iter'0 self)
  
  use mach.int.Int
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function n'0 (self : t_Take'0) : int
  
  axiom n'0_spec : forall self : t_Take'0 . [%#stake6] n'0 self >= 0 /\ n'0 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  let rec take'0 (self:t_I'0) (n:UInt64.t) (return'  (ret:t_Take'0))= {[@expl:take 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_Take'0)-> {inv'3 result}
      {[%#siter2] iter'0 result = self /\ n'0 result = UInt64.t'int n}
      (! return' {result}) ]
  
  
  type t_Skip'0  =
    { t_Skip__iter'0: t_Take'0; t_Skip__n'0: UInt64.t }
  
  predicate inv'0 (_1 : t_Skip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Skip'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Skip__iter'0 = iter ; t_Skip__n'0 = n} -> inv'3 iter
    end
  
  function iter'1 (self : t_Skip'0) : t_Take'0
  
  axiom iter'1_spec : forall self : t_Skip'0 . [%#sskip7] inv'0 self  -> inv'3 (iter'1 self)
  
  function n'1 (self : t_Skip'0) : int
  
  axiom n'1_spec : forall self : t_Skip'0 . [%#sskip8] n'1 self >= 0 /\ n'1 self <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  let rec skip'0 (self:t_Take'0) (n:UInt64.t) (return'  (ret:t_Skip'0))= {[@expl:skip 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Skip'0)-> {inv'0 result}
      {[%#siter3] iter'1 result = self /\ n'1 result = UInt64.t'int n}
      (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  type t_Item'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate invariant'0 (self : MutBorrow.t t_Skip'0) =
    [%#sinvariant19] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Skip'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Skip'0 [inv'4 x] . inv'4 x = invariant'0 x
  
  predicate inv'5 (_1 : t_Item'0)
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'2 (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'2 (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  axiom produces_trans'2_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#siter27] produces'2 a ab b)
   -> ([%#siter28] produces'2 b bc c)  -> ([%#siter29] produces'2 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 (self : t_I'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_I'0 . [%#siter26] produces'2 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate produces'1 (self : t_Take'0) (visited : Seq.seq t_Item'0) (o : t_Take'0) =
    [%#stake17] n'0 self = n'0 o + Seq.length visited /\ produces'2 (iter'0 self) visited (iter'0 o)
  
  function produces_trans'1 (a : t_Take'0) (ab : Seq.seq t_Item'0) (b : t_Take'0) (bc : Seq.seq t_Item'0) (c : t_Take'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_Take'0, ab : Seq.seq t_Item'0, b : t_Take'0, bc : Seq.seq t_Item'0, c : t_Take'0 . ([%#stake21] produces'1 a ab b)
   -> ([%#stake22] produces'1 b bc c)  -> ([%#stake23] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Take'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_Take'0 . [%#stake20] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate resolve'4 (_1 : t_Item'0)
  
  use seq.Seq
  
  predicate produces'0 (self : t_Skip'0) (visited : Seq.seq t_Item'0) (o : t_Skip'0) =
    [%#sskip10] visited = (Seq.empty : Seq.seq t_Item'0) /\ self = o
    \/ n'1 o = 0
    /\ Seq.length visited > 0
    /\ (exists s : Seq.seq t_Item'0 . Seq.length s = n'1 self
    /\ produces'1 (iter'1 self) (Seq.(++) s visited) (iter'1 o)
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'4 (Seq.get s i)))
  
  function produces_trans'0 (a : t_Skip'0) (ab : Seq.seq t_Item'0) (b : t_Skip'0) (bc : Seq.seq t_Item'0) (c : t_Skip'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Skip'0, ab : Seq.seq t_Item'0, b : t_Skip'0, bc : Seq.seq t_Item'0, c : t_Skip'0 . ([%#sskip14] produces'0 a ab b)
   -> ([%#sskip15] produces'0 b bc c)  -> ([%#sskip16] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Skip'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Skip'0 . [%#sskip13] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate resolve'8 (self : MutBorrow.t t_Take'0) =
    [%#sresolve30] self.final = self.current
  
  predicate resolve'6 (_1 : MutBorrow.t t_Take'0) =
    resolve'8 _1
  
  predicate completed'2 (self : MutBorrow.t t_I'0)
  
  function iter_mut'0 (self : MutBorrow.t t_Take'0) : MutBorrow.t t_I'0
  
  axiom iter_mut'0_spec : forall self : MutBorrow.t t_Take'0 . [%#stake24] iter'0 self.current
  = (iter_mut'0 self).current
  /\ iter'0 self.final = (iter_mut'0 self).final
  
  predicate completed'1 (self : MutBorrow.t t_Take'0) =
    [%#stake18] n'0 self.current = 0 /\ resolve'6 self
    \/ n'0 self.current > 0 /\ n'0 self.current = n'0 self.final + 1 /\ completed'2 (iter_mut'0 self)
  
  predicate completed'0 (self : MutBorrow.t t_Skip'0) =
    [%#sskip9] n'1 self.final = 0
    /\ (exists s : Seq.seq t_Item'0, i : MutBorrow.t t_Take'0 . Seq.length s <= n'1 self.current
    /\ produces'1 (iter'1 self.current) s i.current
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> resolve'4 (Seq.get s i))
    /\ completed'1 i /\ i.final = iter'1 self.final)
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_Skip'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'0)-> {inv'1 result}
      {[%#siter4] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'9 (_1 : t_I'0)
  
  predicate resolve'7 (self : t_Take'0) =
    [%#stake25] resolve'9 (iter'0 self)
  
  predicate resolve'5 (_1 : t_Take'0) =
    resolve'7 _1
  
  predicate resolve'2 (self : t_Skip'0) =
    [%#sskip11] resolve'5 (iter'1 self)
  
  predicate resolve'0 (_1 : t_Skip'0) =
    resolve'2 _1
  
  predicate resolve'3 (self : t_Option'0) =
    [%#sresolve12] match self with
      | C_Some'0 x -> resolve'4 x
      | C_None'0 -> true
      end
  
  predicate resolve'1 (_1 : t_Option'0) =
    resolve'3 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec skip_take'0[#"03_std_iterators.rs" 36 0 36 48] (iter:t_I'0) (n:UInt64.t) (return'  (ret:()))= {[@expl:skip_take 'iter' type invariant] [%#s03_std_iterators1] inv'2 iter}
    (! bb0
    [ bb0 = s0 [ s0 = take'0 {iter} {n} (fun (_ret':t_Take'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = skip'0 {_6} {n} (fun (_ret':t_Skip'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'0 _5}
        MutBorrow.borrow_mut <t_Skip'0> {_5}
          (fun (_ret':MutBorrow.t t_Skip'0) ->  [ &_4 <- _ret' ] -{inv'0 _ret'.final}-  [ &_5 <- _ret'.final ] s1)
      | s1 = next'0 {_4} (fun (_ret':t_Option'0) ->  [ &res <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 _5} s1
      | s1 = -{resolve'0 _5}- s2
      | s2 = {[@expl:type invariant] inv'1 res} s3
      | s3 = -{resolve'1 res}- s4
      | s4 = bb4 ]
    
    | bb4 = s0 [ s0 = {[@expl:assertion] [%#s03_std_iterators0] res = C_None'0} s1 | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & iter : t_I'0 = iter
    | & n : UInt64.t = n
    | & res : t_Option'0 = Any.any_l ()
    | & _4 : MutBorrow.t t_Skip'0 = Any.any_l ()
    | & _5 : t_Skip'0 = Any.any_l ()
    | & _6 : t_Take'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_03_std_iterators__counter [#"03_std_iterators.rs" 42 0 42 27]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 43 25 43 26
  let%span s03_std_iterators1 = "03_std_iterators.rs" 54 20 54 40
  let%span s03_std_iterators2 = "03_std_iterators.rs" 55 20 55 33
  let%span s03_std_iterators3 = "03_std_iterators.rs" 56 20 56 36
  let%span svec4 = "../../../creusot-contracts/src/std/vec.rs" 175 26 175 42
  let%span sslice5 = "../../../creusot-contracts/src/std/slice.rs" 303 18 303 33
  let%span s03_std_iterators6 = "03_std_iterators.rs" 48 26 48 45
  let%span s03_std_iterators7 = "03_std_iterators.rs" 49 19 49 20
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 59 21 59 25
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 59 27 59 31
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 53 15 55 69
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 56 15 56 51
  let%span siter12 = "../../../creusot-contracts/src/std/iter.rs" 57 15 57 70
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 59 4 62 61
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 58 14 58 88
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span svec16 = "../../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span smodel17 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sslice18 = "../../../creusot-contracts/src/std/slice.rs" 425 14 425 45
  let%span sslice19 = "../../../creusot-contracts/src/std/slice.rs" 426 27 426 29
  let%span sslice20 = "../../../creusot-contracts/src/std/slice.rs" 430 15 430 32
  let%span sslice21 = "../../../creusot-contracts/src/std/slice.rs" 431 15 431 32
  let%span sslice22 = "../../../creusot-contracts/src/std/slice.rs" 432 14 432 42
  let%span sslice23 = "../../../creusot-contracts/src/std/slice.rs" 433 91 433 93
  let%span sslice24 = "../../../creusot-contracts/src/std/slice.rs" 419 12 419 66
  let%span smap_inv25 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 153 12 156 47
  let%span smap_inv26 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 140 12 145 71
  let%span smap_inv27 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 15 8 18 9
  let%span smap_inv28 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 37 8 49 9
  let%span svec29 = "../../../creusot-contracts/src/std/vec.rs" 297 20 297 32
  let%span sslice30 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice31 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sresolve32 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sops33 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops34 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops35 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops36 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops37 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops38 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops39 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span sslice40 = "../../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice41 = "../../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span sslice42 = "../../../creusot-contracts/src/std/slice.rs" 412 20 412 61
  let%span smap_inv43 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 117 12 119 63
  let%span smap_inv44 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 57 8 57 50
  let%span smap_inv45 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 23 14 23 45
  let%span smap_inv46 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 28 15 28 32
  let%span smap_inv47 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 29 15 29 32
  let%span smap_inv48 = "../../../creusot-contracts/src/std/iter/map_inv.rs" 30 14 30 42
  let%span sindex49 = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span smodel50 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  
  use creusot.int.UInt64
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'1; t_Unique__qy95zmarker'0: () }
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  use creusot.slice.Slice64
  
  use creusot.int.UInt32
  
  predicate inv'0 (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : Slice64.slice UInt32.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Slice64.slice UInt32.t [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.slice.Slice64
  
  function view'4 (self : Slice64.slice UInt32.t) : Seq.seq UInt32.t
  
  axiom view'4_spec : forall self : Slice64.slice UInt32.t . ([%#sslice30] Seq.length (view'4 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice31] view'4 self = Slice64.id self)
  
  function view'1 (self : Slice64.slice UInt32.t) : Seq.seq UInt32.t =
    [%#smodel17] view'4 self
  
  function view'0 (self : t_Vec'0) : Seq.seq UInt32.t
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec16] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'2 (self : t_Vec'0) : Seq.seq UInt32.t =
    [%#smodel17] view'0 self
  
  let rec deref'0 (self:t_Vec'0) (return'  (ret:Slice64.slice UInt32.t))= {[@expl:deref 'self' type invariant] inv'0 self}
    any
    [ return' (result:Slice64.slice UInt32.t)-> {inv'1 result}
      {[%#svec4] view'1 result = view'2 self}
      (! return' {result}) ]
  
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Iter'0  =
    { t_Iter__ptr'0: t_NonNull'0; t_Iter__end_or_len'0: Opaque.ptr; t_Iter__qy95zmarker'0: () }
  
  function view'3 (self : t_Iter'0) : Slice64.slice UInt32.t
  
  let rec iter'0 (self:Slice64.slice UInt32.t) (return'  (ret:t_Iter'0))= {[@expl:iter 'self' type invariant] inv'1 self}
    any [ return' (result:t_Iter'0)-> {[%#sslice5] view'3 result = self} (! return' {result}) ] 
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  type closure0'1  =
    { field_0'0: MutBorrow.t UInt64.t }
  
  predicate resolve'2 (self : MutBorrow.t closure0'1) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t closure0'1) =
    resolve'2 _1
  
  use creusot.prelude.Any
  
  use seq.Seq
  
  predicate postcondition_once'0 (self : closure0'1) (args : (UInt32.t, Seq.seq UInt32.t)) (result : UInt32.t)
  
  predicate resolve'8 (self : MutBorrow.t UInt64.t) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'7 (_1 : MutBorrow.t UInt64.t) =
    resolve'8 _1
  
  predicate resolve'4 (_1 : closure0'1) =
    resolve'7 _1.field_0'0
  
  predicate unnest'0 (self : closure0'1) (_2 : closure0'1) =
    (_2.field_0'0).final = (self.field_0'0).final
  
  let rec closure0'0[#"03_std_iterators.rs" 47 17 47 27] [@coma:extspec] (_1:MutBorrow.t closure0'1) (x:UInt32.t) (_prod:Seq.seq UInt32.t) (return'  (ret:UInt32.t))= bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators6] UInt64.t'int ((_1.current).field_0'0).current = Seq.length _prod}
        s1
      | s1 = UInt64.add {((_1.current).field_0'0).current} {[%#s03_std_iterators7] (1 : UInt64.t)}
          (fun (_ret':UInt64.t) ->
             [ &_1 <- { _1 with current = { field_0'0 = { (_1.current).field_0'0 with current = _ret' } } } ] 
            s2)
      | s2 = -{resolve'0 _1}- s3
      | s3 =  [ &_0 <- x ] s4
      | s4 = return' {_0} ]
     ]
    
    [ & _0 : UInt32.t = Any.any_l ()
    | & _1 : MutBorrow.t closure0'1 = _1
    | & x : UInt32.t = x
    | & _prod : Seq.seq UInt32.t = _prod ]
     [ return' (result:UInt32.t)-> return' {result} ] 
  
  predicate postcondition_mut'0 (self : closure0'1) (args : (UInt32.t, Seq.seq UInt32.t)) (result_state : closure0'1) (result : UInt32.t)
  
   =
    (let (x, _prod) = args in exists __bor_self : MutBorrow.t closure0'1 . closure0'0'post'return' __bor_self x _prod result
    /\ __bor_self.current = self /\ __bor_self.final = result_state)
    /\ unnest'0 self result_state
  
  function fn_mut_once'0 (self : closure0'1) (args : (UInt32.t, Seq.seq UInt32.t)) (res : UInt32.t) : ()
  
  axiom fn_mut_once'0_spec : forall self : closure0'1, args : (UInt32.t, Seq.seq UInt32.t), res : UInt32.t . [%#sops39] postcondition_once'0 self args res
  = (exists res_state : closure0'1 . postcondition_mut'0 self args res_state res /\ resolve'4 res_state)
  
  function unnest_trans'0 (self : closure0'1) (b : closure0'1) (c : closure0'1) : ()
  
  axiom unnest_trans'0_spec : forall self : closure0'1, b : closure0'1, c : closure0'1 . ([%#sops36] unnest'0 self b)
   -> ([%#sops37] unnest'0 b c)  -> ([%#sops38] unnest'0 self c)
  
  function unnest_refl'0 (self : closure0'1) : ()
  
  axiom unnest_refl'0_spec : forall self : closure0'1 . [%#sops35] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : closure0'1) (args : (UInt32.t, Seq.seq UInt32.t)) (res_state : closure0'1) (res : UInt32.t) : ()
  
  
  axiom postcondition_mut_unnest'0_spec : forall self : closure0'1, args : (UInt32.t, Seq.seq UInt32.t), res_state : closure0'1, res : UInt32.t . ([%#sops33] postcondition_mut'0 self args res_state res)
   -> ([%#sops34] unnest'0 self res_state)
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Slice64.slice UInt32.t) (ix : int) : UInt32.t =
    [%#sindex49] Seq.get (view'4 self) ix
  
  function to_ref_seq'0 (self : Slice64.slice UInt32.t) : Seq.seq UInt32.t
  
  axiom to_ref_seq'0_spec : forall self : Slice64.slice UInt32.t . ([%#sslice40] Seq.length (to_ref_seq'0 self)
  = Seq.length (view'1 self))
  && ([%#sslice41] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq'0 self)
   -> Seq.get (to_ref_seq'0 self) i = index_logic'0 self i)
  
  predicate produces'0 (self : t_Iter'0) (visited : Seq.seq UInt32.t) (tl : t_Iter'0) =
    [%#sslice24] to_ref_seq'0 (view'3 self) = Seq.(++) visited (to_ref_seq'0 (view'3 tl))
  
  function produces_trans'1 (a : t_Iter'0) (ab : Seq.seq UInt32.t) (b : t_Iter'0) (bc : Seq.seq UInt32.t) (c : t_Iter'0) : ()
  
   =
    [%#sslice23] ()
  
  axiom produces_trans'1_spec : forall a : t_Iter'0, ab : Seq.seq UInt32.t, b : t_Iter'0, bc : Seq.seq UInt32.t, c : t_Iter'0 . ([%#sslice20] produces'0 a ab b)
   -> ([%#sslice21] produces'0 b bc c)  -> ([%#sslice22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Iter'0) : () =
    [%#sslice19] ()
  
  axiom produces_refl'1_spec : forall self : t_Iter'0 . [%#sslice18] produces'0 self (Seq.empty : Seq.seq UInt32.t) self
  
  function produces_trans'0 (a : t_Iter'0) (ab : Seq.seq UInt32.t) (b : t_Iter'0) (bc : Seq.seq UInt32.t) (c : t_Iter'0) : ()
  
   =
    [%#sslice23] ()
  
  axiom produces_trans'0_spec : forall a : t_Iter'0, ab : Seq.seq UInt32.t, b : t_Iter'0, bc : Seq.seq UInt32.t, c : t_Iter'0 . ([%#sslice20] produces'0 a ab b)
   -> ([%#sslice21] produces'0 b bc c)  -> ([%#sslice22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Iter'0) : () =
    [%#sslice19] ()
  
  axiom produces_refl'0_spec : forall self : t_Iter'0 . [%#sslice18] produces'0 self (Seq.empty : Seq.seq UInt32.t) self
  
  type t_MapInv'0  =
    { t_MapInv__iter'0: t_Iter'0; t_MapInv__func'0: closure0'1; t_MapInv__produced'0: Seq.seq UInt32.t }
  
  predicate inv'2 (_1 : t_Iter'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Iter'0 [inv'2 x] . inv'2 x = true
  
  predicate inv'3 (_1 : closure0'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : closure0'1 [inv'3 x] . inv'3 x = true
  
  use seq.Seq
  
  predicate precondition'0 (self : closure0'1) (args : (UInt32.t, Seq.seq UInt32.t)) =
    let (x, _prod) = args in forall __bor_self : MutBorrow.t closure0'1 . __bor_self.current = self
     -> closure0'0'pre __bor_self x _prod
  
  predicate resolve'5 (self : MutBorrow.t t_Iter'0) =
    [%#sresolve32] self.final = self.current
  
  function view'5 (self : MutBorrow.t t_Iter'0) : Slice64.slice UInt32.t =
    [%#smodel50] view'3 self.current
  
  use seq.Seq
  
  predicate completed'1 (self : MutBorrow.t t_Iter'0) =
    [%#sslice42] resolve'5 self /\ view'4 (view'5 self) = (Seq.empty : Seq.seq UInt32.t)
  
  predicate next_precondition'0 (iter : t_Iter'0) (func : closure0'1) (produced : Seq.seq UInt32.t) =
    [%#smap_inv43] forall e : UInt32.t, i : t_Iter'0 . produces'0 iter (Seq.singleton e) i
     -> precondition'0 func (e, produced)
  
  use seq.Seq
  
  predicate preservation'0 (iter : t_Iter'0) (func : closure0'1) =
    [%#smap_inv26] forall s : Seq.seq UInt32.t, e1 : UInt32.t, e2 : UInt32.t, f : MutBorrow.t closure0'1, b : UInt32.t, i : t_Iter'0 . unnest'0 func f.current
     -> produces'0 iter (Seq.snoc (Seq.snoc s e1) e2) i
     -> precondition'0 f.current (e1, s)
     -> postcondition_mut'0 f.current (e1, s) f.final b  -> precondition'0 f.final (e2, Seq.snoc s e1)
  
  predicate reinitialize'0  =
    [%#smap_inv25] forall iter : MutBorrow.t t_Iter'0, func : closure0'1 . completed'1 iter
     -> next_precondition'0 iter.final func (Seq.empty : Seq.seq UInt32.t) /\ preservation'0 iter.final func
  
  predicate invariant'0 (self : t_MapInv'0)
  
  predicate inv'4 (_1 : t_MapInv'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_MapInv'0 [inv'4 x] . inv'4 x
  = (invariant'0 x
  /\ match x with
    | {t_MapInv__iter'0 = iter ; t_MapInv__func'0 = func ; t_MapInv__produced'0 = produced} -> true
    end)
  
  let rec map_inv'0 (self:t_Iter'0) (func:closure0'1) (return'  (ret:t_MapInv'0))= {[@expl:map_inv 'self' type invariant] [%#siter8] inv'2 self}
    {[@expl:map_inv 'func' type invariant] [%#siter9] inv'3 func}
    {[@expl:map_inv requires #0] [%#siter10] forall e : UInt32.t, i2 : t_Iter'0 . produces'0 self (Seq.singleton e) i2
     -> precondition'0 func (e, Seq.empty : Seq.seq UInt32.t)}
    {[@expl:map_inv requires #1] [%#siter11] reinitialize'0}
    {[@expl:map_inv requires #2] [%#siter12] preservation'0 self func}
    any
    [ return' (result:t_MapInv'0)-> {[%#siter13] inv'4 result}
      {[%#siter14] result
      = { t_MapInv__iter'0 = self; t_MapInv__func'0 = func; t_MapInv__produced'0 = Seq.empty : Seq.seq UInt32.t }}
      (! return' {result}) ]
  
  
  predicate inv'5 (_1 : t_Vec'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Vec'0 [inv'5 x] . inv'5 x = true
  
  predicate resolve'6 (_1 : t_Iter'0) =
    true
  
  predicate resolve'3 (self : t_MapInv'0) =
    [%#smap_inv44] resolve'6 self.t_MapInv__iter'0 /\ resolve'4 self.t_MapInv__func'0
  
  predicate resolve'1 (_1 : t_MapInv'0) =
    resolve'3 _1
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 [@inline:trivial] (self : t_MapInv'0) (visited : Seq.seq UInt32.t) (succ : t_MapInv'0) =
    [%#smap_inv28] unnest'0 self.t_MapInv__func'0 succ.t_MapInv__func'0
    /\ (exists fs : Seq.seq (MutBorrow.t closure0'1) . Seq.length fs = Seq.length visited
    /\ (exists s : Seq.seq UInt32.t . Seq.length s = Seq.length visited
    /\ produces'0 self.t_MapInv__iter'0 s succ.t_MapInv__iter'0
    /\ succ.t_MapInv__produced'0 = Seq.(++) self.t_MapInv__produced'0 s
    /\ (forall i : int . 1 <= i /\ i < Seq.length fs  -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
    /\ (if Seq.length visited = 0 then
      self.t_MapInv__func'0 = succ.t_MapInv__func'0
    else
      (Seq.get fs 0).current = self.t_MapInv__func'0
      /\ (Seq.get fs (Seq.length visited - 1)).final = succ.t_MapInv__func'0
    )
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> unnest'0 self.t_MapInv__func'0 (Seq.get fs i).current
    /\ precondition'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i))
    /\ postcondition_mut'0 (Seq.get fs i).current (Seq.get s i, Seq.(++) self.t_MapInv__produced'0 (Seq.([..]) s 0 i)) (Seq.get fs i).final (Seq.get visited i))))
  
  function produces_trans'2 (a : t_MapInv'0) (ab : Seq.seq UInt32.t) (b : t_MapInv'0) (bc : Seq.seq UInt32.t) (c : t_MapInv'0) : ()
  
  
  axiom produces_trans'2_spec : forall a : t_MapInv'0, ab : Seq.seq UInt32.t, b : t_MapInv'0, bc : Seq.seq UInt32.t, c : t_MapInv'0 . ([%#smap_inv46] produces'1 a ab b)
   -> ([%#smap_inv47] produces'1 b bc c)  -> ([%#smap_inv48] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'2 (self : t_MapInv'0) : ()
  
  axiom produces_refl'2_spec : forall self : t_MapInv'0 . [%#smap_inv45] produces'1 self (Seq.empty : Seq.seq UInt32.t) self
  
  predicate completed'0 (self : MutBorrow.t t_MapInv'0) =
    [%#smap_inv27] (self.final).t_MapInv__produced'0 = (Seq.empty : Seq.seq UInt32.t)
    /\ completed'1 (MutBorrow.borrow_logic (self.current).t_MapInv__iter'0 (self.final).t_MapInv__iter'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1))
    /\ (self.current).t_MapInv__func'0 = (self.final).t_MapInv__func'0
  
  predicate from_iter_post'0 (prod : Seq.seq UInt32.t) (res : t_Vec'0) =
    [%#svec29] prod = view'0 res
  
  let rec collect'0 (self:t_MapInv'0) (return'  (ret:t_Vec'0))= {[@expl:collect 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Vec'0)-> {inv'5 result}
      {[%#siter15] exists done' : MutBorrow.t t_MapInv'0, prod : Seq.seq UInt32.t . resolve'1 done'.final
      /\ completed'0 done' /\ produces'1 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  use seq.Seq
  
  meta "compute_max_steps" 1000000
  
  let rec counter'0[#"03_std_iterators.rs" 42 0 42 27] (v:t_Vec'0) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &cnt <- [%#s03_std_iterators0] (0 : UInt64.t) ] s1
      | s1 = deref'0 {v} (fun (_ret':Slice64.slice UInt32.t) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = iter'0 {_7} (fun (_ret':t_Iter'0) ->  [ &_5 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = MutBorrow.borrow_mut <UInt64.t> {cnt}
          (fun (_ret':MutBorrow.t UInt64.t) ->  [ &_10 <- _ret' ]  [ &cnt <- _ret'.final ] s1)
      | s1 =  [ &_9 <- { field_0'0 = _10 } ] s2
      | s2 = map_inv'0 {_5} {_9} (fun (_ret':t_MapInv'0) ->  [ &_4 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0 [ s0 = collect'0 {_4} (fun (_ret':t_Vec'0) ->  [ &x <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators1] Seq.length (view'0 x) = Seq.length (view'0 v)} s1 | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = {[@expl:assertion] [%#s03_std_iterators2] Seq.(==) (view'0 x) (view'0 v)} s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = {[@expl:assertion] [%#s03_std_iterators3] UInt64.t'int cnt = Seq.length (view'0 x)} s1 | s1 = bb7 ]
    
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & v : t_Vec'0 = v
    | & cnt : UInt64.t = Any.any_l ()
    | & x : t_Vec'0 = Any.any_l ()
    | & _4 : t_MapInv'0 = Any.any_l ()
    | & _5 : t_Iter'0 = Any.any_l ()
    | & _7 : Slice64.slice UInt32.t = Any.any_l ()
    | & _9 : closure0'1 = Any.any_l ()
    | & _10 : MutBorrow.t UInt64.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_03_std_iterators__sum_range [#"03_std_iterators.rs" 61 0 61 35]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 62 16 62 17
  let%span s03_std_iterators1 = "03_std_iterators.rs" 64 13 64 14
  let%span s03_std_iterators2 = "03_std_iterators.rs" 64 4 64 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 64 4 64 7
  let%span s03_std_iterators4 = "03_std_iterators.rs" 63 16 63 46
  let%span s03_std_iterators5 = "03_std_iterators.rs" 64 4 64 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 64 4 64 7
  let%span s03_std_iterators7 = "03_std_iterators.rs" 65 13 65 14
  let%span s03_std_iterators8 = "03_std_iterators.rs" 59 11 59 18
  let%span s03_std_iterators9 = "03_std_iterators.rs" 60 10 60 21
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span srange12 = "../../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  let%span siter13 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter15 = "../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span sord16 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord17 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord18 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord19 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord20 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord21 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord22 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span srange29 = "../../../creusot-contracts/src/std/iter/range.rs" 35 14 35 45
  let%span srange30 = "../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 32
  let%span srange31 = "../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 32
  let%span srange32 = "../../../creusot-contracts/src/std/iter/range.rs" 42 14 42 42
  let%span snum33 = "../../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span srange34 = "../../../creusot-contracts/src/std/iter/range.rs" 17 12 17 78
  let%span sresolve35 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sord36 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.Int64
  
  type t_Range'0  =
    { t_Range__start'0: Int64.t; t_Range__end'0: Int64.t }
  
  predicate inv'0 (_1 : t_Range'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Range'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Range'0) =
    [%#siter14] true
  
  predicate into_iter_post'0 (self : t_Range'0) (res : t_Range'0) =
    [%#siter15] self = res
  
  let rec into_iter'0 (self:t_Range'0) (return'  (ret:t_Range'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter10] into_iter_pre'0 self}
    any [ return' (result:t_Range'0)-> {inv'0 result} {[%#siter11] into_iter_post'0 self result} (! return' {result}) ] 
  
  use seq.Seq
  
  use seq.Seq
  
  use creusot.int.Int64
  
  use seq.Seq
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.Int64
  
  function cmp_log'0 (self : Int64.t) (o : Int64.t) : t_Ordering'0 =
    [%#sord36] if Int64.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom eq_cmp'0_spec : forall x : Int64.t, y : Int64.t . [%#sord28] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom antisym2'0_spec : forall x : Int64.t, y : Int64.t . ([%#sord26] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord27] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom antisym1'0_spec : forall x : Int64.t, y : Int64.t . ([%#sord24] cmp_log'0 x y = C_Less'0)
   -> ([%#sord25] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : Int64.t) (y : Int64.t) (z : Int64.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : Int64.t, y : Int64.t, z : Int64.t, o : t_Ordering'0 . ([%#sord21] cmp_log'0 x y = o)
   -> ([%#sord22] cmp_log'0 y z = o)  -> ([%#sord23] cmp_log'0 x z = o)
  
  function refl'0 (x : Int64.t) : ()
  
  axiom refl'0_spec : forall x : Int64.t . [%#sord20] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.Int64
  
  function cmp_gt_log'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : Int64.t, y : Int64.t . [%#sord19] Int64.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.Int64
  
  function cmp_ge_log'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : Int64.t, y : Int64.t . [%#sord18] Int64.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : Int64.t, y : Int64.t . [%#sord17] Int64.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.Int64
  
  function cmp_le_log'0 (x : Int64.t) (y : Int64.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : Int64.t, y : Int64.t . [%#sord16] Int64.le x y = (cmp_log'0 x y <> C_Greater'0)
  
  use seq.Seq
  
  function deep_model'0 (self : Int64.t) : int =
    [%#snum33] Int64.to_int self
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate produces'0 (self : t_Range'0) (visited : Seq.seq Int64.t) (o : t_Range'0) =
    [%#srange12] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  function produces_trans'0 (a : t_Range'0) (ab : Seq.seq Int64.t) (b : t_Range'0) (bc : Seq.seq Int64.t) (c : t_Range'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Range'0, ab : Seq.seq Int64.t, b : t_Range'0, bc : Seq.seq Int64.t, c : t_Range'0 . ([%#srange30] produces'0 a ab b)
   -> ([%#srange31] produces'0 b bc c)  -> ([%#srange32] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Range'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Range'0 . [%#srange29] produces'0 self (Seq.empty : Seq.seq Int64.t) self
  
  predicate inv'1 (_1 : Seq.seq Int64.t)
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq Int64.t [inv'1 x] . inv'1 x = true
  
  use creusot.prelude.MutBorrow
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int64.t
  
  predicate inv'2 (_1 : MutBorrow.t t_Range'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Range'0 [inv'2 x] . inv'2 x = true
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x = true
  
  predicate resolve'1 (self : MutBorrow.t t_Range'0) =
    [%#sresolve35] self.final = self.current
  
  predicate completed'0 (self : MutBorrow.t t_Range'0) =
    [%#srange34] resolve'1 self
    /\ deep_model'0 (self.current).t_Range__start'0 >= deep_model'0 (self.current).t_Range__end'0
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_Range'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_Option'0)-> {inv'3 result}
      {[%#siter13] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_1 : MutBorrow.t t_Range'0) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:Int64.t))= any
    [ good (field_0:Int64.t)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : Int64.t [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec sum_range'0[#"03_std_iterators.rs" 61 0 61 35] (n:Int64.t) (return'  (ret:Int64.t))= {[@expl:sum_range requires] [%#s03_std_iterators8] Int64.to_int n
    >= 0}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &i <- [%#s03_std_iterators0] (0 : Int64.t) ] s1
      | s1 =  [ &_7 <- { t_Range__start'0 = ([%#s03_std_iterators1] (0 : Int64.t)); t_Range__end'0 = n } ] s2
      | s2 = into_iter'0 {_7} (fun (_ret':t_Range'0) ->  [ &iter <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators2] iter ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators3] Seq.empty : Seq.seq Int64.t ] s1 | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = bb4
      [ bb4 = {[@expl:for invariant] [%#s03_std_iterators5] inv'1 produced}
        {[@expl:for invariant] [%#s03_std_iterators5] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators5] produces'0 iter_old produced iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] Int64.to_int i = Seq.length produced /\ Int64.le i n}
        (! s0) [ s0 = bb5 ] 
        [ bb5 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range'0> {iter}
              (fun (_ret':MutBorrow.t t_Range'0) ->  [ &_21 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Range'0> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret':MutBorrow.t t_Range'0) ->
                 [ &_20 <- _ret' ] 
                 [ &_21 <- { _21 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_20} (fun (_ret':t_Option'0) ->  [ &_19 <- _ret' ] s3)
          | s3 = bb6 ]
        
        | bb6 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = any [ br0 -> {_19 = C_None'0} (! bb9) | br1 (x0:Int64.t)-> {_19 = C_Some'0 x0} (! bb8) ]  ]
        
        | bb8 = bb10
        | bb10 = s0
          [ s0 = v_Some'0 {_19} (fun (r0'0:Int64.t) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 =  [ &_24 <- [%#s03_std_iterators6] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb11 ]
        
        | bb11 = s0
          [ s0 =  [ &produced <- _24 ] s1
          | s1 = Int64.add {i} {[%#s03_std_iterators7] (1 : Int64.t)} (fun (_ret':Int64.t) ->  [ &i <- _ret' ] s2)
          | s2 = bb4 ]
         ]
       ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- i ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : Int64.t = Any.any_l ()
    | & n : Int64.t = n
    | & i : Int64.t = Any.any_l ()
    | & iter : t_Range'0 = Any.any_l ()
    | & _7 : t_Range'0 = Any.any_l ()
    | & iter_old : t_Range'0 = Any.any_l ()
    | & produced : Seq.seq Int64.t = Any.any_l ()
    | & _19 : t_Option'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Range'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Range'0 = Any.any_l ()
    | & __creusot_proc_iter_elem : Int64.t = Any.any_l ()
    | & _24 : Seq.seq Int64.t = Any.any_l () ]
     [ return' (result:Int64.t)-> {[@expl:sum_range ensures] [%#s03_std_iterators9] result = n} (! return' {result}) ] 
end
module M_03_std_iterators__enumerate_range [#"03_std_iterators.rs" 70 0 70 24]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 72 20 72 21
  let%span s03_std_iterators1 = "03_std_iterators.rs" 72 23 72 25
  let%span s03_std_iterators2 = "03_std_iterators.rs" 72 4 72 7
  let%span s03_std_iterators3 = "03_std_iterators.rs" 72 4 72 7
  let%span s03_std_iterators4 = "03_std_iterators.rs" 71 16 71 93
  let%span s03_std_iterators5 = "03_std_iterators.rs" 72 4 72 7
  let%span s03_std_iterators6 = "03_std_iterators.rs" 72 4 72 7
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 176 27 176 99
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 177 27 177 115
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 178 26 178 66
  let%span siter10 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter11 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span sindex12 = "../../../creusot-contracts/src/logic/ops/index.rs" 96 8 96 33
  let%span senumerate13 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 72 12 76 113
  let%span siter14 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span srange15 = "../../../creusot-contracts/src/std/iter/range.rs" 17 12 17 78
  let%span srange16 = "../../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  let%span senumerate17 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 14 14 14 39
  let%span siter18 = "../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span siter19 = "../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span senumerate20 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 82 14 82 45
  let%span senumerate21 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 87 15 87 32
  let%span senumerate22 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 88 15 88 32
  let%span senumerate23 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 89 14 89 42
  let%span senumerate24 = "../../../creusot-contracts/src/std/iter/enumerate.rs" 62 12 64 42
  let%span sresolve25 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span srange26 = "../../../creusot-contracts/src/std/iter/range.rs" 35 14 35 45
  let%span srange27 = "../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 32
  let%span srange28 = "../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 32
  let%span srange29 = "../../../creusot-contracts/src/std/iter/range.rs" 42 14 42 42
  let%span snum30 = "../../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span sinvariant31 = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.int.UInt64
  
  type t_Range'0  =
    { t_Range__start'0: UInt64.t; t_Range__end'0: UInt64.t }
  
  type t_Enumerate'0  =
    { t_Enumerate__iter'0: t_Range'0; t_Enumerate__count'0: UInt64.t }
  
  predicate inv'3 (_1 : t_Range'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Range'0 [inv'3 x] . inv'3 x = true
  
  use creusot.prelude.MutBorrow
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  function deep_model'0 (self : UInt64.t) : int =
    [%#snum30] UInt64.t'int self
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 (self : t_Range'0) (visited : Seq.seq UInt64.t) (o : t_Range'0) =
    [%#srange16] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  function produces_trans'1 (a : t_Range'0) (ab : Seq.seq UInt64.t) (b : t_Range'0) (bc : Seq.seq UInt64.t) (c : t_Range'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_Range'0, ab : Seq.seq UInt64.t, b : t_Range'0, bc : Seq.seq UInt64.t, c : t_Range'0 . ([%#srange27] produces'1 a ab b)
   -> ([%#srange28] produces'1 b bc c)  -> ([%#srange29] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Range'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_Range'0 . [%#srange26] produces'1 self (Seq.empty : Seq.seq UInt64.t) self
  
  predicate resolve'2 (self : MutBorrow.t t_Range'0) =
    [%#sresolve25] self.final = self.current
  
  predicate completed'0 (self : MutBorrow.t t_Range'0) =
    [%#srange15] resolve'2 self
    /\ deep_model'0 (self.current).t_Range__start'0 >= deep_model'0 (self.current).t_Range__end'0
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  predicate invariant'0 (self : t_Enumerate'0)
  
  predicate inv'0 (_1 : t_Enumerate'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Enumerate'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Enumerate__iter'0 = iter ; t_Enumerate__count'0 = count} -> true
    end)
  
  function iter'0 (self : t_Enumerate'0) : t_Range'0
  
  axiom iter'0_spec : forall self : t_Enumerate'0 . [%#senumerate17] inv'0 self  -> inv'3 (iter'0 self)
  
  function n'0 (self : t_Enumerate'0) : int
  
  let rec enumerate'0 (self:t_Range'0) (return'  (ret:t_Enumerate'0))= {[@expl:enumerate 'self' type invariant] inv'3 self}
    {[@expl:enumerate requires #0] [%#siter7] forall i : MutBorrow.t t_Range'0 . completed'0 i
     -> produces'1 i.current (Seq.empty : Seq.seq UInt64.t) i.final}
    {[@expl:enumerate requires #1] [%#siter8] forall s : Seq.seq UInt64.t, i : t_Range'0 . produces'1 self s i
     -> Seq.length s < UInt64.t'int v_MAX'0}
    any
    [ return' (result:t_Enumerate'0)-> {inv'0 result}
      {[%#siter9] iter'0 result = self /\ n'0 result = 0}
      (! return' {result}) ]
  
  
  predicate into_iter_pre'0 (self : t_Enumerate'0) =
    [%#siter18] true
  
  predicate into_iter_post'0 (self : t_Enumerate'0) (res : t_Enumerate'0) =
    [%#siter19] self = res
  
  let rec into_iter'0 (self:t_Enumerate'0) (return'  (ret:t_Enumerate'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter10] into_iter_pre'0 self}
    any
    [ return' (result:t_Enumerate'0)-> {inv'0 result} {[%#siter11] into_iter_post'0 self result} (! return' {result}) ]
  
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Seq.seq (UInt64.t, UInt64.t)) (ix : int) : (UInt64.t, UInt64.t) =
    [%#sindex12] Seq.get self ix
  
  use seq.Seq
  
  predicate produces'0 (self : t_Enumerate'0) (visited : Seq.seq (UInt64.t, UInt64.t)) (o : t_Enumerate'0) =
    [%#senumerate13] Seq.length visited = n'0 o - n'0 self
    /\ (exists s : Seq.seq UInt64.t . produces'1 (iter'0 self) s (iter'0 o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> UInt64.t'int (let (a, _) = Seq.get visited i in a) = n'0 self + i
    /\ (let (_, a) = Seq.get visited i in a) = Seq.get s i))
  
  function produces_trans'0 (a : t_Enumerate'0) (ab : Seq.seq (UInt64.t, UInt64.t)) (b : t_Enumerate'0) (bc : Seq.seq (UInt64.t, UInt64.t)) (c : t_Enumerate'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Enumerate'0, ab : Seq.seq (UInt64.t, UInt64.t), b : t_Enumerate'0, bc : Seq.seq (UInt64.t, UInt64.t), c : t_Enumerate'0 . ([%#senumerate21] produces'0 a ab b)
   -> ([%#senumerate22] produces'0 b bc c)  -> ([%#senumerate23] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Enumerate'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Enumerate'0 . [%#senumerate20] produces'0 self (Seq.empty : Seq.seq (UInt64.t, UInt64.t)) self
  
  predicate inv'1 (_1 : Seq.seq (UInt64.t, UInt64.t))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (UInt64.t, UInt64.t) [inv'1 x] . inv'1 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (UInt64.t, UInt64.t)
  
  predicate invariant'1 (self : MutBorrow.t t_Enumerate'0) =
    [%#sinvariant31] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Enumerate'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Enumerate'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x = true
  
  predicate completed'1 (self : MutBorrow.t t_Enumerate'0) =
    [%#senumerate24] exists inner : MutBorrow.t t_Range'0 . inner.current = iter'0 self.current
    /\ inner.final = iter'0 self.final /\ completed'0 inner /\ n'0 self.current = n'0 self.final
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_Enumerate'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'2 self}
    any
    [ return' (result:t_Option'0)-> {inv'4 result}
      {[%#siter14] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_Enumerate'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Enumerate'0) =
    resolve'1 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:(UInt64.t, UInt64.t)))= any
    [ good (field_0:(UInt64.t, UInt64.t))-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : (UInt64.t, UInt64.t) [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec enumerate_range'0[#"03_std_iterators.rs" 70 0 70 24] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = 
        [ &_3 <- { t_Range__start'0 = ([%#s03_std_iterators0] (0 : UInt64.t));
                   t_Range__end'0 = ([%#s03_std_iterators1] (10 : UInt64.t)) } ]
        
        s1
      | s1 = enumerate'0 {_3} (fun (_ret':t_Enumerate'0) ->  [ &_2 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = into_iter'0 {_2} (fun (_ret':t_Enumerate'0) ->  [ &iter <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators2] iter ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators3] Seq.empty : Seq.seq (UInt64.t, UInt64.t) ] s1 | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = bb5
      [ bb5 = {[@expl:for invariant] [%#s03_std_iterators5] inv'1 produced}
        {[@expl:for invariant] [%#s03_std_iterators5] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators5] produces'0 iter_old produced iter}
        {[@expl:loop invariant] [%#s03_std_iterators4] forall i : int . 0 <= i /\ i < Seq.length produced
         -> (let (a, _) = index_logic'0 produced i in a) = (let (_, a) = index_logic'0 produced i in a)}
        (! s0) [ s0 = bb6 ] 
        [ bb6 = s0
          [ s0 = {inv'0 iter}
            MutBorrow.borrow_mut <t_Enumerate'0> {iter}
              (fun (_ret':MutBorrow.t t_Enumerate'0) ->
                 [ &_16 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &iter <- _ret'.final ] 
                s1)
          | s1 = {inv'0 _16.current}
            MutBorrow.borrow_final <t_Enumerate'0> {_16.current} {MutBorrow.get_id _16}
              (fun (_ret':MutBorrow.t t_Enumerate'0) ->
                 [ &_15 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_16 <- { _16 with current = _ret'.final } ] 
                s2)
          | s2 = next'0 {_15} (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s3)
          | s3 = bb7 ]
        
        | bb7 = s0
          [ s0 = {[@expl:type invariant] inv'2 _16} s1
          | s1 = -{resolve'0 _16}- s2
          | s2 = any
            [ br0 -> {_14 = C_None'0} (! bb10) | br1 (x0:(UInt64.t, UInt64.t))-> {_14 = C_Some'0 x0} (! bb9) ]
           ]
        
        | bb9 = bb11
        | bb11 = s0
          [ s0 = v_Some'0 {_14} (fun (r0'0:(UInt64.t, UInt64.t)) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 =  [ &_19 <- [%#s03_std_iterators6] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb12 ]
        
        | bb12 = s0
          [ s0 =  [ &produced <- _19 ] s1
          | s1 =  [ &ix <- let (r'0, _) = __creusot_proc_iter_elem in r'0 ] s2
          | s2 =  [ &x <- let (_, r'1) = __creusot_proc_iter_elem in r'1 ] s3
          | s3 = bb5 ]
         ]
       ]
    
    | bb10 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & iter : t_Enumerate'0 = Any.any_l ()
    | & _2 : t_Enumerate'0 = Any.any_l ()
    | & _3 : t_Range'0 = Any.any_l ()
    | & iter_old : t_Enumerate'0 = Any.any_l ()
    | & produced : Seq.seq (UInt64.t, UInt64.t) = Any.any_l ()
    | & _14 : t_Option'0 = Any.any_l ()
    | & _15 : MutBorrow.t t_Enumerate'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_Enumerate'0 = Any.any_l ()
    | & __creusot_proc_iter_elem : (UInt64.t, UInt64.t) = Any.any_l ()
    | & _19 : Seq.seq (UInt64.t, UInt64.t) = Any.any_l ()
    | & ix : UInt64.t = Any.any_l ()
    | & x : UInt64.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_03_std_iterators__my_reverse [#"03_std_iterators.rs" 92 0 92 37]
  let%span s03_std_iterators0 = "03_std_iterators.rs" 94 34 94 54
  let%span s03_std_iterators1 = "03_std_iterators.rs" 99 26 99 27
  let%span s03_std_iterators2 = "03_std_iterators.rs" 99 22 99 27
  let%span s03_std_iterators3 = "03_std_iterators.rs" 99 19 99 20
  let%span s03_std_iterators4 = "03_std_iterators.rs" 99 40 99 41
  let%span s03_std_iterators5 = "03_std_iterators.rs" 99 36 99 41
  let%span s03_std_iterators6 = "03_std_iterators.rs" 99 33 99 34
  let%span s03_std_iterators7 = "03_std_iterators.rs" 99 4 99 7
  let%span s03_std_iterators8 = "03_std_iterators.rs" 99 4 99 7
  let%span s03_std_iterators9 = "03_std_iterators.rs" 98 16 98 80
  let%span s03_std_iterators10 = "03_std_iterators.rs" 97 16 97 76
  let%span s03_std_iterators11 = "03_std_iterators.rs" 96 16 96 78
  let%span s03_std_iterators12 = "03_std_iterators.rs" 95 16 95 34
  let%span s03_std_iterators13 = "03_std_iterators.rs" 99 4 99 7
  let%span s03_std_iterators14 = "03_std_iterators.rs" 99 4 99 7
  let%span s03_std_iterators15 = "03_std_iterators.rs" 100 30 100 31
  let%span s03_std_iterators16 = "03_std_iterators.rs" 101 22 101 28
  let%span s03_std_iterators17 = "03_std_iterators.rs" 102 22 102 54
  let%span s03_std_iterators18 = "03_std_iterators.rs" 103 22 103 54
  let%span s03_std_iterators19 = "03_std_iterators.rs" 92 21 92 26
  let%span s03_std_iterators20 = "03_std_iterators.rs" 91 10 91 44
  let%span sslice21 = "../../../creusot-contracts/src/std/slice.rs" 254 18 254 40
  let%span smodel22 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span siter23 = "../../../creusot-contracts/src/std/iter.rs" 185 27 185 48
  let%span siter24 = "../../../creusot-contracts/src/std/iter.rs" 186 26 186 48
  let%span siter25 = "../../../creusot-contracts/src/std/iter.rs" 187 26 187 62
  let%span siter26 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter27 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span s03_std_iterators28 = "03_std_iterators.rs" 87 8 87 60
  let%span s03_std_iterators29 = "03_std_iterators.rs" 80 8 80 58
  let%span szip30 = "../../../creusot-contracts/src/std/iter/zip.rs" 46 12 49 95
  let%span siter31 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span sslice32 = "../../../creusot-contracts/src/std/slice.rs" 258 19 258 35
  let%span sslice33 = "../../../creusot-contracts/src/std/slice.rs" 259 19 259 35
  let%span sslice34 = "../../../creusot-contracts/src/std/slice.rs" 260 18 260 50
  let%span sindex35 = "../../../creusot-contracts/src/logic/ops/index.rs" 96 8 96 33
  let%span sslice36 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice37 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span smodel38 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span siter39 = "../../../creusot-contracts/src/std/iter.rs" 86 20 86 24
  let%span szip40 = "../../../creusot-contracts/src/std/iter/zip.rs" 14 14 14 39
  let%span siter41 = "../../../creusot-contracts/src/std/iter.rs" 92 8 92 19
  let%span szip42 = "../../../creusot-contracts/src/std/iter/zip.rs" 21 14 21 39
  let%span szip43 = "../../../creusot-contracts/src/std/iter/zip.rs" 55 14 55 45
  let%span szip44 = "../../../creusot-contracts/src/std/iter/zip.rs" 60 15 60 32
  let%span szip45 = "../../../creusot-contracts/src/std/iter/zip.rs" 61 15 61 32
  let%span szip46 = "../../../creusot-contracts/src/std/iter/zip.rs" 62 14 62 42
  let%span srange47 = "../../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  let%span szip48 = "../../../creusot-contracts/src/std/iter/zip.rs" 32 12 37 74
  let%span sresolve49 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span srange50 = "../../../creusot-contracts/src/std/iter/range.rs" 35 14 35 45
  let%span srange51 = "../../../creusot-contracts/src/std/iter/range.rs" 40 15 40 32
  let%span srange52 = "../../../creusot-contracts/src/std/iter/range.rs" 41 15 41 32
  let%span srange53 = "../../../creusot-contracts/src/std/iter/range.rs" 42 14 42 42
  let%span snum54 = "../../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span srange55 = "../../../creusot-contracts/src/std/iter/range.rs" 17 12 17 78
  let%span sslice56 = "../../../creusot-contracts/src/std/slice.rs" 17 20 17 30
  let%span sinvariant57 = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant58 = "../../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sseq59 = "../../../creusot-contracts/src/logic/seq.rs" 629 20 629 95
  let%span sboxed60 = "../../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.slice.Slice64
  
  type t_T'0
  
  use creusot.int.UInt64
  
  use seq.Seq
  
  use mach.int.Int
  
  use seq.Seq
  
  predicate inv'11 (_1 : t_T'0)
  
  predicate invariant'4 (self : t_T'0) =
    [%#sboxed60] inv'11 self
  
  predicate inv'10 (_1 : t_T'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_T'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  use seq.Seq
  
  predicate invariant'3 (self : Seq.seq t_T'0) =
    [%#sseq59] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'10 (Seq.get self i)
  
  predicate inv'9 (_1 : Seq.seq t_T'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : Seq.seq t_T'0 [inv'9 x] . inv'9 x = invariant'3 x
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use creusot.slice.Slice64
  
  function view'1 (self : Slice64.slice t_T'0) : Seq.seq t_T'0
  
  axiom view'1_spec : forall self : Slice64.slice t_T'0 . ([%#sslice36] Seq.length (view'1 self)
  <= UInt64.t'int (v_MAX'0 : UInt64.t))
  && ([%#sslice37] view'1 self = Slice64.id self)
  
  predicate invariant'0 (self : Slice64.slice t_T'0) =
    [%#sslice56] inv'9 (view'1 self)
  
  predicate inv'2 (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate invariant'2 (self : Slice64.slice t_T'0) =
    [%#sinvariant58] inv'2 self
  
  predicate inv'4 (_1 : Slice64.slice t_T'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Slice64.slice t_T'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  function view'2 (self : Slice64.slice t_T'0) : Seq.seq t_T'0 =
    [%#smodel38] view'1 self
  
  let rec len'0 (self:Slice64.slice t_T'0) (return'  (ret:UInt64.t))= {[@expl:len 'self' type invariant] inv'4 self}
    any
    [ return' (result:UInt64.t)-> {[%#sslice21] Seq.length (view'2 self) = UInt64.t'int result} (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  function view'0 (self : MutBorrow.t (Slice64.slice t_T'0)) : Seq.seq t_T'0 =
    [%#smodel22] view'1 self.current
  
  type t_Range'0  =
    { t_Range__start'0: UInt64.t; t_Range__end'0: UInt64.t }
  
  type t_Zip'0  =
    { t_Zip__a'0: t_Range'0;
      t_Zip__b'0: t_Range'0;
      t_Zip__index'0: UInt64.t;
      t_Zip__len'0: UInt64.t;
      t_Zip__a_len'0: UInt64.t }
  
  predicate inv'5 (_1 : t_Range'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Range'0 [inv'5 x] . inv'5 x = true
  
  predicate into_iter_pre'0 (self : t_Range'0) =
    [%#siter39] true
  
  predicate inv'0 (_1 : t_Zip'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Zip'0 [inv'0 x] . inv'0 x = true
  
  function itera'0 (self : t_Zip'0) : t_Range'0
  
  axiom itera'0_spec : forall self : t_Zip'0 . [%#szip40] inv'0 self  -> inv'5 (itera'0 self)
  
  predicate into_iter_post'0 (self : t_Range'0) (res : t_Range'0) =
    [%#siter41] self = res
  
  function iterb'0 (self : t_Zip'0) : t_Range'0
  
  axiom iterb'0_spec : forall self : t_Zip'0 . [%#szip42] inv'0 self  -> inv'5 (iterb'0 self)
  
  let rec zip'0 (self:t_Range'0) (other:t_Range'0) (return'  (ret:t_Zip'0))= {[@expl:zip 'self' type invariant] inv'5 self}
    {[@expl:zip 'other' type invariant] inv'5 other}
    {[@expl:zip requires] [%#siter23] into_iter_pre'0 other}
    any
    [ return' (result:t_Zip'0)-> {inv'0 result}
      {[%#siter24] itera'0 result = self}
      {[%#siter25] into_iter_post'0 other (iterb'0 result)}
      (! return' {result}) ]
  
  
  predicate into_iter_pre'1 (self : t_Zip'0) =
    [%#siter39] true
  
  predicate into_iter_post'1 (self : t_Zip'0) (res : t_Zip'0) =
    [%#siter41] self = res
  
  let rec into_iter'0 (self:t_Zip'0) (return'  (ret:t_Zip'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter26] into_iter_pre'1 self}
    any [ return' (result:t_Zip'0)-> {inv'0 result} {[%#siter27] into_iter_post'1 self result} (! return' {result}) ] 
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  predicate equiv_reverse_range'0 [#"03_std_iterators.rs" 85 0 85 81] (s1 : Seq.seq t_T'0) (s2 : Seq.seq t_T'0) (l : int) (u : int) (n : int)
  
   =
    [%#s03_std_iterators28] forall i : int . l <= i /\ i < u  -> Seq.get s1 i = Seq.get s2 (n - i)
  
  use seq.Seq
  
  predicate equiv_range'0 [#"03_std_iterators.rs" 78 0 78 65] (s1 : Seq.seq t_T'0) (s2 : Seq.seq t_T'0) (l : int) (u : int)
  
   =
    [%#s03_std_iterators29] forall i : int . l <= i /\ i < u  -> Seq.get s1 i = Seq.get s2 i
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  use seq.Seq
  
  function deep_model'0 (self : UInt64.t) : int =
    [%#snum54] UInt64.t'int self
  
  predicate produces'1 (self : t_Range'0) (visited : Seq.seq UInt64.t) (o : t_Range'0) =
    [%#srange47] self.t_Range__end'0 = o.t_Range__end'0
    /\ deep_model'0 self.t_Range__start'0 <= deep_model'0 o.t_Range__start'0
    /\ (Seq.length visited > 0  -> deep_model'0 o.t_Range__start'0 <= deep_model'0 o.t_Range__end'0)
    /\ Seq.length visited = deep_model'0 o.t_Range__start'0 - deep_model'0 self.t_Range__start'0
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> deep_model'0 (Seq.get visited i) = deep_model'0 self.t_Range__start'0 + i)
  
  function produces_trans'1 (a : t_Range'0) (ab : Seq.seq UInt64.t) (b : t_Range'0) (bc : Seq.seq UInt64.t) (c : t_Range'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_Range'0, ab : Seq.seq UInt64.t, b : t_Range'0, bc : Seq.seq UInt64.t, c : t_Range'0 . ([%#srange51] produces'1 a ab b)
   -> ([%#srange52] produces'1 b bc c)  -> ([%#srange53] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_Range'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_Range'0 . [%#srange50] produces'1 self (Seq.empty : Seq.seq UInt64.t) self
  
  predicate produces'0 (self : t_Zip'0) (visited : Seq.seq (UInt64.t, UInt64.t)) (o : t_Zip'0) =
    [%#szip30] exists p1 : Seq.seq UInt64.t, p2 : Seq.seq UInt64.t . Seq.length p1 = Seq.length p2
    /\ Seq.length p2 = Seq.length visited
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = (Seq.get p1 i, Seq.get p2 i))
    /\ produces'1 (itera'0 self) p1 (itera'0 o) /\ produces'1 (iterb'0 self) p2 (iterb'0 o)
  
  function produces_trans'0 (a : t_Zip'0) (ab : Seq.seq (UInt64.t, UInt64.t)) (b : t_Zip'0) (bc : Seq.seq (UInt64.t, UInt64.t)) (c : t_Zip'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Zip'0, ab : Seq.seq (UInt64.t, UInt64.t), b : t_Zip'0, bc : Seq.seq (UInt64.t, UInt64.t), c : t_Zip'0 . ([%#szip44] produces'0 a ab b)
   -> ([%#szip45] produces'0 b bc c)  -> ([%#szip46] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Zip'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Zip'0 . [%#szip43] produces'0 self (Seq.empty : Seq.seq (UInt64.t, UInt64.t)) self
  
  predicate inv'1 (_1 : Seq.seq (UInt64.t, UInt64.t))
  
  axiom inv_axiom'1 [@rewrite] : forall x : Seq.seq (UInt64.t, UInt64.t) [inv'1 x] . inv'1 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (UInt64.t, UInt64.t)
  
  predicate inv'6 (_1 : MutBorrow.t t_Zip'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_Zip'0 [inv'6 x] . inv'6 x = true
  
  predicate inv'7 (_1 : t_Option'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Option'0 [inv'7 x] . inv'7 x = true
  
  predicate resolve'6 (self : MutBorrow.t t_Range'0) =
    [%#sresolve49] self.final = self.current
  
  predicate completed'1 (self : MutBorrow.t t_Range'0) =
    [%#srange55] resolve'6 self
    /\ deep_model'0 (self.current).t_Range__start'0 >= deep_model'0 (self.current).t_Range__end'0
  
  predicate resolve'4 (_1 : MutBorrow.t t_Range'0) =
    resolve'6 _1
  
  predicate inv'8 (_1 : UInt64.t)
  
  axiom inv_axiom'8 [@rewrite] : forall x : UInt64.t [inv'8 x] . inv'8 x = true
  
  use seq.Seq
  
  predicate resolve'5 (_1 : UInt64.t) =
    true
  
  predicate completed'0 (self : MutBorrow.t t_Zip'0) =
    [%#szip48] exists a : MutBorrow.t t_Range'0, b : MutBorrow.t t_Range'0 . a.current = itera'0 self.current
    /\ b.current = iterb'0 self.current
    /\ a.final = itera'0 self.final
    /\ b.final = iterb'0 self.final
    /\ (completed'1 a /\ resolve'4 b
    \/ (exists x : UInt64.t . inv'8 x
    /\ produces'1 a.current (Seq.singleton x) a.final /\ resolve'5 x /\ completed'1 b))
  
  use seq.Seq
  
  let rec next'0 (self:MutBorrow.t t_Zip'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] inv'6 self}
    any
    [ return' (result:t_Option'0)-> {inv'7 result}
      {[%#siter31] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'2 (self : MutBorrow.t t_Zip'0) =
    [%#sresolve49] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Zip'0) =
    resolve'2 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:(UInt64.t, UInt64.t)))= any
    [ good (field_0:(UInt64.t, UInt64.t))-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : (UInt64.t, UInt64.t) [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate invariant'1 (self : MutBorrow.t (Slice64.slice t_T'0)) =
    [%#sinvariant57] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : MutBorrow.t (Slice64.slice t_T'0))
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t (Slice64.slice t_T'0) [inv'3 x] . inv'3 x = invariant'1 x
  
  use seq.Permut
  
  let rec swap'0 (self:MutBorrow.t (Slice64.slice t_T'0)) (a:UInt64.t) (b:UInt64.t) (return'  (ret:()))= {[@expl:swap 'self' type invariant] inv'3 self}
    {[@expl:swap requires #0] [%#sslice32] UInt64.t'int a < Seq.length (view'0 self)}
    {[@expl:swap requires #1] [%#sslice33] UInt64.t'int b < Seq.length (view'0 self)}
    any
    [ return' (result:())-> {[%#sslice34] Permut.exchange (view'1 self.final) (view'0 self) (UInt64.t'int a) (UInt64.t'int b)}
      (! return' {result}) ]
  
  
  function index_logic'0 [@inline:trivial] (self : Seq.seq t_T'0) (ix : int) : t_T'0 =
    [%#sindex35] Seq.get self ix
  
  predicate resolve'3 (self : MutBorrow.t (Slice64.slice t_T'0)) =
    [%#sresolve49] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t (Slice64.slice t_T'0)) =
    resolve'3 _1
  
  use creusot.prelude.Any
  
  use seq.Seq
  
  use seq.Reverse
  
  meta "compute_max_steps" 1000000
  
  let rec my_reverse'0[#"03_std_iterators.rs" 92 0 92 37] (slice:MutBorrow.t (Slice64.slice t_T'0)) (return'  (ret:()))= {[@expl:my_reverse 'slice' type invariant] [%#s03_std_iterators19] inv'3 slice}
    (! bb0
    [ bb0 = s0 [ s0 = len'0 {slice.current} (fun (_ret':UInt64.t) ->  [ &n <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &old_v <- [%#s03_std_iterators0] view'0 slice ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- ([%#s03_std_iterators1] (2 : UInt64.t)) = ([%#s03_std_iterators2] (0 : UInt64.t)) ] s1
      | s1 = {[@expl:division by zero] [%#s03_std_iterators2] not _12} s2
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = UInt64.div {n} {[%#s03_std_iterators1] (2 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_10 <- _ret' ] s1)
      | s1 =  [ &_9 <- { t_Range__start'0 = ([%#s03_std_iterators3] (0 : UInt64.t)); t_Range__end'0 = _10 } ] s2
      | s2 =  [ &_16 <- ([%#s03_std_iterators4] (2 : UInt64.t)) = ([%#s03_std_iterators5] (0 : UInt64.t)) ] s3
      | s3 = {[@expl:division by zero] [%#s03_std_iterators5] not _16} s4
      | s4 = bb4 ]
    
    | bb4 = s0
      [ s0 = UInt64.div {n} {[%#s03_std_iterators4] (2 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_14 <- _ret' ] s1)
      | s1 =  [ &_13 <- { t_Range__start'0 = ([%#s03_std_iterators6] (0 : UInt64.t)); t_Range__end'0 = _14 } ] s2
      | s2 = zip'0 {_9} {_13} (fun (_ret':t_Zip'0) ->  [ &_8 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0 [ s0 = into_iter'0 {_8} (fun (_ret':t_Zip'0) ->  [ &iter <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &iter_old <- [%#s03_std_iterators7] iter ] s1 | s1 = bb7 ] 
    | bb7 = s0 [ s0 =  [ &produced <- [%#s03_std_iterators8] Seq.empty : Seq.seq (UInt64.t, UInt64.t) ] s1 | s1 = bb8 ] 
    | bb8 = s0 [ s0 =  [ &old_9_0 <- slice ] s1 | s1 = bb9 ] 
    | bb9 = bb9
      [ bb9 = {[@expl:mut invariant] old_9_0.final = slice.final}
        {[@expl:for invariant] [%#s03_std_iterators13] inv'1 produced}
        {[@expl:for invariant] [%#s03_std_iterators13] inv'0 iter}
        {[@expl:for invariant] [%#s03_std_iterators13] produces'0 iter_old produced iter}
        {[@expl:loop invariant #0] [%#s03_std_iterators12] UInt64.t'int n = Seq.length (view'0 slice)}
        {[@expl:loop invariant #1] [%#s03_std_iterators11] equiv_range'0 (view'0 slice) old_v (Seq.length produced) (UInt64.t'int n
        - Seq.length produced)}
        {[@expl:loop invariant #2] [%#s03_std_iterators10] equiv_reverse_range'0 (view'0 slice) old_v 0 (Seq.length produced) (UInt64.t'int n
        - 1)}
        {[@expl:loop invariant #3] [%#s03_std_iterators9] equiv_reverse_range'0 (view'0 slice) old_v (UInt64.t'int n
        - Seq.length produced) (UInt64.t'int n) (UInt64.t'int n - 1)}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = MutBorrow.borrow_mut <t_Zip'0> {iter}
              (fun (_ret':MutBorrow.t t_Zip'0) ->  [ &_32 <- _ret' ]  [ &iter <- _ret'.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Zip'0> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret':MutBorrow.t t_Zip'0) ->  [ &_31 <- _ret' ]  [ &_32 <- { _32 with current = _ret'.final } ] s2)
          | s2 = next'0 {_31} (fun (_ret':t_Option'0) ->  [ &_30 <- _ret' ] s3)
          | s3 = bb11 ]
        
        | bb11 = s0
          [ s0 = -{resolve'0 _32}- s1
          | s1 = any
            [ br0 -> {_30 = C_None'0} (! bb14) | br1 (x0:(UInt64.t, UInt64.t))-> {_30 = C_Some'0 x0} (! bb13) ]
           ]
        
        | bb13 = bb15
        | bb15 = s0
          [ s0 = v_Some'0 {_30} (fun (r0'0:(UInt64.t, UInt64.t)) ->  [ &__creusot_proc_iter_elem <- r0'0 ] s1)
          | s1 =  [ &_35 <- [%#s03_std_iterators14] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb16 ]
        
        | bb16 = s0
          [ s0 =  [ &produced <- _35 ] s1
          | s1 =  [ &i <- let (r'0, _) = __creusot_proc_iter_elem in r'0 ] s2
          | s2 =  [ &j <- let (_, r'1) = __creusot_proc_iter_elem in r'1 ] s3
          | s3 = {inv'2 slice.current}
            MutBorrow.borrow_mut <Slice64.slice t_T'0> {slice.current}
              (fun (_ret':MutBorrow.t (Slice64.slice t_T'0)) ->
                 [ &_40 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &slice <- { slice with current = _ret'.final } ] 
                s4)
          | s4 = UInt64.sub {n} {j} (fun (_ret':UInt64.t) ->  [ &_43 <- _ret' ] s5)
          | s5 = UInt64.sub {_43} {[%#s03_std_iterators15] (1 : UInt64.t)}
              (fun (_ret':UInt64.t) ->  [ &_42 <- _ret' ] s6)
          | s6 = swap'0 {_40} {i} {_42} (fun (_ret':()) ->  [ &_39 <- _ret' ] s7)
          | s7 = bb17 ]
        
        | bb17 = s0
          [ s0 = {[@expl:assertion] [%#s03_std_iterators16] i = j} s1
          | s1 = {[@expl:assertion] [%#s03_std_iterators17] Seq.get (view'0 slice) (UInt64.t'int i)
            = index_logic'0 old_v (UInt64.t'int n - UInt64.t'int j - 1)}
            s2
          | s2 = {[@expl:assertion] [%#s03_std_iterators18] Seq.get (view'0 slice) (UInt64.t'int n - UInt64.t'int j - 1)
            = index_logic'0 old_v (UInt64.t'int i)}
            s3
          | s3 = bb9 ]
         ]
       ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'3 slice} s1 | s1 = -{resolve'1 slice}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & slice : MutBorrow.t (Slice64.slice t_T'0) = slice
    | & n : UInt64.t = Any.any_l ()
    | & old_v : Seq.seq t_T'0 = Any.any_l ()
    | & iter : t_Zip'0 = Any.any_l ()
    | & _8 : t_Zip'0 = Any.any_l ()
    | & _9 : t_Range'0 = Any.any_l ()
    | & _10 : UInt64.t = Any.any_l ()
    | & _12 : bool = Any.any_l ()
    | & _13 : t_Range'0 = Any.any_l ()
    | & _14 : UInt64.t = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & iter_old : t_Zip'0 = Any.any_l ()
    | & produced : Seq.seq (UInt64.t, UInt64.t) = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _31 : MutBorrow.t t_Zip'0 = Any.any_l ()
    | & _32 : MutBorrow.t t_Zip'0 = Any.any_l ()
    | & __creusot_proc_iter_elem : (UInt64.t, UInt64.t) = Any.any_l ()
    | & _35 : Seq.seq (UInt64.t, UInt64.t) = Any.any_l ()
    | & i : UInt64.t = Any.any_l ()
    | & j : UInt64.t = Any.any_l ()
    | & _39 : () = Any.any_l ()
    | & _40 : MutBorrow.t (Slice64.slice t_T'0) = Any.any_l ()
    | & _42 : UInt64.t = Any.any_l ()
    | & _43 : UInt64.t = Any.any_l ()
    | & old_9_0 : MutBorrow.t (Slice64.slice t_T'0) = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:my_reverse ensures] [%#s03_std_iterators20] Seq.(==) (view'1 slice.final) (Reverse.reverse (view'0 slice))}
      (! return' {result}) ]

end
