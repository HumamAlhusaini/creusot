module M_17_filter__qyi4935072013270782883__resolve_coherence [#"17_filter.rs" 14 9 14 16] (* <Filter<I, F> as creusot_contracts::Resolve> *)
  let%span s17_filter0 = "17_filter.rs" 14 9 14 16
  let%span s17_filter1 = "17_filter.rs" 16 4 17 15
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  predicate resolve'1 (_1 : t_F'0)
  
  predicate resolve'2 (_1 : t_I'0)
  
  predicate structural_resolve'0 (_1 : t_Filter'0) =
    match _1 with
      | {t_Filter__iter'0 = x0 ; t_Filter__func'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  predicate resolve'0 [#"17_filter.rs" 14 9 14 16] (self : t_Filter'0) =
    [%#s17_filter1] resolve'2 self.t_Filter__iter'0 /\ resolve'1 self.t_Filter__func'0
  
  constant self  : t_Filter'0
  
  function resolve_coherence'0 [#"17_filter.rs" 14 9 14 16] (self : t_Filter'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#s17_filter0] structural_resolve'0 self)  -> ([%#s17_filter0] resolve'0 self)
end
module M_17_filter__qyi6180221713105948918__produces_refl [#"17_filter.rs" 53 4 53 26] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 52 14 52 45
  let%span s17_filter1 = "17_filter.rs" 53 27 53 29
  let%span s17_filter2 = "17_filter.rs" 66 12 78 17
  let%span s17_filter3 = "17_filter.rs" 26 12 32 122
  let%span scommon4 = "common.rs" 14 14 14 45
  let%span scommon5 = "common.rs" 18 15 18 32
  let%span scommon6 = "common.rs" 19 15 19 32
  let%span scommon7 = "common.rs" 20 14 20 42
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon5] produces'1 a ab b)
   -> ([%#scommon6] produces'1 b bc c)  -> ([%#scommon7] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#scommon4] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter3] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use map.Map
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 64 4 64 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter2] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  constant self  : t_Filter'0
  
  function produces_refl'0 [#"17_filter.rs" 53 4 53 26] (self : t_Filter'0) : ()
  
  goal vc_produces_refl'0 : [%#s17_filter0] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_17_filter__qyi6180221713105948918__produces_trans [#"17_filter.rs" 60 4 60 90] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 57 15 57 32
  let%span s17_filter1 = "17_filter.rs" 58 15 58 32
  let%span s17_filter2 = "17_filter.rs" 59 14 59 42
  let%span s17_filter3 = "17_filter.rs" 60 91 60 93
  let%span s17_filter4 = "17_filter.rs" 66 12 78 17
  let%span s17_filter5 = "17_filter.rs" 26 12 32 122
  let%span scommon6 = "common.rs" 14 14 14 45
  let%span scommon7 = "common.rs" 18 15 18 32
  let%span scommon8 = "common.rs" 19 15 19 32
  let%span scommon9 = "common.rs" 20 14 20 42
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops16 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'1 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon7] produces'1 a ab b)
   -> ([%#scommon8] produces'1 b bc c)  -> ([%#scommon9] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon6] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter5] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use map.Map
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 64 4 64 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter4] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  constant a  : t_Filter'0
  
  constant ab  : Seq.seq t_Item'0
  
  constant b  : t_Filter'0
  
  constant bc  : Seq.seq t_Item'0
  
  constant c  : t_Filter'0
  
  function produces_trans'0 [#"17_filter.rs" 60 4 60 90] (a : t_Filter'0) (ab : Seq.seq t_Item'0) (b : t_Filter'0) (bc : Seq.seq t_Item'0) (c : t_Filter'0) : ()
  
  
  goal vc_produces_trans'0 : ([%#s17_filter1] produces'0 b bc c)
   -> ([%#s17_filter0] produces'0 a ab b)  -> ([%#s17_filter2] produces'0 a (Seq.(++) ab bc) c)
end
module M_17_filter__qyi6180221713105948918__next [#"17_filter.rs" 86 4 86 41] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 87 23 87 40
  let%span s17_filter1 = "17_filter.rs" 88 27 88 51
  let%span s17_filter2 = "17_filter.rs" 90 8 90 31
  let%span s17_filter3 = "17_filter.rs" 92 20 92 129
  let%span s17_filter4 = "17_filter.rs" 91 20 91 46
  let%span s17_filter5 = "17_filter.rs" 90 20 90 29
  let%span s17_filter6 = "17_filter.rs" 96 23 96 58
  let%span s17_filter7 = "17_filter.rs" 97 12 97 71
  let%span s17_filter8 = "17_filter.rs" 86 17 86 21
  let%span s17_filter9 = "17_filter.rs" 86 26 86 41
  let%span s17_filter10 = "17_filter.rs" 82 14 85 5
  let%span sindex11 = "../../../creusot-contracts/src/logic/ops/index.rs" 96 8 96 33
  let%span scommon12 = "common.rs" 27 17 27 21
  let%span scommon13 = "common.rs" 27 26 27 44
  let%span scommon14 = "common.rs" 23 14 26 5
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 169 27 169 52
  let%span sops16 = "../../../creusot-contracts/src/std/ops.rs" 170 26 170 71
  let%span s17_filter17 = "17_filter.rs" 44 12 46 43
  let%span s17_filter18 = "17_filter.rs" 66 12 78 17
  let%span scommon19 = "common.rs" 14 14 14 45
  let%span scommon20 = "common.rs" 18 15 18 32
  let%span scommon21 = "common.rs" 19 15 19 32
  let%span scommon22 = "common.rs" 20 14 20 42
  let%span sops23 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops24 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops25 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops26 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops27 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops28 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops29 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span sresolve30 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span s17_filter31 = "17_filter.rs" 26 12 32 122
  let%span sinvariant32 = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant33 = "../../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use seq.Seq
  
  type t_I'0
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon20] produces'0 a ab b)
   -> ([%#scommon21] produces'0 b bc c)  -> ([%#scommon22] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon19] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  type t_F'0
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'3 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops29] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'3 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops26] unnest'0 self b)
   -> ([%#sops27] unnest'0 b c)  -> ([%#sops28] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops25] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops23] postcondition_mut'0 self args res_state res)
   -> ([%#sops24] unnest'0 self res_state)
  
  use creusot.prelude.MutBorrow
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : Seq.seq t_Item'0) (ix : int) : t_Item'0 =
    [%#sindex11] Seq.get self ix
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter31] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'1 (_1 : t_I'0)
  
  predicate inv'2 (_1 : t_F'0)
  
  predicate inv'9 (_1 : t_Filter'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Filter'0 [inv'9 x] . inv'9 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'1 iter /\ inv'2 func
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_Filter'0) =
    [%#sinvariant32] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'0 (_1 : MutBorrow.t t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Filter'0 [inv'0 x] . inv'0 x = invariant'1 x
  
  predicate invariant'2 (self : MutBorrow.t t_I'0) =
    [%#sinvariant32] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_I'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_I'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate inv'3 (_1 : t_Item'0)
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate completed'1 [#"common.rs" 11 4 11 36] (self : MutBorrow.t t_I'0)
  
  use seq.Seq
  
  let rec next'1 (self:MutBorrow.t t_I'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] [%#scommon12] inv'5 self}
    any
    [ return' (result:t_Option'0)-> {[%#scommon13] inv'4 result}
      {[%#scommon14] match result with
        | C_None'0 -> completed'1 self
        | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Item'0))= any
    [ good (field_0:t_Item'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Item'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  use seq.Seq
  
  predicate invariant'3 (self : MutBorrow.t t_F'0) =
    [%#sinvariant32] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_F'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_F'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'4 (self : t_Item'0) =
    [%#sinvariant33] inv'3 self
  
  predicate inv'10 (_1 : t_Item'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Item'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  predicate inv'7 (_1 : t_Item'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Item'0 [inv'7 x] . inv'7 x = (let (x0) = x in inv'10 x0)
  
  predicate inv'8 (_1 : bool)
  
  axiom inv_axiom'5 [@rewrite] : forall x : bool [inv'8 x] . inv'8 x = true
  
  let rec call_mut'0 (self:MutBorrow.t t_F'0) (args:t_Item'0) (return'  (ret:bool))= {[@expl:call_mut 'self' type invariant] inv'6 self}
    {[@expl:call_mut 'args' type invariant] inv'7 args}
    {[@expl:call_mut requires] [%#sops15] precondition'0 self.current args}
    any
    [ return' (result:bool)-> {inv'8 result}
      {[%#sops16] postcondition_mut'0 self.current args self.final result}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_1 : t_Item'0)
  
  predicate resolve'2 (self : MutBorrow.t t_Filter'0) =
    [%#sresolve30] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Filter'0) =
    resolve'2 _1
  
  use creusot.prelude.Any
  
  predicate completed'0 [#"17_filter.rs" 42 4 42 35] (self : MutBorrow.t t_Filter'0) =
    [%#s17_filter17] (exists s : Seq.seq t_Item'0, e : MutBorrow.t t_I'0 . produces'0 (self.current).t_Filter__iter'0 s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (self.current).t_Filter__func'0 (Seq.get s i) (self.final).t_Filter__func'0 false))
    /\ (self.current).t_Filter__func'0 = (self.final).t_Filter__func'0
  
  use map.Map
  
  use map.Map
  
  predicate produces'1 [#"17_filter.rs" 64 4 64 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter18] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'0 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  meta "compute_max_steps" 1000000
  
  let rec next'0[#"17_filter.rs" 86 4 86 41] (self:MutBorrow.t t_Filter'0) (return'  (ret:t_Option'0))= {[@expl:next 'self' type invariant] [%#s17_filter8] inv'0 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#s17_filter0] self ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &produced <- [%#s17_filter1] Seq.empty : Seq.seq t_Item'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &old_3_0 <- self ] s1 | s1 = bb3 ] 
    | bb3 = bb3
      [ bb3 = {[@expl:mut invariant] old_3_0.final = self.final}
        {[@expl:loop invariant #0] [%#s17_filter5] inv'0 self}
        {[@expl:loop invariant #1] [%#s17_filter4] (self.current).t_Filter__func'0
        = (old_self.current).t_Filter__func'0}
        {[@expl:loop invariant #2] [%#s17_filter3] forall i : int . 0 <= i /\ i < Seq.length produced
         -> postcondition_mut'0 (self.current).t_Filter__func'0 (index_logic'0 produced i) (self.current).t_Filter__func'0 false}
        {[@expl:loop invariant #3] [%#s17_filter2] produces'0 (old_self.current).t_Filter__iter'0 produced (self.current).t_Filter__iter'0}
        {[@expl:loop invariant #4] [%#s17_filter2] unnest'0 (old_self.current).t_Filter__func'0 (self.current).t_Filter__func'0}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = {inv'1 (self.current).t_Filter__iter'0}
            MutBorrow.borrow_mut <t_I'0> {(self.current).t_Filter__iter'0}
              (fun (_ret':MutBorrow.t t_I'0) ->
                 [ &_16 <- _ret' ] 
                -{inv'1 _ret'.final}-
                 [ &self <- { self with current = { self.current with t_Filter__iter'0 = _ret'.final } } ] 
                s1)
          | s1 = next'1 {_16} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
          | s2 = bb5 ]
        
        | bb5 = any [ br0 -> {_15 = C_None'0 } (! bb13) | br1 (x0:t_Item'0)-> {_15 = C_Some'0 x0} (! bb6) ] 
        | bb6 = bb7
        | bb7 = s0
          [ s0 = v_Some'0 {_15} (fun (r0'0:t_Item'0) ->  [ &n <- r0'0 ] s1)
          | s1 =  [ &_19 <- [%#s17_filter6] Seq.snoc produced n ] s2
          | s2 = bb8 ]
        
        | bb8 = s0
          [ s0 =  [ &produced <- _19 ] s1
          | s1 = {[@expl:assertion] [%#s17_filter7] produces'0 (old_self.current).t_Filter__iter'0 produced (self.current).t_Filter__iter'0}
            s2
          | s2 = {inv'2 (self.current).t_Filter__func'0}
            MutBorrow.borrow_mut <t_F'0> {(self.current).t_Filter__func'0}
              (fun (_ret':MutBorrow.t t_F'0) ->
                 [ &_24 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &self <- { self with current = { self.current with t_Filter__func'0 = _ret'.final } } ] 
                s3)
          | s3 =  [ &_27 <- n ] s4
          | s4 =  [ &_25 <- (_27) ] s5
          | s5 = call_mut'0 {_24} {_25} (fun (_ret':bool) ->  [ &_23 <- _ret' ] s6)
          | s6 = bb9 ]
        
        | bb9 = any [ br0 -> {_23 = false} (! bb12) | br1 -> {_23} (! bb10) ] 
        | bb12 = s0 [ s0 = {[@expl:type invariant] inv'3 n} s1 | s1 = -{resolve'0 n}- s2 | s2 = bb14 ] 
        | bb14 = bb15
        | bb15 = bb3 ]
       ]
    
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match _15 with
          | C_Some'0 x'0 -> inv'3 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match _15 with
          | C_Some'0 x'1 -> resolve'0 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 = bb16 ]
    
    | bb16 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb19 ] 
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1
      | s1 = -{resolve'1 self}- s2
      | s2 =  [ &_0 <- C_Some'0 n ] s3
      | s3 = bb11 ]
    
    | bb11 = bb17
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self : MutBorrow.t t_Filter'0 = self
    | & old_self : MutBorrow.t t_Filter'0 = Any.any_l ()
    | & produced : Seq.seq t_Item'0 = Any.any_l ()
    | & _15 : t_Option'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_I'0 = Any.any_l ()
    | & n : t_Item'0 = Any.any_l ()
    | & _19 : Seq.seq t_Item'0 = Any.any_l ()
    | & _23 : bool = Any.any_l ()
    | & _24 : MutBorrow.t t_F'0 = Any.any_l ()
    | & _25 : t_Item'0 = Any.any_l ()
    | & _27 : t_Item'0 = Any.any_l ()
    | & old_3_0 : MutBorrow.t t_Filter'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:next result type invariant] [%#s17_filter9] inv'4 result}
      {[@expl:next ensures] [%#s17_filter10] match result with
        | C_None'0 -> completed'0 self
        | C_Some'0 v -> produces'1 self.current (Seq.singleton v) self.final
        end}
      (! return' {result}) ]

end
module M_17_filter__filter [#"17_filter.rs" 112 0 114 39]
  let%span s17_filter0 = "17_filter.rs" 112 30 112 34
  let%span s17_filter1 = "17_filter.rs" 112 39 112 40
  let%span s17_filter2 = "17_filter.rs" 108 11 108 23
  let%span s17_filter3 = "17_filter.rs" 109 11 109 29
  let%span s17_filter4 = "17_filter.rs" 110 11 110 21
  let%span s17_filter5 = "17_filter.rs" 112 48 112 60
  let%span s17_filter6 = "17_filter.rs" 111 10 111 49
  let%span s17_filter7 = "17_filter.rs" 139 16 139 59
  let%span s17_filter8 = "17_filter.rs" 133 16 133 57
  let%span s17_filter9 = "17_filter.rs" 145 16 145 126
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops16 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span scommon17 = "common.rs" 14 14 14 45
  let%span scommon18 = "common.rs" 18 15 18 32
  let%span scommon19 = "common.rs" 19 15 19 32
  let%span scommon20 = "common.rs" 20 14 20 42
  let%span s17_filter21 = "17_filter.rs" 26 12 32 122
  
  type t_I'0
  
  type t_P'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_P'0 }
  
  use creusot.prelude.Any
  
  predicate inv'0 (_1 : t_I'0)
  
  predicate inv'1 (_1 : t_P'0)
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon18] produces'0 a ab b)
   -> ([%#scommon19] produces'0 b bc c)  -> ([%#scommon20] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon17] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate postcondition_once'0 (self : t_P'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_P'0)
  
  predicate postcondition_mut'0 (self : t_P'0) (args : t_Item'0) (result_state : t_P'0) (result : bool)
  
  function fn_mut_once'0 (self : t_P'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_P'0, args : t_Item'0, res : bool . [%#sops16] postcondition_once'0 self args res
  = (exists res_state : t_P'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_P'0) (_2 : t_P'0)
  
  function unnest_trans'0 (self : t_P'0) (b : t_P'0) (c : t_P'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_P'0, b : t_P'0, c : t_P'0 . ([%#sops13] unnest'0 self b)
   -> ([%#sops14] unnest'0 b c)  -> ([%#sops15] unnest'0 self c)
  
  function unnest_refl'0 (self : t_P'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_P'0 . [%#sops12] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_P'0) (args : t_Item'0) (res_state : t_P'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_P'0, args : t_Item'0, res_state : t_P'0, res : bool . ([%#sops10] postcondition_mut'0 self args res_state res)
   -> ([%#sops11] unnest'0 self res_state)
  
  predicate immutable'0 [#"17_filter.rs" 138 0 138 54] (_1 : t_P'0) =
    [%#s17_filter7] forall f : t_P'0, g : t_P'0 . unnest'0 f g  -> f = g
  
  predicate precondition'0 (self : t_P'0) (args : t_Item'0)
  
  predicate no_precondition'0 [#"17_filter.rs" 132 0 132 60] (_1 : t_P'0) =
    [%#s17_filter8] forall f : t_P'0, i : t_Item'0 . precondition'0 f (i)
  
  predicate precise'0 [#"17_filter.rs" 144 0 144 52] (_1 : t_P'0) =
    [%#s17_filter9] forall f1 : t_P'0, f2 : t_P'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter21] forall f : t_P'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_P'0, g : t_P'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_P'0, f2 : t_P'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'2 x] . inv'2 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'0 iter /\ inv'1 func
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec filter'0[#"17_filter.rs" 112 0 114 39] (iter:t_I'0) (f:t_P'0) (return'  (ret:t_Filter'0))= {[@expl:filter 'iter' type invariant] [%#s17_filter0] inv'0 iter}
    {[@expl:filter 'f' type invariant] [%#s17_filter1] inv'1 f}
    {[@expl:filter requires #0] [%#s17_filter2] immutable'0 f}
    {[@expl:filter requires #1] [%#s17_filter3] no_precondition'0 f}
    {[@expl:filter requires #2] [%#s17_filter4] precise'0 f}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- { t_Filter__iter'0 = iter; t_Filter__func'0 = f } ] s1 | s1 = bb5 ] 
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = bb8
    | bb8 = return' {_0} ]
    ) [ & _0 : t_Filter'0 = Any.any_l () | & iter : t_I'0 = iter | & f : t_P'0 = f ] 
    [ return' (result:t_Filter'0)-> {[@expl:filter result type invariant] [%#s17_filter5] inv'2 result}
      {[@expl:filter ensures] [%#s17_filter6] result.t_Filter__iter'0 = iter /\ result.t_Filter__func'0 = f}
      (! return' {result}) ]

end
module M_17_filter__less_than [#"17_filter.rs" 121 0 121 49]
  let%span s17_filter0 = "17_filter.rs" 119 10 119 70
  let%span s17_filter1 = "17_filter.rs" 120 10 120 79
  let%span siter2 = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter3 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span s17_filter4 = "17_filter.rs" 124 22 124 40
  let%span siter5 = "../../../creusot-contracts/src/std/iter.rs" 159 27 159 47
  let%span siter6 = "../../../creusot-contracts/src/std/iter.rs" 160 27 160 53
  let%span siter7 = "../../../creusot-contracts/src/std/iter.rs" 161 27 161 45
  let%span siter8 = "../../../creusot-contracts/src/std/iter.rs" 162 26 162 69
  let%span siter9 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span svec10 = "../../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex11 = "../../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span sseq12 = "../../../creusot-contracts/src/logic/seq.rs" 351 20 351 77
  let%span svec13 = "../../../creusot-contracts/src/std/vec.rs" 198 20 198 24
  let%span svec14 = "../../../creusot-contracts/src/std/vec.rs" 204 20 204 33
  let%span sfilter15 = "../../../creusot-contracts/src/std/iter/filter.rs" 58 16 58 59
  let%span sfilter16 = "../../../creusot-contracts/src/std/iter/filter.rs" 50 16 50 57
  let%span sfilter17 = "../../../creusot-contracts/src/std/iter/filter.rs" 65 16 65 126
  let%span sfilter18 = "../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter19 = "../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter20 = "../../../creusot-contracts/src/std/iter/filter.rs" 77 12 79 47
  let%span sfilter21 = "../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span svec22 = "../../../creusot-contracts/src/std/vec.rs" 297 20 297 32
  let%span sord23 = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord24 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord25 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord26 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord27 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord28 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord29 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord30 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord31 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord32 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord33 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord34 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord35 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sresolve36 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sops37 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops38 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops39 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops40 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops41 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops42 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops43 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  let%span sfilter44 = "../../../creusot-contracts/src/std/iter/filter.rs" 104 14 104 45
  let%span sfilter45 = "../../../creusot-contracts/src/std/iter/filter.rs" 109 15 109 32
  let%span sfilter46 = "../../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 32
  let%span sfilter47 = "../../../creusot-contracts/src/std/iter/filter.rs" 111 14 111 42
  let%span svec48 = "../../../creusot-contracts/src/std/vec.rs" 276 12 276 41
  let%span svec49 = "../../../creusot-contracts/src/std/vec.rs" 269 20 269 57
  let%span sord50 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span svec51 = "../../../creusot-contracts/src/std/vec.rs" 282 14 282 45
  let%span svec52 = "../../../creusot-contracts/src/std/vec.rs" 283 27 283 29
  let%span svec53 = "../../../creusot-contracts/src/std/vec.rs" 287 15 287 32
  let%span svec54 = "../../../creusot-contracts/src/std/vec.rs" 288 15 288 32
  let%span svec55 = "../../../creusot-contracts/src/std/vec.rs" 289 14 289 42
  let%span svec56 = "../../../creusot-contracts/src/std/vec.rs" 290 73 290 75
  let%span smodel57 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  
  use creusot.prelude.Opaque
  
  type t_NonNull'1  =
    { t_NonNull__pointer'1: Opaque.ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'1; t_Unique__qy95zmarker'0: () }
  
  use creusot.int.UInt64
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: UInt64.t }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  predicate inv'0 (_1 : t_Vec'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Vec'0 [inv'0 x] . inv'0 x = true
  
  predicate into_iter_pre'0 (self : t_Vec'0) =
    [%#svec13] true
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_ManuallyDrop'0  =
    { t_ManuallyDrop__value'0: () }
  
  type t_IntoIter'0  =
    { t_IntoIter__buf'0: t_NonNull'0;
      t_IntoIter__phantom'0: ();
      t_IntoIter__cap'0: UInt64.t;
      t_IntoIter__alloc'0: t_ManuallyDrop'0;
      t_IntoIter__ptr'0: t_NonNull'0;
      t_IntoIter__end'0: Opaque.ptr }
  
  predicate inv'1 (_1 : t_IntoIter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_IntoIter'0 [inv'1 x] . inv'1 x = true
  
  use seq.Seq
  
  use creusot.int.UInt64
  
  constant v_MAX'0 : UInt64.t = (18446744073709551615 : UInt64.t)
  
  use mach.int.Int
  
  use creusot.int.UInt32
  
  use seq.Seq
  
  function view'0 (self : t_Vec'0) : Seq.seq UInt32.t
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec10] Seq.length (view'0 self) <= UInt64.t'int (v_MAX'0 : UInt64.t)
  
  function view'1 (self : t_IntoIter'0) : Seq.seq UInt32.t
  
  predicate into_iter_post'0 (self : t_Vec'0) (res : t_IntoIter'0) =
    [%#svec14] view'0 self = view'1 res
  
  let rec into_iter'0 (self:t_Vec'0) (return'  (ret:t_IntoIter'0))= {[@expl:into_iter 'self' type invariant] inv'0 self}
    {[@expl:into_iter requires] [%#siter2] into_iter_pre'0 self}
    any
    [ return' (result:t_IntoIter'0)-> {inv'1 result} {[%#siter3] into_iter_post'0 self result} (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  type closure2'1  =
    { field_0'0: UInt32.t }
  
  predicate resolve'2 (self : MutBorrow.t closure2'1) =
    [%#sresolve36] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t closure2'1) =
    resolve'2 _1
  
  use creusot.prelude.Any
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  use creusot.int.UInt32
  
  function cmp_log'0 (self : UInt32.t) (o : UInt32.t) : t_Ordering'0 =
    [%#sord50] if UInt32.lt self o then C_Less'0 else if self = o then C_Equal'0 else C_Greater'0
  
  function eq_cmp'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom eq_cmp'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord35] (x = y) = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom antisym2'0_spec : forall x : UInt32.t, y : UInt32.t . ([%#sord33] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord34] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom antisym1'0_spec : forall x : UInt32.t, y : UInt32.t . ([%#sord31] cmp_log'0 x y = C_Less'0)
   -> ([%#sord32] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : UInt32.t) (y : UInt32.t) (z : UInt32.t) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : UInt32.t, y : UInt32.t, z : UInt32.t, o : t_Ordering'0 . ([%#sord28] cmp_log'0 x y
  = o)  -> ([%#sord29] cmp_log'0 y z = o)  -> ([%#sord30] cmp_log'0 x z = o)
  
  function refl'0 (x : UInt32.t) : ()
  
  axiom refl'0_spec : forall x : UInt32.t . [%#sord27] cmp_log'0 x x = C_Equal'0
  
  use creusot.int.UInt32
  
  function cmp_gt_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_gt_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord26] UInt32.gt x y = (cmp_log'0 x y = C_Greater'0)
  
  use creusot.int.UInt32
  
  function cmp_ge_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_ge_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord25] UInt32.ge x y = (cmp_log'0 x y <> C_Less'0)
  
  function cmp_lt_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_lt_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord24] UInt32.lt x y = (cmp_log'0 x y = C_Less'0)
  
  use creusot.int.UInt32
  
  function cmp_le_log'0 (x : UInt32.t) (y : UInt32.t) : ()
  
  axiom cmp_le_log'0_spec : forall x : UInt32.t, y : UInt32.t . [%#sord23] UInt32.le x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate postcondition_once'0 (self : closure2'1) (args : UInt32.t) (result : bool) =
    [%#s17_filter4] let (i) = args in result = UInt32.lt i self.field_0'0
  
  predicate resolve'3 (_1 : closure2'1) =
    true
  
  predicate unnest'0 (self : closure2'1) (_2 : closure2'1) =
    _2.field_0'0 = self.field_0'0
  
  predicate postcondition_mut'1 (self : closure2'1) (args : UInt32.t) (result_state : closure2'1) (result : bool) =
    (let (i) = args in result = UInt32.lt i result_state.field_0'0) /\ unnest'0 self result_state
  
  function fn_mut_once'0 (self : closure2'1) (args : UInt32.t) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : closure2'1, args : UInt32.t, res : bool . [%#sops43] postcondition_once'0 self args res
  = (exists res_state : closure2'1 . postcondition_mut'1 self args res_state res /\ resolve'3 res_state)
  
  function unnest_trans'0 (self : closure2'1) (b : closure2'1) (c : closure2'1) : ()
  
  axiom unnest_trans'0_spec : forall self : closure2'1, b : closure2'1, c : closure2'1 . ([%#sops40] unnest'0 self b)
   -> ([%#sops41] unnest'0 b c)  -> ([%#sops42] unnest'0 self c)
  
  function unnest_refl'0 (self : closure2'1) : ()
  
  axiom unnest_refl'0_spec : forall self : closure2'1 . [%#sops39] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : closure2'1) (args : UInt32.t) (res_state : closure2'1) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : closure2'1, args : UInt32.t, res_state : closure2'1, res : bool . ([%#sops37] postcondition_mut'1 self args res_state res)
   -> ([%#sops38] unnest'0 self res_state)
  
  let rec closure2'0[#"17_filter.rs" 124 12 124 42] (_1:MutBorrow.t closure2'1) (i:UInt32.t) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 _1}- s1
      | s1 =  [ &res <- UInt32.lt i (_1.current).field_0'0 ] s2
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
     ]
    )
    [ & _0 : bool = Any.any_l ()
    | & _1 : MutBorrow.t closure2'1 = _1
    | & i : UInt32.t = i
    | & res : bool = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:closure ensures] [%#s17_filter4] result = UInt32.lt i (_1.final).field_0'0}
      {[@expl:closure unnest] unnest'0 _1.current _1.final}
      (! return' {result}) ]
  
  
  predicate inv'2 (_1 : closure2'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : closure2'1 [inv'2 x] . inv'2 x = true
  
  predicate postcondition_once'1 (self : closure2'1) (args : UInt32.t) (result : bool) =
    [%#s17_filter4] let (i) = args in result = UInt32.lt i self.field_0'0
  
  predicate postcondition_mut'0 (self : closure2'1) (args : UInt32.t) (result_state : closure2'1) (result : bool) =
    (let (i) = args in result = UInt32.lt i result_state.field_0'0) /\ unnest'0 self result_state
  
  function fn_mut_once'1 (self : closure2'1) (args : UInt32.t) (res : bool) : ()
  
  axiom fn_mut_once'1_spec : forall self : closure2'1, args : UInt32.t, res : bool . [%#sops43] postcondition_once'1 self args res
  = (exists res_state : closure2'1 . postcondition_mut'0 self args res_state res /\ resolve'3 res_state)
  
  predicate unnest'1 (self : closure2'1) (_2 : closure2'1) =
    _2.field_0'0 = self.field_0'0
  
  function unnest_trans'1 (self : closure2'1) (b : closure2'1) (c : closure2'1) : ()
  
  axiom unnest_trans'1_spec : forall self : closure2'1, b : closure2'1, c : closure2'1 . ([%#sops40] unnest'1 self b)
   -> ([%#sops41] unnest'1 b c)  -> ([%#sops42] unnest'1 self c)
  
  function unnest_refl'1 (self : closure2'1) : ()
  
  axiom unnest_refl'1_spec : forall self : closure2'1 . [%#sops39] unnest'1 self self
  
  function postcondition_mut_unnest'1 (self : closure2'1) (args : UInt32.t) (res_state : closure2'1) (res : bool) : ()
  
  axiom postcondition_mut_unnest'1_spec : forall self : closure2'1, args : UInt32.t, res_state : closure2'1, res : bool . ([%#sops37] postcondition_mut'0 self args res_state res)
   -> ([%#sops38] unnest'1 self res_state)
  
  predicate immutable'0 (_1 : closure2'1) =
    [%#sfilter15] forall f : closure2'1, g : closure2'1 . unnest'1 f g  -> f = g
  
  predicate precondition'0 (self : closure2'1) (args : UInt32.t) =
    let (i) = args in true
  
  predicate no_precondition'0 (_1 : closure2'1) =
    [%#sfilter16] forall f : closure2'1, i : UInt32.t . precondition'0 f (i)
  
  predicate precise'0 (_1 : closure2'1) =
    [%#sfilter17] forall f1 : closure2'1, f2 : closure2'1, i : UInt32.t . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false)
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_IntoIter'0; t_Filter__predicate'0: closure2'1 }
  
  predicate invariant'0 (self : t_Filter'0)
  
  predicate inv'3 (_1 : t_Filter'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Filter'0 [inv'3 x] . inv'3 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__predicate'0 = predicate'} -> true
    end)
  
  function iter'0 (self : t_Filter'0) : t_IntoIter'0
  
  axiom iter'0_spec : forall self : t_Filter'0 . [%#sfilter18] inv'3 self  -> inv'1 (iter'0 self)
  
  function func'0 (self : t_Filter'0) : closure2'1
  
  axiom func'0_spec : forall self : t_Filter'0 . [%#sfilter19] inv'3 self  -> inv'2 (func'0 self)
  
  let rec filter'0 (self:t_IntoIter'0) (predicate':closure2'1) (return'  (ret:t_Filter'0))= {[@expl:filter 'self' type invariant] inv'1 self}
    {[@expl:filter 'predicate' type invariant] inv'2 predicate'}
    {[@expl:filter requires #0] [%#siter5] immutable'0 predicate'}
    {[@expl:filter requires #1] [%#siter6] no_precondition'0 predicate'}
    {[@expl:filter requires #2] [%#siter7] precise'0 predicate'}
    any
    [ return' (result:t_Filter'0)-> {inv'3 result}
      {[%#siter8] iter'0 result = self /\ func'0 result = predicate'}
      (! return' {result}) ]
  
  
  predicate resolve'1 (_1 : t_Filter'0) =
    true
  
  use map.Map
  
  use seq.Seq
  
  use seq.Seq
  
  predicate produces'1 (self : t_IntoIter'0) (visited : Seq.seq UInt32.t) (rhs : t_IntoIter'0) =
    [%#svec48] view'1 self = Seq.(++) visited (view'1 rhs)
  
  function produces_trans'1 (a : t_IntoIter'0) (ab : Seq.seq UInt32.t) (b : t_IntoIter'0) (bc : Seq.seq UInt32.t) (c : t_IntoIter'0) : ()
  
   =
    [%#svec56] ()
  
  axiom produces_trans'1_spec : forall a : t_IntoIter'0, ab : Seq.seq UInt32.t, b : t_IntoIter'0, bc : Seq.seq UInt32.t, c : t_IntoIter'0 . ([%#svec53] produces'1 a ab b)
   -> ([%#svec54] produces'1 b bc c)  -> ([%#svec55] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 (self : t_IntoIter'0) : () =
    [%#svec52] ()
  
  axiom produces_refl'1_spec : forall self : t_IntoIter'0 . [%#svec51] produces'1 self (Seq.empty : Seq.seq UInt32.t) self
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 (self : t_Filter'0) (visited : Seq.seq UInt32.t) (succ : t_Filter'0) =
    [%#sfilter21] invariant'0 self
     -> unnest'1 (func'0 self) (func'0 succ)
    /\ (exists s : Seq.seq UInt32.t, f : Map.map int int . produces'1 (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 (func'0 self) (Seq.get s i) (func'0 self) true))
  
  function produces_trans'0 (a : t_Filter'0) (ab : Seq.seq UInt32.t) (b : t_Filter'0) (bc : Seq.seq UInt32.t) (c : t_Filter'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_Filter'0, ab : Seq.seq UInt32.t, b : t_Filter'0, bc : Seq.seq UInt32.t, c : t_Filter'0 . ([%#sfilter45] produces'0 a ab b)
   -> ([%#sfilter46] produces'0 b bc c)  -> ([%#sfilter47] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Filter'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_Filter'0 . [%#sfilter44] produces'0 self (Seq.empty : Seq.seq UInt32.t) self
  
  predicate resolve'4 (self : MutBorrow.t t_IntoIter'0) =
    [%#sresolve36] self.final = self.current
  
  function view'2 (self : MutBorrow.t t_IntoIter'0) : Seq.seq UInt32.t =
    [%#smodel57] view'1 self.current
  
  predicate completed'1 (self : MutBorrow.t t_IntoIter'0) =
    [%#svec49] resolve'4 self /\ view'2 self = (Seq.empty : Seq.seq UInt32.t)
  
  predicate completed'0 (self : MutBorrow.t t_Filter'0) =
    [%#sfilter20] (exists s : Seq.seq UInt32.t, e : MutBorrow.t t_IntoIter'0 . produces'1 (iter'0 self.current) s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (func'0 self.current) (Seq.get s i) (func'0 self.final) false))
    /\ func'0 self.current = func'0 self.final
  
  predicate from_iter_post'0 (prod : Seq.seq UInt32.t) (res : t_Vec'0) =
    [%#svec22] prod = view'0 res
  
  let rec collect'0 (self:t_Filter'0) (return'  (ret:t_Vec'0))= {[@expl:collect 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Vec'0)-> {inv'0 result}
      {[%#siter9] exists done' : MutBorrow.t t_Filter'0, prod : Seq.seq UInt32.t . resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self prod done'.current /\ from_iter_post'0 prod result}
      (! return' {result}) ]
  
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : UInt32.t =
    [%#sindex11] Seq.get (view'0 self) ix
  
  predicate contains'0 (self : Seq.seq UInt32.t) (x : UInt32.t) =
    [%#sseq12] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  let rec less_than'0[#"17_filter.rs" 121 0 121 49] (v:t_Vec'0) (n:UInt32.t) (return'  (ret:t_Vec'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter'0 {v} (fun (_ret':t_IntoIter'0) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_8 <- { field_0'0 = n } ] s1
      | s1 = filter'0 {_6} {_8} (fun (_ret':t_Filter'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = collect'0 {_5} (fun (_ret':t_Vec'0) ->  [ &_0 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = bb5
    | bb5 = return' {_0} ]
    )
    [ & _0 : t_Vec'0 = Any.any_l ()
    | & v : t_Vec'0 = v
    | & n : UInt32.t = n
    | & _5 : t_Filter'0 = Any.any_l ()
    | & _6 : t_IntoIter'0 = Any.any_l ()
    | & _8 : closure2'1 = Any.any_l () ]
    
    [ return' (result:t_Vec'0)-> {[@expl:less_than ensures #0] [%#s17_filter0] forall i : int . 0 <= i
      /\ i < Seq.length (view'0 result)  -> UInt32.lt (index_logic'0 result i) n}
      {[@expl:less_than ensures #1] [%#s17_filter1] forall i : int . 0 <= i /\ i < Seq.length (view'0 result)
       -> contains'0 (view'0 v) (index_logic'0 result i)}
      (! return' {result}) ]

end
module M_17_filter__qyi4935072013270782883__resolve_coherence__refines [#"17_filter.rs" 14 9 14 16] (* <Filter<I, F> as creusot_contracts::Resolve> *)
  let%span s17_filter0 = "17_filter.rs" 14 9 14 16
  let%span s17_filter1 = "17_filter.rs" 16 4 17 15
  let%span sinvariant2 = "../../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span s17_filter3 = "17_filter.rs" 26 12 32 122
  let%span scommon4 = "common.rs" 14 14 14 45
  let%span scommon5 = "common.rs" 18 15 18 32
  let%span scommon6 = "common.rs" 19 15 19 32
  let%span scommon7 = "common.rs" 20 14 20 42
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  predicate resolve'1 (_1 : t_F'0)
  
  predicate resolve'2 (_1 : t_I'0)
  
  predicate structural_resolve'0 (_1 : t_Filter'0) =
    match _1 with
      | {t_Filter__iter'0 = x0 ; t_Filter__func'0 = x1} -> resolve'1 x1 /\ resolve'2 x0
      end
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'0 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon5] produces'0 a ab b)
   -> ([%#scommon6] produces'0 b bc c)  -> ([%#scommon7] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon4] produces'0 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops14] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'1 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops11] unnest'0 self b)
   -> ([%#sops12] unnest'0 b c)  -> ([%#sops13] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops10] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops8] postcondition_mut'0 self args res_state res)
   -> ([%#sops9] unnest'0 self res_state)
  
  predicate invariant'1 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter3] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'2 (_1 : t_I'0)
  
  predicate inv'3 (_1 : t_F'0)
  
  predicate inv'1 (_1 : t_Filter'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Filter'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'2 iter /\ inv'3 func
    end)
  
  predicate invariant'0 (self : t_Filter'0) =
    [%#sinvariant2] inv'1 self
  
  predicate inv'0 (_1 : t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Filter'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"17_filter.rs" 14 9 14 16] (self : t_Filter'0) =
    [%#s17_filter1] resolve'2 self.t_Filter__iter'0 /\ resolve'1 self.t_Filter__func'0
  
  goal refines : [%#s17_filter0] forall self : t_Filter'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_17_filter__qyi6180221713105948918__next__refines [#"17_filter.rs" 86 4 86 41] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 86 4 86 41
  let%span s17_filter1 = "17_filter.rs" 44 12 46 43
  let%span s17_filter2 = "17_filter.rs" 66 12 78 17
  let%span s17_filter3 = "17_filter.rs" 26 12 32 122
  let%span sinvariant4 = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span scommon5 = "common.rs" 14 14 14 45
  let%span scommon6 = "common.rs" 18 15 18 32
  let%span scommon7 = "common.rs" 19 15 19 32
  let%span scommon8 = "common.rs" 20 14 20 42
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops14 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops15 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  use creusot.prelude.MutBorrow
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon6] produces'1 a ab b)
   -> ([%#scommon7] produces'1 b bc c)  -> ([%#scommon8] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon5] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops15] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops12] unnest'0 self b)
   -> ([%#sops13] unnest'0 b c)  -> ([%#sops14] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops11] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops9] postcondition_mut'0 self args res_state res)
   -> ([%#sops10] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter3] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  predicate inv'4 (_1 : t_I'0)
  
  predicate inv'5 (_1 : t_F'0)
  
  predicate inv'3 (_1 : t_Filter'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Filter'0 [inv'3 x] . inv'3 x
  = (invariant'0 x
  /\ match x with
    | {t_Filter__iter'0 = iter ; t_Filter__func'0 = func} -> inv'4 iter /\ inv'5 func
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_Filter'0) =
    [%#sinvariant4] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'0 (_1 : MutBorrow.t t_Filter'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Filter'0 [inv'0 x] . inv'0 x = invariant'1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Item'0
  
  predicate completed'1 [#"common.rs" 11 4 11 36] (self : MutBorrow.t t_I'0)
  
  use mach.int.Int
  
  use seq.Seq
  
  use seq.Seq
  
  predicate completed'0 [#"17_filter.rs" 42 4 42 35] (self : MutBorrow.t t_Filter'0) =
    [%#s17_filter1] (exists s : Seq.seq t_Item'0, e : MutBorrow.t t_I'0 . produces'1 (self.current).t_Filter__iter'0 s e.current
    /\ completed'1 e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut'0 (self.current).t_Filter__func'0 (Seq.get s i) (self.final).t_Filter__func'0 false))
    /\ (self.current).t_Filter__func'0 = (self.final).t_Filter__func'0
  
  use map.Map
  
  use map.Map
  
  predicate produces'0 [#"17_filter.rs" 64 4 64 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter2] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  use seq.Seq
  
  predicate inv'2 (_1 : t_Item'0)
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'2 a_0
    end
  
  goal refines : [%#s17_filter0] forall self : MutBorrow.t t_Filter'0 . inv'0 self
   -> inv'0 self
  /\ (forall result : t_Option'0 . match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result
   -> match result with
    | C_None'0 -> completed'0 self
    | C_Some'0 v -> produces'0 self.current (Seq.singleton v) self.final
    end
  /\ inv'1 result)
end
module M_17_filter__qyi6180221713105948918__produces_refl__refines [#"17_filter.rs" 53 4 53 26] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 53 4 53 26
  let%span s17_filter1 = "17_filter.rs" 66 12 78 17
  let%span s17_filter2 = "17_filter.rs" 26 12 32 122
  let%span scommon3 = "common.rs" 14 14 14 45
  let%span scommon4 = "common.rs" 18 15 18 32
  let%span scommon5 = "common.rs" 19 15 19 32
  let%span scommon6 = "common.rs" 20 14 20 42
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'0 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'0_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon4] produces'1 a ab b)
   -> ([%#scommon5] produces'1 b bc c)  -> ([%#scommon6] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'1 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'1_spec : forall self : t_I'0 . [%#scommon3] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter2] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use map.Map
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 64 4 64 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter1] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  goal refines : [%#s17_filter0] forall self : t_Filter'0 . forall result : () . produces'0 self (Seq.empty : Seq.seq t_Item'0) self
   -> produces'0 self (Seq.empty : Seq.seq t_Item'0) self
end
module M_17_filter__qyi6180221713105948918__produces_trans__refines [#"17_filter.rs" 60 4 60 90] (* <Filter<I, F> as common::Iterator> *)
  let%span s17_filter0 = "17_filter.rs" 60 4 60 90
  let%span s17_filter1 = "17_filter.rs" 66 12 78 17
  let%span scommon2 = "common.rs" 14 14 14 45
  let%span scommon3 = "common.rs" 18 15 18 32
  let%span scommon4 = "common.rs" 19 15 19 32
  let%span scommon5 = "common.rs" 20 14 20 42
  let%span s17_filter6 = "17_filter.rs" 26 12 32 122
  let%span sops7 = "../../../creusot-contracts/src/std/ops.rs" 115 15 115 59
  let%span sops8 = "../../../creusot-contracts/src/std/ops.rs" 116 14 116 36
  let%span sops9 = "../../../creusot-contracts/src/std/ops.rs" 121 14 121 31
  let%span sops10 = "../../../creusot-contracts/src/std/ops.rs" 126 15 126 29
  let%span sops11 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 26
  let%span sops12 = "../../../creusot-contracts/src/std/ops.rs" 128 14 128 28
  let%span sops13 = "../../../creusot-contracts/src/std/ops.rs" 133 14 134 105
  
  type t_I'0
  
  type t_F'0
  
  type t_Filter'0  =
    { t_Filter__iter'0: t_I'0; t_Filter__func'0: t_F'0 }
  
  use seq.Seq
  
  use seq.Seq
  
  type t_Item'0
  
  use seq.Seq
  
  predicate produces'1 [#"common.rs" 8 4 8 65] (self : t_I'0) (visited : Seq.seq t_Item'0) (o : t_I'0)
  
  function produces_trans'1 [#"common.rs" 21 4 21 91] (a : t_I'0) (ab : Seq.seq t_Item'0) (b : t_I'0) (bc : Seq.seq t_Item'0) (c : t_I'0) : ()
  
  
  axiom produces_trans'1_spec : forall a : t_I'0, ab : Seq.seq t_Item'0, b : t_I'0, bc : Seq.seq t_Item'0, c : t_I'0 . ([%#scommon3] produces'1 a ab b)
   -> ([%#scommon4] produces'1 b bc c)  -> ([%#scommon5] produces'1 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 [#"common.rs" 15 4 15 27] (self : t_I'0) : ()
  
  axiom produces_refl'0_spec : forall self : t_I'0 . [%#scommon2] produces'1 self (Seq.empty : Seq.seq t_Item'0) self
  
  predicate precondition'0 (self : t_F'0) (args : t_Item'0)
  
  predicate postcondition_once'0 (self : t_F'0) (args : t_Item'0) (result : bool)
  
  predicate resolve'0 (_1 : t_F'0)
  
  predicate postcondition_mut'0 (self : t_F'0) (args : t_Item'0) (result_state : t_F'0) (result : bool)
  
  function fn_mut_once'0 (self : t_F'0) (args : t_Item'0) (res : bool) : ()
  
  axiom fn_mut_once'0_spec : forall self : t_F'0, args : t_Item'0, res : bool . [%#sops13] postcondition_once'0 self args res
  = (exists res_state : t_F'0 . postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate unnest'0 (self : t_F'0) (_2 : t_F'0)
  
  function unnest_trans'0 (self : t_F'0) (b : t_F'0) (c : t_F'0) : ()
  
  axiom unnest_trans'0_spec : forall self : t_F'0, b : t_F'0, c : t_F'0 . ([%#sops10] unnest'0 self b)
   -> ([%#sops11] unnest'0 b c)  -> ([%#sops12] unnest'0 self c)
  
  function unnest_refl'0 (self : t_F'0) : ()
  
  axiom unnest_refl'0_spec : forall self : t_F'0 . [%#sops9] unnest'0 self self
  
  function postcondition_mut_unnest'0 (self : t_F'0) (args : t_Item'0) (res_state : t_F'0) (res : bool) : ()
  
  axiom postcondition_mut_unnest'0_spec : forall self : t_F'0, args : t_Item'0, res_state : t_F'0, res : bool . ([%#sops7] postcondition_mut'0 self args res_state res)
   -> ([%#sops8] unnest'0 self res_state)
  
  predicate invariant'0 [#"17_filter.rs" 23 4 23 30] (self : t_Filter'0) =
    [%#s17_filter6] forall f : t_F'0, i : t_Item'0 . precondition'0 f (i)
    /\ (forall f : t_F'0, g : t_F'0 . unnest'0 f g  -> f = g)
    /\ (forall f1 : t_F'0, f2 : t_F'0, i : t_Item'0 . not (postcondition_mut'0 f1 (i) f2 true
    /\ postcondition_mut'0 f1 (i) f2 false))
  
  use map.Map
  
  use mach.int.Int
  
  use seq.Seq
  
  use map.Map
  
  use seq.Seq
  
  predicate produces'0 [#"17_filter.rs" 64 4 64 67] (self : t_Filter'0) (visited : Seq.seq t_Item'0) (succ : t_Filter'0)
   =
    [%#s17_filter1] invariant'0 self
     -> unnest'0 self.t_Filter__func'0 succ.t_Filter__func'0
    /\ (exists s : Seq.seq t_Item'0, f : Map.map int int . produces'1 self.t_Filter__iter'0 s succ.t_Filter__iter'0
    /\ (forall i : int, j : int . 0 <= i /\ i <= j /\ j < Seq.length visited
     -> 0 <= Map.get f i /\ Map.get f i <= Map.get f j /\ Map.get f j < Seq.length s)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut'0 self.t_Filter__func'0 (Seq.get s i) self.t_Filter__func'0 true))
  
  goal refines : [%#s17_filter0] forall a : t_Filter'0 . forall ab : Seq.seq t_Item'0 . forall b : t_Filter'0 . forall bc : Seq.seq t_Item'0 . forall c : t_Filter'0 . produces'0 b bc c
  /\ produces'0 a ab b
   -> produces'0 b bc c
  /\ produces'0 a ab b /\ (forall result : () . produces'0 a (Seq.(++) ab bc) c  -> produces'0 a (Seq.(++) ab bc) c)
end
