module M_red_black_tree__qyi11959472507597060150__clone [#"red_black_tree.rs" 12 9 12 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 12 9 12 14
  
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"red_black_tree.rs" 12 9 12 14] (self:t_Color'0) (return'  (ret:t_Color'0))= (! bb0
    [ bb0 = any [ br0 -> {self = C_Red'0} (! bb2) | br1 -> {self = C_Black'0} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- C_Black'0 ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_Red'0 ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : t_Color'0 = Any.any_l () | & self : t_Color'0 = self ] 
    [ return' (result:t_Color'0)-> {[@expl:clone ensures] [%#sred_black_tree0] result = self} (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__model_acc_has_mapping [#"red_black_tree.rs" 69 4 69 83] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree1 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree2 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree3 = "red_black_tree.rs" 37 12 41 13
  
  use map.Map
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'1  =
    | C_None'0
    | C_Some'1 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'1 }
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'0 t_V'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) : Map.map t_DeepModelTy'0 t_Option'0
  
   =
    [%#sred_black_tree2] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc'0 right accu2
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree3] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  constant self  : t_Tree'0
  
  constant accu  : Map.map t_DeepModelTy'0 t_Option'0
  
  constant k  : t_DeepModelTy'0
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
  
  goal vc_model_acc_has_mapping'0 : match self with
    | {t_Tree__node'0 = C_None'0} -> [%#sred_black_tree0] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)
    | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> ([%#sred_black_tree0] Map.get (model_acc'0 left accu) k
    = Map.get accu k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 left accu) k = C_Some'0 v /\ has_mapping'0 left k v))
     -> (let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in ([%#sred_black_tree0] Map.get (model_acc'0 right accu2) k
    = Map.get accu2 k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 right accu2) k = C_Some'0 v /\ has_mapping'0 right k v))
     -> ([%#sred_black_tree0] Map.get (model_acc'0 self accu) k = Map.get accu k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)))
    end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model_acc [#"red_black_tree.rs" 86 4 88 33] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree1 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree2 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree3 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree4 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree5 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree6 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree7 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree8 = "red_black_tree.rs" 215 12 216 104
  let%span sord9 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord10 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord11 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord12 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'1  =
    | C_None'0
    | C_Some'1 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'1 }
  
  type t_DeepModelTy'0
  
  type t_Option'0  =
    | C_None'1
    | C_Some'0 t_V'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree5] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord19] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord20] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord17] cmp_log'0 x y = C_Less'0)
   -> ([%#sord18] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord14] cmp_log'0 x y
  = o)  -> ([%#sord15] cmp_log'0 y z = o)  -> ([%#sord16] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord13] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord12] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord11] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord10] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord9] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree8] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree4] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) : Map.map t_DeepModelTy'0 t_Option'0
  
   =
    [%#sred_black_tree6] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc'0 right accu2
      end
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree7] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'0, k : t_DeepModelTy'0 . [%#sred_black_tree2] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)
  
  constant self  : t_Tree'0
  
  constant accu  : Map.map t_DeepModelTy'0 t_Option'0
  
  constant k  : t_DeepModelTy'0
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
  
  goal vc_has_mapping_model_acc'0 : ([%#sred_black_tree0] bst_invariant'0 self)
   -> match self with
    | {t_Tree__node'0 = C_None'0} -> [%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self k v
     -> Map.get (model_acc'0 self accu) k = C_Some'0 v
    | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> ([@expl:has_mapping_model_acc requires] [%#sred_black_tree0] bst_invariant'0 left)
    /\ (([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 left k v
     -> Map.get (model_acc'0 left accu) k = C_Some'0 v)
     -> (let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in ([@expl:has_mapping_model_acc requires] [%#sred_black_tree0] bst_invariant'0 right)
    /\ (([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 right k v
     -> Map.get (model_acc'0 right accu2) k = C_Some'0 v)
     -> (let _ = has_mapping_model_acc'0 right accu2 k in ([%#sred_black_tree2] Map.get (model_acc'0 right accu2) k
    = Map.get accu2 k
    \/ (exists v : t_V'0 . Map.get (model_acc'0 right accu2) k = C_Some'0 v /\ has_mapping'0 right k v))
     -> ([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self k v
     -> Map.get (model_acc'0 self accu) k = C_Some'0 v)))))
    end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model [#"red_black_tree.rs" 107 4 109 33] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree1 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree2 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree3 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree4 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree5 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree6 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree7 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree8 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree9 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree10 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree11 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree12 = "red_black_tree.rs" 215 12 216 104
  let%span sord13 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord14 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord15 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord16 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  use map.Const
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'1  =
    | C_None'1
    | C_Some'1 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'1 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree7] match self with
      | {t_Tree__node'0 = C_None'1} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord25] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord23] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord24] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord21] cmp_log'0 x y = C_Less'0)
   -> ([%#sord22] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord18] cmp_log'0 x y
  = o)  -> ([%#sord19] cmp_log'0 y z = o)  -> ([%#sord20] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord17] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord16] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord15] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord14] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord13] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree12] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree6] match self with
      | {t_Tree__node'0 = C_None'1} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) : Map.map t_DeepModelTy'0 t_Option'0
  
   =
    [%#sred_black_tree9] match self with
      | {t_Tree__node'0 = C_None'1} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc'0 right accu2
      end
  
  function view'0 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'0 =
    [%#sred_black_tree8] model_acc'0 self (Const.const (C_None'0))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree10] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'0, k : t_DeepModelTy'0 . [%#sred_black_tree2] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree11] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'0, k : t_DeepModelTy'0 . ([%#sred_black_tree3] bst_invariant'0 self)
   -> ([%#sred_black_tree4] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'0 v)
  
  constant self  : t_Tree'0
  
  constant k  : t_DeepModelTy'0
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : ()
  
  goal vc_has_mapping_model'0 : ([%#sred_black_tree0] bst_invariant'0 self)
   -> ([%#sred_black_tree2] Map.get (model_acc'0 self (Const.const (C_None'0))) k = Map.get (Const.const (C_None'0)) k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self (Const.const (C_None'0))) k = C_Some'0 v /\ has_mapping'0 self k v))
   -> (let _ = model_acc_has_mapping'0 self (Const.const (C_None'0)) k in ([@expl:has_mapping_model_acc requires] [%#sred_black_tree3] bst_invariant'0 self)
  /\ (([%#sred_black_tree4] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self (Const.const (C_None'0))) k = C_Some'0 v)
   -> ([%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = C_Some'0 v))))
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_inj [#"red_black_tree.rs" 122 4 124 33] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 118 15 118 35
  let%span sred_black_tree1 = "red_black_tree.rs" 119 15 119 38
  let%span sred_black_tree2 = "red_black_tree.rs" 120 15 120 38
  let%span sred_black_tree3 = "red_black_tree.rs" 121 14 121 22
  let%span sred_black_tree4 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree5 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree6 = "red_black_tree.rs" 127 12 127 37
  let%span sred_black_tree7 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree8 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree9 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree10 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree11 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree12 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree13 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree14 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree15 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree16 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree17 = "red_black_tree.rs" 91 12 100 13
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord26 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord27 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord28 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord29 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord30 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  use map.Const
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'1  =
    | C_None'1
    | C_Some'1 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'1 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree8] match self with
      | {t_Tree__node'0 = C_None'1} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord30] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord28] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord29] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord26] cmp_log'0 x y = C_Less'0)
   -> ([%#sord27] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord23] cmp_log'0 x y
  = o)  -> ([%#sord24] cmp_log'0 y z = o)  -> ([%#sord25] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord22] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord18] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree11] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree7] match self with
      | {t_Tree__node'0 = C_None'1} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) : Map.map t_DeepModelTy'0 t_Option'0
  
   =
    [%#sred_black_tree12] match self with
      | {t_Tree__node'0 = C_None'1} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc'0 right accu2
      end
  
  function view'0 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'0 =
    [%#sred_black_tree9] model_acc'0 self (Const.const (C_None'0))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree14] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'0, k : t_DeepModelTy'0 . [%#sred_black_tree13] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'0) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree17] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'0, k : t_DeepModelTy'0 . ([%#sred_black_tree15] bst_invariant'0 self)
   -> ([%#sred_black_tree16] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'0 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree10] let _ = model_acc_has_mapping'0 self (Const.const (C_None'0)) k in has_mapping_model_acc'0 self (Const.const (C_None'0)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree4] bst_invariant'0 self)
   -> ([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = C_Some'0 v))
  
  constant self  : t_Tree'0
  
  constant k  : t_DeepModelTy'0
  
  constant v1  : t_V'0
  
  constant v2  : t_V'0
  
  function has_mapping_inj'0 [#"red_black_tree.rs" 122 4 124 33] (self : t_Tree'0) (k : t_DeepModelTy'0) (v1 : t_V'0) (v2 : t_V'0) : ()
  
  
  goal vc_has_mapping_inj'0 : ([%#sred_black_tree0] bst_invariant'0 self)
   -> ([%#sred_black_tree1] has_mapping'0 self k v1)
   -> ([%#sred_black_tree2] has_mapping'0 self k v2)
   -> ([@expl:has_mapping_model requires] [%#sred_black_tree4] bst_invariant'0 self)
  /\ (([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = C_Some'0 v))
   -> (let _ = has_mapping_model'0 self k in match Map.get (view'0 self) k with
    | C_None'0 -> [%#sred_black_tree3] v1 = v2
    | C_Some'0 _v -> [%#sred_black_tree3] v1 = v2
    end))
end
module M_red_black_tree__qyi3665871523867809084__has_mapping [#"red_black_tree.rs" 137 4 137 57] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree1 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree2 = "red_black_tree.rs" 37 12 41 13
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree2] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  constant self  : t_Node'0
  
  constant k  : t_DeepModelTy'0
  
  constant v  : t_V'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0)
  
  goal vc_has_mapping'0 : if has_mapping'1 self.t_Node__left'0 k v then
    [%#sred_black_tree0] forall node : t_Node'0 . self = node
     -> true = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  else
    if has_mapping'1 self.t_Node__right'0 k v then
      [%#sred_black_tree0] forall node : t_Node'0 . self = node
       -> true = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
    else
      if k = deep_model'0 self.t_Node__key'0 then
        [%#sred_black_tree0] forall node : t_Node'0 . self = node
         -> (v = self.t_Node__val'0) = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
      else
        [%#sred_black_tree0] forall node : t_Node'0 . self = node
         -> false = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
    
  

end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence [#"red_black_tree.rs" 187 4 187 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 185 15 185 39
  let%span sred_black_tree1 = "red_black_tree.rs" 186 14 186 31
  let%span sred_black_tree2 = "red_black_tree.rs" 187 32 187 34
  let%span sred_black_tree3 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree4 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sresolve6 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sred_black_tree7 = "red_black_tree.rs" 195 12 195 69
  let%span sred_black_tree8 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree9 = "red_black_tree.rs" 138 8 141 9
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree4] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree9] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree8] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate resolve'2 (_1 : t_V'0)
  
  predicate resolve'7 [#"red_black_tree.rs" 193 4 193 28] (self : t_Node'0) =
    [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'6 (_1 : t_Node'0) =
    resolve'7 _1
  
  predicate resolve'5 (self : t_Node'0) =
    [%#sresolve6] resolve'6 self
  
  predicate resolve'4 (_1 : t_Node'0) =
    resolve'5 _1
  
  predicate resolve'3 (self : t_Option'0) =
    [%#sresolve5] match self with
      | C_Some'0 x -> resolve'4 x
      | C_None'0 -> true
      end
  
  predicate resolve'1 (_1 : t_Option'0) =
    resolve'3 _1
  
  predicate structural_resolve'0 (_1 : t_Tree'0) =
    match _1 with
      | {t_Tree__node'0 = x0} -> resolve'1 x0
      end
  
  predicate resolve'0 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree3] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  constant self  : t_Tree'0
  
  function resolve_coherence'0 [#"red_black_tree.rs" 187 4 187 31] (self : t_Tree'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sred_black_tree0] structural_resolve'0 self)
   -> ([%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence [#"red_black_tree.rs" 203 4 203 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 201 15 201 39
  let%span sred_black_tree1 = "red_black_tree.rs" 202 14 202 31
  let%span sred_black_tree2 = "red_black_tree.rs" 203 32 203 34
  let%span sred_black_tree3 = "red_black_tree.rs" 195 12 195 69
  let%span sred_black_tree4 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree5 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree6 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree7 = "red_black_tree.rs" 37 12 41 13
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree7] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'2 (_1 : t_V'0)
  
  predicate resolve'5 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'1 (_1 : t_Tree'0) =
    resolve'5 _1
  
  predicate resolve'3 (_1 : t_K'0)
  
  predicate resolve'4 (_1 : t_Color'0) =
    true
  
  predicate structural_resolve'0 (_1 : t_Node'0) =
    match _1 with
      | {t_Node__left'0 = x0 ; t_Node__color'0 = x1 ; t_Node__key'0 = x2 ; t_Node__val'0 = x3 ; t_Node__right'0 = x4} -> resolve'1 x4
      /\ resolve'2 x3 /\ resolve'3 x2 /\ resolve'4 x1 /\ resolve'1 x0
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree5] has_mapping'1 self.t_Node__left'0 k v
    \/ has_mapping'1 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'0_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree4] forall node : t_Node'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate resolve'0 [#"red_black_tree.rs" 193 4 193 28] (self : t_Node'0) =
    [%#sred_black_tree3] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  constant self  : t_Node'0
  
  function resolve_coherence'0 [#"red_black_tree.rs" 203 4 203 31] (self : t_Node'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sred_black_tree0] structural_resolve'0 self)
   -> ([%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi3529752165842986389__height [#"red_black_tree.rs" 325 4 325 26] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree1 = "red_black_tree.rs" 327 12 335 13
  
  use mach.int.Int
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  constant self  : t_Tree'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int
  
  goal vc_height'0 : match self with
    | {t_Tree__node'0 = C_None'0} -> [%#sred_black_tree0] 0 >= 0
    | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
      | C_Red'0 -> ([%#sred_black_tree0] height'0 left >= 0)  -> ([%#sred_black_tree0] height'0 left >= 0)
      | C_Black'0 -> ([%#sred_black_tree0] height'0 left >= 0)  -> ([%#sred_black_tree0] height'0 left + 1 >= 0)
      end
    end
end
module M_red_black_tree__qyi3665871523867809084__height [#"red_black_tree.rs" 357 4 357 26] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree1 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree2 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree3 = "red_black_tree.rs" 327 12 335 13
  
  use mach.int.Int
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree3] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree1] height'1 self >= 0
  
  constant self  : t_Node'0
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int
  
  goal vc_height'0 : match self.t_Node__color'0 with
    | C_Red'0 -> ([%#sred_black_tree1] height'1 self.t_Node__left'0 >= 0)
     -> ([%#sred_black_tree0] forall node : t_Node'0 . self = node
     -> height'1 self.t_Node__left'0 = height'1 { t_Tree__node'0 = C_Some'0 node })
    | C_Black'0 -> ([%#sred_black_tree1] height'1 self.t_Node__left'0 >= 0)
     -> ([%#sred_black_tree0] forall node : t_Node'0 . self = node
     -> height'1 self.t_Node__left'0 + 1 = height'1 { t_Tree__node'0 = C_Some'0 node })
    end
end
module M_red_black_tree__qyi3529752165842986389__is_red [#"red_black_tree.rs" 412 4 412 28] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 415 17 415 22
  let%span sred_black_tree1 = "red_black_tree.rs" 414 49 414 53
  let%span sred_black_tree2 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree3 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree4 = "red_black_tree.rs" 287 12 290 13
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed6 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate inv'5 (_1 : t_K'0)
  
  predicate inv'6 (_1 : t_V'0)
  
  predicate inv'4 (_1 : t_Node'0)
  
  predicate inv'1 (_1 : t_Tree'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'1 left
    /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  predicate invariant'1 (self : t_Node'0) =
    [%#sboxed6] inv'4 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Tree'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'2 node
    end
  
  predicate invariant'0 (self : t_Tree'0) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'0 (_1 : t_Tree'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Tree'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree4] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  meta "compute_max_steps" 1000000
  
  let rec is_red'0[#"red_black_tree.rs" 412 4 412 28] (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree2] inv'0 self}
    (! bb0
    [ bb0 = any
      [ br0 -> {self.t_Tree__node'0 = C_None'0} (! bb6)
      | br1 (x0:t_Node'0)-> {self.t_Tree__node'0 = C_Some'0 x0} (! bb2) ]
    
    | bb6 = bb1
    | bb2 = v_Some'0 {self.t_Tree__node'0}
        (fun (r0'0:t_Node'0) ->
          any [ br0 -> {r0'0.t_Node__color'0 = C_Red'0} (! bb3) | br1 -> {r0'0.t_Node__color'0 = C_Black'0} (! bb1) ] )
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree0] false ] s1 | s1 = bb5 ] 
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree1] true ] s1 | s1 = bb5 ] 
    | bb5 = return' {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self : t_Tree'0 = self ] 
    [ return' (result:bool)-> {[@expl:is_red ensures] [%#sred_black_tree3] result = (color'0 self = C_Red'0)}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__rotate_right [#"red_black_tree.rs" 436 4 436 30] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 437 23 437 41
  let%span sred_black_tree1 = "red_black_tree.rs" 465 8 465 90
  let%span sred_black_tree2 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree3 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree4 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree5 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree6 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree7 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree8 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree9 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree10 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree11 = "red_black_tree.rs" 432 14 435 34
  let%span smem12 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem13 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span smem16 = "../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem17 = "../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree18 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree19 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree20 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree21 = "red_black_tree.rs" 147 12 147 89
  let%span sred_black_tree22 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree23 = "red_black_tree.rs" 359 12 362 13
  let%span soption24 = "../../creusot-contracts/src/std/option.rs" 429 20 429 32
  let%span sresolve25 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree26 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree27 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree28 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree29 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree30 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree31 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree32 = "red_black_tree.rs" 327 12 335 13
  let%span sord33 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord34 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord35 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord36 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord37 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord38 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord39 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord40 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord41 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord42 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord43 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord44 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant46 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed47 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sred_black_tree48 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree49 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree50 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree51 = "red_black_tree.rs" 342 12 348 13
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'9 (_1 : t_K'0)
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'2 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Tree'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'4 (_1 : t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'2 left
    /\ inv'9 key /\ inv'10 val' /\ inv'2 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed47] inv'4 self
  
  predicate inv'5 (_1 : t_Node'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Node'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate invariant'0 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant46] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate is_default'0 (self : t_Option'0) =
    [%#soption24] self = C_None'0
  
  let rec take'0 (dest:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'dest' type invariant] inv'1 dest}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem12] result = dest.current}
      {[%#smem13] is_default'0 dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t t_Option'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'0}
    any [ return' (result:t_Node'0)-> {inv'5 result} {[%#soption15] C_Some'0 result = self} (! return' {result}) ] 
  
  predicate invariant'1 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant46] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  let rec swap'0 (x:MutBorrow.t t_Tree'0) (y:MutBorrow.t t_Tree'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'3 x}
    {[@expl:swap 'y' type invariant] inv'3 y}
    any
    [ return' (result:())-> {[%#smem16] x.final = y.current} {[%#smem17] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'7 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Tree'0) =
    resolve'7 _1
  
  predicate invariant'4 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant46] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  let rec swap'1 (x:MutBorrow.t t_Node'0) (y:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'7 x}
    {[@expl:swap 'y' type invariant] inv'7 y}
    any
    [ return' (result:())-> {[%#smem16] x.final = y.current} {[%#smem17] y.final = x.current} (! return' {result}) ]
  
  
  predicate invariant'3 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant46] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate resolve'8 (self : MutBorrow.t t_Node'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Node'0) =
    resolve'8 _1
  
  predicate inv'8 (_1 : MutBorrow.t t_Color'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Color'0 [inv'8 x] . inv'8 x = true
  
  let rec swap'2 (x:MutBorrow.t t_Color'0) (y:MutBorrow.t t_Color'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'8 x}
    {[@expl:swap 'y' type invariant] inv'8 y}
    any
    [ return' (result:())-> {[%#smem16] x.final = y.current} {[%#smem17] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'9 (self : MutBorrow.t t_Color'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_Color'0) =
    resolve'9 _1
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree18] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'12 (_1 : t_V'0)
  
  predicate resolve'10 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree26] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'12 v
  
  predicate resolve'4 (_1 : t_Tree'0) =
    resolve'10 _1
  
  predicate resolve'11 (self : MutBorrow.t t_Node'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_Node'0) =
    resolve'11 _1
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord43] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord44] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord41] cmp_log'0 x y = C_Less'0)
   -> ([%#sord42] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord38] cmp_log'0 x y
  = o)  -> ([%#sord39] cmp_log'0 y z = o)  -> ([%#sord40] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord37] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord36] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord35] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord34] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord33] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree48] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree49] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree27] bst_invariant_here'0 self
    /\ bst_invariant'1 self.t_Node__left'0 /\ bst_invariant'1 self.t_Node__right'0
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree32] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree31] height'1 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree50] height'1 self.t_Node__left'0 = height'1 self.t_Node__right'0
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree51] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree28] height_invariant_here'0 self
    /\ height_invariant'1 self.t_Node__left'0 /\ height_invariant'1 self.t_Node__right'0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree19] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree20] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree30] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree29] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree21] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree23] match self.t_Node__color'0 with
      | C_Red'0 -> height'1 self.t_Node__left'0
      | C_Black'0 -> height'1 self.t_Node__left'0 + 1
      end
  
  axiom height'0_spec : forall self : t_Node'0 . [%#sred_black_tree22] forall node : t_Node'0 . self = node
   -> height'0 self = height'1 { t_Tree__node'0 = C_Some'0 node }
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_right'0[#"red_black_tree.rs" 436 4 436 30] (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree2] inv'7 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree3] internal_invariant'0 self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree4] color'0 (self.current).t_Node__left'0 = C_Red'0}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 ((self.current).t_Node__left'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Node__left'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__left'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = {inv'0 _16.current}
        MutBorrow.borrow_final <t_Option'0> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_16 <- { _16 with current = _ret'.final } ] 
            s2)
      | s2 = take'0 {_15} (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':t_Node'0) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'2 (self.current).t_Node__left'0}
        MutBorrow.borrow_mut <t_Tree'0> {(self.current).t_Node__left'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_19 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_Node__left'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'2 _19.current}
        MutBorrow.borrow_final <t_Tree'0> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_18 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_19 <- { _19 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'2 x.t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {x.t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_21 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &x <- { x with t_Node__right'0 = _ret'.final } ] 
            s3)
      | s3 = {inv'2 _21.current}
        MutBorrow.borrow_final <t_Tree'0> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_20 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_21 <- { _21 with current = _ret'.final } ] 
            s4)
      | s4 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s5)
      | s5 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'3 _21} s1
      | s1 = -{resolve'1 _21}- s2
      | s2 = {[@expl:type invariant] inv'3 _19} s3
      | s3 = -{resolve'1 _19}- s4
      | s4 = {inv'4 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_23 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s5)
      | s5 = {inv'5 x}
        MutBorrow.borrow_mut <t_Node'0> {x}
          (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_25 <- _ret' ] -{inv'5 _ret'.final}-  [ &x <- _ret'.final ] s6)
      | s6 = {inv'4 _25.current}
        MutBorrow.borrow_final <t_Node'0> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_24 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_25 <- { _25 with current = _ret'.final } ] 
            s7)
      | s7 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s8)
      | s8 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = MutBorrow.borrow_final
          <t_Color'0>
          {(self.current).t_Node__color'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Color'0) ->
             [ &_28 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Node__color'0 = _ret'.final } } ] 
            s3)
      | s3 = MutBorrow.borrow_final <t_Color'0> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret':MutBorrow.t t_Color'0) ->  [ &_27 <- _ret' ]  [ &_28 <- { _28 with current = _ret'.final } ] s4)
      | s4 = MutBorrow.borrow_mut <t_Color'0> {x.t_Node__color'0}
          (fun (_ret':MutBorrow.t t_Color'0) ->
             [ &_30 <- _ret' ] 
             [ &x <- { x with t_Node__color'0 = _ret'.final } ] 
            s5)
      | s5 = MutBorrow.borrow_final <t_Color'0> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret':MutBorrow.t t_Color'0) ->  [ &_29 <- _ret' ]  [ &_30 <- { _30 with current = _ret'.final } ] s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
    
    | bb6 = s0
      [ s0 = -{resolve'3 _30}- s1
      | s1 = -{resolve'3 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree1] has_mapping'0 (old_self.current).t_Node__left'0 (deep_model'0 (self.current).t_Node__key'0) (self.current).t_Node__val'0}
        s3
      | s3 =  [ &_34 <- C_Some'0 x ] s4
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &_33 <- { t_Tree__node'0 = _34 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = {t_Node__right'0 = x'0}} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = {t_Node__right'0 = x'1}} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self <- { self with current = { self.current with t_Node__right'0 = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'5 self}- s5
      | s5 = bb11 ]
    
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Node'0 = self
    | & old_self : MutBorrow.t t_Node'0 = Any.any_l ()
    | & x : t_Node'0 = Any.any_l ()
    | & _14 : t_Option'0 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _18 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _19 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _22 : () = Any.any_l ()
    | & _23 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _25 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _27 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _28 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _29 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _30 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _33 : t_Tree'0 = Any.any_l ()
    | & _34 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:rotate_right ensures #0] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      {[@expl:rotate_right ensures #1] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:rotate_right ensures #2] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:rotate_right ensures #3] [%#sred_black_tree8] lt_log'0 (deep_model'0 (self.final).t_Node__key'0) (deep_model'0 (self.current).t_Node__key'0)}
      {[@expl:rotate_right ensures #4] [%#sred_black_tree9] color'0 (self.final).t_Node__right'0 = C_Red'0}
      {[@expl:rotate_right ensures #5] [%#sred_black_tree10] (self.final).t_Node__color'0
      = (self.current).t_Node__color'0}
      {[@expl:rotate_right ensures #6] [%#sred_black_tree11] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r
      /\ ((self.final).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      = (l.t_Node__left'0, l.t_Node__right'0, (self.current).t_Node__right'0)
      /\ r.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__rotate_left [#"red_black_tree.rs" 486 4 486 29] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 487 23 487 41
  let%span sred_black_tree1 = "red_black_tree.rs" 492 8 492 91
  let%span sred_black_tree2 = "red_black_tree.rs" 486 24 486 28
  let%span sred_black_tree3 = "red_black_tree.rs" 474 15 474 43
  let%span sred_black_tree4 = "red_black_tree.rs" 475 15 475 43
  let%span sred_black_tree5 = "red_black_tree.rs" 476 14 476 42
  let%span sred_black_tree6 = "red_black_tree.rs" 477 14 477 42
  let%span sred_black_tree7 = "red_black_tree.rs" 478 14 478 50
  let%span sred_black_tree8 = "red_black_tree.rs" 479 14 479 65
  let%span sred_black_tree9 = "red_black_tree.rs" 480 14 480 41
  let%span sred_black_tree10 = "red_black_tree.rs" 481 14 481 44
  let%span sred_black_tree11 = "red_black_tree.rs" 482 14 485 34
  let%span smem12 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem13 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span smem16 = "../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem17 = "../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree18 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree19 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree20 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree21 = "red_black_tree.rs" 147 12 147 89
  let%span sred_black_tree22 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree23 = "red_black_tree.rs" 359 12 362 13
  let%span soption24 = "../../creusot-contracts/src/std/option.rs" 429 20 429 32
  let%span sresolve25 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree26 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree27 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree28 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree29 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree30 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree31 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree32 = "red_black_tree.rs" 327 12 335 13
  let%span sord33 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord34 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord35 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord36 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord37 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord38 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord39 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord40 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord41 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord42 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord43 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord44 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant46 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed47 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sred_black_tree48 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree49 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree50 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree51 = "red_black_tree.rs" 342 12 348 13
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'9 (_1 : t_K'0)
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'2 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Tree'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'4 (_1 : t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'2 left
    /\ inv'9 key /\ inv'10 val' /\ inv'2 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed47] inv'4 self
  
  predicate inv'5 (_1 : t_Node'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Node'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  predicate invariant'0 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant46] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate is_default'0 (self : t_Option'0) =
    [%#soption24] self = C_None'0
  
  let rec take'0 (dest:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'dest' type invariant] inv'1 dest}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem12] result = dest.current}
      {[%#smem13] is_default'0 dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t t_Option'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'0}
    any [ return' (result:t_Node'0)-> {inv'5 result} {[%#soption15] C_Some'0 result = self} (! return' {result}) ] 
  
  predicate invariant'1 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant46] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  let rec swap'0 (x:MutBorrow.t t_Tree'0) (y:MutBorrow.t t_Tree'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'3 x}
    {[@expl:swap 'y' type invariant] inv'3 y}
    any
    [ return' (result:())-> {[%#smem16] x.final = y.current} {[%#smem17] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'7 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Tree'0) =
    resolve'7 _1
  
  predicate invariant'4 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant46] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  let rec swap'1 (x:MutBorrow.t t_Node'0) (y:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'7 x}
    {[@expl:swap 'y' type invariant] inv'7 y}
    any
    [ return' (result:())-> {[%#smem16] x.final = y.current} {[%#smem17] y.final = x.current} (! return' {result}) ]
  
  
  predicate invariant'3 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant46] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate resolve'8 (self : MutBorrow.t t_Node'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Node'0) =
    resolve'8 _1
  
  predicate inv'8 (_1 : MutBorrow.t t_Color'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Color'0 [inv'8 x] . inv'8 x = true
  
  let rec swap'2 (x:MutBorrow.t t_Color'0) (y:MutBorrow.t t_Color'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'8 x}
    {[@expl:swap 'y' type invariant] inv'8 y}
    any
    [ return' (result:())-> {[%#smem16] x.final = y.current} {[%#smem17] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'9 (self : MutBorrow.t t_Color'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_Color'0) =
    resolve'9 _1
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree18] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'12 (_1 : t_V'0)
  
  predicate resolve'10 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree26] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'12 v
  
  predicate resolve'4 (_1 : t_Tree'0) =
    resolve'10 _1
  
  predicate resolve'11 (self : MutBorrow.t t_Node'0) =
    [%#sresolve25] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_Node'0) =
    resolve'11 _1
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord43] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord44] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord41] cmp_log'0 x y = C_Less'0)
   -> ([%#sord42] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord38] cmp_log'0 x y
  = o)  -> ([%#sord39] cmp_log'0 y z = o)  -> ([%#sord40] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord37] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord36] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord35] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord34] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord33] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree48] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree49] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree27] bst_invariant_here'0 self
    /\ bst_invariant'1 self.t_Node__left'0 /\ bst_invariant'1 self.t_Node__right'0
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree32] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree31] height'1 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree50] height'1 self.t_Node__left'0 = height'1 self.t_Node__right'0
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree51] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree28] height_invariant_here'0 self
    /\ height_invariant'1 self.t_Node__left'0 /\ height_invariant'1 self.t_Node__right'0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree19] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree20] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree30] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree29] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree21] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree23] match self.t_Node__color'0 with
      | C_Red'0 -> height'1 self.t_Node__left'0
      | C_Black'0 -> height'1 self.t_Node__left'0 + 1
      end
  
  axiom height'0_spec : forall self : t_Node'0 . [%#sred_black_tree22] forall node : t_Node'0 . self = node
   -> height'0 self = height'1 { t_Tree__node'0 = C_Some'0 node }
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_left'0[#"red_black_tree.rs" 486 4 486 29] (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree2] inv'7 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree3] internal_invariant'0 self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree4] color'0 (self.current).t_Node__right'0 = C_Red'0}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 ((self.current).t_Node__right'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Node__right'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__right'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = {inv'0 _16.current}
        MutBorrow.borrow_final <t_Option'0> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_16 <- { _16 with current = _ret'.final } ] 
            s2)
      | s2 = take'0 {_15} (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 _16} s1
      | s1 = -{resolve'0 _16}- s2
      | s2 = unwrap'0 {_14} (fun (_ret':t_Node'0) ->  [ &x <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'2 (self.current).t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {(self.current).t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_19 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_Node__right'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'2 _19.current}
        MutBorrow.borrow_final <t_Tree'0> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_18 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_19 <- { _19 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'2 x.t_Node__left'0}
        MutBorrow.borrow_mut <t_Tree'0> {x.t_Node__left'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_21 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &x <- { x with t_Node__left'0 = _ret'.final } ] 
            s3)
      | s3 = {inv'2 _21.current}
        MutBorrow.borrow_final <t_Tree'0> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_20 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_21 <- { _21 with current = _ret'.final } ] 
            s4)
      | s4 = swap'0 {_18} {_20} (fun (_ret':()) ->  [ &_17 <- _ret' ] s5)
      | s5 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'3 _21} s1
      | s1 = -{resolve'1 _21}- s2
      | s2 = {[@expl:type invariant] inv'3 _19} s3
      | s3 = -{resolve'1 _19}- s4
      | s4 = {inv'4 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_23 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s5)
      | s5 = {inv'5 x}
        MutBorrow.borrow_mut <t_Node'0> {x}
          (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_25 <- _ret' ] -{inv'5 _ret'.final}-  [ &x <- _ret'.final ] s6)
      | s6 = {inv'4 _25.current}
        MutBorrow.borrow_final <t_Node'0> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_24 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_25 <- { _25 with current = _ret'.final } ] 
            s7)
      | s7 = swap'1 {_23} {_24} (fun (_ret':()) ->  [ &_22 <- _ret' ] s8)
      | s8 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _25} s1
      | s1 = -{resolve'2 _25}- s2
      | s2 = MutBorrow.borrow_final
          <t_Color'0>
          {(self.current).t_Node__color'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Color'0) ->
             [ &_28 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Node__color'0 = _ret'.final } } ] 
            s3)
      | s3 = MutBorrow.borrow_final <t_Color'0> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret':MutBorrow.t t_Color'0) ->  [ &_27 <- _ret' ]  [ &_28 <- { _28 with current = _ret'.final } ] s4)
      | s4 = MutBorrow.borrow_mut <t_Color'0> {x.t_Node__color'0}
          (fun (_ret':MutBorrow.t t_Color'0) ->
             [ &_30 <- _ret' ] 
             [ &x <- { x with t_Node__color'0 = _ret'.final } ] 
            s5)
      | s5 = MutBorrow.borrow_final <t_Color'0> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret':MutBorrow.t t_Color'0) ->  [ &_29 <- _ret' ]  [ &_30 <- { _30 with current = _ret'.final } ] s6)
      | s6 = swap'2 {_27} {_29} (fun (_ret':()) ->  [ &_26 <- _ret' ] s7)
      | s7 = bb6 ]
    
    | bb6 = s0
      [ s0 = -{resolve'3 _30}- s1
      | s1 = -{resolve'3 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree1] has_mapping'0 (old_self.current).t_Node__right'0 (deep_model'0 (self.current).t_Node__key'0) (self.current).t_Node__val'0}
        s3
      | s3 =  [ &_34 <- C_Some'0 x ] s4
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &_33 <- { t_Tree__node'0 = _34 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = {t_Node__left'0 = x'0}} -> inv'2 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = {t_Node__left'0 = x'1}} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self <- { self with current = { self.current with t_Node__left'0 = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self} s4
      | s4 = -{resolve'5 self}- s5
      | s5 = bb11 ]
    
    | bb11 = bb12
    | bb12 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Node'0 = self
    | & old_self : MutBorrow.t t_Node'0 = Any.any_l ()
    | & x : t_Node'0 = Any.any_l ()
    | & _14 : t_Option'0 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _18 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _19 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _22 : () = Any.any_l ()
    | & _23 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _25 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _27 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _28 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _29 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _30 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _33 : t_Tree'0 = Any.any_l ()
    | & _34 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:rotate_left ensures #0] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      {[@expl:rotate_left ensures #1] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:rotate_left ensures #2] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:rotate_left ensures #3] [%#sred_black_tree8] lt_log'0 (deep_model'0 (self.current).t_Node__key'0) (deep_model'0 (self.final).t_Node__key'0)}
      {[@expl:rotate_left ensures #4] [%#sred_black_tree9] color'0 (self.final).t_Node__left'0 = C_Red'0}
      {[@expl:rotate_left ensures #5] [%#sred_black_tree10] (self.final).t_Node__color'0
      = (self.current).t_Node__color'0}
      {[@expl:rotate_left ensures #6] [%#sred_black_tree11] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l
      /\ (l.t_Node__left'0, l.t_Node__right'0, (self.final).t_Node__right'0)
      = ((self.current).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      /\ l.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__flip_colors [#"red_black_tree.rs" 510 4 510 29] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree1 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree2 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree3 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree4 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree5 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree6 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree7 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree8 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree9 = "red_black_tree.rs" 504 14 506 68
  let%span sred_black_tree10 = "red_black_tree.rs" 507 14 509 88
  let%span soption11 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span smem15 = "../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem16 = "../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree17 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree18 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree19 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree20 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree21 = "red_black_tree.rs" 147 12 147 89
  let%span sresolve22 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree23 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree24 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree25 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree26 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree27 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree28 = "red_black_tree.rs" 138 8 141 9
  let%span sinvariant29 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree30 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree31 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree32 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree33 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree34 = "red_black_tree.rs" 37 12 41 13
  let%span sboxed35 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sord36 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord37 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord38 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord39 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord40 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord41 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord42 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord43 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord44 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord46 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord47 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord48 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'9 (_1 : t_K'0)
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'8 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Tree'0 [inv'8 x] . inv'8 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'7 (_1 : t_Node'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Node'0 [inv'7 x] . inv'7 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'8 left
    /\ inv'9 key /\ inv'10 val' /\ inv'8 right
    end
  
  predicate invariant'3 (self : t_Node'0) =
    [%#sboxed35] inv'7 self
  
  predicate inv'6 (_1 : t_Node'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Node'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_Node'0)
  
  predicate invariant'2 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant29] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'0 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant29] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate inv'4 (_1 : t_Option'1)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'1 [inv'4 x] . inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'1 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Option'1)-> {inv'4 result}
      {[%#soption11] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption12] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'4 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'1 result}
      {[%#soption14] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t t_Node'0) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'3 _1
  
  predicate inv'5 (_1 : MutBorrow.t t_Color'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_Color'0 [inv'5 x] . inv'5 x = true
  
  let rec swap'0 (x:MutBorrow.t t_Color'0) (y:MutBorrow.t t_Color'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'5 x}
    {[@expl:swap 'y' type invariant] inv'5 y}
    any
    [ return' (result:())-> {[%#smem15] x.final = y.current} {[%#smem16] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'4 (self : MutBorrow.t t_Color'0) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Color'0) =
    resolve'4 _1
  
  predicate invariant'1 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant29] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'5 (self : MutBorrow.t t_Node'0) =
    [%#sresolve22] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Node'0) =
    resolve'5 _1
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree34] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord48] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord46] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord47] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord44] cmp_log'0 x y = C_Less'0)
   -> ([%#sord45] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord41] cmp_log'0 x y
  = o)  -> ([%#sord42] cmp_log'0 y z = o)  -> ([%#sord43] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord40] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord39] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord38] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord37] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord36] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree30] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree31] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree23] bst_invariant_here'0 self
    /\ bst_invariant'1 self.t_Node__left'0 /\ bst_invariant'1 self.t_Node__right'0
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree26] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree25] height'1 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree32] height'1 self.t_Node__left'0 = height'1 self.t_Node__right'0
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree33] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree24] height_invariant_here'0 self
    /\ height_invariant'1 self.t_Node__left'0 /\ height_invariant'1 self.t_Node__right'0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree17] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree18] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree20] match self.t_Node__color'0 with
      | C_Red'0 -> height'1 self.t_Node__left'0
      | C_Black'0 -> height'1 self.t_Node__left'0 + 1
      end
  
  axiom height'0_spec : forall self : t_Node'0 . [%#sred_black_tree19] forall node : t_Node'0 . self = node
   -> height'0 self = height'1 { t_Tree__node'0 = C_Some'0 node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree28] has_mapping'1 self.t_Node__left'0 k v
    \/ has_mapping'1 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'0_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree27] forall node : t_Node'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree21] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  meta "compute_max_steps" 1000000
  
  let rec flip_colors'0[#"red_black_tree.rs" 510 4 510 29] (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree0] inv'2 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree1] internal_invariant'0 self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree2] ((self.current).t_Node__left'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #2] [%#sred_black_tree3] ((self.current).t_Node__right'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #3] [%#sred_black_tree4] color'0 (self.current).t_Node__left'0
    = color'0 (self.current).t_Node__right'0}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 ((self.current).t_Node__left'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Node__left'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__left'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':t_Option'1) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_13 <- { _13 with current = { _13.current with t_Node__color'0 = (self.current).t_Node__color'0 } } ] 
        s1
      | s1 = {[@expl:type invariant] inv'1 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = MutBorrow.borrow_final
          <t_Color'0>
          {(self.current).t_Node__color'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Color'0) ->
             [ &_18 <- _ret' ] 
             [ &self <- { self with current = { self.current with t_Node__color'0 = _ret'.final } } ] 
            s4)
      | s4 = MutBorrow.borrow_final <t_Color'0> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret':MutBorrow.t t_Color'0) ->  [ &_17 <- _ret' ]  [ &_18 <- { _18 with current = _ret'.final } ] s5)
      | s5 = {inv'0 ((self.current).t_Node__right'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Node__right'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_23 <- _ret' ] 
            -{inv'0 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__right'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s6)
      | s6 = as_mut'0 {_23} (fun (_ret':t_Option'1) ->  [ &_22 <- _ret' ] s7)
      | s7 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_22} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = MutBorrow.borrow_final
          <t_Color'0>
          {(_21.current).t_Node__color'0}
          {MutBorrow.inherit_id (MutBorrow.get_id _21) 2}
          (fun (_ret':MutBorrow.t t_Color'0) ->
             [ &_20 <- _ret' ] 
             [ &_21 <- { _21 with current = { _21.current with t_Node__color'0 = _ret'.final } } ] 
            s1)
      | s1 = MutBorrow.borrow_final <t_Color'0> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret':MutBorrow.t t_Color'0) ->  [ &_19 <- _ret' ]  [ &_20 <- { _20 with current = _ret'.final } ] s2)
      | s2 = swap'0 {_17} {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'1 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'1 _20}- s3
      | s3 = -{resolve'1 _18}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 = return' {_0} ]
     ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Node'0 = self
    | & _13 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _14 : t_Option'1 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _16 : () = Any.any_l ()
    | & _17 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _18 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _19 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Color'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _22 : t_Option'1 = Any.any_l ()
    | & _23 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:flip_colors ensures #0] [%#sred_black_tree5] internal_invariant'0 self.final}
      {[@expl:flip_colors ensures #1] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:flip_colors ensures #2] [%#sred_black_tree7] same_mappings'0 self.current self.final}
      {[@expl:flip_colors ensures #3] [%#sred_black_tree8] (self.current).t_Node__key'0 = (self.final).t_Node__key'0}
      {[@expl:flip_colors ensures #4] [%#sred_black_tree9] exists l1 : t_Node'0, l2 : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l1
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l2
      /\ l1.t_Node__left'0 = l2.t_Node__left'0
      /\ l1.t_Node__right'0 = l2.t_Node__right'0
      /\ l1.t_Node__key'0 = l2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = l2.t_Node__color'0 /\ (self.final).t_Node__color'0 = l1.t_Node__color'0}
      {[@expl:flip_colors ensures #5] [%#sred_black_tree10] exists r1 : t_Node'0, r2 : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r1
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r2
      /\ r1.t_Node__left'0 = r2.t_Node__left'0
      /\ r1.t_Node__right'0 = r2.t_Node__right'0
      /\ r1.t_Node__key'0 = r2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = r2.t_Node__color'0
      /\ (self.final).t_Node__color'0 = r1.t_Node__color'0 /\ r1.t_Node__key'0 = r2.t_Node__key'0}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__balance [#"red_black_tree.rs" 534 4 534 25] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree1 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree2 = "red_black_tree.rs" 516 15 517 45
  let%span sred_black_tree3 = "red_black_tree.rs" 518 15 519 46
  let%span sred_black_tree4 = "red_black_tree.rs" 520 15 520 108
  let%span sred_black_tree5 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree6 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree7 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree8 = "red_black_tree.rs" 524 14 525 32
  let%span sred_black_tree9 = "red_black_tree.rs" 526 14 527 37
  let%span sred_black_tree10 = "red_black_tree.rs" 528 14 529 61
  let%span sred_black_tree11 = "red_black_tree.rs" 530 14 531 59
  let%span sred_black_tree12 = "red_black_tree.rs" 532 14 533 37
  let%span sred_black_tree13 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree14 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree15 = "red_black_tree.rs" 486 24 486 28
  let%span sred_black_tree16 = "red_black_tree.rs" 474 15 474 43
  let%span sred_black_tree17 = "red_black_tree.rs" 475 15 475 43
  let%span sred_black_tree18 = "red_black_tree.rs" 476 14 476 42
  let%span sred_black_tree19 = "red_black_tree.rs" 477 14 477 42
  let%span sred_black_tree20 = "red_black_tree.rs" 478 14 478 50
  let%span sred_black_tree21 = "red_black_tree.rs" 479 14 479 65
  let%span sred_black_tree22 = "red_black_tree.rs" 480 14 480 41
  let%span sred_black_tree23 = "red_black_tree.rs" 481 14 481 44
  let%span sred_black_tree24 = "red_black_tree.rs" 482 14 485 34
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 55 26 55 58
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 57 20 57 89
  let%span soption27 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption28 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sred_black_tree29 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree30 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree31 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree32 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree33 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree34 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree35 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree36 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree37 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree38 = "red_black_tree.rs" 432 14 435 34
  let%span sred_black_tree39 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree40 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree41 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree42 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree43 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree44 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree45 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree46 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree47 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree48 = "red_black_tree.rs" 504 14 506 68
  let%span sred_black_tree49 = "red_black_tree.rs" 507 14 509 88
  let%span sred_black_tree50 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree51 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree52 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree53 = "red_black_tree.rs" 147 12 147 89
  let%span sred_black_tree54 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree55 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree56 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree57 = "red_black_tree.rs" 256 16 256 48
  let%span sresolve58 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree59 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree60 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree61 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree62 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree63 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree64 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree65 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree66 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree67 = "red_black_tree.rs" 263 12 268 13
  let%span sord68 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord69 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord70 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord71 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord72 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord73 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord74 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord75 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord76 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord77 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord78 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord79 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord80 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant81 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree82 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree83 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree84 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree85 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree86 = "red_black_tree.rs" 37 12 41 13
  let%span sinvariant87 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed88 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'1 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  predicate inv'7 (_1 : t_K'0)
  
  predicate inv'8 (_1 : t_V'0)
  
  predicate inv'0 (_1 : t_Node'0)
  
  predicate inv'6 (_1 : t_Tree'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'6 left
    /\ inv'7 key /\ inv'8 val' /\ inv'6 right
    end
  
  predicate invariant'4 (self : t_Node'0) =
    [%#sboxed88] inv'0 self
  
  predicate inv'10 (_1 : t_Node'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Node'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  predicate inv'9 (_1 : t_Option'1)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Option'1 [inv'9 x] . inv'9 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'10 a_0
    end
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Tree'0 [inv'6 x] . inv'6 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'9 node
    end
  
  predicate invariant'1 (self : t_Tree'0) =
    [%#sinvariant87] inv'6 self
  
  predicate inv'2 (_1 : t_Tree'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Tree'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree51] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree13] inv'2 self}
    any [ return' (result:bool)-> {[%#sred_black_tree14] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate invariant'0 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant81] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree86] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord80] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord78] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord79] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord76] cmp_log'0 x y = C_Less'0)
   -> ([%#sord77] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord73] cmp_log'0 x y
  = o)  -> ([%#sord74] cmp_log'0 y z = o)  -> ([%#sord75] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord72] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord71] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord70] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord69] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord68] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree82] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree83] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree59] bst_invariant_here'0 self
    /\ bst_invariant'1 self.t_Node__left'0 /\ bst_invariant'1 self.t_Node__right'0
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree65] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree64] height'1 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree84] height'1 self.t_Node__left'0 = height'1 self.t_Node__right'0
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree85] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree60] height_invariant_here'0 self
    /\ height_invariant'1 self.t_Node__left'0 /\ height_invariant'1 self.t_Node__right'0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree50] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree63] has_mapping'1 self.t_Node__left'0 k v
    \/ has_mapping'1 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'0_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree62] forall node : t_Node'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree53] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree55] match self.t_Node__color'0 with
      | C_Red'0 -> height'1 self.t_Node__left'0
      | C_Black'0 -> height'1 self.t_Node__left'0 + 1
      end
  
  axiom height'0_spec : forall self : t_Node'0 . [%#sred_black_tree54] forall node : t_Node'0 . self = node
   -> height'0 self = height'1 { t_Tree__node'0 = C_Some'0 node }
  
  let rec rotate_left'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree15] inv'1 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree16] internal_invariant'0 self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree17] color'0 (self.current).t_Node__right'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree18] same_mappings'0 self.current self.final}
      {[%#sred_black_tree19] internal_invariant'0 self.final}
      {[%#sred_black_tree20] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree21] lt_log'0 (deep_model'0 (self.current).t_Node__key'0) (deep_model'0 (self.final).t_Node__key'0)}
      {[%#sred_black_tree22] color'0 (self.final).t_Node__left'0 = C_Red'0}
      {[%#sred_black_tree23] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree24] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l
      /\ (l.t_Node__left'0, l.t_Node__right'0, (self.final).t_Node__right'0)
      = ((self.current).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      /\ l.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_Node'0
  
  predicate invariant'2 (self : t_Option'1) =
    [%#sinvariant87] inv'9 self
  
  predicate inv'3 (_1 : t_Option'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'1 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'3 (self : t_Node'0) =
    [%#sinvariant87] inv'10 self
  
  predicate inv'5 (_1 : t_Node'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Node'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  let rec as_ref'0 (self:t_Option'1) (return'  (ret:t_Option'0))= {[@expl:as_ref 'self' type invariant] inv'3 self}
    any
    [ return' (result:t_Option'0)-> {inv'4 result}
      {[%#soption25] self = C_None'0  -> result = C_None'1}
      {[%#soption26] self = C_None'0 \/ (exists r : t_Node'0 . result = C_Some'1 r /\ self = C_Some'0 r)}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'4 self}
    {[@expl:unwrap requires] [%#soption27] self <> C_None'1}
    any [ return' (result:t_Node'0)-> {inv'5 result} {[%#soption28] C_Some'1 result = self} (! return' {result}) ] 
  
  let rec rotate_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree29] inv'1 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree30] internal_invariant'0 self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree31] color'0 (self.current).t_Node__left'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree32] same_mappings'0 self.current self.final}
      {[%#sred_black_tree33] internal_invariant'0 self.final}
      {[%#sred_black_tree34] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree35] lt_log'0 (deep_model'0 (self.final).t_Node__key'0) (deep_model'0 (self.current).t_Node__key'0)}
      {[%#sred_black_tree36] color'0 (self.final).t_Node__right'0 = C_Red'0}
      {[%#sred_black_tree37] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree38] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r
      /\ ((self.final).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      = (l.t_Node__left'0, l.t_Node__right'0, (self.current).t_Node__right'0)
      /\ r.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  let rec flip_colors'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree39] inv'1 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree40] internal_invariant'0 self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree41] ((self.current).t_Node__left'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #2] [%#sred_black_tree42] ((self.current).t_Node__right'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #3] [%#sred_black_tree43] color'0 (self.current).t_Node__left'0
    = color'0 (self.current).t_Node__right'0}
    any
    [ return' (result:())-> {[%#sred_black_tree44] internal_invariant'0 self.final}
      {[%#sred_black_tree45] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree46] same_mappings'0 self.current self.final}
      {[%#sred_black_tree47] (self.current).t_Node__key'0 = (self.final).t_Node__key'0}
      {[%#sred_black_tree48] exists l1 : t_Node'0, l2 : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l1
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l2
      /\ l1.t_Node__left'0 = l2.t_Node__left'0
      /\ l1.t_Node__right'0 = l2.t_Node__right'0
      /\ l1.t_Node__key'0 = l2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = l2.t_Node__color'0 /\ (self.final).t_Node__color'0 = l1.t_Node__color'0}
      {[%#sred_black_tree49] exists r1 : t_Node'0, r2 : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r1
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r2
      /\ r1.t_Node__left'0 = r2.t_Node__left'0
      /\ r1.t_Node__right'0 = r2.t_Node__right'0
      /\ r1.t_Node__key'0 = r2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = r2.t_Node__color'0
      /\ (self.final).t_Node__color'0 = r1.t_Node__color'0 /\ r1.t_Node__key'0 = r2.t_Node__key'0}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_Node'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'1 _1
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree61] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree52] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree66] color_invariant_here'0 self
    /\ color_invariant'0 self.t_Node__left'0 /\ color_invariant'0 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree67] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree56] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'1 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree57] C_CPN'0 c l r
  
  meta "compute_max_steps" 1000000
  
  let rec balance'0[#"red_black_tree.rs" 534 4 534 25] (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree0] inv'1 self}
    {[@expl:balance requires #0] [%#sred_black_tree1] internal_invariant'0 self.current}
    {[@expl:balance requires #1] [%#sred_black_tree2] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__left'0}
    {[@expl:balance requires #2] [%#sred_black_tree3] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__right'0}
    {[@expl:balance requires #3] [%#sred_black_tree4] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0 /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> false}
    (! bb0
    [ bb0 = s0
      [ s0 = is_red'0 {(self.current).t_Node__right'0} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s1) | s1 = bb1 ]
    
    | bb1 = any [ br0 -> {_15 = false} (! bb7) | br1 -> {_15} (! bb2) ] 
    | bb2 = s0 [ s0 = is_red'0 {(self.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ] 
    | bb4 = bb8
    | bb5 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_20 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = rotate_left'0 {_20} (fun (_ret':()) ->  [ &_19 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = bb9
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = s0
      [ s0 = is_red'0 {(self.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s1) | s1 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 = as_ref'0 {((self.current).t_Node__left'0).t_Tree__node'0} (fun (_ret':t_Option'0) ->  [ &_27 <- _ret' ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':t_Node'0) ->  [ &_26 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0 [ s0 = is_red'0 {_26.t_Node__left'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = any [ br0 -> {_24 = false} (! bb17) | br1 -> {_24} (! bb15) ] 
    | bb15 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = rotate_right'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = bb20
    | bb17 = bb19
    | bb18 = bb19
    | bb19 = bb20
    | bb20 = s0
      [ s0 = is_red'0 {(self.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s1) | s1 = bb21 ]
    
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ] 
    | bb22 = s0
      [ s0 = is_red'0 {(self.current).t_Node__right'0} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s1) | s1 = bb23 ]
    
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ] 
    | bb24 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_Node'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_36 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = flip_colors'0 {_36} (fun (_ret':()) ->  [ &_35 <- _ret' ] s2)
      | s2 = bb25 ]
    
    | bb25 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb29 ] 
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb28 ] 
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = bb28 ] 
    | bb28 = bb29
    | bb29 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Node'0 = self
    | & _15 : bool = Any.any_l ()
    | & _17 : bool = Any.any_l ()
    | & _19 : () = Any.any_l ()
    | & _20 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _24 : bool = Any.any_l ()
    | & _26 : t_Node'0 = Any.any_l ()
    | & _27 : t_Option'0 = Any.any_l ()
    | & _29 : () = Any.any_l ()
    | & _30 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & _33 : bool = Any.any_l ()
    | & _35 : () = Any.any_l ()
    | & _36 : MutBorrow.t t_Node'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:balance ensures #0] [%#sred_black_tree5] same_mappings'0 self.current self.final}
      {[@expl:balance ensures #1] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:balance ensures #2] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:balance ensures #3] [%#sred_black_tree8] color_invariant'0 (self.current).t_Node__left'0
      /\ color'0 (self.current).t_Node__right'0 = C_Black'0  -> self.current = self.final}
      {[@expl:balance ensures #4] [%#sred_black_tree9] match_n'0 (cpn'0 (C_Black'0) (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      {[@expl:balance ensures #5] [%#sred_black_tree10] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[@expl:balance ensures #6] [%#sred_black_tree11] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[@expl:balance ensures #7] [%#sred_black_tree12] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__move_red_left [#"red_black_tree.rs" 566 4 566 44] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 566 26 566 30
  let%span sred_black_tree1 = "red_black_tree.rs" 548 15 548 41
  let%span sred_black_tree2 = "red_black_tree.rs" 549 15 549 43
  let%span sred_black_tree3 = "red_black_tree.rs" 550 15 550 86
  let%span sred_black_tree4 = "red_black_tree.rs" 566 35 566 44
  let%span sred_black_tree5 = "red_black_tree.rs" 551 14 551 44
  let%span sred_black_tree6 = "red_black_tree.rs" 552 14 554 46
  let%span sred_black_tree7 = "red_black_tree.rs" 555 14 555 95
  let%span sred_black_tree8 = "red_black_tree.rs" 556 14 556 42
  let%span sred_black_tree9 = "red_black_tree.rs" 557 14 557 103
  let%span sred_black_tree10 = "red_black_tree.rs" 558 14 559 45
  let%span sred_black_tree11 = "red_black_tree.rs" 560 14 561 106
  let%span sred_black_tree12 = "red_black_tree.rs" 562 14 563 61
  let%span sred_black_tree13 = "red_black_tree.rs" 564 14 565 43
  let%span sred_black_tree14 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree15 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree16 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree17 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree18 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree19 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree20 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree21 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree22 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree23 = "red_black_tree.rs" 504 14 506 68
  let%span sred_black_tree24 = "red_black_tree.rs" 507 14 509 88
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption27 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption28 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sred_black_tree29 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree30 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree31 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree32 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree33 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree34 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree35 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree36 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree37 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree38 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree39 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree40 = "red_black_tree.rs" 432 14 435 34
  let%span sred_black_tree41 = "red_black_tree.rs" 486 24 486 28
  let%span sred_black_tree42 = "red_black_tree.rs" 474 15 474 43
  let%span sred_black_tree43 = "red_black_tree.rs" 475 15 475 43
  let%span sred_black_tree44 = "red_black_tree.rs" 476 14 476 42
  let%span sred_black_tree45 = "red_black_tree.rs" 477 14 477 42
  let%span sred_black_tree46 = "red_black_tree.rs" 478 14 478 50
  let%span sred_black_tree47 = "red_black_tree.rs" 479 14 479 65
  let%span sred_black_tree48 = "red_black_tree.rs" 480 14 480 41
  let%span sred_black_tree49 = "red_black_tree.rs" 481 14 481 44
  let%span sred_black_tree50 = "red_black_tree.rs" 482 14 485 34
  let%span sred_black_tree51 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree52 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree53 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree54 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree55 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree56 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree57 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree58 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree59 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree60 = "red_black_tree.rs" 147 12 147 89
  let%span sresolve61 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree62 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree63 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree64 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree65 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree66 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree67 = "red_black_tree.rs" 37 12 41 13
  let%span sord68 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord69 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord70 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord71 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord72 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord73 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord74 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord75 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord76 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord77 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord78 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord79 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord80 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree81 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree82 = "red_black_tree.rs" 297 12 303 13
  let%span sinvariant83 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree84 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree85 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree86 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree87 = "red_black_tree.rs" 342 12 348 13
  let%span sinvariant88 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed89 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  predicate inv'8 (_1 : t_K'0)
  
  predicate inv'9 (_1 : t_V'0)
  
  predicate inv'0 (_1 : t_Node'0)
  
  predicate invariant'4 (self : t_Node'0) =
    [%#sboxed89] inv'0 self
  
  predicate inv'10 (_1 : t_Node'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Node'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'10 a_0
    end
  
  predicate inv'7 (_1 : t_Tree'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Tree'0 [inv'7 x] . inv'7 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'1 node
    end
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'7 left
    /\ inv'8 key /\ inv'9 val' /\ inv'7 right
    end
  
  predicate invariant'1 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant83] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree67] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord80] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord78] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord79] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord76] cmp_log'0 x y = C_Less'0)
   -> ([%#sord77] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord73] cmp_log'0 x y
  = o)  -> ([%#sord74] cmp_log'0 y z = o)  -> ([%#sord75] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord72] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord71] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord70] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord69] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord68] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree84] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree85] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree62] bst_invariant_here'0 self
    /\ bst_invariant'1 self.t_Node__left'0 /\ bst_invariant'1 self.t_Node__right'0
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree66] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree65] height'1 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree86] height'1 self.t_Node__left'0 = height'1 self.t_Node__right'0
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree87] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree63] height_invariant_here'0 self
    /\ height_invariant'1 self.t_Node__left'0 /\ height_invariant'1 self.t_Node__right'0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree51] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree59] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree55] match self.t_Node__color'0 with
      | C_Red'0 -> height'1 self.t_Node__left'0
      | C_Black'0 -> height'1 self.t_Node__left'0 + 1
      end
  
  axiom height'0_spec : forall self : t_Node'0 . [%#sred_black_tree54] forall node : t_Node'0 . self = node
   -> height'0 self = height'1 { t_Tree__node'0 = C_Some'0 node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree57] has_mapping'1 self.t_Node__left'0 k v
    \/ has_mapping'1 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'0_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree56] forall node : t_Node'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree60] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree14] inv'3 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree15] internal_invariant'0 self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree16] ((self.current).t_Node__left'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #2] [%#sred_black_tree17] ((self.current).t_Node__right'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #3] [%#sred_black_tree18] color'0 (self.current).t_Node__left'0
    = color'0 (self.current).t_Node__right'0}
    any
    [ return' (result:())-> {[%#sred_black_tree19] internal_invariant'0 self.final}
      {[%#sred_black_tree20] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree21] same_mappings'0 self.current self.final}
      {[%#sred_black_tree22] (self.current).t_Node__key'0 = (self.final).t_Node__key'0}
      {[%#sred_black_tree23] exists l1 : t_Node'0, l2 : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l1
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l2
      /\ l1.t_Node__left'0 = l2.t_Node__left'0
      /\ l1.t_Node__right'0 = l2.t_Node__right'0
      /\ l1.t_Node__key'0 = l2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = l2.t_Node__color'0 /\ (self.final).t_Node__color'0 = l1.t_Node__color'0}
      {[%#sred_black_tree24] exists r1 : t_Node'0, r2 : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r1
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r2
      /\ r1.t_Node__left'0 = r2.t_Node__left'0
      /\ r1.t_Node__right'0 = r2.t_Node__right'0
      /\ r1.t_Node__key'0 = r2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = r2.t_Node__color'0
      /\ (self.final).t_Node__color'0 = r1.t_Node__color'0 /\ r1.t_Node__key'0 = r2.t_Node__key'0}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_Node'0)
  
  predicate invariant'2 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant83] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'0 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant83] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'5 (_1 : t_Option'1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option'1 [inv'5 x] . inv'5 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'1)-> {inv'5 result}
      {[%#soption25] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption26] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'5 self}
    {[@expl:unwrap requires] [%#soption27] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'2 result}
      {[%#soption28] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  predicate invariant'3 (self : t_Tree'0) =
    [%#sinvariant88] inv'7 self
  
  predicate inv'6 (_1 : t_Tree'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Tree'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree29] inv'6 self}
    any [ return' (result:bool)-> {[%#sred_black_tree30] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate resolve'2 (self : MutBorrow.t t_Node'0) =
    [%#sresolve61] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'2 _1
  
  let rec rotate_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree31] inv'3 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree32] internal_invariant'0 self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree33] color'0 (self.current).t_Node__left'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree34] same_mappings'0 self.current self.final}
      {[%#sred_black_tree35] internal_invariant'0 self.final}
      {[%#sred_black_tree36] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree37] lt_log'0 (deep_model'0 (self.final).t_Node__key'0) (deep_model'0 (self.current).t_Node__key'0)}
      {[%#sred_black_tree38] color'0 (self.final).t_Node__right'0 = C_Red'0}
      {[%#sred_black_tree39] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree40] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r
      /\ ((self.final).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      = (l.t_Node__left'0, l.t_Node__right'0, (self.current).t_Node__right'0)
      /\ r.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  let rec rotate_left'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree41] inv'3 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree42] internal_invariant'0 self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree43] color'0 (self.current).t_Node__right'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree44] same_mappings'0 self.current self.final}
      {[%#sred_black_tree45] internal_invariant'0 self.final}
      {[%#sred_black_tree46] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree47] lt_log'0 (deep_model'0 (self.current).t_Node__key'0) (deep_model'0 (self.final).t_Node__key'0)}
      {[%#sred_black_tree48] color'0 (self.final).t_Node__left'0 = C_Red'0}
      {[%#sred_black_tree49] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree50] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l
      /\ (l.t_Node__left'0, l.t_Node__right'0, (self.final).t_Node__right'0)
      = ((self.current).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      /\ l.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t t_Node'0) =
    [%#sresolve61] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Node'0) =
    resolve'3 _1
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree81] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'1 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree82] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree58] color_invariant_here'0 self
    /\ color_invariant'1 self.t_Node__left'0 /\ color_invariant'1 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree64] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'1 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree52] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'0 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree53] C_CPN'0 c l r
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_left'0[#"red_black_tree.rs" 566 4 566 44] (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree0] inv'3 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree1] ((self.current).t_Node__right'0).t_Tree__node'0 <> C_None'0}
    {[@expl:move_red_left requires #1] [%#sred_black_tree2] internal_invariant'0 self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree3] match_n'0 (cpn'0 (C_Red'0) (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'1 ((self.current).t_Node__right'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Node__right'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_22 <- _ret' ] 
            -{inv'1 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__right'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = as_mut'0 {_22} (fun (_ret':t_Option'1) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = unwrap'0 {_21} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_20 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = is_red'0 {(_20.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = {inv'1 ((self.current).t_Node__right'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Node__right'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_28 <- _ret' ] 
            -{inv'1 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__right'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = as_mut'0 {_28} (fun (_ret':t_Option'1) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_26 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {inv'0 _26.current}
        MutBorrow.borrow_final <t_Node'0> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_26 <- { _26 with current = _ret'.final } ] 
            s1)
      | s1 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'2 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_30 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s3)
      | s3 = rotate_left'0 {_30} (fun (_ret':()) ->  [ &_29 <- _ret' ] s4)
      | s4 = bb9 ]
    
    | bb9 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_32 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = flip_colors'0 {_32} (fun (_ret':()) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = s0
      [ s0 = {inv'1 ((self.current).t_Node__left'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Node__left'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_35 <- _ret' ] 
            -{inv'1 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__left'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = as_mut'0 {_35} (fun (_ret':t_Option'1) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = unwrap'0 {_34} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_33 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {inv'0 _33.current}
        MutBorrow.borrow_final <t_Node'0> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_33 <- { _33 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _33} s2
      | s2 = -{resolve'0 _33}- s3
      | s3 = bb16 ]
    
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb14 ] 
    | bb13 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = bb14 ] 
    | bb14 = return' {_0} ]
    )
    [ & _0 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & self : MutBorrow.t t_Node'0 = self
    | & _15 : () = Any.any_l ()
    | & _16 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _18 : bool = Any.any_l ()
    | & _20 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _21 : t_Option'1 = Any.any_l ()
    | & _22 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _24 : () = Any.any_l ()
    | & _25 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _26 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _27 : t_Option'1 = Any.any_l ()
    | & _28 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _29 : () = Any.any_l ()
    | & _30 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _31 : () = Any.any_l ()
    | & _32 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _33 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _34 : t_Option'1 = Any.any_l ()
    | & _35 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_Node'0)-> {[@expl:move_red_left result type invariant] [%#sred_black_tree4] inv'3 result}
      {[@expl:move_red_left ensures #0] [%#sred_black_tree5] internal_invariant'0 result.current}
      {[@expl:move_red_left ensures #1] [%#sred_black_tree6] internal_invariant'0 result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant'0 self.final}
      {[@expl:move_red_left ensures #2] [%#sred_black_tree7] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_left ensures #3] [%#sred_black_tree8] (self.current).t_Node__key'0
      = (result.current).t_Node__key'0}
      {[@expl:move_red_left ensures #4] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:move_red_left ensures #5] [%#sred_black_tree10] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
      /\ le_log'0 k (deep_model'0 (self.current).t_Node__key'0)  -> has_mapping'0 result.current k v}
      {[@expl:move_red_left ensures #6] [%#sred_black_tree11] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_left ensures #7] [%#sred_black_tree12] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) result.current
      \/ match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) result.current}
      {[@expl:move_red_left ensures #8] [%#sred_black_tree13] color_invariant'0 result.final
      /\ (color'0 (result.current).t_Node__right'0 = C_Black'0  -> (result.final).t_Node__color'0 = C_Black'0)
       -> color_invariant'0 self.final}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__move_red_right [#"red_black_tree.rs" 595 4 595 45] (* Node<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 595 27 595 31
  let%span sred_black_tree1 = "red_black_tree.rs" 577 15 577 40
  let%span sred_black_tree2 = "red_black_tree.rs" 578 15 578 43
  let%span sred_black_tree3 = "red_black_tree.rs" 579 15 579 86
  let%span sred_black_tree4 = "red_black_tree.rs" 595 36 595 45
  let%span sred_black_tree5 = "red_black_tree.rs" 580 14 580 44
  let%span sred_black_tree6 = "red_black_tree.rs" 581 14 583 46
  let%span sred_black_tree7 = "red_black_tree.rs" 584 14 584 95
  let%span sred_black_tree8 = "red_black_tree.rs" 585 14 585 42
  let%span sred_black_tree9 = "red_black_tree.rs" 586 14 586 103
  let%span sred_black_tree10 = "red_black_tree.rs" 587 14 588 45
  let%span sred_black_tree11 = "red_black_tree.rs" 589 14 590 106
  let%span sred_black_tree12 = "red_black_tree.rs" 591 14 592 61
  let%span sred_black_tree13 = "red_black_tree.rs" 593 14 594 43
  let%span sred_black_tree14 = "red_black_tree.rs" 510 24 510 28
  let%span sred_black_tree15 = "red_black_tree.rs" 496 15 496 43
  let%span sred_black_tree16 = "red_black_tree.rs" 497 15 497 40
  let%span sred_black_tree17 = "red_black_tree.rs" 498 15 498 41
  let%span sred_black_tree18 = "red_black_tree.rs" 499 15 499 60
  let%span sred_black_tree19 = "red_black_tree.rs" 500 14 500 42
  let%span sred_black_tree20 = "red_black_tree.rs" 501 14 501 50
  let%span sred_black_tree21 = "red_black_tree.rs" 502 14 502 42
  let%span sred_black_tree22 = "red_black_tree.rs" 503 14 503 40
  let%span sred_black_tree23 = "red_black_tree.rs" 504 14 506 68
  let%span sred_black_tree24 = "red_black_tree.rs" 507 14 509 88
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption27 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption28 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sred_black_tree29 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree30 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree31 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree32 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree33 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree34 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree35 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree36 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree37 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree38 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree39 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree40 = "red_black_tree.rs" 432 14 435 34
  let%span sred_black_tree41 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree42 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree43 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree44 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree45 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree46 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree47 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree48 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree49 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree50 = "red_black_tree.rs" 147 12 147 89
  let%span sresolve51 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree52 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree53 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree54 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree55 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree56 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree57 = "red_black_tree.rs" 37 12 41 13
  let%span sord58 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord59 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord60 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord61 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord62 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord63 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord64 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord65 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord66 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord67 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord68 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord69 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord70 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree71 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree72 = "red_black_tree.rs" 297 12 303 13
  let%span sinvariant73 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree74 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree75 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree76 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree77 = "red_black_tree.rs" 342 12 348 13
  let%span sinvariant78 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed79 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  predicate inv'8 (_1 : t_K'0)
  
  predicate inv'9 (_1 : t_V'0)
  
  predicate inv'0 (_1 : t_Node'0)
  
  predicate invariant'4 (self : t_Node'0) =
    [%#sboxed79] inv'0 self
  
  predicate inv'10 (_1 : t_Node'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Node'0 [inv'10 x] . inv'10 x = invariant'4 x
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'10 a_0
    end
  
  predicate inv'7 (_1 : t_Tree'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Tree'0 [inv'7 x] . inv'7 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'1 node
    end
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'7 left
    /\ inv'8 key /\ inv'9 val' /\ inv'7 right
    end
  
  predicate invariant'1 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant73] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree57] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord70] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord68] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord69] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord66] cmp_log'0 x y = C_Less'0)
   -> ([%#sord67] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord63] cmp_log'0 x y
  = o)  -> ([%#sord64] cmp_log'0 y z = o)  -> ([%#sord65] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord62] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord61] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord60] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord59] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord58] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree74] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree75] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'1 left /\ bst_invariant'1 right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree52] bst_invariant_here'0 self
    /\ bst_invariant'1 self.t_Node__left'0 /\ bst_invariant'1 self.t_Node__right'0
  
  function height'1 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree56] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'1 left
        | C_Black'0 -> height'1 left + 1
        end
      end
  
  axiom height'1_spec : forall self : t_Tree'0 . [%#sred_black_tree55] height'1 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree76] height'1 self.t_Node__left'0 = height'1 self.t_Node__right'0
  
  predicate height_invariant'1 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree77] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'1 left /\ height_invariant'1 right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree53] height_invariant_here'0 self
    /\ height_invariant'1 self.t_Node__left'0 /\ height_invariant'1 self.t_Node__right'0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree41] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree49] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  function height'0 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree45] match self.t_Node__color'0 with
      | C_Red'0 -> height'1 self.t_Node__left'0
      | C_Black'0 -> height'1 self.t_Node__left'0 + 1
      end
  
  axiom height'0_spec : forall self : t_Node'0 . [%#sred_black_tree44] forall node : t_Node'0 . self = node
   -> height'0 self = height'1 { t_Tree__node'0 = C_Some'0 node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree47] has_mapping'1 self.t_Node__left'0 k v
    \/ has_mapping'1 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'0_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree46] forall node : t_Node'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree50] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree14] inv'3 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree15] internal_invariant'0 self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree16] ((self.current).t_Node__left'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #2] [%#sred_black_tree17] ((self.current).t_Node__right'0).t_Tree__node'0 <> C_None'0}
    {[@expl:flip_colors requires #3] [%#sred_black_tree18] color'0 (self.current).t_Node__left'0
    = color'0 (self.current).t_Node__right'0}
    any
    [ return' (result:())-> {[%#sred_black_tree19] internal_invariant'0 self.final}
      {[%#sred_black_tree20] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree21] same_mappings'0 self.current self.final}
      {[%#sred_black_tree22] (self.current).t_Node__key'0 = (self.final).t_Node__key'0}
      {[%#sred_black_tree23] exists l1 : t_Node'0, l2 : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l1
      /\ ((self.final).t_Node__left'0).t_Tree__node'0 = C_Some'0 l2
      /\ l1.t_Node__left'0 = l2.t_Node__left'0
      /\ l1.t_Node__right'0 = l2.t_Node__right'0
      /\ l1.t_Node__key'0 = l2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = l2.t_Node__color'0 /\ (self.final).t_Node__color'0 = l1.t_Node__color'0}
      {[%#sred_black_tree24] exists r1 : t_Node'0, r2 : t_Node'0 . ((self.current).t_Node__right'0).t_Tree__node'0
      = C_Some'0 r1
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r2
      /\ r1.t_Node__left'0 = r2.t_Node__left'0
      /\ r1.t_Node__right'0 = r2.t_Node__right'0
      /\ r1.t_Node__key'0 = r2.t_Node__key'0
      /\ (self.current).t_Node__color'0 = r2.t_Node__color'0
      /\ (self.final).t_Node__color'0 = r1.t_Node__color'0 /\ r1.t_Node__key'0 = r2.t_Node__key'0}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_Node'0)
  
  predicate invariant'2 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant73] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate invariant'0 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant73] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'5 (_1 : t_Option'1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option'1 [inv'5 x] . inv'5 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'4 self}
    any
    [ return' (result:t_Option'1)-> {inv'5 result}
      {[%#soption25] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption26] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'5 self}
    {[@expl:unwrap requires] [%#soption27] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'2 result}
      {[%#soption28] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  predicate invariant'3 (self : t_Tree'0) =
    [%#sinvariant78] inv'7 self
  
  predicate inv'6 (_1 : t_Tree'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Tree'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree29] inv'6 self}
    any [ return' (result:bool)-> {[%#sred_black_tree30] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate resolve'2 (self : MutBorrow.t t_Node'0) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'2 _1
  
  let rec rotate_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree31] inv'3 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree32] internal_invariant'0 self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree33] color'0 (self.current).t_Node__left'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree34] same_mappings'0 self.current self.final}
      {[%#sred_black_tree35] internal_invariant'0 self.final}
      {[%#sred_black_tree36] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree37] lt_log'0 (deep_model'0 (self.final).t_Node__key'0) (deep_model'0 (self.current).t_Node__key'0)}
      {[%#sred_black_tree38] color'0 (self.final).t_Node__right'0 = C_Red'0}
      {[%#sred_black_tree39] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree40] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r
      /\ ((self.final).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      = (l.t_Node__left'0, l.t_Node__right'0, (self.current).t_Node__right'0)
      /\ r.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t t_Node'0) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Node'0) =
    resolve'3 _1
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree71] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'1 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree72] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'1 left /\ color_invariant'1 right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree48] color_invariant_here'0 self
    /\ color_invariant'1 self.t_Node__left'0 /\ color_invariant'1 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree54] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'1 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree42] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'0 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree43] C_CPN'0 c l r
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_right'0[#"red_black_tree.rs" 595 4 595 45] (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree0] inv'3 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree1] ((self.current).t_Node__left'0).t_Tree__node'0 <> C_None'0}
    {[@expl:move_red_right requires #1] [%#sred_black_tree2] internal_invariant'0 self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree3] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Black'0)))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = flip_colors'0 {_16} (fun (_ret':()) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'1 ((self.current).t_Node__left'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Node__left'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_22 <- _ret' ] 
            -{inv'1 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__left'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = as_mut'0 {_22} (fun (_ret':t_Option'1) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = unwrap'0 {_21} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_20 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = is_red'0 {(_20.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'2 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = rotate_right'0 {_25} (fun (_ret':()) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_Node'0> {self.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_27 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = flip_colors'0 {_27} (fun (_ret':()) ->  [ &_26 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'1 ((self.current).t_Node__right'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Node__right'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_30 <- _ret' ] 
            -{inv'1 _ret'.final}-
            
            [ &self <- { self with current = { self.current with t_Node__right'0 = { t_Tree__node'0 = _ret'.final } } } ]
            
            s1)
      | s1 = as_mut'0 {_30} (fun (_ret':t_Option'1) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0 [ s0 = unwrap'0 {_29} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_28 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = {inv'0 _28.current}
        MutBorrow.borrow_final <t_Node'0> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_0 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_28 <- { _28 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'2 _28} s2
      | s2 = -{resolve'0 _28}- s3
      | s3 = bb13 ]
    
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'3 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb11 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- self ] s1 | s1 = bb11 ] 
    | bb11 = return' {_0} ]
    )
    [ & _0 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & self : MutBorrow.t t_Node'0 = self
    | & _15 : () = Any.any_l ()
    | & _16 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _18 : bool = Any.any_l ()
    | & _20 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _21 : t_Option'1 = Any.any_l ()
    | & _22 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _24 : () = Any.any_l ()
    | & _25 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _27 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _28 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _29 : t_Option'1 = Any.any_l ()
    | & _30 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:MutBorrow.t t_Node'0)-> {[@expl:move_red_right result type invariant] [%#sred_black_tree4] inv'3 result}
      {[@expl:move_red_right ensures #0] [%#sred_black_tree5] internal_invariant'0 result.current}
      {[@expl:move_red_right ensures #1] [%#sred_black_tree6] internal_invariant'0 result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant'0 self.final}
      {[@expl:move_red_right ensures #2] [%#sred_black_tree7] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_right ensures #3] [%#sred_black_tree8] (result.current).t_Node__key'0
      = (self.current).t_Node__key'0}
      {[@expl:move_red_right ensures #4] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:move_red_right ensures #5] [%#sred_black_tree10] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
      /\ le_log'0 (deep_model'0 (self.current).t_Node__key'0) k  -> has_mapping'0 result.current k v}
      {[@expl:move_red_right ensures #6] [%#sred_black_tree11] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_right ensures #7] [%#sred_black_tree12] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) result.current
      \/ match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) result.current}
      {[@expl:move_red_right ensures #8] [%#sred_black_tree13] color_invariant'0 result.final
      /\ (color'0 (result.current).t_Node__left'0 = C_Black'0  -> (result.final).t_Node__color'0 = C_Black'0)
       -> color_invariant'0 self.final}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__insert_rec [#"red_black_tree.rs" 618 4 618 44] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 618 23 618 27
  let%span sred_black_tree1 = "red_black_tree.rs" 618 29 618 32
  let%span sred_black_tree2 = "red_black_tree.rs" 618 37 618 40
  let%span sred_black_tree3 = "red_black_tree.rs" 610 15 610 43
  let%span sred_black_tree4 = "red_black_tree.rs" 611 15 611 40
  let%span sred_black_tree5 = "red_black_tree.rs" 612 14 612 42
  let%span sred_black_tree6 = "red_black_tree.rs" 613 14 613 50
  let%span sred_black_tree7 = "red_black_tree.rs" 614 14 615 39
  let%span sred_black_tree8 = "red_black_tree.rs" 616 14 616 56
  let%span sred_black_tree9 = "red_black_tree.rs" 617 14 617 125
  let%span scmp10 = "../../creusot-contracts/src/std/cmp.rs" 72 26 72 85
  let%span sred_black_tree11 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree12 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree13 = "red_black_tree.rs" 516 15 517 45
  let%span sred_black_tree14 = "red_black_tree.rs" 518 15 519 46
  let%span sred_black_tree15 = "red_black_tree.rs" 520 15 520 108
  let%span sred_black_tree16 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree17 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree18 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree19 = "red_black_tree.rs" 524 14 525 32
  let%span sred_black_tree20 = "red_black_tree.rs" 526 14 527 37
  let%span sred_black_tree21 = "red_black_tree.rs" 528 14 529 61
  let%span sred_black_tree22 = "red_black_tree.rs" 530 14 531 59
  let%span sred_black_tree23 = "red_black_tree.rs" 532 14 533 37
  let%span sred_black_tree24 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree25 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree26 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree27 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree28 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree29 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree30 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree31 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve32 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sresolve33 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sred_black_tree34 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree35 = "red_black_tree.rs" 147 12 147 89
  let%span sred_black_tree36 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree37 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree38 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree39 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree40 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree41 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant42 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed43 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sord44 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord46 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord47 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord48 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord49 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord50 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord51 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord52 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord53 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord54 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord55 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord56 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree57 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree58 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree59 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree60 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree61 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree62 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree63 = "red_black_tree.rs" 368 20 368 61
  let%span sresolve64 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sinvariant65 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree66 = "red_black_tree.rs" 195 12 195 69
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'5 (_1 : t_K'0)
  
  predicate inv'6 (_1 : t_V'0)
  
  predicate inv'4 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Tree'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'8 (_1 : t_Node'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Node'0 [inv'8 x] . inv'8 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'4 left
    /\ inv'5 key /\ inv'6 val' /\ inv'4 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed43] inv'8 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  predicate invariant'0 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant42] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'6 (self : MutBorrow.t t_Option'0) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Option'0) =
    resolve'6 _1
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree31] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree60] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree59] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate resolve'4 (_1 : t_V'0)
  
  predicate resolve'13 [#"red_black_tree.rs" 193 4 193 28] (self : t_Node'0) =
    [%#sred_black_tree66] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'4 v
  
  predicate resolve'12 (_1 : t_Node'0) =
    resolve'13 _1
  
  predicate resolve'11 (self : t_Node'0) =
    [%#sresolve64] resolve'12 self
  
  predicate resolve'10 (_1 : t_Node'0) =
    resolve'11 _1
  
  predicate resolve'7 (self : t_Option'0) =
    [%#sresolve33] match self with
      | C_Some'0 x -> resolve'10 x
      | C_None'0 -> true
      end
  
  predicate resolve'1 (_1 : t_Option'0) =
    resolve'7 _1
  
  predicate invariant'1 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant42] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'8 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Tree'0) =
    resolve'8 _1
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  predicate invariant'4 (self : t_K'0) =
    [%#sinvariant65] inv'5 self
  
  predicate inv'9 (_1 : t_K'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_K'0 [inv'9 x] . inv'9 x = invariant'4 x
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord56] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord54] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord55] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord52] cmp_log'0 x y = C_Less'0)
   -> ([%#sord53] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord49] cmp_log'0 x y
  = o)  -> ([%#sord50] cmp_log'0 y z = o)  -> ([%#sord51] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord48] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord46] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:t_Ordering'0))= {[@expl:cmp 'self' type invariant] inv'9 self}
    {[@expl:cmp 'other' type invariant] inv'9 other}
    any
    [ return' (result:t_Ordering'0)-> {[%#scmp10] result = cmp_log'0 (deep_model'0 self) (deep_model'0 other)}
      (! return' {result}) ]
  
  
  predicate resolve'3 (_1 : t_K'0)
  
  predicate invariant'3 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant42] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'7 x] . inv'7 x = invariant'3 x
  
  predicate resolve'9 (self : MutBorrow.t t_Node'0) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_Node'0) =
    resolve'9 _1
  
  predicate invariant'5 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant42] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'10 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree62] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree39] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree57] bst_invariant_here'0 self
    /\ bst_invariant'0 self.t_Node__left'0 /\ bst_invariant'0 self.t_Node__right'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree27] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree26] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree63] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree40] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree58] height_invariant_here'0 self
    /\ height_invariant'0 self.t_Node__left'0 /\ height_invariant'0 self.t_Node__right'0
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree34] bst_invariant'1 self /\ height_invariant'1 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree30] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree41] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree25] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree35] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree37] match self.t_Node__color'0 with
      | C_Red'0 -> height'0 self.t_Node__left'0
      | C_Black'0 -> height'0 self.t_Node__left'0 + 1
      end
  
  axiom height'1_spec : forall self : t_Node'0 . [%#sred_black_tree36] forall node : t_Node'0 . self = node
   -> height'1 self = height'0 { t_Tree__node'0 = C_Some'0 node }
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree61] color_invariant_here'0 self
    /\ color_invariant'0 self.t_Node__left'0 /\ color_invariant'0 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree28] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree38] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'1 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree29] C_CPN'0 c l r
  
  let rec balance'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree11] inv'10 self}
    {[@expl:balance requires #0] [%#sred_black_tree12] internal_invariant'1 self.current}
    {[@expl:balance requires #1] [%#sred_black_tree13] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__left'0}
    {[@expl:balance requires #2] [%#sred_black_tree14] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__right'0}
    {[@expl:balance requires #3] [%#sred_black_tree15] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0 /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> false}
    any
    [ return' (result:())-> {[%#sred_black_tree16] same_mappings'0 self.current self.final}
      {[%#sred_black_tree17] internal_invariant'1 self.final}
      {[%#sred_black_tree18] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree19] color_invariant'0 (self.current).t_Node__left'0
      /\ color'0 (self.current).t_Node__right'0 = C_Black'0  -> self.current = self.final}
      {[%#sred_black_tree20] match_n'0 (cpn'0 (C_Black'0) (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      {[%#sred_black_tree21] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree22] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree23] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      (! return' {result}) ]
  
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree24] bst_invariant'0 self /\ height_invariant'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec insert_rec'0[#"red_black_tree.rs" 618 4 618 44] (self:MutBorrow.t t_Tree'0) (key:t_K'0) (val':t_V'0) (return'  (ret:()))= {[@expl:insert_rec 'self' type invariant] [%#sred_black_tree0] inv'2 self}
    {[@expl:insert_rec 'key' type invariant] [%#sred_black_tree1] inv'5 key}
    {[@expl:insert_rec 'val' type invariant] [%#sred_black_tree2] inv'6 val'}
    {[@expl:insert_rec requires #0] [%#sred_black_tree3] internal_invariant'0 self.current}
    {[@expl:insert_rec requires #1] [%#sred_black_tree4] color_invariant'0 self.current}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {(self.current).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_11 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = any
        [ br0 -> {_11.current = C_None'0} (! bb19) | br1 (x0:t_Node'0)-> {_11.current = C_Some'0 x0} (! bb3) ]
       ]
    
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'1 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 =  [ &_35 <- C_None'0 ] s3
      | s3 =  [ &_34 <- { t_Tree__node'0 = _35 } ] s4
      | s4 = bb20 ]
    
    | bb20 = s0
      [ s0 =  [ &_36 <- C_Red'0 ] s1
      | s1 =  [ &_40 <- C_None'0 ] s2
      | s2 =  [ &_39 <- { t_Tree__node'0 = _40 } ] s3
      | s3 = bb21 ]
    
    | bb21 = s0
      [ s0 = 
        [ &_33 <- { t_Node__left'0 = _34;
                    t_Node__color'0 = _36;
                    t_Node__key'0 = key;
                    t_Node__val'0 = val';
                    t_Node__right'0 = _39 } ]
        
        s1
      | s1 = bb22 ]
    
    | bb22 = bb23
    | bb23 = bb24
    | bb24 = bb25
    | bb25 = bb26
    | bb26 = s0 [ s0 =  [ &_31 <- C_Some'0 _33 ] s1 | s1 = bb27 ] 
    | bb27 = bb28
    | bb28 = s0
      [ s0 = {[@expl:type invariant] match self with
          | {current = {t_Tree__node'0 = x'0}} -> inv'0 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self with
          | {current = {t_Tree__node'0 = x'1}} -> resolve'1 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &self <- { self with current = { t_Tree__node'0 = _31 } } ] s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'2 self}- s5
      | s5 = bb30 ]
    
    | bb30 = bb32
    | bb3 = bb4
    | bb4 = s0
      [ s0 = v_Some'0 {_11.current}
          (fun (r0'0:t_Node'0) ->
            {inv'3 r0'0}
            MutBorrow.borrow_final <t_Node'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id _11) 1}
              (fun (_ret':MutBorrow.t t_Node'0) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_11 <- { _11 with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 =  [ &_18 <- (node.current).t_Node__key'0 ] s2
      | s2 = cmp'0 {key} {_18} (fun (_ret':t_Ordering'0) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = any
      [ br0 -> {_15 = C_Less'0} (! bb7) | br1 -> {_15 = C_Equal'0} (! bb8) | br2 -> {_15 = C_Greater'0} (! bb9) ]
    
    | bb9 = s0
      [ s0 = {inv'4 (node.current).t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_25 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__right'0 = _ret'.final } } ] 
            s1)
      | s1 = insert_rec'0 {_25} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = bb17
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv'5 key} s1 | s1 = -{resolve'3 key}- s2 | s2 = bb10 ] 
    | bb10 = bb13
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match node with
          | {current = {t_Node__val'0 = x'0}} -> inv'6 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node with
          | {current = {t_Node__val'0 = x'1}} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 =  [ &node <- { node with current = { node.current with t_Node__val'0 = val' } } ] s3
      | s3 = {[@expl:type invariant] inv'7 node} s4
      | s4 = -{resolve'5 node}- s5
      | s5 = {[@expl:type invariant] inv'1 _11} s6
      | s6 = -{resolve'0 _11}- s7
      | s7 = {[@expl:type invariant] inv'2 self} s8
      | s8 = -{resolve'2 self}- s9
      | s9 = bb15 ]
    
    | bb15 = bb32
    | bb32 = bb33
    | bb33 = bb34
    | bb7 = bb11
    | bb11 = s0
      [ s0 = {inv'4 (node.current).t_Node__left'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__left'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_20 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__left'0 = _ret'.final } } ] 
            s1)
      | s1 = insert_rec'0 {_20} {key} {val'} (fun (_ret':()) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = bb17
    | bb17 = s0
      [ s0 = {inv'8 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_29 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = balance'0 {_29} (fun (_ret':()) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb18 ]
    
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'7 node} s1
      | s1 = -{resolve'5 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'2 self} s5
      | s5 = -{resolve'2 self}- s6
      | s6 = bb31 ]
    
    | bb31 = bb34
    | bb34 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Tree'0 = self
    | & key : t_K'0 = key
    | & val' : t_V'0 = val'
    | & _11 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _14 : () = Any.any_l ()
    | & _15 : t_Ordering'0 = Any.any_l ()
    | & _18 : t_K'0 = Any.any_l ()
    | & _20 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _25 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _28 : () = Any.any_l ()
    | & _29 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _31 : t_Option'0 = Any.any_l ()
    | & _33 : t_Node'0 = Any.any_l ()
    | & _34 : t_Tree'0 = Any.any_l ()
    | & _35 : t_Option'0 = Any.any_l ()
    | & _36 : t_Color'0 = Any.any_l ()
    | & _39 : t_Tree'0 = Any.any_l ()
    | & _40 : t_Option'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:insert_rec ensures #0] [%#sred_black_tree5] internal_invariant'0 self.final}
      {[@expl:insert_rec ensures #1] [%#sred_black_tree6] height'0 self.current = height'0 self.final}
      {[@expl:insert_rec ensures #2] [%#sred_black_tree7] match_t'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final
      /\ color'0 self.current = C_Red'0
      \/ color_invariant'0 self.final}
      {[@expl:insert_rec ensures #3] [%#sred_black_tree8] has_mapping'0 self.final (deep_model'0 key) val'}
      {[@expl:insert_rec ensures #4] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . k = deep_model'0 key
      \/ has_mapping'0 self.current k v = has_mapping'0 self.final k v}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__delete_max_rec [#"red_black_tree.rs" 652 4 652 42] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 652 27 652 31
  let%span sred_black_tree1 = "red_black_tree.rs" 641 15 641 43
  let%span sred_black_tree2 = "red_black_tree.rs" 642 15 643 62
  let%span sred_black_tree3 = "red_black_tree.rs" 652 36 652 42
  let%span sred_black_tree4 = "red_black_tree.rs" 644 14 644 42
  let%span sred_black_tree5 = "red_black_tree.rs" 645 14 645 50
  let%span sred_black_tree6 = "red_black_tree.rs" 646 14 646 66
  let%span sred_black_tree7 = "red_black_tree.rs" 647 14 647 102
  let%span sred_black_tree8 = "red_black_tree.rs" 648 14 649 71
  let%span sred_black_tree9 = "red_black_tree.rs" 650 14 650 39
  let%span sred_black_tree10 = "red_black_tree.rs" 651 14 651 67
  let%span soption11 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 48 26 48 43
  let%span sboxed16 = "../../creusot-contracts/src/std/boxed.rs" 49 26 49 43
  let%span sred_black_tree17 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree18 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree19 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree20 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree21 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree22 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree23 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree24 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree25 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree26 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree27 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree28 = "red_black_tree.rs" 432 14 435 34
  let%span soption29 = "../../creusot-contracts/src/std/option.rs" 55 26 55 58
  let%span soption30 = "../../creusot-contracts/src/std/option.rs" 57 20 57 89
  let%span sred_black_tree31 = "red_black_tree.rs" 595 27 595 31
  let%span sred_black_tree32 = "red_black_tree.rs" 577 15 577 40
  let%span sred_black_tree33 = "red_black_tree.rs" 578 15 578 43
  let%span sred_black_tree34 = "red_black_tree.rs" 579 15 579 86
  let%span sred_black_tree35 = "red_black_tree.rs" 595 36 595 45
  let%span sred_black_tree36 = "red_black_tree.rs" 580 14 580 44
  let%span sred_black_tree37 = "red_black_tree.rs" 581 14 583 46
  let%span sred_black_tree38 = "red_black_tree.rs" 584 14 584 95
  let%span sred_black_tree39 = "red_black_tree.rs" 585 14 585 42
  let%span sred_black_tree40 = "red_black_tree.rs" 586 14 586 103
  let%span sred_black_tree41 = "red_black_tree.rs" 587 14 588 45
  let%span sred_black_tree42 = "red_black_tree.rs" 589 14 590 106
  let%span sred_black_tree43 = "red_black_tree.rs" 591 14 592 61
  let%span sred_black_tree44 = "red_black_tree.rs" 593 14 594 43
  let%span sred_black_tree45 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree46 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree47 = "red_black_tree.rs" 516 15 517 45
  let%span sred_black_tree48 = "red_black_tree.rs" 518 15 519 46
  let%span sred_black_tree49 = "red_black_tree.rs" 520 15 520 108
  let%span sred_black_tree50 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree51 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree52 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree53 = "red_black_tree.rs" 524 14 525 32
  let%span sred_black_tree54 = "red_black_tree.rs" 526 14 527 37
  let%span sred_black_tree55 = "red_black_tree.rs" 528 14 529 61
  let%span sred_black_tree56 = "red_black_tree.rs" 530 14 531 59
  let%span sred_black_tree57 = "red_black_tree.rs" 532 14 533 37
  let%span smem58 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem59 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span sred_black_tree60 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree61 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree62 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree63 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree64 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree65 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree66 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree67 = "red_black_tree.rs" 287 12 290 13
  let%span sresolve68 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree69 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree70 = "red_black_tree.rs" 147 12 147 89
  let%span sred_black_tree71 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree72 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree73 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree74 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree75 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree76 = "red_black_tree.rs" 316 8 316 112
  let%span soption77 = "../../creusot-contracts/src/std/option.rs" 429 20 429 32
  let%span sred_black_tree78 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree79 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree80 = "red_black_tree.rs" 342 12 348 13
  let%span sord81 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord82 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord83 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord84 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord85 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord86 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord87 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord88 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord89 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord90 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord91 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord92 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord93 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree94 = "red_black_tree.rs" 311 20 311 102
  let%span sboxed95 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant96 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree97 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree98 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree99 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree100 = "red_black_tree.rs" 368 20 368 61
  let%span sinvariant101 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'14 (_1 : t_K'0)
  
  predicate inv'15 (_1 : t_V'0)
  
  predicate inv'5 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Tree'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'5 left
    /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'0 (self : t_Node'0) =
    [%#sboxed95] inv'3 self
  
  predicate inv'1 (_1 : t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Node'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_Node'0)
  
  predicate invariant'4 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant96] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'1 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant96] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'9 (_1 : t_Option'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Option'1 [inv'9 x] . inv'9 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'7 self}
    any
    [ return' (result:t_Option'1)-> {inv'9 result}
      {[%#soption11] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption12] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'9 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'2 result}
      {[%#soption14] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant96] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  let rec as_mut'1 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:as_mut 'self' type invariant] inv'2 self}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'4 result}
      {[%#sboxed15] self.current = result.current}
      {[%#sboxed16] self.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'5 (self : MutBorrow.t t_Node'0) =
    [%#sresolve68] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'5 _1
  
  predicate invariant'5 (self : t_Tree'0) =
    [%#sinvariant101] inv'5 self
  
  predicate inv'10 (_1 : t_Tree'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_Tree'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree67] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree17] inv'10 self}
    any [ return' (result:bool)-> {[%#sred_black_tree18] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree65] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord93] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord91] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord92] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord89] cmp_log'0 x y = C_Less'0)
   -> ([%#sord90] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord86] cmp_log'0 x y
  = o)  -> ([%#sord87] cmp_log'0 y z = o)  -> ([%#sord88] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord85] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord84] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord83] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord82] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord81] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree99] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree79] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree97] bst_invariant_here'0 self
    /\ bst_invariant'0 self.t_Node__left'0 /\ bst_invariant'0 self.t_Node__right'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree64] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree63] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree100] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree80] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree98] height_invariant_here'0 self
    /\ height_invariant'0 self.t_Node__left'0 /\ height_invariant'0 self.t_Node__right'0
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree69] bst_invariant'1 self /\ height_invariant'1 self
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree75] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree74] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree70] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree72] match self.t_Node__color'0 with
      | C_Red'0 -> height'0 self.t_Node__left'0
      | C_Black'0 -> height'0 self.t_Node__left'0 + 1
      end
  
  axiom height'1_spec : forall self : t_Node'0 . [%#sred_black_tree71] forall node : t_Node'0 . self = node
   -> height'1 self = height'0 { t_Tree__node'0 = C_Some'0 node }
  
  let rec rotate_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree19] inv'4 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree20] internal_invariant'1 self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree21] color'0 (self.current).t_Node__left'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree22] same_mappings'0 self.current self.final}
      {[%#sred_black_tree23] internal_invariant'1 self.final}
      {[%#sred_black_tree24] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree25] lt_log'0 (deep_model'0 (self.final).t_Node__key'0) (deep_model'0 (self.current).t_Node__key'0)}
      {[%#sred_black_tree26] color'0 (self.final).t_Node__right'0 = C_Red'0}
      {[%#sred_black_tree27] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree28] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'0 l
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'0 r
      /\ ((self.final).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      = (l.t_Node__left'0, l.t_Node__right'0, (self.current).t_Node__right'0)
      /\ r.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Node'0
  
  predicate invariant'6 (self : t_Option'0) =
    [%#sinvariant101] inv'0 self
  
  predicate inv'11 (_1 : t_Option'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Option'0 [inv'11 x] . inv'11 x = invariant'6 x
  
  predicate invariant'7 (self : t_Node'0) =
    [%#sinvariant101] inv'1 self
  
  predicate inv'13 (_1 : t_Node'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Node'0 [inv'13 x] . inv'13 x = invariant'7 x
  
  predicate inv'12 (_1 : t_Option'2)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Option'2 [inv'12 x] . inv'12 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'13 a_0
    end
  
  let rec as_ref'0 (self:t_Option'0) (return'  (ret:t_Option'2))= {[@expl:as_ref 'self' type invariant] inv'11 self}
    any
    [ return' (result:t_Option'2)-> {inv'12 result}
      {[%#soption29] self = C_None'0  -> result = C_None'2}
      {[%#soption30] self = C_None'0 \/ (exists r : t_Node'0 . result = C_Some'2 r /\ self = C_Some'0 r)}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'2) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'12 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'2}
    any [ return' (result:t_Node'0)-> {inv'13 result} {[%#soption14] C_Some'2 result = self} (! return' {result}) ] 
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree94] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree66] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree76] color_invariant_here'0 self
    /\ color_invariant'0 self.t_Node__left'0 /\ color_invariant'0 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree61] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree73] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'1 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree62] C_CPN'0 c l r
  
  let rec move_red_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree31] inv'4 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree32] ((self.current).t_Node__left'0).t_Tree__node'0
    <> C_None'0}
    {[@expl:move_red_right requires #1] [%#sred_black_tree33] internal_invariant'1 self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree34] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Black'0)))) self.current}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {[%#sred_black_tree35] inv'4 result}
      {[%#sred_black_tree36] internal_invariant'1 result.current}
      {[%#sred_black_tree37] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree38] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree39] (result.current).t_Node__key'0 = (self.current).t_Node__key'0}
      {[%#sred_black_tree40] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree41] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 (deep_model'0 (self.current).t_Node__key'0) k  -> has_mapping'1 result.current k v}
      {[%#sred_black_tree42] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree43] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) result.current
      \/ match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) result.current}
      {[%#sred_black_tree44] color_invariant'1 result.final
      /\ (color'0 (result.current).t_Node__left'0 = C_Black'0  -> (result.final).t_Node__color'0 = C_Black'0)
       -> color_invariant'1 self.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t t_Node'0) =
    [%#sresolve68] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Node'0) =
    resolve'6 _1
  
  let rec balance'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree45] inv'4 self}
    {[@expl:balance requires #0] [%#sred_black_tree46] internal_invariant'1 self.current}
    {[@expl:balance requires #1] [%#sred_black_tree47] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__left'0}
    {[@expl:balance requires #2] [%#sred_black_tree48] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__right'0}
    {[@expl:balance requires #3] [%#sred_black_tree49] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0 /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> false}
    any
    [ return' (result:())-> {[%#sred_black_tree50] same_mappings'0 self.current self.final}
      {[%#sred_black_tree51] internal_invariant'1 self.final}
      {[%#sred_black_tree52] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree53] color_invariant'0 (self.current).t_Node__left'0
      /\ color'0 (self.current).t_Node__right'0 = C_Black'0  -> self.current = self.final}
      {[%#sred_black_tree54] match_n'0 (cpn'0 (C_Black'0) (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      {[%#sred_black_tree55] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree56] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree57] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      (! return' {result}) ]
  
  
  predicate invariant'3 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant96] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate resolve'7 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve68] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Tree'0) =
    resolve'7 _1
  
  predicate is_default'0 (self : t_Option'0) =
    [%#soption77] self = C_None'0
  
  let rec take'0 (dest:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'dest' type invariant] inv'7 dest}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem58] result = dest.current}
      {[%#smem59] is_default'0 dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'8 (self : MutBorrow.t t_Option'0) =
    [%#sresolve68] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_Option'0) =
    resolve'8 _1
  
  let rec unwrap'2 (self:t_Option'0) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'0}
    any [ return' (result:t_Node'0)-> {inv'1 result} {[%#soption14] C_Some'0 result = self} (! return' {result}) ] 
  
  predicate resolve'10 (_1 : t_V'0)
  
  predicate resolve'9 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree78] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'10 v
  
  predicate resolve'4 (_1 : t_Tree'0) =
    resolve'9 _1
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree60] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate inv'8 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'8 x] . inv'8 x
  = (let (x0, x1) = x in inv'14 x0 /\ inv'15 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max_rec'0[#"red_black_tree.rs" 652 4 652 42] (self:MutBorrow.t t_Tree'0) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:delete_max_rec 'self' type invariant] [%#sred_black_tree0] inv'6 self}
    {[@expl:delete_max_rec requires #0] [%#sred_black_tree1] internal_invariant'0 self.current}
    {[@expl:delete_max_rec requires #1] [%#sred_black_tree2] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {(self.current).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':t_Option'1) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'1 _13.current}
        MutBorrow.borrow_final <t_Node'0> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final } ] 
            s1)
      | s1 = as_mut'1 {_12} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_17 <- _ret' ] s3)
      | s3 = bb4 ]
    
    | bb4 = any [ br0 -> {_17 = false} (! bb7) | br1 -> {_17} (! bb5) ] 
    | bb5 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node'0> {node.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_19 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = rotate_right'0 {_19} (fun (_ret':()) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = bb8
    | bb7 = bb8
    | bb8 = any
      [ br0 -> {((node.current).t_Node__right'0).t_Tree__node'0 = C_None'0} (! bb9)
      | br1 (x0:t_Node'0)-> {((node.current).t_Node__right'0).t_Tree__node'0 = C_Some'0 x0} (! bb15) ]
    
    | bb15 = s0
      [ s0 = is_red'0 {(node.current).t_Node__right'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1) | s1 = bb16 ]
    
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb25
    | bb18 = s0
      [ s0 = as_ref'0 {((node.current).t_Node__right'0).t_Tree__node'0}
          (fun (_ret':t_Option'2) ->  [ &_35 <- _ret' ] s1)
      | s1 = bb19 ]
    
    | bb19 = s0 [ s0 = unwrap'1 {_35} (fun (_ret':t_Node'0) ->  [ &_34 <- _ret' ] s1) | s1 = bb20 ] 
    | bb20 = s0 [ s0 = is_red'0 {_34.t_Node__left'0} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb22) ] 
    | bb22 = bb25
    | bb25 = bb26
    | bb23 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_39 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = move_red_right'0 {_39} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 = {inv'3 _38.current}
        MutBorrow.borrow_final <t_Node'0> {_38.current} {MutBorrow.get_id _38}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_37 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_38 <- { _38 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _37 ] s4
      | s4 = {[@expl:type invariant] inv'4 _38} s5
      | s5 = -{resolve'1 _38}- s6
      | s6 = bb26 ]
    
    | bb26 = s0
      [ s0 = {inv'5 (node.current).t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_41 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__right'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_max_rec'0 {_41} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb27 ]
    
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_43 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = balance'0 {_43} (fun (_ret':()) ->  [ &_42 <- _ret' ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb29 ]
    
    | bb29 = bb31
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'4 node} s1 | s1 = -{resolve'1 node}- s2 | s2 = bb10 ] 
    | bb10 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {(self.current).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_26 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _26.current}
        MutBorrow.borrow_final <t_Option'0> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_26 <- { _26 with current = _ret'.final } ] 
            s2)
      | s2 = take'0 {_25} (fun (_ret':t_Option'0) ->  [ &_24 <- _ret' ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'3 _26}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = unwrap'2 {_24} (fun (_ret':t_Node'0) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb12 ]
    
    | bb12 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | {t_Node__right'0 = x'0} -> inv'5 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | {t_Node__right'0 = x'1} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | {t_Node__left'0 = x'2} -> inv'5 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | {t_Node__left'0 = x'3} -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 =  [ &_0 <- (node1.t_Node__key'0, node1.t_Node__val'0) ] s5
      | s5 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb30
    | bb30 = bb31
    | bb31 = return' {_0} ]
    )
    [ & _0 : (t_K'0, t_V'0) = Any.any_l ()
    | & self : MutBorrow.t t_Tree'0 = self
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _12 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _13 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _14 : t_Option'1 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _16 : () = Any.any_l ()
    | & _17 : bool = Any.any_l ()
    | & _19 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & node1 : t_Node'0 = Any.any_l ()
    | & _24 : t_Option'0 = Any.any_l ()
    | & _25 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _26 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _30 : bool = Any.any_l ()
    | & _32 : bool = Any.any_l ()
    | & _34 : t_Node'0 = Any.any_l ()
    | & _35 : t_Option'2 = Any.any_l ()
    | & _37 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _38 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _39 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & r : (t_K'0, t_V'0) = Any.any_l ()
    | & _41 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _42 : () = Any.any_l ()
    | & _43 : MutBorrow.t t_Node'0 = Any.any_l () ]
    
    [ return' (result:(t_K'0, t_V'0))-> {[@expl:delete_max_rec result type invariant] [%#sred_black_tree3] inv'8 result}
      {[@expl:delete_max_rec ensures #0] [%#sred_black_tree4] internal_invariant'0 self.final}
      {[@expl:delete_max_rec ensures #1] [%#sred_black_tree5] height'0 self.current = height'0 self.final}
      {[@expl:delete_max_rec ensures #2] [%#sred_black_tree6] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:delete_max_rec ensures #3] [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 k (deep_model'0 (let (a, _) = result in a))}
      {[@expl:delete_max_rec ensures #4] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[@expl:delete_max_rec ensures #5] [%#sred_black_tree9] color_invariant'0 self.final}
      {[@expl:delete_max_rec ensures #6] [%#sred_black_tree10] color'0 self.current = C_Black'0
       -> color'0 self.final = C_Black'0}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__delete_min_rec [#"red_black_tree.rs" 680 4 680 42] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 680 27 680 31
  let%span sred_black_tree1 = "red_black_tree.rs" 669 15 669 43
  let%span sred_black_tree2 = "red_black_tree.rs" 670 15 671 62
  let%span sred_black_tree3 = "red_black_tree.rs" 680 36 680 42
  let%span sred_black_tree4 = "red_black_tree.rs" 672 14 672 42
  let%span sred_black_tree5 = "red_black_tree.rs" 673 14 673 50
  let%span sred_black_tree6 = "red_black_tree.rs" 674 14 674 66
  let%span sred_black_tree7 = "red_black_tree.rs" 675 14 675 102
  let%span sred_black_tree8 = "red_black_tree.rs" 676 14 677 71
  let%span sred_black_tree9 = "red_black_tree.rs" 678 14 678 39
  let%span sred_black_tree10 = "red_black_tree.rs" 679 14 679 67
  let%span soption11 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 48 26 48 43
  let%span sboxed16 = "../../creusot-contracts/src/std/boxed.rs" 49 26 49 43
  let%span sred_black_tree17 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree18 = "red_black_tree.rs" 411 14 411 45
  let%span soption19 = "../../creusot-contracts/src/std/option.rs" 55 26 55 58
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 57 20 57 89
  let%span sred_black_tree21 = "red_black_tree.rs" 566 26 566 30
  let%span sred_black_tree22 = "red_black_tree.rs" 548 15 548 41
  let%span sred_black_tree23 = "red_black_tree.rs" 549 15 549 43
  let%span sred_black_tree24 = "red_black_tree.rs" 550 15 550 86
  let%span sred_black_tree25 = "red_black_tree.rs" 566 35 566 44
  let%span sred_black_tree26 = "red_black_tree.rs" 551 14 551 44
  let%span sred_black_tree27 = "red_black_tree.rs" 552 14 554 46
  let%span sred_black_tree28 = "red_black_tree.rs" 555 14 555 95
  let%span sred_black_tree29 = "red_black_tree.rs" 556 14 556 42
  let%span sred_black_tree30 = "red_black_tree.rs" 557 14 557 103
  let%span sred_black_tree31 = "red_black_tree.rs" 558 14 559 45
  let%span sred_black_tree32 = "red_black_tree.rs" 560 14 561 106
  let%span sred_black_tree33 = "red_black_tree.rs" 562 14 563 61
  let%span sred_black_tree34 = "red_black_tree.rs" 564 14 565 43
  let%span sred_black_tree35 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree36 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree37 = "red_black_tree.rs" 516 15 517 45
  let%span sred_black_tree38 = "red_black_tree.rs" 518 15 519 46
  let%span sred_black_tree39 = "red_black_tree.rs" 520 15 520 108
  let%span sred_black_tree40 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree41 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree42 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree43 = "red_black_tree.rs" 524 14 525 32
  let%span sred_black_tree44 = "red_black_tree.rs" 526 14 527 37
  let%span sred_black_tree45 = "red_black_tree.rs" 528 14 529 61
  let%span sred_black_tree46 = "red_black_tree.rs" 530 14 531 59
  let%span sred_black_tree47 = "red_black_tree.rs" 532 14 533 37
  let%span smem48 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem49 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span sred_black_tree50 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree51 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree52 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree53 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree54 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree55 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree56 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree57 = "red_black_tree.rs" 287 12 290 13
  let%span sresolve58 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree59 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree60 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree61 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree62 = "red_black_tree.rs" 359 12 362 13
  let%span sred_black_tree63 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree64 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree65 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree66 = "red_black_tree.rs" 147 12 147 89
  let%span soption67 = "../../creusot-contracts/src/std/option.rs" 429 20 429 32
  let%span sred_black_tree68 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree69 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree70 = "red_black_tree.rs" 342 12 348 13
  let%span sord71 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord72 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord73 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord74 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord75 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord76 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord77 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord78 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord79 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord80 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord81 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord82 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord83 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree84 = "red_black_tree.rs" 311 20 311 102
  let%span sboxed85 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant86 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree87 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree88 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree89 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree90 = "red_black_tree.rs" 368 20 368 61
  let%span sinvariant91 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'14 (_1 : t_K'0)
  
  predicate inv'15 (_1 : t_V'0)
  
  predicate inv'5 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Tree'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'5 left
    /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'0 (self : t_Node'0) =
    [%#sboxed85] inv'3 self
  
  predicate inv'1 (_1 : t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Node'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'1 a_0
    end
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_Node'0)
  
  predicate invariant'4 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant86] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'1 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant86] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'9 (_1 : t_Option'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Option'1 [inv'9 x] . inv'9 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'7 self}
    any
    [ return' (result:t_Option'1)-> {inv'9 result}
      {[%#soption11] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption12] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'9 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'2 result}
      {[%#soption14] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant86] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  let rec as_mut'1 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:as_mut 'self' type invariant] inv'2 self}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'4 result}
      {[%#sboxed15] self.current = result.current}
      {[%#sboxed16] self.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'5 (self : MutBorrow.t t_Node'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'5 _1
  
  predicate invariant'5 (self : t_Tree'0) =
    [%#sinvariant91] inv'5 self
  
  predicate inv'10 (_1 : t_Tree'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_Tree'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree57] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree17] inv'10 self}
    any [ return' (result:bool)-> {[%#sred_black_tree18] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Node'0
  
  predicate invariant'6 (self : t_Option'0) =
    [%#sinvariant91] inv'0 self
  
  predicate inv'11 (_1 : t_Option'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Option'0 [inv'11 x] . inv'11 x = invariant'6 x
  
  predicate invariant'7 (self : t_Node'0) =
    [%#sinvariant91] inv'1 self
  
  predicate inv'13 (_1 : t_Node'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Node'0 [inv'13 x] . inv'13 x = invariant'7 x
  
  predicate inv'12 (_1 : t_Option'2)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Option'2 [inv'12 x] . inv'12 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'13 a_0
    end
  
  let rec as_ref'0 (self:t_Option'0) (return'  (ret:t_Option'2))= {[@expl:as_ref 'self' type invariant] inv'11 self}
    any
    [ return' (result:t_Option'2)-> {inv'12 result}
      {[%#soption19] self = C_None'0  -> result = C_None'2}
      {[%#soption20] self = C_None'0 \/ (exists r : t_Node'0 . result = C_Some'2 r /\ self = C_Some'0 r)}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'2) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'12 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'2}
    any [ return' (result:t_Node'0)-> {inv'13 result} {[%#soption14] C_Some'2 result = self} (! return' {result}) ] 
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree55] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord83] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord81] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord82] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord79] cmp_log'0 x y = C_Less'0)
   -> ([%#sord80] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord76] cmp_log'0 x y
  = o)  -> ([%#sord77] cmp_log'0 y z = o)  -> ([%#sord78] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord75] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord74] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord73] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord72] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord71] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree89] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree69] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree87] bst_invariant_here'0 self
    /\ bst_invariant'0 self.t_Node__left'0 /\ bst_invariant'0 self.t_Node__right'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree54] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree53] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree90] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree70] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree88] height_invariant_here'0 self
    /\ height_invariant'0 self.t_Node__left'0 /\ height_invariant'0 self.t_Node__right'0
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree59] bst_invariant'1 self /\ height_invariant'1 self
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree84] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree56] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree65] color_invariant_here'0 self
    /\ color_invariant'0 self.t_Node__left'0 /\ color_invariant'0 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree51] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree60] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'1 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree52] C_CPN'0 c l r
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree62] match self.t_Node__color'0 with
      | C_Red'0 -> height'0 self.t_Node__left'0
      | C_Black'0 -> height'0 self.t_Node__left'0 + 1
      end
  
  axiom height'1_spec : forall self : t_Node'0 . [%#sred_black_tree61] forall node : t_Node'0 . self = node
   -> height'1 self = height'0 { t_Tree__node'0 = C_Some'0 node }
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree64] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree63] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  let rec move_red_left'0 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree21] inv'4 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree22] ((self.current).t_Node__right'0).t_Tree__node'0
    <> C_None'0}
    {[@expl:move_red_left requires #1] [%#sred_black_tree23] internal_invariant'1 self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree24] match_n'0 (cpn'0 (C_Red'0) (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {[%#sred_black_tree25] inv'4 result}
      {[%#sred_black_tree26] internal_invariant'1 result.current}
      {[%#sred_black_tree27] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree28] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree29] (self.current).t_Node__key'0 = (result.current).t_Node__key'0}
      {[%#sred_black_tree30] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree31] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 k (deep_model'0 (self.current).t_Node__key'0)  -> has_mapping'1 result.current k v}
      {[%#sred_black_tree32] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree33] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) result.current
      \/ match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) result.current}
      {[%#sred_black_tree34] color_invariant'1 result.final
      /\ (color'0 (result.current).t_Node__right'0 = C_Black'0  -> (result.final).t_Node__color'0 = C_Black'0)
       -> color_invariant'1 self.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t t_Node'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Node'0) =
    resolve'6 _1
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree66] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  let rec balance'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree35] inv'4 self}
    {[@expl:balance requires #0] [%#sred_black_tree36] internal_invariant'1 self.current}
    {[@expl:balance requires #1] [%#sred_black_tree37] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__left'0}
    {[@expl:balance requires #2] [%#sred_black_tree38] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__right'0}
    {[@expl:balance requires #3] [%#sred_black_tree39] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0 /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> false}
    any
    [ return' (result:())-> {[%#sred_black_tree40] same_mappings'0 self.current self.final}
      {[%#sred_black_tree41] internal_invariant'1 self.final}
      {[%#sred_black_tree42] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree43] color_invariant'0 (self.current).t_Node__left'0
      /\ color'0 (self.current).t_Node__right'0 = C_Black'0  -> self.current = self.final}
      {[%#sred_black_tree44] match_n'0 (cpn'0 (C_Black'0) (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      {[%#sred_black_tree45] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree46] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree47] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      (! return' {result}) ]
  
  
  predicate invariant'3 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant86] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate resolve'7 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Tree'0) =
    resolve'7 _1
  
  predicate is_default'0 (self : t_Option'0) =
    [%#soption67] self = C_None'0
  
  let rec take'0 (dest:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'dest' type invariant] inv'7 dest}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem48] result = dest.current}
      {[%#smem49] is_default'0 dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'8 (self : MutBorrow.t t_Option'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_Option'0) =
    resolve'8 _1
  
  let rec unwrap'2 (self:t_Option'0) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'0}
    any [ return' (result:t_Node'0)-> {inv'1 result} {[%#soption14] C_Some'0 result = self} (! return' {result}) ] 
  
  predicate resolve'10 (_1 : t_V'0)
  
  predicate resolve'9 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree68] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'10 v
  
  predicate resolve'4 (_1 : t_Tree'0) =
    resolve'9 _1
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree50] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate inv'8 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'8 x] . inv'8 x
  = (let (x0, x1) = x in inv'14 x0 /\ inv'15 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min_rec'0[#"red_black_tree.rs" 680 4 680 42] (self:MutBorrow.t t_Tree'0) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree0] inv'6 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree1] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree2] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {(self.current).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_15 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = as_mut'0 {_15} (fun (_ret':t_Option'1) ->  [ &_14 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap'0 {_14} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'1 _13.current}
        MutBorrow.borrow_final <t_Node'0> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_13 <- { _13 with current = _ret'.final } ] 
            s1)
      | s1 = as_mut'1 {_12} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = any
        [ br0 -> {((node.current).t_Node__left'0).t_Tree__node'0 = C_None'0} (! bb4)
        | br1 (x0:t_Node'0)-> {((node.current).t_Node__left'0).t_Tree__node'0 = C_Some'0 x0} (! bb10) ]
       ]
    
    | bb10 = s0
      [ s0 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1) | s1 = bb11 ]
    
    | bb11 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = as_ref'0 {((node.current).t_Node__left'0).t_Tree__node'0} (fun (_ret':t_Option'2) ->  [ &_31 <- _ret' ] s1)
      | s1 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'1 {_31} (fun (_ret':t_Node'0) ->  [ &_30 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0 [ s0 = is_red'0 {_30.t_Node__left'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_35 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = move_red_left'0 {_35} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_34 <- _ret' ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0
      [ s0 = {inv'3 _34.current}
        MutBorrow.borrow_final <t_Node'0> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_33 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_34 <- { _34 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'4 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _33 ] s4
      | s4 = {[@expl:type invariant] inv'4 _34} s5
      | s5 = -{resolve'1 _34}- s6
      | s6 = bb21 ]
    
    | bb21 = s0
      [ s0 = {inv'5 (node.current).t_Node__left'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__left'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_37 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__left'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_min_rec'0 {_37} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb22 ]
    
    | bb22 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_39 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = balance'0 {_39} (fun (_ret':()) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb23 ]
    
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb24 ]
    
    | bb24 = bb26
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'4 node} s1 | s1 = -{resolve'1 node}- s2 | s2 = bb5 ] 
    | bb5 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {(self.current).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_22 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _22.current}
        MutBorrow.borrow_final <t_Option'0> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_21 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_22 <- { _22 with current = _ret'.final } ] 
            s2)
      | s2 = take'0 {_21} (fun (_ret':t_Option'0) ->  [ &_20 <- _ret' ] s3)
      | s3 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'7 _22} s1
      | s1 = -{resolve'3 _22}- s2
      | s2 = {[@expl:type invariant] inv'6 self} s3
      | s3 = -{resolve'2 self}- s4
      | s4 = unwrap'2 {_20} (fun (_ret':t_Node'0) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | {t_Node__right'0 = x'0} -> inv'5 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | {t_Node__right'0 = x'1} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | {t_Node__left'0 = x'2} -> inv'5 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | {t_Node__left'0 = x'3} -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 =  [ &_0 <- (node1.t_Node__key'0, node1.t_Node__val'0) ] s5
      | s5 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb25
    | bb25 = bb26
    | bb26 = return' {_0} ]
    )
    [ & _0 : (t_K'0, t_V'0) = Any.any_l ()
    | & self : MutBorrow.t t_Tree'0 = self
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _12 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _13 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _14 : t_Option'1 = Any.any_l ()
    | & _15 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & node1 : t_Node'0 = Any.any_l ()
    | & _20 : t_Option'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _22 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _26 : bool = Any.any_l ()
    | & _28 : bool = Any.any_l ()
    | & _30 : t_Node'0 = Any.any_l ()
    | & _31 : t_Option'2 = Any.any_l ()
    | & _33 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _34 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _35 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & r : (t_K'0, t_V'0) = Any.any_l ()
    | & _37 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _38 : () = Any.any_l ()
    | & _39 : MutBorrow.t t_Node'0 = Any.any_l () ]
    
    [ return' (result:(t_K'0, t_V'0))-> {[@expl:delete_min_rec result type invariant] [%#sred_black_tree3] inv'8 result}
      {[@expl:delete_min_rec ensures #0] [%#sred_black_tree4] internal_invariant'0 self.final}
      {[@expl:delete_min_rec ensures #1] [%#sred_black_tree5] height'0 self.current = height'0 self.final}
      {[@expl:delete_min_rec ensures #2] [%#sred_black_tree6] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[@expl:delete_min_rec ensures #3] [%#sred_black_tree7] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'0 (let (a, _) = result in a)) k}
      {[@expl:delete_min_rec ensures #4] [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[@expl:delete_min_rec ensures #5] [%#sred_black_tree9] color_invariant'0 self.final}
      {[@expl:delete_min_rec ensures #6] [%#sred_black_tree10] color'0 self.current = C_Black'0
       -> color'0 self.final = C_Black'0}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__delete_rec [#"red_black_tree.rs" 706 4 706 55] (* Tree<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 736 24 736 59
  let%span sred_black_tree1 = "red_black_tree.rs" 706 23 706 27
  let%span sred_black_tree2 = "red_black_tree.rs" 706 29 706 32
  let%span sred_black_tree3 = "red_black_tree.rs" 694 15 694 43
  let%span sred_black_tree4 = "red_black_tree.rs" 695 15 696 62
  let%span sred_black_tree5 = "red_black_tree.rs" 706 41 706 55
  let%span sred_black_tree6 = "red_black_tree.rs" 697 14 697 42
  let%span sred_black_tree7 = "red_black_tree.rs" 698 14 698 50
  let%span sred_black_tree8 = "red_black_tree.rs" 699 14 702 5
  let%span sred_black_tree9 = "red_black_tree.rs" 703 14 703 127
  let%span sred_black_tree10 = "red_black_tree.rs" 704 14 704 39
  let%span sred_black_tree11 = "red_black_tree.rs" 705 14 705 67
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sboxed16 = "../../creusot-contracts/src/std/boxed.rs" 48 26 48 43
  let%span sboxed17 = "../../creusot-contracts/src/std/boxed.rs" 49 26 49 43
  let%span scmp18 = "../../creusot-contracts/src/std/cmp.rs" 72 26 72 85
  let%span sred_black_tree19 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree20 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree21 = "red_black_tree.rs" 436 25 436 29
  let%span sred_black_tree22 = "red_black_tree.rs" 424 15 424 43
  let%span sred_black_tree23 = "red_black_tree.rs" 425 15 425 42
  let%span sred_black_tree24 = "red_black_tree.rs" 426 14 426 42
  let%span sred_black_tree25 = "red_black_tree.rs" 427 14 427 42
  let%span sred_black_tree26 = "red_black_tree.rs" 428 14 428 50
  let%span sred_black_tree27 = "red_black_tree.rs" 429 14 429 65
  let%span sred_black_tree28 = "red_black_tree.rs" 430 14 430 42
  let%span sred_black_tree29 = "red_black_tree.rs" 431 14 431 44
  let%span sred_black_tree30 = "red_black_tree.rs" 432 14 435 34
  let%span soption31 = "../../creusot-contracts/src/std/option.rs" 51 26 51 51
  let%span smem32 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 37
  let%span smem33 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 42
  let%span soption34 = "../../creusot-contracts/src/std/option.rs" 55 26 55 58
  let%span soption35 = "../../creusot-contracts/src/std/option.rs" 57 20 57 89
  let%span sred_black_tree36 = "red_black_tree.rs" 595 27 595 31
  let%span sred_black_tree37 = "red_black_tree.rs" 577 15 577 40
  let%span sred_black_tree38 = "red_black_tree.rs" 578 15 578 43
  let%span sred_black_tree39 = "red_black_tree.rs" 579 15 579 86
  let%span sred_black_tree40 = "red_black_tree.rs" 595 36 595 45
  let%span sred_black_tree41 = "red_black_tree.rs" 580 14 580 44
  let%span sred_black_tree42 = "red_black_tree.rs" 581 14 583 46
  let%span sred_black_tree43 = "red_black_tree.rs" 584 14 584 95
  let%span sred_black_tree44 = "red_black_tree.rs" 585 14 585 42
  let%span sred_black_tree45 = "red_black_tree.rs" 586 14 586 103
  let%span sred_black_tree46 = "red_black_tree.rs" 587 14 588 45
  let%span sred_black_tree47 = "red_black_tree.rs" 589 14 590 106
  let%span sred_black_tree48 = "red_black_tree.rs" 591 14 592 61
  let%span sred_black_tree49 = "red_black_tree.rs" 593 14 594 43
  let%span sred_black_tree50 = "red_black_tree.rs" 680 27 680 31
  let%span sred_black_tree51 = "red_black_tree.rs" 669 15 669 43
  let%span sred_black_tree52 = "red_black_tree.rs" 670 15 671 62
  let%span sred_black_tree53 = "red_black_tree.rs" 680 36 680 42
  let%span sred_black_tree54 = "red_black_tree.rs" 672 14 672 42
  let%span sred_black_tree55 = "red_black_tree.rs" 673 14 673 50
  let%span sred_black_tree56 = "red_black_tree.rs" 674 14 674 66
  let%span sred_black_tree57 = "red_black_tree.rs" 675 14 675 102
  let%span sred_black_tree58 = "red_black_tree.rs" 676 14 677 71
  let%span sred_black_tree59 = "red_black_tree.rs" 678 14 678 39
  let%span sred_black_tree60 = "red_black_tree.rs" 679 14 679 67
  let%span sred_black_tree61 = "red_black_tree.rs" 118 15 118 35
  let%span sred_black_tree62 = "red_black_tree.rs" 119 15 119 38
  let%span sred_black_tree63 = "red_black_tree.rs" 120 15 120 38
  let%span sred_black_tree64 = "red_black_tree.rs" 121 14 121 22
  let%span sred_black_tree65 = "red_black_tree.rs" 127 12 127 37
  let%span smem66 = "../../creusot-contracts/src/std/mem.rs" 13 22 13 30
  let%span smem67 = "../../creusot-contracts/src/std/mem.rs" 14 22 14 30
  let%span sred_black_tree68 = "red_black_tree.rs" 566 26 566 30
  let%span sred_black_tree69 = "red_black_tree.rs" 548 15 548 41
  let%span sred_black_tree70 = "red_black_tree.rs" 549 15 549 43
  let%span sred_black_tree71 = "red_black_tree.rs" 550 15 550 86
  let%span sred_black_tree72 = "red_black_tree.rs" 566 35 566 44
  let%span sred_black_tree73 = "red_black_tree.rs" 551 14 551 44
  let%span sred_black_tree74 = "red_black_tree.rs" 552 14 554 46
  let%span sred_black_tree75 = "red_black_tree.rs" 555 14 555 95
  let%span sred_black_tree76 = "red_black_tree.rs" 556 14 556 42
  let%span sred_black_tree77 = "red_black_tree.rs" 557 14 557 103
  let%span sred_black_tree78 = "red_black_tree.rs" 558 14 559 45
  let%span sred_black_tree79 = "red_black_tree.rs" 560 14 561 106
  let%span sred_black_tree80 = "red_black_tree.rs" 562 14 563 61
  let%span sred_black_tree81 = "red_black_tree.rs" 564 14 565 43
  let%span sred_black_tree82 = "red_black_tree.rs" 534 20 534 24
  let%span sred_black_tree83 = "red_black_tree.rs" 515 15 515 43
  let%span sred_black_tree84 = "red_black_tree.rs" 516 15 517 45
  let%span sred_black_tree85 = "red_black_tree.rs" 518 15 519 46
  let%span sred_black_tree86 = "red_black_tree.rs" 520 15 520 108
  let%span sred_black_tree87 = "red_black_tree.rs" 521 14 521 42
  let%span sred_black_tree88 = "red_black_tree.rs" 522 14 522 42
  let%span sred_black_tree89 = "red_black_tree.rs" 523 14 523 50
  let%span sred_black_tree90 = "red_black_tree.rs" 524 14 525 32
  let%span sred_black_tree91 = "red_black_tree.rs" 526 14 527 37
  let%span sred_black_tree92 = "red_black_tree.rs" 528 14 529 61
  let%span sred_black_tree93 = "red_black_tree.rs" 530 14 531 59
  let%span sred_black_tree94 = "red_black_tree.rs" 532 14 533 37
  let%span sred_black_tree95 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree96 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree97 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree98 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree99 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree100 = "red_black_tree.rs" 37 12 41 13
  let%span smodel101 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sred_black_tree102 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree103 = "red_black_tree.rs" 287 12 290 13
  let%span sresolve104 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree105 = "red_black_tree.rs" 403 12 403 59
  let%span sred_black_tree106 = "red_black_tree.rs" 147 12 147 89
  let%span sred_black_tree107 = "red_black_tree.rs" 355 14 356 75
  let%span sred_black_tree108 = "red_black_tree.rs" 359 12 362 13
  let%span soption109 = "../../creusot-contracts/src/std/option.rs" 429 20 429 32
  let%span sred_black_tree110 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree111 = "red_black_tree.rs" 275 12 278 13
  let%span sred_black_tree112 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree113 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree114 = "red_black_tree.rs" 316 8 316 112
  let%span sred_black_tree115 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree116 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree117 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree118 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree119 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree120 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree121 = "red_black_tree.rs" 311 20 311 102
  let%span sboxed122 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sinvariant123 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sord124 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord125 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord126 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord127 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord128 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord129 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord130 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord131 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord132 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord133 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord134 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord135 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord136 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree137 = "red_black_tree.rs" 222 8 224 9
  let%span sred_black_tree138 = "red_black_tree.rs" 373 8 373 115
  let%span sred_black_tree139 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree140 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree141 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree142 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree143 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree144 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree145 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant146 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree147 = "red_black_tree.rs" 368 20 368 61
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'1
    | C_Some'1 t_Node'0
  
  predicate inv'8 (_1 : t_K'0)
  
  predicate inv'10 (_1 : t_V'0)
  
  predicate inv'4 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Tree'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'4 left
    /\ inv'8 key /\ inv'10 val' /\ inv'4 right
    end
  
  predicate invariant'0 (self : t_Node'0) =
    [%#sboxed122] inv'3 self
  
  predicate inv'1 (_1 : t_Node'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Node'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'1 a_0
    end
  
  type t_Option'1  =
    | C_None'2
    | C_Some'2 (MutBorrow.t t_Node'0)
  
  predicate invariant'3 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant123] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate invariant'1 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant123] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'14 (_1 : t_Option'1)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Option'1 [inv'14 x] . inv'14 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'6 self}
    any
    [ return' (result:t_Option'1)-> {inv'14 result}
      {[%#soption12] self.current = C_None'1  -> result = C_None'2 /\ self.final = C_None'1}
      {[%#soption13] self.current = C_None'1
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'2 r
      /\ self.current = C_Some'1 (r.current) /\ self.final = C_Some'1 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'14 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'2}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'2 result}
      {[%#soption15] C_Some'2 result = self}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant123] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  let rec as_mut'1 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:as_mut 'self' type invariant] inv'2 self}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'5 result}
      {[%#sboxed16] self.current = result.current}
      {[%#sboxed17] self.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'7 (self : MutBorrow.t t_Node'0) =
    [%#sresolve104] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'7 _1
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  predicate invariant'7 (self : t_K'0) =
    [%#sinvariant146] inv'8 self
  
  predicate inv'12 (_1 : t_K'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_K'0 [inv'12 x] . inv'12 x = invariant'7 x
  
  type t_DeepModelTy'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord136] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord134] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord135] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord132] cmp_log'0 x y = C_Less'0)
   -> ([%#sord133] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord129] cmp_log'0 x y
  = o)  -> ([%#sord130] cmp_log'0 y z = o)  -> ([%#sord131] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord128] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord127] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord126] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord125] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord124] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:t_Ordering'0))= {[@expl:cmp 'self' type invariant] inv'12 self}
    {[@expl:cmp 'other' type invariant] inv'12 other}
    any
    [ return' (result:t_Ordering'0)-> {[%#scmp18] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate invariant'8 (self : t_Tree'0) =
    [%#sinvariant146] inv'4 self
  
  predicate inv'15 (_1 : t_Tree'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Tree'0 [inv'15 x] . inv'15 x = invariant'8 x
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree103] match self.t_Tree__node'0 with
      | C_Some'1 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree19] inv'15 self}
    any [ return' (result:bool)-> {[%#sred_black_tree20] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree100] match self with
      | {t_Tree__node'0 = C_None'1} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree139] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'1 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'1 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree115] match self with
      | {t_Tree__node'0 = C_None'1} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  predicate bst_invariant'1 [#"red_black_tree.rs" 221 4 221 34] (self : t_Node'0) =
    [%#sred_black_tree137] bst_invariant_here'0 self
    /\ bst_invariant'0 self.t_Node__left'0 /\ bst_invariant'0 self.t_Node__right'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree99] match self with
      | {t_Tree__node'0 = C_None'1} -> 0
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree98] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree147] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree120] match self with
      | {t_Tree__node'0 = C_None'1} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate height_invariant'1 [#"red_black_tree.rs" 372 4 372 37] (self : t_Node'0) =
    [%#sred_black_tree138] height_invariant_here'0 self
    /\ height_invariant'0 self.t_Node__left'0 /\ height_invariant'0 self.t_Node__right'0
  
  predicate internal_invariant'1 [#"red_black_tree.rs" 401 4 401 39] (self : t_Node'0) =
    [%#sred_black_tree105] bst_invariant'1 self /\ height_invariant'1 self
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree113] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'1 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree112] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'1 node } k v
  
  predicate same_mappings'0 [#"red_black_tree.rs" 145 4 145 43] (self : t_Node'0) (o : t_Node'0) =
    [%#sred_black_tree106] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v = has_mapping'1 o k v
  
  function height'1 [#"red_black_tree.rs" 357 4 357 26] (self : t_Node'0) : int =
    [%#sred_black_tree108] match self.t_Node__color'0 with
      | C_Red'0 -> height'0 self.t_Node__left'0
      | C_Black'0 -> height'0 self.t_Node__left'0 + 1
      end
  
  axiom height'1_spec : forall self : t_Node'0 . [%#sred_black_tree107] forall node : t_Node'0 . self = node
   -> height'1 self = height'0 { t_Tree__node'0 = C_Some'1 node }
  
  let rec rotate_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree21] inv'5 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree22] internal_invariant'1 self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree23] color'0 (self.current).t_Node__left'0 = C_Red'0}
    any
    [ return' (result:())-> {[%#sred_black_tree24] same_mappings'0 self.current self.final}
      {[%#sred_black_tree25] internal_invariant'1 self.final}
      {[%#sred_black_tree26] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree27] lt_log'0 (deep_model'1 (self.final).t_Node__key'0) (deep_model'1 (self.current).t_Node__key'0)}
      {[%#sred_black_tree28] color'0 (self.final).t_Node__right'0 = C_Red'0}
      {[%#sred_black_tree29] (self.final).t_Node__color'0 = (self.current).t_Node__color'0}
      {[%#sred_black_tree30] exists l : t_Node'0, r : t_Node'0 . ((self.current).t_Node__left'0).t_Tree__node'0
      = C_Some'1 l
      /\ ((self.final).t_Node__right'0).t_Tree__node'0 = C_Some'1 r
      /\ ((self.final).t_Node__left'0, r.t_Node__left'0, r.t_Node__right'0)
      = (l.t_Node__left'0, l.t_Node__right'0, (self.current).t_Node__right'0)
      /\ r.t_Node__key'0 = (self.current).t_Node__key'0}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'0
    | C_Some'0 (t_K'0, t_V'0)
  
  predicate invariant'9 (self : t_Option'0) =
    [%#sinvariant146] inv'0 self
  
  predicate inv'16 (_1 : t_Option'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_Option'0 [inv'16 x] . inv'16 x = invariant'9 x
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= {[@expl:is_none 'self' type invariant] inv'16 self}
    any [ return' (result:bool)-> {[%#soption31] result = (self = C_None'1)} (! return' {result}) ] 
  
  predicate resolve'8 (self : MutBorrow.t t_Node'0) =
    [%#sresolve104] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Node'0) =
    resolve'8 _1
  
  predicate is_default'0 (self : t_Option'0) =
    [%#soption109] self = C_None'1
  
  let rec take'0 (dest:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= {[@expl:take 'dest' type invariant] inv'6 dest}
    any
    [ return' (result:t_Option'0)-> {inv'0 result}
      {[%#smem32] result = dest.current}
      {[%#smem33] is_default'0 dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'9 (self : MutBorrow.t t_Option'0) =
    [%#sresolve104] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Option'0) =
    resolve'9 _1
  
  predicate invariant'4 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant123] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate resolve'10 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve104] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_Tree'0) =
    resolve'10 _1
  
  let rec unwrap'1 (self:t_Option'0) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'0 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'1}
    any [ return' (result:t_Node'0)-> {inv'1 result} {[%#soption15] C_Some'1 result = self} (! return' {result}) ] 
  
  predicate resolve'14 (_1 : t_V'0)
  
  predicate resolve'11 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree110] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'14 v
  
  predicate resolve'4 (_1 : t_Tree'0) =
    resolve'11 _1
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_Node'0
  
  predicate invariant'10 (self : t_Node'0) =
    [%#sinvariant146] inv'1 self
  
  predicate inv'18 (_1 : t_Node'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_Node'0 [inv'18 x] . inv'18 x = invariant'10 x
  
  predicate inv'17 (_1 : t_Option'3)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_Option'3 [inv'17 x] . inv'17 x
  = match x with
    | C_None'3 -> true
    | C_Some'3 a_0 -> inv'18 a_0
    end
  
  let rec as_ref'0 (self:t_Option'0) (return'  (ret:t_Option'3))= {[@expl:as_ref 'self' type invariant] inv'16 self}
    any
    [ return' (result:t_Option'3)-> {inv'17 result}
      {[%#soption34] self = C_None'1  -> result = C_None'3}
      {[%#soption35] self = C_None'1 \/ (exists r : t_Node'0 . result = C_Some'3 r /\ self = C_Some'1 r)}
      (! return' {result}) ]
  
  
  let rec unwrap'2 (self:t_Option'3) (return'  (ret:t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'17 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'3}
    any [ return' (result:t_Node'0)-> {inv'18 result} {[%#soption15] C_Some'3 result = self} (! return' {result}) ] 
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree121] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree102] match self with
      | {t_Tree__node'0 = C_None'1} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate color_invariant'1 [#"red_black_tree.rs" 315 4 315 36] (self : t_Node'0) =
    [%#sred_black_tree114] color_invariant_here'0 self
    /\ color_invariant'0 self.t_Node__left'0 /\ color_invariant'0 self.t_Node__right'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree96] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'1 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  predicate match_n'0 [#"red_black_tree.rs" 273 4 273 52] (self : t_CP'0) (node : t_Node'0) =
    [%#sred_black_tree111] match self with
      | C_CPL'0 color -> node.t_Node__color'0 = color /\ color_invariant'1 node
      | C_CPN'0 color l r -> node.t_Node__color'0 = color
      /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree97] C_CPN'0 c l r
  
  let rec move_red_right'0 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree36] inv'5 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree37] ((self.current).t_Node__left'0).t_Tree__node'0
    <> C_None'1}
    {[@expl:move_red_right requires #1] [%#sred_black_tree38] internal_invariant'1 self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree39] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Black'0)))) self.current}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {[%#sred_black_tree40] inv'5 result}
      {[%#sred_black_tree41] internal_invariant'1 result.current}
      {[%#sred_black_tree42] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree43] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree44] (result.current).t_Node__key'0 = (self.current).t_Node__key'0}
      {[%#sred_black_tree45] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree46] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 (deep_model'1 (self.current).t_Node__key'0) k  -> has_mapping'1 result.current k v}
      {[%#sred_black_tree47] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree48] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) result.current
      \/ match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) result.current}
      {[%#sred_black_tree49] color_invariant'1 result.final
      /\ (color'0 (result.current).t_Node__left'0 = C_Black'0  -> (result.final).t_Node__color'0 = C_Black'0)
       -> color_invariant'1 self.final}
      (! return' {result}) ]
  
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree95] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate inv'19 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'17 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'19 x] . inv'19 x
  = (let (x0, x1) = x in inv'8 x0 /\ inv'10 x1)
  
  let rec delete_min_rec'0 (self:MutBorrow.t t_Tree'0) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree50] inv'7 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree51] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree52] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    any
    [ return' (result:(t_K'0, t_V'0))-> {[%#sred_black_tree53] inv'19 result}
      {[%#sred_black_tree54] internal_invariant'0 self.final}
      {[%#sred_black_tree55] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree56] has_mapping'0 self.current (deep_model'1 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#sred_black_tree57] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'1 (let (a, _) = result in a)) k}
      {[%#sred_black_tree58] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'1 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree59] color_invariant'0 self.final}
      {[%#sred_black_tree60] color'0 self.current = C_Black'0  -> color'0 self.final = C_Black'0}
      (! return' {result}) ]
  
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'4) : Map.map t_DeepModelTy'0 t_Option'4
  
   =
    [%#sred_black_tree145] match self with
      | {t_Tree__node'0 = C_None'1} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'4 val') in model_acc'0 right accu2
      end
  
  function view'0 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'4 =
    [%#sred_black_tree119] model_acc'0 self (Const.const (C_None'4))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'4) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree141] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'4 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'4, k : t_DeepModelTy'0 . [%#sred_black_tree140] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'4 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'4) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree144] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'4 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'4, k : t_DeepModelTy'0 . ([%#sred_black_tree142] bst_invariant'0 self)
   -> ([%#sred_black_tree143] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'4 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree118] let _ = model_acc_has_mapping'0 self (Const.const (C_None'4)) k in has_mapping_model_acc'0 self (Const.const (C_None'4)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree116] bst_invariant'0 self)
   -> ([%#sred_black_tree117] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'0 self) k = C_Some'4 v))
  
  function has_mapping_inj'0 [#"red_black_tree.rs" 122 4 124 33] (self : t_Tree'0) (k : t_DeepModelTy'0) (v1 : t_V'0) (v2 : t_V'0) : ()
  
   =
    [%#sred_black_tree65] let _ = has_mapping_model'0 self k in match Map.get (view'0 self) k with
      | C_None'4 -> ()
      | C_Some'4 _v -> ()
      end
  
  axiom has_mapping_inj'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0, v1 : t_V'0, v2 : t_V'0 . ([%#sred_black_tree61] bst_invariant'0 self)
   -> ([%#sred_black_tree62] has_mapping'0 self k v1)
   -> ([%#sred_black_tree63] has_mapping'0 self k v2)  -> ([%#sred_black_tree64] v1 = v2)
  
  predicate invariant'5 (self : MutBorrow.t t_K'0) =
    [%#sinvariant123] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_1 : MutBorrow.t t_K'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_K'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  let rec swap'0 (x:MutBorrow.t t_K'0) (y:MutBorrow.t t_K'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'9 x}
    {[@expl:swap 'y' type invariant] inv'9 y}
    any
    [ return' (result:())-> {[%#smem66] x.final = y.current} {[%#smem67] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'12 (self : MutBorrow.t t_K'0) =
    [%#sresolve104] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_K'0) =
    resolve'12 _1
  
  predicate invariant'6 (self : MutBorrow.t t_V'0) =
    [%#sinvariant123] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'11 (_1 : MutBorrow.t t_V'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : MutBorrow.t t_V'0 [inv'11 x] . inv'11 x = invariant'6 x
  
  let rec swap'1 (x:MutBorrow.t t_V'0) (y:MutBorrow.t t_V'0) (return'  (ret:()))= {[@expl:swap 'x' type invariant] inv'11 x}
    {[@expl:swap 'y' type invariant] inv'11 y}
    any
    [ return' (result:())-> {[%#smem66] x.final = y.current} {[%#smem67] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'13 (self : MutBorrow.t t_V'0) =
    [%#sresolve104] self.final = self.current
  
  predicate resolve'6 (_1 : MutBorrow.t t_V'0) =
    resolve'13 _1
  
  let rec move_red_left'0 (self:MutBorrow.t t_Node'0) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree68] inv'5 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree69] ((self.current).t_Node__right'0).t_Tree__node'0
    <> C_None'1}
    {[@expl:move_red_left requires #1] [%#sred_black_tree70] internal_invariant'1 self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree71] match_n'0 (cpn'0 (C_Red'0) (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {[%#sred_black_tree72] inv'5 result}
      {[%#sred_black_tree73] internal_invariant'1 result.current}
      {[%#sred_black_tree74] internal_invariant'1 result.final
      /\ height'1 result.current = height'1 result.final
      /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.final k v  -> has_mapping'1 result.current k v)
       -> internal_invariant'1 self.final}
      {[%#sred_black_tree75] height'1 result.current = height'1 result.final
       -> height'1 self.current = height'1 self.final}
      {[%#sred_black_tree76] (self.current).t_Node__key'0 = (result.current).t_Node__key'0}
      {[%#sred_black_tree77] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 result.current k v
       -> has_mapping'1 self.current k v}
      {[%#sred_black_tree78] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.current k v
      /\ le_log'0 k (deep_model'1 (self.current).t_Node__key'0)  -> has_mapping'1 result.current k v}
      {[%#sred_black_tree79] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self.final k v
      = (has_mapping'1 result.final k v \/ has_mapping'1 self.current k v /\ not has_mapping'1 result.current k v)}
      {[%#sred_black_tree80] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) result.current
      \/ match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) result.current}
      {[%#sred_black_tree81] color_invariant'1 result.final
      /\ (color'0 (result.current).t_Node__right'0 = C_Black'0  -> (result.final).t_Node__color'0 = C_Black'0)
       -> color_invariant'1 self.final}
      (! return' {result}) ]
  
  
  let rec balance'0 (self:MutBorrow.t t_Node'0) (return'  (ret:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree82] inv'5 self}
    {[@expl:balance requires #0] [%#sred_black_tree83] internal_invariant'1 self.current}
    {[@expl:balance requires #1] [%#sred_black_tree84] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__left'0}
    {[@expl:balance requires #2] [%#sred_black_tree85] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0  -> color_invariant'0 (self.current).t_Node__right'0}
    {[@expl:balance requires #3] [%#sred_black_tree86] (self.current).t_Node__color'0 = C_Red'0
    /\ color'0 (self.current).t_Node__right'0 = C_Red'0 /\ color'0 (self.current).t_Node__left'0 = C_Red'0  -> false}
    any
    [ return' (result:())-> {[%#sred_black_tree87] same_mappings'0 self.current self.final}
      {[%#sred_black_tree88] internal_invariant'1 self.final}
      {[%#sred_black_tree89] height'1 self.current = height'1 self.final}
      {[%#sred_black_tree90] color_invariant'0 (self.current).t_Node__left'0
      /\ color'0 (self.current).t_Node__right'0 = C_Black'0  -> self.current = self.final}
      {[%#sred_black_tree91] match_n'0 (cpn'0 (C_Black'0) (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) (C_CPL'0 (C_Black'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      {[%#sred_black_tree92] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree93] match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Black'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final}
      {[%#sred_black_tree94] match_n'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Red'0))) self.current
       -> match_n'0 (C_CPL'0 (C_Red'0)) self.final}
      (! return' {result}) ]
  
  
  predicate inv'13 (_1 : t_Option'2)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Option'2 [inv'13 x] . inv'13 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'19 a_0
    end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel101] deep_model'1 self
  
  meta "compute_max_steps" 1000000
  
  let rec delete_rec'0[#"red_black_tree.rs" 706 4 706 55] (self:MutBorrow.t t_Tree'0) (key:t_K'0) (return'  (ret:t_Option'2))= {[@expl:delete_rec 'self' type invariant] [%#sred_black_tree1] inv'7 self}
    {[@expl:delete_rec 'key' type invariant] [%#sred_black_tree2] inv'12 key}
    {[@expl:delete_rec requires #0] [%#sred_black_tree3] internal_invariant'0 self.current}
    {[@expl:delete_rec requires #1] [%#sred_black_tree4] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {(self.current).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = as_mut'0 {_16} (fun (_ret':t_Option'1) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap'0 {_15} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_14 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'1 _14.current}
        MutBorrow.borrow_final <t_Node'0> {_14.current} {MutBorrow.get_id _14}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_13 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_14 <- { _14 with current = _ret'.final } ] 
            s1)
      | s1 = as_mut'1 {_13} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &node <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 =  [ &_21 <- (node.current).t_Node__key'0 ] s3
      | s3 = cmp'0 {key} {_21} (fun (_ret':t_Ordering'0) ->  [ &_18 <- _ret' ] s4)
      | s4 = bb4 ]
    
    | bb4 = any
      [ br0 -> {_18 = C_Less'0} (! bb6) | br1 -> {_18 = C_Equal'0} (! bb5) | br2 -> {_18 = C_Greater'0} (! bb5) ]
    
    | bb5 = s0
      [ s0 =  [ &ord <- _18 ] s1
      | s1 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_42 <- _ret' ] s2)
      | s2 = bb26 ]
    
    | bb26 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ] 
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node'0> {node.current}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_45 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = rotate_right'0 {_45} (fun (_ret':()) ->  [ &_44 <- _ret' ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0
      [ s0 = {inv'4 (node.current).t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_47 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__right'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_rec'0 {_47} {key} (fun (_ret':t_Option'2) ->  [ &_46 <- _ret' ] s2)
      | s2 = bb29 ]
    
    | bb29 = bb30
    | bb30 = s0 [ s0 =  [ &r <- _46 ] s1 | s1 = bb32 ] 
    | bb32 = bb68
    | bb33 = s0
      [ s0 = is_none'0 {((node.current).t_Node__right'0).t_Tree__node'0} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s1)
      | s1 = bb34 ]
    
    | bb34 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ] 
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = any
        [ br0 -> {ord = C_Less'0} (! bb38) | br1 -> {ord = C_Equal'0} (! bb38) | br2 -> {ord = C_Greater'0} (! bb36) ]
       ]
    
    | bb38 = s0
      [ s0 = {inv'0 (self.current).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {(self.current).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_59 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Tree__node'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'0 _59.current}
        MutBorrow.borrow_final <t_Option'0> {_59.current} {MutBorrow.get_id _59}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_58 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &_59 <- { _59 with current = _ret'.final } ] 
            s2)
      | s2 = take'0 {_58} (fun (_ret':t_Option'0) ->  [ &_57 <- _ret' ] s3)
      | s3 = bb39 ]
    
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'6 _59} s1
      | s1 = -{resolve'2 _59}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 = unwrap'1 {_57} (fun (_ret':t_Node'0) ->  [ &node1 <- _ret' ] s5)
      | s5 = bb40 ]
    
    | bb40 = s0
      [ s0 = {[@expl:type invariant] match node1 with
          | {t_Node__right'0 = x'0} -> inv'4 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match node1 with
          | {t_Node__right'0 = x'1} -> resolve'4 x'1
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node1 with
          | {t_Node__left'0 = x'2} -> inv'4 x'2
          | _ -> true
          end}
        s3
      | s3 = -{match node1 with
          | {t_Node__left'0 = x'3} -> resolve'4 x'3
          | _ -> true
          end}-
        s4
      | s4 =  [ &_60 <- (node1.t_Node__key'0, node1.t_Node__val'0) ] s5
      | s5 = bb41 ]
    
    | bb41 = bb42
    | bb42 = s0 [ s0 =  [ &_0 <- C_Some'0 _60 ] s1 | s1 = bb43 ] 
    | bb43 = bb72
    | bb72 = bb73
    | bb36 = s0 [ s0 = {[@expl:type invariant] inv'7 self} s1 | s1 = -{resolve'3 self}- s2 | s2 = bb37 ] 
    | bb37 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = bb73 ] 
    | bb73 = bb74
    | bb44 = s0
      [ s0 = as_ref'0 {((node.current).t_Node__right'0).t_Tree__node'0}
          (fun (_ret':t_Option'3) ->  [ &_67 <- _ret' ] s1)
      | s1 = bb45 ]
    
    | bb45 = s0 [ s0 = unwrap'2 {_67} (fun (_ret':t_Node'0) ->  [ &_66 <- _ret' ] s1) | s1 = bb46 ] 
    | bb46 = s0 [ s0 = is_red'0 {_66.t_Node__left'0} (fun (_ret':bool) ->  [ &_64 <- _ret' ] s1) | s1 = bb47 ] 
    | bb47 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb48) ] 
    | bb48 = bb51
    | bb49 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_71 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = move_red_right'0 {_71} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_70 <- _ret' ] s2)
      | s2 = bb50 ]
    
    | bb50 = s0
      [ s0 = {inv'3 _70.current}
        MutBorrow.borrow_final <t_Node'0> {_70.current} {MutBorrow.get_id _70}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_69 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_70 <- { _70 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'5 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _69 ] s4
      | s4 = {[@expl:type invariant] inv'5 _70} s5
      | s5 = -{resolve'1 _70}- s6
      | s6 = bb51 ]
    
    | bb51 = any
      [ br0 -> {ord = C_Less'0} (! bb63) | br1 -> {ord = C_Equal'0} (! bb52) | br2 -> {ord = C_Greater'0} (! bb63) ]
    
    | bb63 = s0
      [ s0 = {inv'4 (node.current).t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_90 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__right'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_rec'0 {_90} {key} (fun (_ret':t_Option'2) ->  [ &_89 <- _ret' ] s2)
      | s2 = bb64 ]
    
    | bb64 = bb65
    | bb65 = s0 [ s0 =  [ &r <- _89 ] s1 | s1 = bb67 ] 
    | bb67 = bb68
    | bb52 = bb53
    | bb53 = s0
      [ s0 = {inv'4 (node.current).t_Node__right'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__right'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_74 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__right'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_min_rec'0 {_74} (fun (_ret':(t_K'0, t_V'0)) ->  [ &kv <- _ret' ] s2)
      | s2 = bb54 ]
    
    | bb54 = s0 [ s0 =  [ &_75 <- [%#sred_black_tree0] () ] s1 | s1 = bb55 ] 
    | bb55 = s0
      [ s0 = {inv'8 (node.current).t_Node__key'0}
        MutBorrow.borrow_mut <t_K'0> {(node.current).t_Node__key'0}
          (fun (_ret':MutBorrow.t t_K'0) ->
             [ &_79 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__key'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'8 _79.current}
        MutBorrow.borrow_final <t_K'0> {_79.current} {MutBorrow.get_id _79}
          (fun (_ret':MutBorrow.t t_K'0) ->
             [ &_78 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &_79 <- { _79 with current = _ret'.final } ] 
            s2)
      | s2 = {inv'8 (let (r'0, _) = kv in r'0)}
        MutBorrow.borrow_mut <t_K'0> {let (r'0, _) = kv in r'0}
          (fun (_ret':MutBorrow.t t_K'0) ->
             [ &_81 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &kv <- let (_, r'2) = kv in (_ret'.final, r'2) ] 
            s3)
      | s3 = {inv'8 _81.current}
        MutBorrow.borrow_final <t_K'0> {_81.current} {MutBorrow.get_id _81}
          (fun (_ret':MutBorrow.t t_K'0) ->
             [ &_80 <- _ret' ] 
            -{inv'8 _ret'.final}-
             [ &_81 <- { _81 with current = _ret'.final } ] 
            s4)
      | s4 = swap'0 {_78} {_80} (fun (_ret':()) ->  [ &_77 <- _ret' ] s5)
      | s5 = bb56 ]
    
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'9 _81} s1
      | s1 = -{resolve'5 _81}- s2
      | s2 = {[@expl:type invariant] inv'9 _79} s3
      | s3 = -{resolve'5 _79}- s4
      | s4 = {inv'10 (node.current).t_Node__val'0}
        MutBorrow.borrow_mut <t_V'0> {(node.current).t_Node__val'0}
          (fun (_ret':MutBorrow.t t_V'0) ->
             [ &_84 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__val'0 = _ret'.final } } ] 
            s5)
      | s5 = {inv'10 _84.current}
        MutBorrow.borrow_final <t_V'0> {_84.current} {MutBorrow.get_id _84}
          (fun (_ret':MutBorrow.t t_V'0) ->
             [ &_83 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &_84 <- { _84 with current = _ret'.final } ] 
            s6)
      | s6 = {inv'10 (let (_, r'0) = kv in r'0)}
        MutBorrow.borrow_mut <t_V'0> {let (_, r'0) = kv in r'0}
          (fun (_ret':MutBorrow.t t_V'0) ->
             [ &_86 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &kv <- let (r'1, _) = kv in (r'1, _ret'.final) ] 
            s7)
      | s7 = {inv'10 _86.current}
        MutBorrow.borrow_final <t_V'0> {_86.current} {MutBorrow.get_id _86}
          (fun (_ret':MutBorrow.t t_V'0) ->
             [ &_85 <- _ret' ] 
            -{inv'10 _ret'.final}-
             [ &_86 <- { _86 with current = _ret'.final } ] 
            s8)
      | s8 = swap'1 {_83} {_85} (fun (_ret':()) ->  [ &_82 <- _ret' ] s9)
      | s9 = bb57 ]
    
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'11 _86} s1
      | s1 = -{resolve'6 _86}- s2
      | s2 = {[@expl:type invariant] inv'11 _84} s3
      | s3 = -{resolve'6 _84}- s4
      | s4 =  [ &_87 <- C_Some'0 kv ] s5
      | s5 = bb58 ]
    
    | bb58 = bb59
    | bb59 = s0 [ s0 =  [ &r <- _87 ] s1 | s1 = bb61 ] 
    | bb61 = bb62
    | bb62 = bb68
    | bb68 = bb69
    | bb6 = bb7
    | bb7 = s0
      [ s0 = is_none'0 {((node.current).t_Node__left'0).t_Tree__node'0} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s1)
      | s1 = bb8 ]
    
    | bb8 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ] 
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- C_None'0 ] s5
      | s5 = bb74 ]
    
    | bb74 = bb75
    | bb75 = bb76
    | bb10 = s0
      [ s0 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s1) | s1 = bb11 ]
    
    | bb11 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = as_ref'0 {((node.current).t_Node__left'0).t_Tree__node'0} (fun (_ret':t_Option'3) ->  [ &_33 <- _ret' ] s1)
      | s1 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'2 {_33} (fun (_ret':t_Node'0) ->  [ &_32 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0 [ s0 = is_red'0 {_32.t_Node__left'0} (fun (_ret':bool) ->  [ &_30 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_37 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = move_red_left'0 {_37} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_36 <- _ret' ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0
      [ s0 = {inv'3 _36.current}
        MutBorrow.borrow_final <t_Node'0> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_35 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_36 <- { _36 with current = _ret'.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'5 node} s2
      | s2 = -{resolve'1 node}- s3
      | s3 =  [ &node <- _35 ] s4
      | s4 = {[@expl:type invariant] inv'5 _36} s5
      | s5 = -{resolve'1 _36}- s6
      | s6 = bb21 ]
    
    | bb21 = s0
      [ s0 = {inv'4 (node.current).t_Node__left'0}
        MutBorrow.borrow_mut <t_Tree'0> {(node.current).t_Node__left'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_39 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__left'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_rec'0 {_39} {key} (fun (_ret':t_Option'2) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb22 ]
    
    | bb22 = bb23
    | bb23 = s0 [ s0 =  [ &r <- _38 ] s1 | s1 = bb25 ] 
    | bb25 = bb69
    | bb69 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node'0> {node.current} {MutBorrow.get_id node}
          (fun (_ret':MutBorrow.t t_Node'0) ->
             [ &_93 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &node <- { node with current = _ret'.final } ] 
            s1)
      | s1 = balance'0 {_93} (fun (_ret':()) ->  [ &_92 <- _ret' ] s2)
      | s2 = bb70 ]
    
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'5 node} s1
      | s1 = -{resolve'1 node}- s2
      | s2 = {[@expl:type invariant] inv'7 self} s3
      | s3 = -{resolve'3 self}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb71 ]
    
    | bb71 = bb76
    | bb76 = return' {_0} ]
    )
    [ & _0 : t_Option'2 = Any.any_l ()
    | & self : MutBorrow.t t_Tree'0 = self
    | & key : t_K'0 = key
    | & r : t_Option'2 = Any.any_l ()
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _13 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _14 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _15 : t_Option'1 = Any.any_l ()
    | & _16 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _18 : t_Ordering'0 = Any.any_l ()
    | & _21 : t_K'0 = Any.any_l ()
    | & _24 : bool = Any.any_l ()
    | & _28 : bool = Any.any_l ()
    | & _30 : bool = Any.any_l ()
    | & _32 : t_Node'0 = Any.any_l ()
    | & _33 : t_Option'3 = Any.any_l ()
    | & _35 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _36 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _38 : t_Option'2 = Any.any_l ()
    | & _39 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & ord : t_Ordering'0 = Any.any_l ()
    | & _42 : bool = Any.any_l ()
    | & _44 : () = Any.any_l ()
    | & _45 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _46 : t_Option'2 = Any.any_l ()
    | & _47 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _50 : bool = Any.any_l ()
    | & node1 : t_Node'0 = Any.any_l ()
    | & _57 : t_Option'0 = Any.any_l ()
    | & _58 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _59 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _60 : (t_K'0, t_V'0) = Any.any_l ()
    | & _64 : bool = Any.any_l ()
    | & _66 : t_Node'0 = Any.any_l ()
    | & _67 : t_Option'3 = Any.any_l ()
    | & _69 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _70 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _71 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & kv : (t_K'0, t_V'0) = Any.any_l ()
    | & _74 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _75 : () = Any.any_l ()
    | & _77 : () = Any.any_l ()
    | & _78 : MutBorrow.t t_K'0 = Any.any_l ()
    | & _79 : MutBorrow.t t_K'0 = Any.any_l ()
    | & _80 : MutBorrow.t t_K'0 = Any.any_l ()
    | & _81 : MutBorrow.t t_K'0 = Any.any_l ()
    | & _82 : () = Any.any_l ()
    | & _83 : MutBorrow.t t_V'0 = Any.any_l ()
    | & _84 : MutBorrow.t t_V'0 = Any.any_l ()
    | & _85 : MutBorrow.t t_V'0 = Any.any_l ()
    | & _86 : MutBorrow.t t_V'0 = Any.any_l ()
    | & _87 : t_Option'2 = Any.any_l ()
    | & _89 : t_Option'2 = Any.any_l ()
    | & _90 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _92 : () = Any.any_l ()
    | & _93 : MutBorrow.t t_Node'0 = Any.any_l () ]
    
    [ return' (result:t_Option'2)-> {[@expl:delete_rec result type invariant] [%#sred_black_tree5] inv'13 result}
      {[@expl:delete_rec ensures #0] [%#sred_black_tree6] internal_invariant'0 self.final}
      {[@expl:delete_rec ensures #1] [%#sred_black_tree7] height'0 self.current = height'0 self.final}
      {[@expl:delete_rec ensures #2] [%#sred_black_tree8] match result with
        | C_None'0 -> forall v : t_V'0 . not has_mapping'0 self.current (deep_model'0 key) v
        | C_Some'0 (k, v) -> deep_model'0 key = deep_model'1 k /\ has_mapping'0 self.current (deep_model'1 k) v
        end}
      {[@expl:delete_rec ensures #3] [%#sred_black_tree9] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 key <> k /\ has_mapping'0 self.current k v)}
      {[@expl:delete_rec ensures #4] [%#sred_black_tree10] color_invariant'0 self.final}
      {[@expl:delete_rec ensures #5] [%#sred_black_tree11] color'0 self.current = C_Black'0
       -> color'0 self.final = C_Black'0}
      (! return' {result}) ]

end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence [#"red_black_tree.rs" 793 4 793 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 790 15 790 39
  let%span sred_black_tree1 = "red_black_tree.rs" 791 14 791 31
  let%span sred_black_tree2 = "red_black_tree.rs" 794 8 794 39
  let%span sred_black_tree3 = "red_black_tree.rs" 785 20 785 68
  let%span sred_black_tree4 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree5 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree6 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree7 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree8 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree9 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree10 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree11 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree12 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree13 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree14 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree15 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree16 = "red_black_tree.rs" 179 12 179 69
  let%span sresolve17 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sred_black_tree18 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree19 = "red_black_tree.rs" 55 12 62 13
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord26 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord27 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord28 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord29 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord30 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord31 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord32 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  use map.Const
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'1
    | C_Some'1 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree9] match self with
      | {t_Tree__node'0 = C_None'1} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'5 (_1 : t_V'0)
  
  predicate resolve'3 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree16] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'5 v
  
  predicate resolve'1 (_1 : t_Tree'0) =
    resolve'3 _1
  
  predicate structural_resolve'0 (_1 : t_Map'0) =
    match _1 with
      | {t_Map__0'0 = x0} -> resolve'1 x0
      end
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_V'0
  
  predicate resolve'4 (self : t_Option'1) =
    [%#sresolve17] match self with
      | C_Some'0 x -> resolve'5 x
      | C_None'0 -> true
      end
  
  predicate resolve'2 (_1 : t_Option'1) =
    resolve'4 _1
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'1) : Map.map t_DeepModelTy'0 t_Option'1
  
   =
    [%#sred_black_tree19] match self with
      | {t_Tree__node'0 = C_None'1} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc'0 right accu2
      end
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'1 =
    [%#sred_black_tree10] model_acc'0 self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'1 =
    [%#sred_black_tree7] view'1 self.t_Map__0'0
  
  predicate resolve'0 [#"red_black_tree.rs" 784 4 784 28] (self : t_Map'0) =
    [%#sred_black_tree3] forall k : t_DeepModelTy'0 . resolve'2 (Map.get (view'0 self) k)
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord32] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord30] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord31] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord28] cmp_log'0 x y = C_Less'0)
   -> ([%#sord29] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord25] cmp_log'0 x y
  = o)  -> ([%#sord26] cmp_log'0 y z = o)  -> ([%#sord27] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord24] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord23] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord22] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree18] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree8] match self with
      | {t_Tree__node'0 = C_None'1} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'1) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree12] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'1, k : t_DeepModelTy'0 . [%#sred_black_tree11] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'1) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree15] match self with
      | {t_Tree__node'0 = C_None'1} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'1, k : t_DeepModelTy'0 . ([%#sred_black_tree13] bst_invariant'0 self)
   -> ([%#sred_black_tree14] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'0 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree6] let _ = model_acc_has_mapping'0 self (Const.const (C_None'0)) k in has_mapping_model_acc'0 self (Const.const (C_None'0)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree4] bst_invariant'0 self)
   -> ([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'1 self) k = C_Some'0 v))
  
  constant self  : t_Map'0
  
  function resolve_coherence'0 [#"red_black_tree.rs" 793 4 793 31] (self : t_Map'0) : ()
  
  goal vc_resolve_coherence'0 : ([%#sred_black_tree0] structural_resolve'0 self)
   -> (let _ = has_mapping_model'0 in [%#sred_black_tree1] resolve'0 self)
end
module M_red_black_tree__qyi1722927563742988856__new [#"red_black_tree.rs" 803 4 803 24] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 803 20 803 24
  let%span sred_black_tree1 = "red_black_tree.rs" 802 14 802 43
  let%span sred_black_tree2 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree3 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree4 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree5 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree6 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree7 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree8 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree9 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree10 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree11 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree12 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree13 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree14 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree15 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree16 = "red_black_tree.rs" 327 12 335 13
  let%span sord17 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord18 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord19 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord26 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord27 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord28 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord29 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sboxed30 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Any
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree14] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord29] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord27] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord28] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord25] cmp_log'0 x y = C_Less'0)
   -> ([%#sord26] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord22] cmp_log'0 x y
  = o)  -> ([%#sord23] cmp_log'0 y z = o)  -> ([%#sord24] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord21] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord19] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord18] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord17] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree12] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree9] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree16] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree15] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree13] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree10] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree6] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree8] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree11] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree7] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate invariant'0 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree4] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'5 (_1 : t_K'0)
  
  predicate inv'6 (_1 : t_V'0)
  
  predicate inv'4 (_1 : t_Node'0)
  
  predicate inv'1 (_1 : t_Tree'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'1 left
    /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  predicate invariant'1 (self : t_Node'0) =
    [%#sboxed30] inv'4 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Tree'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'2 node
    end
  
  predicate inv'0 (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'1 a_0
    end)
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'1) : Map.map t_DeepModelTy'0 t_Option'1
  
   =
    [%#sred_black_tree5] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'1 val') in model_acc'0 right accu2
      end
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'1 =
    [%#sred_black_tree3] model_acc'0 self (Const.const (C_None'1))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'1 =
    [%#sred_black_tree2] view'1 self.t_Map__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"red_black_tree.rs" 803 4 803 24] (return'  (ret:t_Map'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- C_None'0 ] s1 | s1 =  [ &_2 <- { t_Tree__node'0 = _3 } ] s2 | s2 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_Map__0'0 = _2 } ] s1 | s1 = bb2 ] 
    | bb2 = return' {_0} ]
    ) [ & _0 : t_Map'0 = Any.any_l () | & _2 : t_Tree'0 = Any.any_l () | & _3 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Map'0)-> {[@expl:new result type invariant] [%#sred_black_tree0] inv'0 result}
      {[@expl:new ensures] [%#sred_black_tree1] view'0 result = Const.const (C_None'1)}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__insert [#"red_black_tree.rs" 808 4 808 44] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 811 8 811 53
  let%span sred_black_tree1 = "red_black_tree.rs" 808 23 808 27
  let%span sred_black_tree2 = "red_black_tree.rs" 808 29 808 32
  let%span sred_black_tree3 = "red_black_tree.rs" 808 37 808 40
  let%span sred_black_tree4 = "red_black_tree.rs" 807 14 807 64
  let%span sred_black_tree5 = "red_black_tree.rs" 618 23 618 27
  let%span sred_black_tree6 = "red_black_tree.rs" 618 29 618 32
  let%span sred_black_tree7 = "red_black_tree.rs" 618 37 618 40
  let%span sred_black_tree8 = "red_black_tree.rs" 610 15 610 43
  let%span sred_black_tree9 = "red_black_tree.rs" 611 15 611 40
  let%span sred_black_tree10 = "red_black_tree.rs" 612 14 612 42
  let%span sred_black_tree11 = "red_black_tree.rs" 613 14 613 50
  let%span sred_black_tree12 = "red_black_tree.rs" 614 14 615 39
  let%span sred_black_tree13 = "red_black_tree.rs" 616 14 616 56
  let%span sred_black_tree14 = "red_black_tree.rs" 617 14 617 125
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption16 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption17 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption18 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sred_black_tree19 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree20 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree21 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree22 = "red_black_tree.rs" 761 20 761 27
  let%span smodel23 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sred_black_tree24 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree25 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree26 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree27 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree28 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree29 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree30 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree31 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve32 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree33 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree34 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree35 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree36 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree37 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree38 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree39 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree40 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree41 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant42 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sred_black_tree43 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree44 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree45 = "red_black_tree.rs" 368 20 368 61
  let%span sboxed46 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sord47 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord48 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord49 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord50 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord51 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord52 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord53 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord54 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord55 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord56 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord57 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord58 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord59 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree60 = "red_black_tree.rs" 772 8 774 9
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'1 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  predicate inv'4 (_1 : t_K'0)
  
  predicate inv'5 (_1 : t_V'0)
  
  predicate inv'11 (_1 : t_Node'0)
  
  predicate inv'0 (_1 : t_Tree'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Node'0 [inv'11 x] . inv'11 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'0 left
    /\ inv'4 key /\ inv'5 val' /\ inv'0 right
    end
  
  predicate invariant'4 (self : t_Node'0) =
    [%#sboxed46] inv'11 self
  
  predicate inv'9 (_1 : t_Node'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Node'0 [inv'9 x] . inv'9 x = invariant'4 x
  
  predicate inv'1 (_1 : t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Option'0 [inv'1 x] . inv'1 x
  = match x with
    | C_None'0 -> true
    | C_Some'1 a_0 -> inv'9 a_0
    end
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Tree'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'1 node
    end
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  predicate invariant'2 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant42] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'6 x] . inv'6 x = invariant'2 x
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree31] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord59] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord57] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord58] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord55] cmp_log'0 x y = C_Less'0)
   -> ([%#sord56] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord52] cmp_log'0 x y
  = o)  -> ([%#sord53] cmp_log'0 y z = o)  -> ([%#sord54] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord51] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord50] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord49] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord48] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree43] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree33] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree27] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree26] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree45] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree40] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree24] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree30] match self.t_Tree__node'0 with
      | C_Some'1 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree41] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree25] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'1 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree28] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'1 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree29] C_CPN'0 c l r
  
  let rec insert_rec'0 (self:MutBorrow.t t_Tree'0) (key:t_K'0) (val':t_V'0) (return'  (ret:()))= {[@expl:insert_rec 'self' type invariant] [%#sred_black_tree5] inv'6 self}
    {[@expl:insert_rec 'key' type invariant] [%#sred_black_tree6] inv'4 key}
    {[@expl:insert_rec 'val' type invariant] [%#sred_black_tree7] inv'5 val'}
    {[@expl:insert_rec requires #0] [%#sred_black_tree8] internal_invariant'0 self.current}
    {[@expl:insert_rec requires #1] [%#sred_black_tree9] color_invariant'0 self.current}
    any
    [ return' (result:())-> {[%#sred_black_tree10] internal_invariant'0 self.final}
      {[%#sred_black_tree11] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree12] match_t'0 (cpn'0 (C_Red'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.final
      /\ color'0 self.current = C_Red'0
      \/ color_invariant'0 self.final}
      {[%#sred_black_tree13] has_mapping'0 self.final (deep_model'0 key) val'}
      {[%#sred_black_tree14] forall k : t_DeepModelTy'0, v : t_V'0 . k = deep_model'0 key
      \/ has_mapping'0 self.current k v = has_mapping'0 self.final k v}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'2 (MutBorrow.t t_Node'0)
  
  predicate invariant'3 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant42] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'7 x] . inv'7 x = invariant'3 x
  
  predicate invariant'0 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant42] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate inv'8 (_1 : t_Option'1)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Option'1 [inv'8 x] . inv'8 x
  = match x with
    | C_None'1 -> true
    | C_Some'2 a_0 -> inv'2 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'7 self}
    any
    [ return' (result:t_Option'1)-> {inv'8 result}
      {[%#soption15] self.current = C_None'0  -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption16] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'2 r
      /\ self.current = C_Some'1 (r.current) /\ self.final = C_Some'1 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'8 self}
    {[@expl:unwrap requires] [%#soption17] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'2 result}
      {[%#soption18] C_Some'2 result = self}
      (! return' {result}) ]
  
  
  predicate resolve'2 (self : MutBorrow.t t_Node'0) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Node'0) =
    resolve'2 _1
  
  predicate invariant'5 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree60] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'10 (_1 : t_Map'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Map'0 [inv'10 x] . inv'10 x
  = (invariant'5 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'0 a_0
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_Map'0) =
    [%#sinvariant42] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_Map'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_Map'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate resolve'3 (self : MutBorrow.t t_Map'0) =
    [%#sresolve32] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Map'0) =
    resolve'3 _1
  
  type t_Option'2  =
    | C_None'2
    | C_Some'0 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) : Map.map t_DeepModelTy'0 t_Option'2
  
   =
    [%#sred_black_tree44] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#sred_black_tree34] model_acc'0 self (Const.const (C_None'2))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree36] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'2, k : t_DeepModelTy'0 . [%#sred_black_tree35] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'0 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree39] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'1 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'0 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'2, k : t_DeepModelTy'0 . ([%#sred_black_tree37] bst_invariant'0 self)
   -> ([%#sred_black_tree38] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'0 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree21] let _ = model_acc_has_mapping'0 self (Const.const (C_None'2)) k in has_mapping_model_acc'0 self (Const.const (C_None'2)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree19] bst_invariant'0 self)
   -> ([%#sred_black_tree20] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = C_Some'0 v))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#sred_black_tree22] view'2 self.t_Map__0'0
  
  function view'1 (self : MutBorrow.t t_Map'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#smodel23] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec insert'0[#"red_black_tree.rs" 808 4 808 44] (self:MutBorrow.t t_Map'0) (key:t_K'0) (val':t_V'0) (return'  (ret:()))= {[@expl:insert 'self' type invariant] [%#sred_black_tree1] inv'3 self}
    {[@expl:insert 'key' type invariant] [%#sred_black_tree2] inv'4 key}
    {[@expl:insert 'val' type invariant] [%#sred_black_tree3] inv'5 val'}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = {inv'0 (self.current).t_Map__0'0}
        MutBorrow.borrow_mut <t_Tree'0> {(self.current).t_Map__0'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = _ret'.final } } ] 
            s1)
      | s1 = insert_rec'0 {_6} {key} {val'} (fun (_ret':()) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 =  [ &_9 <- C_Black'0 ] s1
      | s1 = {inv'1 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Map__0'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_12 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s2)
      | s2 = as_mut'0 {_12} (fun (_ret':t_Option'1) ->  [ &_11 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_11} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_10 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &_10 <- { _10 with current = { _10.current with t_Node__color'0 = _9 } } ] s1
      | s1 = {[@expl:type invariant] inv'2 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'3 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 =  [ &_13 <- [%#sred_black_tree0] () ] s6
      | s6 = bb5 ]
    
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return' {_0} ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_Map'0 = self
    | & key : t_K'0 = key
    | & val' : t_V'0 = val'
    | & _5 : () = Any.any_l ()
    | & _6 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _9 : t_Color'0 = Any.any_l ()
    | & _10 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _11 : t_Option'1 = Any.any_l ()
    | & _12 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _13 : () = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:insert ensures] [%#sred_black_tree4] view'0 self.final
      = Map.set (view'1 self) (deep_model'0 key) (C_Some'0 val')}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__delete_max [#"red_black_tree.rs" 820 4 820 50] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 821 23 821 41
  let%span sred_black_tree1 = "red_black_tree.rs" 829 8 829 58
  let%span sred_black_tree2 = "red_black_tree.rs" 834 8 834 53
  let%span sred_black_tree3 = "red_black_tree.rs" 820 27 820 31
  let%span sred_black_tree4 = "red_black_tree.rs" 820 36 820 50
  let%span sred_black_tree5 = "red_black_tree.rs" 814 14 819 5
  let%span sred_black_tree6 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree7 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree8 = "red_black_tree.rs" 48 12 48 89
  let%span sred_black_tree9 = "red_black_tree.rs" 652 27 652 31
  let%span sred_black_tree10 = "red_black_tree.rs" 641 15 641 43
  let%span sred_black_tree11 = "red_black_tree.rs" 642 15 643 62
  let%span sred_black_tree12 = "red_black_tree.rs" 652 36 652 42
  let%span sred_black_tree13 = "red_black_tree.rs" 644 14 644 42
  let%span sred_black_tree14 = "red_black_tree.rs" 645 14 645 50
  let%span sred_black_tree15 = "red_black_tree.rs" 646 14 646 66
  let%span sred_black_tree16 = "red_black_tree.rs" 647 14 647 102
  let%span sred_black_tree17 = "red_black_tree.rs" 648 14 649 71
  let%span sred_black_tree18 = "red_black_tree.rs" 650 14 650 39
  let%span sred_black_tree19 = "red_black_tree.rs" 651 14 651 67
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption21 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption22 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption23 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sred_black_tree24 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree25 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree26 = "red_black_tree.rs" 112 12 112 61
  let%span smodel27 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sred_black_tree28 = "red_black_tree.rs" 761 20 761 27
  let%span sresolve29 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree30 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree31 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree32 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree33 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree34 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree35 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree36 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree37 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree38 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree39 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree40 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree41 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree42 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree43 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree44 = "red_black_tree.rs" 91 12 100 13
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord46 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord47 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord48 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord49 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord50 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord51 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord52 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord53 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord54 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord55 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord56 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord57 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant58 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed59 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sred_black_tree60 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree61 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree62 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree63 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant64 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree65 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree66 = "red_black_tree.rs" 772 8 774 9
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  
  predicate inv'13 (_1 : t_K'0)
  
  predicate inv'14 (_1 : t_V'0)
  
  predicate inv'5 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Tree'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'12 (_1 : t_Node'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Node'0 [inv'12 x] . inv'12 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'5 left
    /\ inv'13 key /\ inv'14 val' /\ inv'5 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed59] inv'12 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  predicate invariant'0 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant58] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'3 (self : MutBorrow.t t_Option'0) =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Option'0) =
    resolve'3 _1
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree31] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord57] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord55] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord56] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord53] cmp_log'0 x y = C_Less'0)
   -> ([%#sord54] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord50] cmp_log'0 x y
  = o)  -> ([%#sord51] cmp_log'0 y z = o)  -> ([%#sord52] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord49] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord48] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord46] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree62] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree38] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree36] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree35] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree65] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree60] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree32] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree30] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree61] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree37] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate invariant'6 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree66] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'11 (_1 : t_Map'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Map'0 [inv'11 x] . inv'11 x
  = (invariant'6 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'5 a_0
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_Map'0) =
    [%#sinvariant58] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Map'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Map'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'4 (self : MutBorrow.t t_Map'0) =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Map'0) =
    resolve'4 _1
  
  type t_Option'2  =
    | C_None'1
    | C_Some'1 (t_K'0, t_V'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'4 (self : t_Tree'0) =
    [%#sinvariant64] inv'5 self
  
  predicate inv'7 (_1 : t_Tree'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Tree'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree6] inv'7 self}
    any [ return' (result:bool)-> {[%#sred_black_tree7] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate invariant'3 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant58] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate resolve'5 (self : MutBorrow.t t_Node'0) =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Node'0) =
    resolve'5 _1
  
  predicate same_mappings'0 [#"red_black_tree.rs" 46 4 46 43] (self : t_Tree'0) (o : t_Tree'0) =
    [%#sred_black_tree8] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v = has_mapping'0 o k v
  
  predicate invariant'5 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant58] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree33] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree34] C_CPN'0 c l r
  
  predicate inv'9 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'9 x] . inv'9 x
  = (let (x0, x1) = x in inv'13 x0 /\ inv'14 x1)
  
  let rec delete_max_rec'0 (self:MutBorrow.t t_Tree'0) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:delete_max_rec 'self' type invariant] [%#sred_black_tree9] inv'8 self}
    {[@expl:delete_max_rec requires #0] [%#sred_black_tree10] internal_invariant'0 self.current}
    {[@expl:delete_max_rec requires #1] [%#sred_black_tree11] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    any
    [ return' (result:(t_K'0, t_V'0))-> {[%#sred_black_tree12] inv'9 result}
      {[%#sred_black_tree13] internal_invariant'0 self.final}
      {[%#sred_black_tree14] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree15] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#sred_black_tree16] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 k (deep_model'0 (let (a, _) = result in a))}
      {[%#sred_black_tree17] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree18] color_invariant'0 self.final}
      {[%#sred_black_tree19] color'0 self.current = C_Black'0  -> color'0 self.final = C_Black'0}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'3
    | C_Some'3 (MutBorrow.t t_Node'0)
  
  predicate inv'10 (_1 : t_Option'1)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_Option'1 [inv'10 x] . inv'10 x
  = match x with
    | C_None'3 -> true
    | C_Some'3 a_0 -> inv'4 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_Option'1)-> {inv'10 result}
      {[%#soption20] self.current = C_None'0  -> result = C_None'3 /\ self.final = C_None'0}
      {[%#soption21] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'3 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'10 self}
    {[@expl:unwrap requires] [%#soption22] self <> C_None'3}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'4 result}
      {[%#soption23] C_Some'3 result = self}
      (! return' {result}) ]
  
  
  type t_Option'3  =
    | C_None'2
    | C_Some'2 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) : Map.map t_DeepModelTy'0 t_Option'3
  
   =
    [%#sred_black_tree63] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#sred_black_tree39] model_acc'0 self (Const.const (C_None'2))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree41] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'3, k : t_DeepModelTy'0 . [%#sred_black_tree40] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'2 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree44] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'3, k : t_DeepModelTy'0 . ([%#sred_black_tree42] bst_invariant'0 self)
   -> ([%#sred_black_tree43] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'2 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree26] let _ = model_acc_has_mapping'0 self (Const.const (C_None'2)) k in has_mapping_model_acc'0 self (Const.const (C_None'2)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree24] bst_invariant'0 self)
   -> ([%#sred_black_tree25] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = C_Some'2 v))
  
  predicate inv'6 (_1 : t_Option'2)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Option'2 [inv'6 x] . inv'6 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'9 a_0
    end
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#sred_black_tree28] view'2 self.t_Map__0'0
  
  function view'0 (self : MutBorrow.t t_Map'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#smodel27] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max'0[#"red_black_tree.rs" 820 4 820 50] (self:MutBorrow.t t_Map'0) (return'  (ret:t_Option'2))= {[@expl:delete_max 'self' type invariant] [%#sred_black_tree3] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree0] self ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Map__0'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s1)
      | s1 = any [ br0 -> {_6.current = C_None'0} (! bb8) | br1 (x0:t_Node'0)-> {_6.current = C_Some'0 x0} (! bb2) ]  ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- C_None'1 ] s5
      | s5 = bb19 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some'0 {_6.current}
          (fun (r0'0:t_Node'0) ->
            {inv'3 r0'0}
            MutBorrow.borrow_final <t_Node'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret':MutBorrow.t t_Node'0) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_6 <- { _6 with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    
    | bb6 = s0
      [ s0 =  [ &_11 <- C_Red'0 ] s1
      | s1 =  [ &node <- { node with current = { node.current with t_Node__color'0 = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#sred_black_tree1] same_mappings'0 (old_self.current).t_Map__0'0 (self.current).t_Map__0'0}
        s1
      | s1 = {inv'5 (self.current).t_Map__0'0}
        MutBorrow.borrow_mut <t_Tree'0> {(self.current).t_Map__0'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_16 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = _ret'.final } } ] 
            s2)
      | s2 = delete_max_rec'0 {_16} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s3)
      | s3 = bb9 ]
    
    | bb9 = s0 [ s0 = is_red'0 {(self.current).t_Map__0'0} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_20 <- C_Black'0 ] s1
      | s1 = {inv'0 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Map__0'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_23 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s2)
      | s2 = as_mut'0 {_23} (fun (_ret':t_Option'1) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_22} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_21 <- { _21 with current = { _21.current with t_Node__color'0 = _20 } } ] s1
      | s1 = {[@expl:type invariant] inv'4 _21} s2
      | s2 = -{resolve'2 _21}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_24 <- [%#sred_black_tree2] () ] s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 =  [ &_0 <- C_Some'1 r ] s1 | s1 = bb17 ] 
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return' {_0} ]
    )
    [ & _0 : t_Option'2 = Any.any_l ()
    | & self : MutBorrow.t t_Map'0 = self
    | & old_self : MutBorrow.t t_Map'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _11 : t_Color'0 = Any.any_l ()
    | & r : (t_K'0, t_V'0) = Any.any_l ()
    | & _16 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _18 : bool = Any.any_l ()
    | & _20 : t_Color'0 = Any.any_l ()
    | & _21 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _22 : t_Option'1 = Any.any_l ()
    | & _23 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _24 : () = Any.any_l () ]
    
    [ return' (result:t_Option'2)-> {[@expl:delete_max result type invariant] [%#sred_black_tree4] inv'6 result}
      {[@expl:delete_max ensures] [%#sred_black_tree5] match result with
        | C_Some'1 (k, v) -> Map.get (view'0 self) (deep_model'0 k) = C_Some'2 v
        /\ (forall k2 : t_DeepModelTy'0 . Map.get (view'0 self) k2 = C_None'2 \/ le_log'0 k2 (deep_model'0 k))
        /\ view'1 self.final = Map.set (view'0 self) (deep_model'0 k) (C_None'2)
        | C_None'1 -> view'1 self.final = view'0 self /\ view'0 self = Const.const (C_None'2)
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__delete_min [#"red_black_tree.rs" 845 4 845 50] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 846 8 846 53
  let%span sred_black_tree1 = "red_black_tree.rs" 845 27 845 31
  let%span sred_black_tree2 = "red_black_tree.rs" 845 36 845 50
  let%span sred_black_tree3 = "red_black_tree.rs" 838 14 844 5
  let%span sred_black_tree4 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree5 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree6 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree7 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree8 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree9 = "red_black_tree.rs" 680 27 680 31
  let%span sred_black_tree10 = "red_black_tree.rs" 669 15 669 43
  let%span sred_black_tree11 = "red_black_tree.rs" 670 15 671 62
  let%span sred_black_tree12 = "red_black_tree.rs" 680 36 680 42
  let%span sred_black_tree13 = "red_black_tree.rs" 672 14 672 42
  let%span sred_black_tree14 = "red_black_tree.rs" 673 14 673 50
  let%span sred_black_tree15 = "red_black_tree.rs" 674 14 674 66
  let%span sred_black_tree16 = "red_black_tree.rs" 675 14 675 102
  let%span sred_black_tree17 = "red_black_tree.rs" 676 14 677 71
  let%span sred_black_tree18 = "red_black_tree.rs" 678 14 678 39
  let%span sred_black_tree19 = "red_black_tree.rs" 679 14 679 67
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption21 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption22 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption23 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span smodel24 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sred_black_tree25 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree26 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree27 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree28 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree29 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree30 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree31 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree32 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree33 = "red_black_tree.rs" 91 12 100 13
  let%span sresolve34 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree35 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree36 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree37 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree38 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree39 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree40 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree41 = "red_black_tree.rs" 297 12 303 13
  let%span sord42 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord43 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord44 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord46 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord47 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord48 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord49 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord50 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord51 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord52 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord53 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord54 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree55 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree56 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant57 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed58 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sred_black_tree59 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree60 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant61 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree62 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree63 = "red_black_tree.rs" 772 8 774 9
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree27] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord54] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord52] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord53] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord50] cmp_log'0 x y = C_Less'0)
   -> ([%#sord51] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord47] cmp_log'0 x y
  = o)  -> ([%#sord48] cmp_log'0 y z = o)  -> ([%#sord49] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord46] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord43] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord42] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree55] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree26] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  type t_Option'3  =
    | C_None'2
    | C_Some'2 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) : Map.map t_DeepModelTy'0 t_Option'3
  
   =
    [%#sred_black_tree56] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#sred_black_tree28] model_acc'0 self (Const.const (C_None'2))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree30] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'3, k : t_DeepModelTy'0 . [%#sred_black_tree29] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'2 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree33] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'3, k : t_DeepModelTy'0 . ([%#sred_black_tree31] bst_invariant'0 self)
   -> ([%#sred_black_tree32] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'2 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree6] let _ = model_acc_has_mapping'0 self (Const.const (C_None'2)) k in has_mapping_model_acc'0 self (Const.const (C_None'2)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree4] bst_invariant'0 self)
   -> ([%#sred_black_tree5] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = C_Some'2 v))
  
  predicate inv'13 (_1 : t_K'0)
  
  predicate inv'14 (_1 : t_V'0)
  
  predicate inv'5 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Tree'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'12 (_1 : t_Node'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Node'0 [inv'12 x] . inv'12 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'5 left
    /\ inv'13 key /\ inv'14 val' /\ inv'5 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed58] inv'12 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  predicate invariant'0 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant57] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'3 (self : MutBorrow.t t_Option'0) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Option'0) =
    resolve'3 _1
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree40] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree39] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree62] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree59] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree36] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree35] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree60] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree41] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate invariant'6 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree63] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'11 (_1 : t_Map'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Map'0 [inv'11 x] . inv'11 x
  = (invariant'6 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'5 a_0
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_Map'0) =
    [%#sinvariant57] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Map'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Map'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'4 (self : MutBorrow.t t_Map'0) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Map'0) =
    resolve'4 _1
  
  type t_Option'2  =
    | C_None'1
    | C_Some'1 (t_K'0, t_V'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'4 (self : t_Tree'0) =
    [%#sinvariant61] inv'5 self
  
  predicate inv'7 (_1 : t_Tree'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Tree'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree7] inv'7 self}
    any [ return' (result:bool)-> {[%#sred_black_tree8] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate invariant'3 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant57] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate resolve'5 (self : MutBorrow.t t_Node'0) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Node'0) =
    resolve'5 _1
  
  predicate invariant'5 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant57] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree37] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree38] C_CPN'0 c l r
  
  predicate inv'9 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'9 x] . inv'9 x
  = (let (x0, x1) = x in inv'13 x0 /\ inv'14 x1)
  
  let rec delete_min_rec'0 (self:MutBorrow.t t_Tree'0) (return'  (ret:(t_K'0, t_V'0)))= {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree9] inv'8 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree10] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree11] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    any
    [ return' (result:(t_K'0, t_V'0))-> {[%#sred_black_tree12] inv'9 result}
      {[%#sred_black_tree13] internal_invariant'0 self.final}
      {[%#sred_black_tree14] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree15] has_mapping'0 self.current (deep_model'0 (let (a, _) = result in a)) (let (_, a) = result in a)}
      {[%#sred_black_tree16] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.current k v
       -> le_log'0 (deep_model'0 (let (a, _) = result in a)) k}
      {[%#sred_black_tree17] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'0 (let (a, _) = result in a) <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree18] color_invariant'0 self.final}
      {[%#sred_black_tree19] color'0 self.current = C_Black'0  -> color'0 self.final = C_Black'0}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'3
    | C_Some'3 (MutBorrow.t t_Node'0)
  
  predicate inv'10 (_1 : t_Option'1)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_Option'1 [inv'10 x] . inv'10 x
  = match x with
    | C_None'3 -> true
    | C_Some'3 a_0 -> inv'4 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= {[@expl:as_mut 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_Option'1)-> {inv'10 result}
      {[%#soption20] self.current = C_None'0  -> result = C_None'3 /\ self.final = C_None'0}
      {[%#soption21] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'3 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'10 self}
    {[@expl:unwrap requires] [%#soption22] self <> C_None'3}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'4 result}
      {[%#soption23] C_Some'3 result = self}
      (! return' {result}) ]
  
  
  predicate inv'6 (_1 : t_Option'2)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Option'2 [inv'6 x] . inv'6 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'9 a_0
    end
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#sred_black_tree25] view'2 self.t_Map__0'0
  
  function view'0 (self : MutBorrow.t t_Map'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#smodel24] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min'0[#"red_black_tree.rs" 845 4 845 50] (self:MutBorrow.t t_Map'0) (return'  (ret:t_Option'2))= {[@expl:delete_min 'self' type invariant] [%#sred_black_tree1] inv'2 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sred_black_tree0] () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Map__0'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s1)
      | s1 = any [ br0 -> {_6.current = C_None'0} (! bb8) | br1 (x0:t_Node'0)-> {_6.current = C_Some'0 x0} (! bb2) ]  ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- C_None'1 ] s5
      | s5 = bb18 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some'0 {_6.current}
          (fun (r0'0:t_Node'0) ->
            {inv'3 r0'0}
            MutBorrow.borrow_final <t_Node'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret':MutBorrow.t t_Node'0) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_6 <- { _6 with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_9 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    
    | bb6 = s0
      [ s0 =  [ &_11 <- C_Red'0 ] s1
      | s1 =  [ &node <- { node with current = { node.current with t_Node__color'0 = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'5 (self.current).t_Map__0'0}
        MutBorrow.borrow_mut <t_Tree'0> {(self.current).t_Map__0'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_14 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_min_rec'0 {_14} (fun (_ret':(t_K'0, t_V'0)) ->  [ &r <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = is_red'0 {(self.current).t_Map__0'0} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_18 <- C_Black'0 ] s1
      | s1 = {inv'0 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Map__0'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_21 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s2)
      | s2 = as_mut'0 {_21} (fun (_ret':t_Option'1) ->  [ &_20 <- _ret' ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_20} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_19 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_19 <- { _19 with current = { _19.current with t_Node__color'0 = _18 } } ] s1
      | s1 = {[@expl:type invariant] inv'4 _19} s2
      | s2 = -{resolve'2 _19}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- C_Some'1 r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = bb18
    | bb18 = return' {_0} ]
    )
    [ & _0 : t_Option'2 = Any.any_l ()
    | & self : MutBorrow.t t_Map'0 = self
    | & _3 : () = Any.any_l ()
    | & _6 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _11 : t_Color'0 = Any.any_l ()
    | & r : (t_K'0, t_V'0) = Any.any_l ()
    | & _14 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _18 : t_Color'0 = Any.any_l ()
    | & _19 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _20 : t_Option'1 = Any.any_l ()
    | & _21 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:t_Option'2)-> {[@expl:delete_min result type invariant] [%#sred_black_tree2] inv'6 result}
      {[@expl:delete_min ensures] [%#sred_black_tree3] match result with
        | C_Some'1 (k, v) -> Map.get (view'0 self) (deep_model'0 k) = C_Some'2 v
        /\ (forall k2 : t_DeepModelTy'0 . Map.get (view'0 self) k2 = C_None'2 \/ le_log'0 (deep_model'0 k) k2)
        /\ view'1 self.final = Map.set (view'0 self) (deep_model'0 k) (C_None'2)
        | C_None'1 -> view'1 self.final = view'0 self /\ view'0 self = Const.const (C_None'2)
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__delete [#"red_black_tree.rs" 868 4 868 55] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 869 8 869 53
  let%span sred_black_tree1 = "red_black_tree.rs" 868 23 868 27
  let%span sred_black_tree2 = "red_black_tree.rs" 868 29 868 32
  let%span sred_black_tree3 = "red_black_tree.rs" 868 41 868 55
  let%span sred_black_tree4 = "red_black_tree.rs" 862 14 866 5
  let%span sred_black_tree5 = "red_black_tree.rs" 867 14 867 59
  let%span sred_black_tree6 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree7 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree8 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree9 = "red_black_tree.rs" 412 15 412 19
  let%span sred_black_tree10 = "red_black_tree.rs" 411 14 411 45
  let%span sred_black_tree11 = "red_black_tree.rs" 706 23 706 27
  let%span sred_black_tree12 = "red_black_tree.rs" 706 29 706 32
  let%span sred_black_tree13 = "red_black_tree.rs" 694 15 694 43
  let%span sred_black_tree14 = "red_black_tree.rs" 695 15 696 62
  let%span sred_black_tree15 = "red_black_tree.rs" 706 41 706 55
  let%span sred_black_tree16 = "red_black_tree.rs" 697 14 697 42
  let%span sred_black_tree17 = "red_black_tree.rs" 698 14 698 50
  let%span sred_black_tree18 = "red_black_tree.rs" 699 14 702 5
  let%span sred_black_tree19 = "red_black_tree.rs" 703 14 703 127
  let%span sred_black_tree20 = "red_black_tree.rs" 704 14 704 39
  let%span sred_black_tree21 = "red_black_tree.rs" 705 14 705 67
  let%span soption22 = "../../creusot-contracts/src/std/option.rs" 62 26 62 75
  let%span soption23 = "../../creusot-contracts/src/std/option.rs" 64 20 65 100
  let%span soption24 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span smodel26 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel27 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sred_black_tree28 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree29 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree30 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree31 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree32 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree33 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree34 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree35 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree36 = "red_black_tree.rs" 91 12 100 13
  let%span sresolve37 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree38 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree39 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree40 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree41 = "red_black_tree.rs" 256 16 256 48
  let%span sred_black_tree42 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree43 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree44 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree45 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree46 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant47 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed48 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sred_black_tree49 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree50 = "red_black_tree.rs" 311 20 311 102
  let%span sinvariant51 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree52 = "red_black_tree.rs" 368 20 368 61
  let%span sord53 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord54 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord55 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord56 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord57 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord58 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord59 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord60 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord61 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord62 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord63 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord64 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord65 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree66 = "red_black_tree.rs" 772 8 774 9
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree30] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord65] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord63] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord64] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord61] cmp_log'0 x y = C_Less'0)
   -> ([%#sord62] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord58] cmp_log'0 x y
  = o)  -> ([%#sord59] cmp_log'0 y z = o)  -> ([%#sord60] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord57] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord56] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord55] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord54] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord53] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree45] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree29] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  type t_Option'3  =
    | C_None'2
    | C_Some'2 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) : Map.map t_DeepModelTy'0 t_Option'3
  
   =
    [%#sred_black_tree46] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#sred_black_tree31] model_acc'0 self (Const.const (C_None'2))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree33] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'3, k : t_DeepModelTy'0 . [%#sred_black_tree32] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'2 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'3) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree36] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'2 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'3, k : t_DeepModelTy'0 . ([%#sred_black_tree34] bst_invariant'0 self)
   -> ([%#sred_black_tree35] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'2 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree8] let _ = model_acc_has_mapping'0 self (Const.const (C_None'2)) k in has_mapping_model_acc'0 self (Const.const (C_None'2)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree6] bst_invariant'0 self)
   -> ([%#sred_black_tree7] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = C_Some'2 v))
  
  predicate inv'14 (_1 : t_K'0)
  
  predicate inv'15 (_1 : t_V'0)
  
  predicate inv'5 (_1 : t_Tree'0)
  
  predicate inv'0 (_1 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Tree'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'0 node
    end
  
  predicate inv'13 (_1 : t_Node'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Node'0 [inv'13 x] . inv'13 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'5 left
    /\ inv'14 key /\ inv'15 val' /\ inv'5 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed48] inv'13 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Option'0 [inv'0 x] . inv'0 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  predicate invariant'0 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant47] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate resolve'3 (self : MutBorrow.t t_Option'0) =
    [%#sresolve37] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Option'0) =
    resolve'3 _1
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree43] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree42] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree52] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree49] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree39] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree38] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree50] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree44] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate invariant'7 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree66] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'12 (_1 : t_Map'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Map'0 [inv'12 x] . inv'12 x
  = (invariant'7 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'5 a_0
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_Map'0) =
    [%#sinvariant47] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'2 (_1 : MutBorrow.t t_Map'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Map'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate resolve'4 (self : MutBorrow.t t_Map'0) =
    [%#sresolve37] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Map'0) =
    resolve'4 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (t_K'0, t_V'0)
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'5 (self : t_Tree'0) =
    [%#sinvariant51] inv'5 self
  
  predicate inv'8 (_1 : t_Tree'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Tree'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  let rec is_red'0 (self:t_Tree'0) (return'  (ret:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree9] inv'8 self}
    any [ return' (result:bool)-> {[%#sred_black_tree10] result = (color'0 self = C_Red'0)} (! return' {result}) ] 
  
  predicate invariant'3 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant47] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate resolve'5 (self : MutBorrow.t t_Node'0) =
    [%#sresolve37] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Node'0) =
    resolve'5 _1
  
  predicate invariant'6 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant47] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'9 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'4 (self : t_K'0) =
    [%#sinvariant51] inv'14 self
  
  predicate inv'6 (_1 : t_K'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_K'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree40] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function cpn'0 [#"red_black_tree.rs" 255 0 255 36] (c : t_Color'0) (l : t_CP'0) (r : t_CP'0) : t_CP'0 =
    [%#sred_black_tree41] C_CPN'0 c l r
  
  predicate inv'11 (_1 : (t_K'0, t_V'0))
  
  axiom inv_axiom'11 [@rewrite] : forall x : (t_K'0, t_V'0) [inv'11 x] . inv'11 x
  = (let (x0, x1) = x in inv'14 x0 /\ inv'15 x1)
  
  predicate inv'7 (_1 : t_Option'1)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Option'1 [inv'7 x] . inv'7 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'11 a_0
    end
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel26] deep_model'0 self
  
  let rec delete_rec'0 (self:MutBorrow.t t_Tree'0) (key:t_K'0) (return'  (ret:t_Option'1))= {[@expl:delete_rec 'self' type invariant] [%#sred_black_tree11] inv'9 self}
    {[@expl:delete_rec 'key' type invariant] [%#sred_black_tree12] inv'6 key}
    {[@expl:delete_rec requires #0] [%#sred_black_tree13] internal_invariant'0 self.current}
    {[@expl:delete_rec requires #1] [%#sred_black_tree14] match_t'0 (C_CPL'0 (C_Red'0)) self.current
    \/ match_t'0 (cpn'0 (C_Black'0) (C_CPL'0 (C_Red'0)) (C_CPL'0 (C_Black'0))) self.current}
    any
    [ return' (result:t_Option'1)-> {[%#sred_black_tree15] inv'7 result}
      {[%#sred_black_tree16] internal_invariant'0 self.final}
      {[%#sred_black_tree17] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree18] match result with
        | C_None'1 -> forall v : t_V'0 . not has_mapping'0 self.current (deep_model'1 key) v
        | C_Some'1 (k, v) -> deep_model'1 key = deep_model'0 k /\ has_mapping'0 self.current (deep_model'0 k) v
        end}
      {[%#sred_black_tree19] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.final k v
      = (deep_model'1 key <> k /\ has_mapping'0 self.current k v)}
      {[%#sred_black_tree20] color_invariant'0 self.final}
      {[%#sred_black_tree21] color'0 self.current = C_Black'0  -> color'0 self.final = C_Black'0}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'3
    | C_Some'3 (MutBorrow.t t_Node'0)
  
  predicate inv'10 (_1 : t_Option'2)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_Option'2 [inv'10 x] . inv'10 x
  = match x with
    | C_None'3 -> true
    | C_Some'3 a_0 -> inv'4 a_0
    end
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'2))= {[@expl:as_mut 'self' type invariant] inv'1 self}
    any
    [ return' (result:t_Option'2)-> {inv'10 result}
      {[%#soption22] self.current = C_None'0  -> result = C_None'3 /\ self.final = C_None'0}
      {[%#soption23] self.current = C_None'0
      \/ (exists r : MutBorrow.t t_Node'0 . result = C_Some'3 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'2) (return'  (ret:MutBorrow.t t_Node'0))= {[@expl:unwrap 'self' type invariant] inv'10 self}
    {[@expl:unwrap requires] [%#soption24] self <> C_None'3}
    any
    [ return' (result:MutBorrow.t t_Node'0)-> {inv'4 result}
      {[%#soption25] C_Some'3 result = self}
      (! return' {result}) ]
  
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#sred_black_tree28] view'2 self.t_Map__0'0
  
  function view'0 (self : MutBorrow.t t_Map'0) : Map.map t_DeepModelTy'0 t_Option'3 =
    [%#smodel27] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec delete'0[#"red_black_tree.rs" 868 4 868 55] (self:MutBorrow.t t_Map'0) (key:t_K'0) (return'  (ret:t_Option'1))= {[@expl:delete 'self' type invariant] [%#sred_black_tree1] inv'2 self}
    {[@expl:delete 'key' type invariant] [%#sred_black_tree2] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_mut <t_Option'0> {((self.current).t_Map__0'0).t_Tree__node'0}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_8 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s1)
      | s1 = any [ br0 -> {_8.current = C_None'0} (! bb8) | br1 (x0:t_Node'0)-> {_8.current = C_Some'0 x0} (! bb2) ]  ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'1 _8} s1
      | s1 = -{resolve'0 _8}- s2
      | s2 = {[@expl:type invariant] inv'2 self} s3
      | s3 = -{resolve'1 self}- s4
      | s4 =  [ &_0 <- C_None'1 ] s5
      | s5 = bb17 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some'0 {_8.current}
          (fun (r0'0:t_Node'0) ->
            {inv'3 r0'0}
            MutBorrow.borrow_final <t_Node'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id _8) 1}
              (fun (_ret':MutBorrow.t t_Node'0) ->
                 [ &node <- _ret' ] 
                -{inv'3 _ret'.final}-
                 [ &_8 <- { _8 with current = C_Some'0 _ret'.final } ] 
                s1))
      | s1 = is_red'0 {(node.current).t_Node__left'0} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'4 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'1 _8} s3
      | s3 = -{resolve'0 _8}- s4
      | s4 = bb7 ]
    
    | bb6 = s0
      [ s0 =  [ &_13 <- C_Red'0 ] s1
      | s1 =  [ &node <- { node with current = { node.current with t_Node__color'0 = _13 } } ] s2
      | s2 = {[@expl:type invariant] inv'4 node} s3
      | s3 = -{resolve'2 node}- s4
      | s4 = {[@expl:type invariant] inv'1 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'5 (self.current).t_Map__0'0}
        MutBorrow.borrow_mut <t_Tree'0> {(self.current).t_Map__0'0}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &_16 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = _ret'.final } } ] 
            s1)
      | s1 = delete_rec'0 {_16} {key} (fun (_ret':t_Option'1) ->  [ &r <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = is_red'0 {(self.current).t_Map__0'0} (fun (_ret':bool) ->  [ &_19 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_19 = false} (! bb14) | br1 -> {_19} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_21 <- C_Black'0 ] s1
      | s1 = {inv'0 ((self.current).t_Map__0'0).t_Tree__node'0}
        MutBorrow.borrow_final
          <t_Option'0>
          {((self.current).t_Map__0'0).t_Tree__node'0}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret':MutBorrow.t t_Option'0) ->
             [ &_24 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = { t_Tree__node'0 = _ret'.final } } } ] 
            s2)
      | s2 = as_mut'0 {_24} (fun (_ret':t_Option'2) ->  [ &_23 <- _ret' ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_23} (fun (_ret':MutBorrow.t t_Node'0) ->  [ &_22 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_22 <- { _22 with current = { _22.current with t_Node__color'0 = _21 } } ] s1
      | s1 = {[@expl:type invariant] inv'4 _22} s2
      | s2 = -{resolve'2 _22}- s3
      | s3 = {[@expl:type invariant] inv'2 self} s4
      | s4 = -{resolve'1 self}- s5
      | s5 = bb15 ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'2 self} s1 | s1 = -{resolve'1 self}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = return' {_0} ]
    )
    [ & _0 : t_Option'1 = Any.any_l ()
    | & self : MutBorrow.t t_Map'0 = self
    | & key : t_K'0 = key
    | & _5 : () = Any.any_l ()
    | & _8 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & _13 : t_Color'0 = Any.any_l ()
    | & r : t_Option'1 = Any.any_l ()
    | & _16 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _19 : bool = Any.any_l ()
    | & _21 : t_Color'0 = Any.any_l ()
    | & _22 : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _23 : t_Option'2 = Any.any_l ()
    | & _24 : MutBorrow.t t_Option'0 = Any.any_l () ]
    
    [ return' (result:t_Option'1)-> {[@expl:delete result type invariant] [%#sred_black_tree3] inv'7 result}
      {[@expl:delete ensures #0] [%#sred_black_tree4] match result with
        | C_Some'1 (k, v) -> deep_model'0 k = deep_model'1 key /\ Map.get (view'0 self) (deep_model'1 key) = C_Some'2 v
        | C_None'1 -> Map.get (view'0 self) (deep_model'1 key) = C_None'2
        end}
      {[@expl:delete ensures #1] [%#sred_black_tree5] view'1 self.final
      = Map.set (view'0 self) (deep_model'1 key) (C_None'2)}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__get [#"red_black_tree.rs" 889 4 889 44] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 890 8 890 53
  let%span sred_black_tree1 = "red_black_tree.rs" 895 20 895 116
  let%span sred_black_tree2 = "red_black_tree.rs" 894 20 894 40
  let%span sred_black_tree3 = "red_black_tree.rs" 893 20 893 29
  let%span sred_black_tree4 = "red_black_tree.rs" 889 16 889 20
  let%span sred_black_tree5 = "red_black_tree.rs" 889 22 889 25
  let%span sred_black_tree6 = "red_black_tree.rs" 889 34 889 44
  let%span sred_black_tree7 = "red_black_tree.rs" 885 14 888 5
  let%span sred_black_tree8 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree9 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree10 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree11 = "red_black_tree.rs" 37 12 41 13
  let%span smodel12 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sred_black_tree13 = "red_black_tree.rs" 235 12 241 13
  let%span scmp14 = "../../creusot-contracts/src/std/cmp.rs" 72 26 72 85
  let%span smodel15 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sred_black_tree16 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree17 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree18 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree19 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree20 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree21 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree22 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree23 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree24 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sord26 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord27 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord28 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord29 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord30 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord31 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord32 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord33 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord34 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord35 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord36 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord37 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord38 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sred_black_tree39 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree40 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree41 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree42 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree43 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree44 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree45 = "red_black_tree.rs" 368 20 368 61
  let%span sboxed46 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sred_black_tree47 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree48 = "red_black_tree.rs" 327 12 335 13
  
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'1  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'1 }
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree11] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord38] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord36] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord37] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord34] cmp_log'0 x y = C_Less'0)
   -> ([%#sord35] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord31] cmp_log'0 x y
  = o)  -> ([%#sord32] cmp_log'0 y z = o)  -> ([%#sord33] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord30] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord29] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord28] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord27] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord26] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree22] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'1 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'1 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree13] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) : Map.map t_DeepModelTy'0 t_Option'2
  
   =
    [%#sred_black_tree24] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'2 val') in model_acc'0 right accu2
      end
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#sred_black_tree16] model_acc'0 self (Const.const (C_None'2))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree18] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'2 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'2, k : t_DeepModelTy'0 . [%#sred_black_tree17] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'2 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree21] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'2 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'2, k : t_DeepModelTy'0 . ([%#sred_black_tree19] bst_invariant'0 self)
   -> ([%#sred_black_tree20] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'2 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree10] let _ = model_acc_has_mapping'0 self (Const.const (C_None'2)) k in has_mapping_model_acc'0 self (Const.const (C_None'2)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree8] bst_invariant'0 self)
   -> ([%#sred_black_tree9] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'1 self) k = C_Some'2 v))
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel12] deep_model'1 self
  
  predicate inv'7 (_1 : t_K'0)
  
  predicate inv'9 (_1 : t_V'0)
  
  predicate inv'11 (_1 : t_Node'0)
  
  predicate inv'5 (_1 : t_Tree'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Node'0 [inv'11 x] . inv'11 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'5 left
    /\ inv'7 key /\ inv'9 val' /\ inv'5 right
    end
  
  predicate invariant'5 (self : t_Node'0) =
    [%#sboxed46] inv'11 self
  
  predicate inv'10 (_1 : t_Node'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Node'0 [inv'10 x] . inv'10 x = invariant'5 x
  
  predicate inv'8 (_1 : t_Option'1)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Option'1 [inv'8 x] . inv'8 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'10 a_0
    end
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Tree'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'8 node
    end
  
  predicate invariant'0 (self : t_Tree'0) =
    [%#sinvariant25] inv'5 self
  
  predicate inv'0 (_1 : t_Tree'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Tree'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  let rec v_Some'0 (input:t_Option'1) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'1] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'2 (self : t_K'0) =
    [%#sinvariant25] inv'7 self
  
  predicate inv'2 (_1 : t_K'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_K'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:t_Ordering'0))= {[@expl:cmp 'self' type invariant] inv'2 self}
    {[@expl:cmp 'other' type invariant] inv'2 other}
    any
    [ return' (result:t_Ordering'0)-> {[%#scmp14] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 t_V'0
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree48] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree47] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree45] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree43] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree40] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree42] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree44] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree41] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate invariant'4 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree39] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'6 (_1 : t_Map'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Map'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'5 a_0
    end)
  
  predicate invariant'1 (self : t_Map'0) =
    [%#sinvariant25] inv'6 self
  
  predicate inv'1 (_1 : t_Map'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Map'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate invariant'3 (self : t_V'0) =
    [%#sinvariant25] inv'9 self
  
  predicate inv'4 (_1 : t_V'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_V'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'4 a_0
    end
  
  function view'2 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#sred_black_tree23] view'1 self.t_Map__0'0
  
  function view'0 (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#smodel15] view'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec get'0[#"red_black_tree.rs" 889 4 889 44] (self:t_Map'0) (key:t_K'0) (return'  (ret:t_Option'0))= {[@expl:get 'self' type invariant] [%#sred_black_tree4] inv'1 self}
    {[@expl:get 'key' type invariant] [%#sred_black_tree5] inv'2 key}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] () ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &tree <- self.t_Map__0'0 ] s1 | s1 = bb2 ] 
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant #0] [%#sred_black_tree3] inv'0 tree}
        {[@expl:loop invariant #1] [%#sred_black_tree2] bst_invariant'0 tree}
        {[@expl:loop invariant #2] [%#sred_black_tree1] forall v : t_V'0 . has_mapping'0 self.t_Map__0'0 (deep_model'0 key) v
        = has_mapping'0 tree (deep_model'0 key) v}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 =  [ &_14 <- tree.t_Tree__node'0 ] s1
          | s1 = any [ br0 -> {_14 = C_None'0} (! bb14) | br1 (x0:t_Node'0)-> {_14 = C_Some'0 x0} (! bb4) ]  ]
        
        | bb4 = bb5
        | bb5 = s0
          [ s0 = v_Some'0 {_14} (fun (r0'0:t_Node'0) ->  [ &node <- r0'0 ] s1)
          | s1 =  [ &_20 <- node.t_Node__key'0 ] s2
          | s2 = cmp'0 {key} {_20} (fun (_ret':t_Ordering'0) ->  [ &_17 <- _ret' ] s3)
          | s3 = bb6 ]
        
        | bb6 = any
          [ br0 -> {_17 = C_Less'0} (! bb8) | br1 -> {_17 = C_Equal'0} (! bb9) | br2 -> {_17 = C_Greater'0} (! bb10) ]
        
        | bb10 = s0 [ s0 =  [ &_28 <- node.t_Node__right'0 ] s1 | s1 =  [ &tree <- _28 ] s2 | s2 = bb13 ] 
        | bb8 = bb12
        | bb12 = s0 [ s0 =  [ &_23 <- node.t_Node__left'0 ] s1 | s1 =  [ &tree <- _23 ] s2 | s2 = bb13 ] 
        | bb13 = bb2 ]
       ]
    
    | bb14 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb15 ] 
    | bb9 = bb11
    | bb11 = s0 [ s0 =  [ &_26 <- node.t_Node__val'0 ] s1 | s1 =  [ &_0 <- C_Some'1 _26 ] s2 | s2 = bb15 ] 
    | bb15 = return' {_0} ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & self : t_Map'0 = self
    | & key : t_K'0 = key
    | & _5 : () = Any.any_l ()
    | & tree : t_Tree'0 = Any.any_l ()
    | & _14 : t_Option'1 = Any.any_l ()
    | & node : t_Node'0 = Any.any_l ()
    | & _17 : t_Ordering'0 = Any.any_l ()
    | & _20 : t_K'0 = Any.any_l ()
    | & _23 : t_Tree'0 = Any.any_l ()
    | & _26 : t_V'0 = Any.any_l ()
    | & _28 : t_Tree'0 = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:get result type invariant] [%#sred_black_tree6] inv'3 result}
      {[@expl:get ensures] [%#sred_black_tree7] match result with
        | C_Some'1 v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'2 v
        | C_None'1 -> Map.get (view'0 self) (deep_model'0 key) = C_None'2
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__get_mut [#"red_black_tree.rs" 910 4 910 56] (* Map<K, V> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 911 8 911 53
  let%span sred_black_tree1 = "red_black_tree.rs" 914 23 914 41
  let%span sred_black_tree2 = "red_black_tree.rs" 927 20 928 84
  let%span sred_black_tree3 = "red_black_tree.rs" 926 20 926 90
  let%span sred_black_tree4 = "red_black_tree.rs" 924 20 925 51
  let%span sred_black_tree5 = "red_black_tree.rs" 922 20 923 80
  let%span sred_black_tree6 = "red_black_tree.rs" 921 20 921 122
  let%span sred_black_tree7 = "red_black_tree.rs" 920 20 920 122
  let%span sred_black_tree8 = "red_black_tree.rs" 919 20 919 42
  let%span sred_black_tree9 = "red_black_tree.rs" 918 20 918 43
  let%span sred_black_tree10 = "red_black_tree.rs" 917 20 917 40
  let%span sred_black_tree11 = "red_black_tree.rs" 916 20 916 29
  let%span sred_black_tree12 = "red_black_tree.rs" 910 24 910 28
  let%span sred_black_tree13 = "red_black_tree.rs" 910 30 910 33
  let%span sred_black_tree14 = "red_black_tree.rs" 910 42 910 56
  let%span sred_black_tree15 = "red_black_tree.rs" 906 14 909 5
  let%span sred_black_tree16 = "red_black_tree.rs" 105 15 105 35
  let%span sred_black_tree17 = "red_black_tree.rs" 106 14 106 78
  let%span sred_black_tree18 = "red_black_tree.rs" 112 12 112 61
  let%span sred_black_tree19 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree20 = "red_black_tree.rs" 263 12 268 13
  let%span sred_black_tree21 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree22 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree23 = "red_black_tree.rs" 327 12 335 13
  let%span sred_black_tree24 = "red_black_tree.rs" 342 12 348 13
  let%span smodel25 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sred_black_tree26 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree27 = "red_black_tree.rs" 297 12 303 13
  let%span scmp28 = "../../creusot-contracts/src/std/cmp.rs" 72 26 72 85
  let%span smodel29 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sred_black_tree30 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree31 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree32 = "red_black_tree.rs" 67 14 68 91
  let%span sred_black_tree33 = "red_black_tree.rs" 71 12 79 13
  let%span sred_black_tree34 = "red_black_tree.rs" 84 15 84 35
  let%span sred_black_tree35 = "red_black_tree.rs" 85 14 85 92
  let%span sred_black_tree36 = "red_black_tree.rs" 91 12 100 13
  let%span sred_black_tree37 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree38 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree39 = "red_black_tree.rs" 311 20 311 102
  let%span sresolve40 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sred_black_tree41 = "red_black_tree.rs" 55 12 62 13
  let%span sinvariant42 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sboxed43 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sord44 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord45 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord46 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord47 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord48 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord49 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord50 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord51 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord52 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord53 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord54 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord55 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord56 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant57 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree58 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree59 = "red_black_tree.rs" 387 12 387 59
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'1 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree19] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'1 key /\ v = val'
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord56] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord54] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord55] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord52] cmp_log'0 x y = C_Less'0)
   -> ([%#sord53] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord49] cmp_log'0 x y
  = o)  -> ([%#sord50] cmp_log'0 y z = o)  -> ([%#sord51] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord48] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord47] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord46] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord45] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord44] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree38] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'1 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'1 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree26] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V'0
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) : Map.map t_DeepModelTy'0 t_Option'2
  
   =
    [%#sred_black_tree41] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'2 val') in model_acc'0 right accu2
      end
  
  function view'2 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#sred_black_tree31] model_acc'0 self (Const.const (C_None'2))
  
  function model_acc_has_mapping'0 [#"red_black_tree.rs" 69 4 69 83] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree33] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = model_acc_has_mapping'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'2 val') in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom model_acc_has_mapping'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'2, k : t_DeepModelTy'0 . [%#sred_black_tree32] Map.get (model_acc'0 self accu) k
  = Map.get accu k
  \/ (exists v : t_V'0 . Map.get (model_acc'0 self accu) k = C_Some'2 v /\ has_mapping'0 self k v)
  
  function has_mapping_model_acc'0 [#"red_black_tree.rs" 86 4 88 33] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'2) (k : t_DeepModelTy'0) : ()
  
   =
    [%#sred_black_tree36] match self with
      | {t_Tree__node'0 = C_None'0} -> ()
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let _ = has_mapping_model_acc'0 left accu k in let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'1 key) (C_Some'2 val') in let _ = has_mapping_model_acc'0 right accu2 k in model_acc_has_mapping'0 right accu2 k
      end
  
  axiom has_mapping_model_acc'0_spec : forall self : t_Tree'0, accu : Map.map t_DeepModelTy'0 t_Option'2, k : t_DeepModelTy'0 . ([%#sred_black_tree34] bst_invariant'0 self)
   -> ([%#sred_black_tree35] forall v : t_V'0 . has_mapping'0 self k v
   -> Map.get (model_acc'0 self accu) k = C_Some'2 v)
  
  function has_mapping_model'0 [#"red_black_tree.rs" 107 4 109 33] (self : t_Tree'0) (k : t_DeepModelTy'0) : () =
    [%#sred_black_tree18] let _ = model_acc_has_mapping'0 self (Const.const (C_None'2)) k in has_mapping_model_acc'0 self (Const.const (C_None'2)) k
  
  axiom has_mapping_model'0_spec : forall self : t_Tree'0, k : t_DeepModelTy'0 . ([%#sred_black_tree16] bst_invariant'0 self)
   -> ([%#sred_black_tree17] forall v : t_V'0 . has_mapping'0 self k v = (Map.get (view'2 self) k = C_Some'2 v))
  
  predicate inv'13 (_1 : t_K'0)
  
  predicate inv'6 (_1 : t_V'0)
  
  predicate inv'11 (_1 : t_Node'0)
  
  predicate inv'0 (_1 : t_Tree'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_Node'0 [inv'11 x] . inv'11 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'0 left
    /\ inv'13 key /\ inv'6 val' /\ inv'0 right
    end
  
  predicate invariant'1 (self : t_Node'0) =
    [%#sboxed43] inv'11 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Tree'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'2 node
    end
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  type t_CP'0  =
    | C_CPL'0 t_Color'0
    | C_CPN'0 t_Color'0 t_CP'0 t_CP'0
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree21] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree39] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree27] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate match_t'0 [#"red_black_tree.rs" 261 4 261 52] (self : t_CP'0) (tree : t_Tree'0) =
    [%#sred_black_tree20] match self with
      | C_CPL'0 color -> color'0 tree = color /\ color_invariant'0 tree
      | C_CPN'0 color l r -> exists node : t_Node'0 . tree.t_Tree__node'0 = C_Some'0 node
      /\ node.t_Node__color'0 = color /\ match_t'0 l node.t_Node__left'0 /\ match_t'0 r node.t_Node__right'0
      end
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree23] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree22] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree37] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree24] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0 =
    [%#smodel25] deep_model'1 self
  
  predicate invariant'0 (self : MutBorrow.t t_Tree'0) =
    [%#sinvariant42] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_Tree'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_Tree'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:t_Node'0))= any
    [ good (field_0:t_Node'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Node'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input} (! {false} any) ]
  
  
  predicate invariant'6 (self : t_K'0) =
    [%#sinvariant57] inv'13 self
  
  predicate inv'9 (_1 : t_K'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_K'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  let rec cmp'0 (self:t_K'0) (other:t_K'0) (return'  (ret:t_Ordering'0))= {[@expl:cmp 'self' type invariant] inv'9 self}
    {[@expl:cmp 'other' type invariant] inv'9 other}
    any
    [ return' (result:t_Ordering'0)-> {[%#scmp28] result = cmp_log'0 (deep_model'1 self) (deep_model'1 other)}
      (! return' {result}) ]
  
  
  predicate resolve'5 (self : MutBorrow.t t_Tree'0) =
    [%#sresolve40] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_Tree'0) =
    resolve'5 _1
  
  predicate invariant'2 (self : MutBorrow.t t_Node'0) =
    [%#sinvariant42] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_Node'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate resolve'6 (self : MutBorrow.t t_Node'0) =
    [%#sresolve40] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_Node'0) =
    resolve'6 _1
  
  predicate invariant'3 (self : MutBorrow.t t_Option'0) =
    [%#sinvariant42] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_Option'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate resolve'7 (self : MutBorrow.t t_Option'0) =
    [%#sresolve40] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Option'0) =
    resolve'7 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V'0)
  
  predicate invariant'4 (self : MutBorrow.t t_V'0) =
    [%#sinvariant42] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_V'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_V'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate resolve'8 (self : MutBorrow.t t_V'0) =
    [%#sresolve40] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_V'0) =
    resolve'8 _1
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree59] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate invariant'7 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree58] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'12 (_1 : t_Map'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Map'0 [inv'12 x] . inv'12 x
  = (invariant'7 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'0 a_0
    end)
  
  predicate invariant'5 (self : MutBorrow.t t_Map'0) =
    [%#sinvariant42] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_Map'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Map'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  predicate resolve'9 (self : MutBorrow.t t_Map'0) =
    [%#sresolve40] self.final = self.current
  
  predicate resolve'4 (_1 : MutBorrow.t t_Map'0) =
    resolve'9 _1
  
  predicate inv'10 (_1 : t_Option'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Option'1 [inv'10 x] . inv'10 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'7 a_0
    end
  
  function view'1 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#sred_black_tree30] view'2 self.t_Map__0'0
  
  function view'0 (self : MutBorrow.t t_Map'0) : Map.map t_DeepModelTy'0 t_Option'2 =
    [%#smodel29] view'1 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec get_mut'0[#"red_black_tree.rs" 910 4 910 56] (self:MutBorrow.t t_Map'0) (key:t_K'0) (return'  (ret:t_Option'1))= {[@expl:get_mut 'self' type invariant] [%#sred_black_tree12] inv'8 self}
    {[@expl:get_mut 'key' type invariant] [%#sred_black_tree13] inv'9 key}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree0] () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 (self.current).t_Map__0'0}
        MutBorrow.borrow_final <t_Tree'0> {(self.current).t_Map__0'0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret':MutBorrow.t t_Tree'0) ->
             [ &tree <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { t_Map__0'0 = _ret'.final } } ] 
            s1)
      | s1 =  [ &old_tree <- [%#sred_black_tree1] tree ] s2
      | s2 = bb2 ]
    
    | bb2 = bb3
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] [%#sred_black_tree11] inv'1 tree}
        {[@expl:loop invariant #1] [%#sred_black_tree10] bst_invariant'0 tree.current}
        {[@expl:loop invariant #2] [%#sred_black_tree9] height_invariant'0 tree.current}
        {[@expl:loop invariant #3] [%#sred_black_tree8] color_invariant'0 tree.current}
        {[@expl:loop invariant #4] [%#sred_black_tree7] forall v : t_V'0 . has_mapping'0 tree.final (deep_model'0 key) v
        = has_mapping'0 old_tree.final (deep_model'0 key) v}
        {[@expl:loop invariant #5] [%#sred_black_tree6] forall v : t_V'0 . has_mapping'0 tree.current (deep_model'0 key) v
        = has_mapping'0 old_tree.current (deep_model'0 key) v}
        {[@expl:loop invariant #6] [%#sred_black_tree5] (forall k : t_DeepModelTy'0, v : t_V'0 . k = deep_model'0 key
        \/ has_mapping'0 tree.current k v = has_mapping'0 tree.final k v)
         -> bst_invariant'0 tree.final  -> bst_invariant'0 old_tree.final}
        {[@expl:loop invariant #7] [%#sred_black_tree4] height'0 tree.current = height'0 tree.final
        /\ height_invariant'0 tree.final  -> height_invariant'0 old_tree.final}
        {[@expl:loop invariant #8] [%#sred_black_tree3] match_t'0 (C_CPL'0 (color'0 tree.current)) tree.final
         -> match_t'0 (C_CPL'0 (C_Black'0)) old_tree.final}
        {[@expl:loop invariant #9] [%#sred_black_tree2] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 tree.current k v
        = has_mapping'0 tree.final k v  -> has_mapping'0 old_tree.current k v = has_mapping'0 old_tree.final k v}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = {inv'2 (tree.current).t_Tree__node'0}
            MutBorrow.borrow_final
              <t_Option'0>
              {(tree.current).t_Tree__node'0}
              {MutBorrow.inherit_id (MutBorrow.get_id tree) 1}
              (fun (_ret':MutBorrow.t t_Option'0) ->
                 [ &_23 <- _ret' ] 
                -{inv'2 _ret'.final}-
                 [ &tree <- { tree with current = { t_Tree__node'0 = _ret'.final } } ] 
                s1)
          | s1 = any
            [ br0 -> {_23.current = C_None'0} (! bb15) | br1 (x0:t_Node'0)-> {_23.current = C_Some'0 x0} (! bb5) ]
           ]
        
        | bb5 = bb6
        | bb6 = s0
          [ s0 = v_Some'0 {_23.current}
              (fun (r0'0:t_Node'0) ->
                {inv'3 r0'0}
                MutBorrow.borrow_final <t_Node'0> {r0'0} {MutBorrow.inherit_id (MutBorrow.get_id _23) 1}
                  (fun (_ret':MutBorrow.t t_Node'0) ->
                     [ &node <- _ret' ] 
                    -{inv'3 _ret'.final}-
                     [ &_23 <- { _23 with current = C_Some'0 _ret'.final } ] 
                    s1))
          | s1 =  [ &_29 <- (node.current).t_Node__key'0 ] s2
          | s2 = cmp'0 {key} {_29} (fun (_ret':t_Ordering'0) ->  [ &_26 <- _ret' ] s3)
          | s3 = bb7 ]
        
        | bb7 = any
          [ br0 -> {_26 = C_Less'0} (! bb9) | br1 -> {_26 = C_Equal'0} (! bb10) | br2 -> {_26 = C_Greater'0} (! bb11) ]
        
        | bb11 = s0
          [ s0 = {inv'0 (node.current).t_Node__right'0}
            MutBorrow.borrow_final
              <t_Tree'0>
              {(node.current).t_Node__right'0}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 5}
              (fun (_ret':MutBorrow.t t_Tree'0) ->
                 [ &_37 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &node <- { node with current = { node.current with t_Node__right'0 = _ret'.final } } ] 
                s1)
          | s1 = {inv'0 _37.current}
            MutBorrow.borrow_final <t_Tree'0> {_37.current} {MutBorrow.get_id _37}
              (fun (_ret':MutBorrow.t t_Tree'0) ->
                 [ &_36 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_37 <- { _37 with current = _ret'.final } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'1 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _36 ] s5
          | s5 = {[@expl:type invariant] inv'1 _37} s6
          | s6 = -{resolve'0 _37}- s7
          | s7 = bb14 ]
        
        | bb9 = bb13
        | bb13 = s0
          [ s0 = {inv'0 (node.current).t_Node__left'0}
            MutBorrow.borrow_final
              <t_Tree'0>
              {(node.current).t_Node__left'0}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 1}
              (fun (_ret':MutBorrow.t t_Tree'0) ->
                 [ &_32 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &node <- { node with current = { node.current with t_Node__left'0 = _ret'.final } } ] 
                s1)
          | s1 = {inv'0 _32.current}
            MutBorrow.borrow_final <t_Tree'0> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret':MutBorrow.t t_Tree'0) ->
                 [ &_31 <- _ret' ] 
                -{inv'0 _ret'.final}-
                 [ &_32 <- { _32 with current = _ret'.final } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'1 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _31 ] s5
          | s5 = {[@expl:type invariant] inv'1 _32} s6
          | s6 = -{resolve'0 _32}- s7
          | s7 = bb14 ]
        
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'4 node} s1
          | s1 = -{resolve'1 node}- s2
          | s2 = {[@expl:type invariant] inv'5 _23} s3
          | s3 = -{resolve'2 _23}- s4
          | s4 = bb3 ]
         ]
       ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'5 _23} s1
      | s1 = -{resolve'2 _23}- s2
      | s2 =  [ &_0 <- C_None'1 ] s3
      | s3 = bb16 ]
    
    | bb10 = bb12
    | bb12 = s0
      [ s0 = {inv'6 (node.current).t_Node__val'0}
        MutBorrow.borrow_final <t_V'0> {(node.current).t_Node__val'0} {MutBorrow.inherit_id (MutBorrow.get_id node) 4}
          (fun (_ret':MutBorrow.t t_V'0) ->
             [ &_35 <- _ret' ] 
            -{inv'6 _ret'.final}-
             [ &node <- { node with current = { node.current with t_Node__val'0 = _ret'.final } } ] 
            s1)
      | s1 = {inv'6 _35.current}
        MutBorrow.borrow_final <t_V'0> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret':MutBorrow.t t_V'0) ->
             [ &_34 <- _ret' ] 
            -{inv'6 _ret'.final}-
             [ &_35 <- { _35 with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_0 <- C_Some'1 _34 ] s3
      | s3 = {[@expl:type invariant] inv'7 _35} s4
      | s4 = -{resolve'3 _35}- s5
      | s5 = {[@expl:type invariant] inv'4 node} s6
      | s6 = -{resolve'1 node}- s7
      | s7 = {[@expl:type invariant] inv'5 _23} s8
      | s8 = -{resolve'2 _23}- s9
      | s9 = bb16 ]
    
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'1 tree} s1
      | s1 = -{resolve'0 tree}- s2
      | s2 = {[@expl:type invariant] inv'8 self} s3
      | s3 = -{resolve'4 self}- s4
      | s4 = return' {_0} ]
     ]
    )
    [ & _0 : t_Option'1 = Any.any_l ()
    | & self : MutBorrow.t t_Map'0 = self
    | & key : t_K'0 = key
    | & _5 : () = Any.any_l ()
    | & tree : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & old_tree : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _23 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & node : MutBorrow.t t_Node'0 = Any.any_l ()
    | & _26 : t_Ordering'0 = Any.any_l ()
    | & _29 : t_K'0 = Any.any_l ()
    | & _31 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _32 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _34 : MutBorrow.t t_V'0 = Any.any_l ()
    | & _35 : MutBorrow.t t_V'0 = Any.any_l ()
    | & _36 : MutBorrow.t t_Tree'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_Tree'0 = Any.any_l () ]
    
    [ return' (result:t_Option'1)-> {[@expl:get_mut result type invariant] [%#sred_black_tree14] inv'10 result}
      {[@expl:get_mut ensures] [%#sred_black_tree15] match result with
        | C_Some'1 v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'2 (v.current)
        /\ view'1 self.final = Map.set (view'0 self) (deep_model'0 key) (C_Some'2 (v.final))
        | C_None'1 -> Map.get (view'0 self) (deep_model'0 key) = C_None'2 /\ view'1 self.final = view'0 self
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi11959472507597060150__clone__refines [#"red_black_tree.rs" 12 9 12 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 12 9 12 14
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  predicate inv'0 (_1 : t_Color'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Color'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Color'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Color'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sred_black_tree0] forall self : t_Color'0 . inv'0 self
   -> (forall result : t_Color'0 . result = self  -> result = self /\ inv'1 result)
end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence__refines [#"red_black_tree.rs" 187 4 187 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 187 4 187 31
  let%span sred_black_tree1 = "red_black_tree.rs" 179 12 179 69
  let%span sred_black_tree2 = "red_black_tree.rs" 37 12 41 13
  let%span sresolve3 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sred_black_tree6 = "red_black_tree.rs" 195 12 195 69
  let%span sred_black_tree7 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree8 = "red_black_tree.rs" 138 8 141 9
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree2] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate has_mapping'1 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree8] has_mapping'0 self.t_Node__left'0 k v
    \/ has_mapping'0 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'1_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree7] forall node : t_Node'0 . self
  = node  -> has_mapping'1 self k v = has_mapping'0 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate resolve'2 (_1 : t_V'0)
  
  predicate resolve'7 [#"red_black_tree.rs" 193 4 193 28] (self : t_Node'0) =
    [%#sred_black_tree6] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'6 (_1 : t_Node'0) =
    resolve'7 _1
  
  predicate resolve'5 (self : t_Node'0) =
    [%#sresolve5] resolve'6 self
  
  predicate resolve'4 (_1 : t_Node'0) =
    resolve'5 _1
  
  predicate resolve'3 (self : t_Option'0) =
    [%#sresolve3] match self with
      | C_Some'0 x -> resolve'4 x
      | C_None'0 -> true
      end
  
  predicate resolve'1 (_1 : t_Option'0) =
    resolve'3 _1
  
  predicate structural_resolve'0 (_1 : t_Tree'0) =
    match _1 with
      | {t_Tree__node'0 = x0} -> resolve'1 x0
      end
  
  predicate inv'5 (_1 : t_K'0)
  
  predicate inv'6 (_1 : t_V'0)
  
  predicate inv'4 (_1 : t_Node'0)
  
  predicate inv'1 (_1 : t_Tree'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'4 x] . inv'4 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'1 left
    /\ inv'5 key /\ inv'6 val' /\ inv'1 right
    end
  
  predicate invariant'1 (self : t_Node'0) =
    [%#sboxed9] inv'4 self
  
  predicate inv'3 (_1 : t_Node'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Node'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate inv'2 (_1 : t_Option'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Option'0 [inv'2 x] . inv'2 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Tree'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'2 node
    end
  
  predicate invariant'0 (self : t_Tree'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 (_1 : t_Tree'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Tree'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'0 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree1] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  goal refines : [%#sred_black_tree0] forall self : t_Tree'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence__refines [#"red_black_tree.rs" 203 4 203 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 203 4 203 31
  let%span sred_black_tree1 = "red_black_tree.rs" 195 12 195 69
  let%span sred_black_tree2 = "red_black_tree.rs" 135 14 136 84
  let%span sred_black_tree3 = "red_black_tree.rs" 138 8 141 9
  let%span sred_black_tree4 = "red_black_tree.rs" 179 12 179 69
  let%span sinvariant5 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sred_black_tree6 = "red_black_tree.rs" 37 12 41 13
  let%span sboxed7 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  with t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'1 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree6] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'1 left k v
      \/ has_mapping'1 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'2 (_1 : t_V'0)
  
  predicate resolve'5 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree4] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'1 self k v  -> resolve'2 v
  
  predicate resolve'1 (_1 : t_Tree'0) =
    resolve'5 _1
  
  predicate resolve'3 (_1 : t_K'0)
  
  predicate resolve'4 (_1 : t_Color'0) =
    true
  
  predicate structural_resolve'0 (_1 : t_Node'0) =
    match _1 with
      | {t_Node__left'0 = x0 ; t_Node__color'0 = x1 ; t_Node__key'0 = x2 ; t_Node__val'0 = x3 ; t_Node__right'0 = x4} -> resolve'1 x4
      /\ resolve'2 x3 /\ resolve'3 x2 /\ resolve'4 x1 /\ resolve'1 x0
      end
  
  predicate inv'3 (_1 : t_K'0)
  
  predicate inv'4 (_1 : t_V'0)
  
  predicate inv'1 (_1 : t_Node'0)
  
  predicate invariant'1 (self : t_Node'0) =
    [%#sboxed7] inv'1 self
  
  predicate inv'6 (_1 : t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'6 x] . inv'6 x = invariant'1 x
  
  predicate inv'5 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'5 x] . inv'5 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  predicate inv'2 (_1 : t_Tree'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Tree'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'5 node
    end
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Node'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'2 left
    /\ inv'3 key /\ inv'4 val' /\ inv'2 right
    end
  
  predicate invariant'0 (self : t_Node'0) =
    [%#sinvariant5] inv'1 self
  
  predicate inv'0 (_1 : t_Node'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Node'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate has_mapping'0 [#"red_black_tree.rs" 137 4 137 57] (self : t_Node'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree3] has_mapping'1 self.t_Node__left'0 k v
    \/ has_mapping'1 self.t_Node__right'0 k v \/ k = deep_model'0 self.t_Node__key'0 /\ v = self.t_Node__val'0
  
  axiom has_mapping'0_spec : forall self : t_Node'0, k : t_DeepModelTy'0, v : t_V'0 . [%#sred_black_tree2] forall node : t_Node'0 . self
  = node  -> has_mapping'0 self k v = has_mapping'1 { t_Tree__node'0 = C_Some'0 node } k v
  
  predicate resolve'0 [#"red_black_tree.rs" 193 4 193 28] (self : t_Node'0) =
    [%#sred_black_tree1] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'2 v
  
  goal refines : [%#sred_black_tree0] forall self : t_Node'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence__refines [#"red_black_tree.rs" 793 4 793 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree0 = "red_black_tree.rs" 793 4 793 31
  let%span sred_black_tree1 = "red_black_tree.rs" 785 20 785 68
  let%span sred_black_tree2 = "red_black_tree.rs" 761 20 761 27
  let%span sred_black_tree3 = "red_black_tree.rs" 179 12 179 69
  let%span sinvariant4 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sresolve5 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sred_black_tree6 = "red_black_tree.rs" 170 20 170 54
  let%span sred_black_tree7 = "red_black_tree.rs" 37 12 41 13
  let%span sred_black_tree8 = "red_black_tree.rs" 55 12 62 13
  let%span sred_black_tree9 = "red_black_tree.rs" 772 8 774 9
  let%span sred_black_tree10 = "red_black_tree.rs" 387 12 387 59
  let%span sred_black_tree11 = "red_black_tree.rs" 297 12 303 13
  let%span sred_black_tree12 = "red_black_tree.rs" 287 12 290 13
  let%span sred_black_tree13 = "red_black_tree.rs" 235 12 241 13
  let%span sred_black_tree14 = "red_black_tree.rs" 342 12 348 13
  let%span sred_black_tree15 = "red_black_tree.rs" 311 20 311 102
  let%span sred_black_tree16 = "red_black_tree.rs" 215 12 216 104
  let%span sred_black_tree17 = "red_black_tree.rs" 368 20 368 61
  let%span sred_black_tree18 = "red_black_tree.rs" 324 14 324 25
  let%span sred_black_tree19 = "red_black_tree.rs" 327 12 335 13
  let%span sord20 = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord21 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord22 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord23 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord24 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord25 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord26 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord27 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord28 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord29 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord30 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord31 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord32 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sboxed33 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color'0  =
    | C_Red'0
    | C_Black'0
  
  type t_K'0
  
  type t_V'0
  
  type t_Node'0  =
    { t_Node__left'0: t_Tree'0;
      t_Node__color'0: t_Color'0;
      t_Node__key'0: t_K'0;
      t_Node__val'0: t_V'0;
      t_Node__right'0: t_Tree'0 }
  with t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node'0
  with t_Tree'0  =
    { t_Tree__node'0: t_Option'0 }
  
  type t_Map'0  =
    { t_Map__0'0: t_Tree'0 }
  
  type t_DeepModelTy'0
  
  function deep_model'0 (self : t_K'0) : t_DeepModelTy'0
  
  predicate has_mapping'0 [#"red_black_tree.rs" 35 4 35 57] (self : t_Tree'0) (k : t_DeepModelTy'0) (v : t_V'0) =
    [%#sred_black_tree7] match self with
      | {t_Tree__node'0 = C_None'0} -> false
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> has_mapping'0 left k v
      \/ has_mapping'0 right k v \/ k = deep_model'0 key /\ v = val'
      end
  
  predicate resolve'5 (_1 : t_V'0)
  
  predicate resolve'3 [#"red_black_tree.rs" 177 4 177 28] (self : t_Tree'0) =
    [%#sred_black_tree3] forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self k v  -> resolve'5 v
  
  predicate resolve'1 (_1 : t_Tree'0) =
    resolve'3 _1
  
  predicate structural_resolve'0 (_1 : t_Map'0) =
    match _1 with
      | {t_Map__0'0 = x0} -> resolve'1 x0
      end
  
  type t_Ordering'0  =
    | C_Less'0
    | C_Equal'0
    | C_Greater'0
  
  function cmp_log'0 (self : t_DeepModelTy'0) (other : t_DeepModelTy'0) : t_Ordering'0
  
  function eq_cmp'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom eq_cmp'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord32] (x = y)
  = (cmp_log'0 x y = C_Equal'0)
  
  function antisym2'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym2'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord30] cmp_log'0 x y = C_Greater'0)
   -> ([%#sord31] cmp_log'0 y x = C_Less'0)
  
  function antisym1'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom antisym1'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . ([%#sord28] cmp_log'0 x y = C_Less'0)
   -> ([%#sord29] cmp_log'0 y x = C_Greater'0)
  
  function trans'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) (z : t_DeepModelTy'0) (o : t_Ordering'0) : ()
  
  axiom trans'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0, z : t_DeepModelTy'0, o : t_Ordering'0 . ([%#sord25] cmp_log'0 x y
  = o)  -> ([%#sord26] cmp_log'0 y z = o)  -> ([%#sord27] cmp_log'0 x z = o)
  
  function refl'0 (x : t_DeepModelTy'0) : ()
  
  axiom refl'0_spec : forall x : t_DeepModelTy'0 . [%#sord24] cmp_log'0 x x = C_Equal'0
  
  predicate gt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_gt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_gt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord23] gt_log'0 x y
  = (cmp_log'0 x y = C_Greater'0)
  
  predicate ge_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_ge_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_ge_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord22] ge_log'0 x y
  = (cmp_log'0 x y <> C_Less'0)
  
  predicate lt_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_lt_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_lt_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord21] lt_log'0 x y
  = (cmp_log'0 x y = C_Less'0)
  
  predicate le_log'0 (self : t_DeepModelTy'0) (o : t_DeepModelTy'0)
  
  function cmp_le_log'0 (x : t_DeepModelTy'0) (y : t_DeepModelTy'0) : ()
  
  axiom cmp_le_log'0_spec : forall x : t_DeepModelTy'0, y : t_DeepModelTy'0 . [%#sord20] le_log'0 x y
  = (cmp_log'0 x y <> C_Greater'0)
  
  predicate bst_invariant_here'0 [#"red_black_tree.rs" 213 4 213 39] (self : t_Node'0) =
    [%#sred_black_tree16] (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__left'0 k v
     -> lt_log'0 k (deep_model'0 self.t_Node__key'0))
    /\ (forall k : t_DeepModelTy'0, v : t_V'0 . has_mapping'0 self.t_Node__right'0 k v
     -> lt_log'0 (deep_model'0 self.t_Node__key'0) k)
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 233 4 233 34] (self : t_Tree'0) =
    [%#sred_black_tree13] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in bst_invariant_here'0 node
      /\ bst_invariant'0 left /\ bst_invariant'0 right
      end
  
  function height'0 [#"red_black_tree.rs" 325 4 325 26] (self : t_Tree'0) : int =
    [%#sred_black_tree19] match self with
      | {t_Tree__node'0 = C_None'0} -> 0
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__color'0 = color}} -> match color with
        | C_Red'0 -> height'0 left
        | C_Black'0 -> height'0 left + 1
        end
      end
  
  axiom height'0_spec : forall self : t_Tree'0 . [%#sred_black_tree18] height'0 self >= 0
  
  predicate height_invariant_here'0 [#"red_black_tree.rs" 367 4 367 42] (self : t_Node'0) =
    [%#sred_black_tree17] height'0 self.t_Node__left'0 = height'0 self.t_Node__right'0
  
  predicate height_invariant'0 [#"red_black_tree.rs" 340 4 340 37] (self : t_Tree'0) =
    [%#sred_black_tree14] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in height_invariant_here'0 node
      /\ height_invariant'0 left /\ height_invariant'0 right
      end
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 385 4 385 39] (self : t_Tree'0) =
    [%#sred_black_tree10] bst_invariant'0 self /\ height_invariant'0 self
  
  function color'0 [#"red_black_tree.rs" 285 4 285 27] (self : t_Tree'0) : t_Color'0 =
    [%#sred_black_tree12] match self.t_Tree__node'0 with
      | C_Some'0 {t_Node__color'0 = color} -> color
      | _ -> C_Black'0
      end
  
  predicate color_invariant_here'0 [#"red_black_tree.rs" 310 4 310 41] (self : t_Node'0) =
    [%#sred_black_tree15] color'0 self.t_Node__right'0 = C_Black'0
    /\ (self.t_Node__color'0 = C_Black'0 \/ color'0 self.t_Node__left'0 = C_Black'0)
  
  predicate color_invariant'0 [#"red_black_tree.rs" 295 4 295 36] (self : t_Tree'0) =
    [%#sred_black_tree11] match self with
      | {t_Tree__node'0 = C_None'0} -> true
      | {t_Tree__node'0 = C_Some'0 node} -> let {t_Node__left'0 = left ; t_Node__right'0 = right} = node in color_invariant_here'0 node
      /\ color_invariant'0 left /\ color_invariant'0 right
      end
  
  predicate invariant'1 [#"red_black_tree.rs" 771 4 771 30] (self : t_Map'0) =
    [%#sred_black_tree9] internal_invariant'0 self.t_Map__0'0
    /\ color_invariant'0 self.t_Map__0'0 /\ color'0 self.t_Map__0'0 = C_Black'0
  
  predicate inv'6 (_1 : t_K'0)
  
  predicate inv'7 (_1 : t_V'0)
  
  predicate inv'5 (_1 : t_Node'0)
  
  predicate inv'2 (_1 : t_Tree'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Node'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_Node__left'0 = left ; t_Node__color'0 = color ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right} -> inv'2 left
    /\ inv'6 key /\ inv'7 val' /\ inv'2 right
    end
  
  predicate invariant'2 (self : t_Node'0) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : t_Node'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Node'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'3 (_1 : t_Option'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Option'0 [inv'3 x] . inv'3 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Tree'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_Tree__node'0 = node} -> inv'3 node
    end
  
  predicate inv'1 (_1 : t_Map'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Map'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Map__0'0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant'0 (self : t_Map'0) =
    [%#sinvariant4] inv'1 self
  
  predicate inv'0 (_1 : t_Map'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Map'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V'0
  
  predicate resolve'4 (self : t_Option'1) =
    [%#sresolve5] match self with
      | C_Some'1 x -> resolve'5 x
      | C_None'1 -> true
      end
  
  predicate resolve'2 (_1 : t_Option'1) =
    resolve'4 _1
  
  function model_acc'0 [#"red_black_tree.rs" 53 4 53 78] (self : t_Tree'0) (accu : Map.map t_DeepModelTy'0 t_Option'1) : Map.map t_DeepModelTy'0 t_Option'1
  
   =
    [%#sred_black_tree8] match self with
      | {t_Tree__node'0 = C_None'0} -> accu
      | {t_Tree__node'0 = C_Some'0 {t_Node__left'0 = left ; t_Node__key'0 = key ; t_Node__val'0 = val' ; t_Node__right'0 = right}} -> let accu1 = model_acc'0 left accu in let accu2 = Map.set accu1 (deep_model'0 key) (C_Some'1 val') in model_acc'0 right accu2
      end
  
  function view'1 [#"red_black_tree.rs" 169 4 169 33] (self : t_Tree'0) : Map.map t_DeepModelTy'0 t_Option'1 =
    [%#sred_black_tree6] model_acc'0 self (Const.const (C_None'1))
  
  function view'0 [#"red_black_tree.rs" 760 4 760 33] (self : t_Map'0) : Map.map t_DeepModelTy'0 t_Option'1 =
    [%#sred_black_tree2] view'1 self.t_Map__0'0
  
  predicate resolve'0 [#"red_black_tree.rs" 784 4 784 28] (self : t_Map'0) =
    [%#sred_black_tree1] forall k : t_DeepModelTy'0 . resolve'2 (Map.get (view'0 self) k)
  
  goal refines : [%#sred_black_tree0] forall self : t_Map'0 . structural_resolve'0 self /\ inv'0 self
   -> structural_resolve'0 self /\ (forall result : () . resolve'0 self  -> resolve'0 self)
end
