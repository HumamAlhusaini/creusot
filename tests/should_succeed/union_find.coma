module M_union_find__implementation__qyi17232405883558456141__eq [#"union_find.rs" 17 8 17 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find0 = "union_find.rs" 16 18 16 69
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 131 22 131 66
  let%span smodel2 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sunion_find3 = "union_find.rs" 23 8 23 16
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  let rec addr_eq'0 (p:Opaque.ptr) (q:Opaque.ptr) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sptr1] result = (addr_logic'0 p = addr_logic'0 q)} (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find3] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel2] deep_model'1 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'0[#"union_find.rs" 17 8 17 42] (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = addr_eq'0 {self.t_Element__0'0} {other.t_Element__0'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = bb1 ]
    
    | bb1 = return' {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self : t_Element'0 = self | & other : t_Element'0 = other ] 
    [ return' (result:bool)-> {[@expl:eq ensures] [%#sunion_find0] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi15934775324707434347__addr [#"union_find.rs" 33 8 33 38] (* implementation::Element<T> *)
  let%span sunion_find0 = "union_find.rs" 34 12 34 40
  let%span sunion_find1 = "union_find.rs" 32 18 32 46
  let%span sunion_find2 = "union_find.rs" 23 8 23 16
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find2] addr_logic'0 self.t_Element__0'0
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec addr'0[#"union_find.rs" 33 8 33 38] (self:t_Element'0) (return'  (ret:int))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sunion_find0] deep_model'0 self ] s1 | s1 = bb1 ]  | bb1 = return' {_0} ]
    ) [ & _0 : int = Any.any_l () | & self : t_Element'0 = self ] 
    [ return' (result:int)-> {[@expl:addr ensures] [%#sunion_find1] result = deep_model'0 self} (! return' {result}) ]

end
module M_union_find__implementation__qyi10464084137166016688__clone [#"union_find.rs" 46 8 46 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find0 = "union_find.rs" 44 18 44 33
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"union_find.rs" 46 8 46 31] (self:t_Element'0) (return'  (ret:t_Element'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_Element__0'0 = self.t_Element__0'0 } ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_Element'0 = Any.any_l () | & self : t_Element'0 = self ] 
    [ return' (result:t_Element'0)-> {[@expl:clone ensures] [%#sunion_find0] self = result} (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__new [#"union_find.rs" 116 8 116 28] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 118 24 118 46
  let%span sunion_find1 = "union_find.rs" 119 21 119 32
  let%span sunion_find2 = "union_find.rs" 120 24 120 54
  let%span sunion_find3 = "union_find.rs" 121 26 121 56
  let%span sunion_find4 = "union_find.rs" 122 25 122 55
  let%span sunion_find5 = "union_find.rs" 123 27 123 39
  let%span sunion_find6 = "union_find.rs" 116 24 116 28
  let%span sunion_find7 = "union_find.rs" 115 8 115 44
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 240 4 240 34
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 238 14 238 31
  let%span sutil10 = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil11 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sghost13 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap19 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sunion_find20 = "union_find.rs" 82 8 82 20
  let%span sfmap21 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap22 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap23 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfset24 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find25 = "union_find.rs" 23 8 23 16
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find27 = "union_find.rs" 127 8 127 16
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sboxed29 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sutil32 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil33 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own35 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr36 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr37 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use set.Fset
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap22] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap21] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr37] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr36] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  use creusot.int.UInt64
  
  type t_T'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed29] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own35] not is_null_logic'0 (ptr'0 self) /\ inv'7 (val'0 self)
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed29] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil32] op <> C_None'0)
   -> ([%#sutil33] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap31] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap34] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed29] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap17] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap15] ext_eq'0 self other  -> self = other)
  && ([%#sfmap16] (forall k : int . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  use mach.int.Int
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap23] len'0 self >= 0
  
  use map.Const
  
  function empty'0 (_1 : ()) : t_FMap'0
  
  axiom empty'0_spec : forall _1 : () . ([%#sfmap18] len'0 (empty'0 _1) = 0)
  && ([%#sfmap19] view'0 (empty'0 _1) = Const.const (C_None'0))
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap12] ext_eq'0 self (empty'0 ())
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost13] self.t_GhostBox__0'0
  
  let rec new'1 (_1:()) (return'  (ret:t_GhostBox'0))= any
    [ return' (result:t_GhostBox'0)-> {[%#sfmap8] inv'1 result}
      {[%#sfmap9] is_empty'0 (inner_logic'0 result)}
      (! return' {result}) ]
  
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function index_logic'0 (self : Map.map (Map.map t_Element'0 t_T'0) bool) (a : Map.map t_Element'0 t_T'0) : bool =
    [%#smapping14] Map.get self a
  
  function such_that'0 (p : Map.map (Map.map t_Element'0 t_T'0) bool) : Map.map t_Element'0 t_T'0
  
  axiom such_that'0_spec : forall p : Map.map (Map.map t_Element'0 t_T'0) bool . ([%#sutil10] exists x : Map.map t_Element'0 t_T'0 . index_logic'0 p x)
   -> ([%#sutil11] index_logic'0 p (such_that'0 p))
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function index_logic'1 (self : Map.map (Map.map t_Element'0 int) bool) (a : Map.map t_Element'0 int) : bool =
    [%#smapping14] Map.get self a
  
  function such_that'1 (p : Map.map (Map.map t_Element'0 int) bool) : Map.map t_Element'0 int
  
  axiom such_that'1_spec : forall p : Map.map (Map.map t_Element'0 int) bool . ([%#sutil10] exists x : Map.map t_Element'0 int . index_logic'1 p x)
   -> ([%#sutil11] index_logic'1 p (such_that'1 p))
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  function index_logic'2 (self : Map.map (Map.map t_Element'0 t_Element'0) bool) (a : Map.map t_Element'0 t_Element'0) : bool
  
   =
    [%#smapping14] Map.get self a
  
  function such_that'2 (p : Map.map (Map.map t_Element'0 t_Element'0) bool) : Map.map t_Element'0 t_Element'0
  
  axiom such_that'2_spec : forall p : Map.map (Map.map t_Element'0 t_Element'0) bool . ([%#sutil10] exists x : Map.map t_Element'0 t_Element'0 . index_logic'2 p x)
   -> ([%#sutil11] index_logic'2 p (such_that'2 p))
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use creusot.prelude.Any
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset24] Fset.mem e self
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find25] addr_logic'0 self.t_Element__0'0
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap30] lookup_unsized'0 self k
  
  function index_logic'6 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap28] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find27] index_logic'6 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'3 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  use map.Map
  
  function index_logic'4 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  use map.Map
  
  function index_logic'5 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find20] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'3 self.t_UnionFind__values'0 e
    = index_logic'3 self.t_UnionFind__values'0 (index_logic'4 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'4 self.t_UnionFind__root_of'0 (index_logic'4 self.t_UnionFind__root_of'0 e)
    = index_logic'4 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'4 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'4 self.t_UnionFind__root_of'0 e = index_logic'4 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'3 self.t_UnionFind__values'0 e = v
      /\ index_logic'4 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'5 self.t_UnionFind__distance'0 e < index_logic'5 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'5 self.t_UnionFind__distance'0 e
    /\ index_logic'5 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'4 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  use set.Fset
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"union_find.rs" 116 8 116 28] (_1:()) (return'  (ret:t_UnionFind'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_2 <- [%#sunion_find0] Fset.empty : Fset.fset t_Element'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = new'1 {[%#sunion_find1] ()} (fun (_ret':t_GhostBox'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_5 <- [%#sunion_find2] such_that'0 (fun (_2 : Map.map t_Element'0 t_T'0) -> true) ] s1 | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_7 <- [%#sunion_find3] such_that'1 (fun (_2 : Map.map t_Element'0 int) -> true) ] s1 | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_9 <- [%#sunion_find4] such_that'2 (fun (_2 : Map.map t_Element'0 t_Element'0) -> true) ] s1
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_11 <- [%#sunion_find5] 0 ] s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = 
        [ &_0 <- { t_UnionFind__domain'0 = _2;
                   t_UnionFind__map'0 = _4;
                   t_UnionFind__values'0 = _5;
                   t_UnionFind__distance'0 = _7;
                   t_UnionFind__root_of'0 = _9;
                   t_UnionFind__max_depth'0 = _11 } ]
        
        s1
      | s1 = bb7 ]
    
    | bb7 = return' {_0} ]
    )
    [ & _0 : t_UnionFind'0 = Any.any_l ()
    | & _2 : Fset.fset t_Element'0 = Any.any_l ()
    | & _4 : t_GhostBox'0 = Any.any_l ()
    | & _5 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _7 : Map.map t_Element'0 int = Any.any_l ()
    | & _9 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _11 : int = Any.any_l () ]
    
    [ return' (result:t_UnionFind'0)-> {[@expl:new result type invariant] [%#sunion_find6] inv'0 result}
      {[@expl:new ensures] [%#sunion_find7] Fset.is_empty result.t_UnionFind__domain'0}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__domain [#"union_find.rs" 137 8 137 47] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 135 19 135 28
  let%span sunion_find1 = "union_find.rs" 136 18 136 150
  let%span sunion_find2 = "union_find.rs" 133 8 133 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find4 = "union_find.rs" 23 8 23 16
  let%span sunion_find5 = "union_find.rs" 82 8 82 20
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find8 = "union_find.rs" 127 8 127 16
  let%span smapping9 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil16 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil17 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr21 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find4] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap10] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap6] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost7] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil16] op <> C_None'0)
   -> ([%#sutil17] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap14] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap11] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find8] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping9] Map.get self a
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping9] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping9] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find5] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values'0 e
    = index_logic'0 self.t_UnionFind__values'0 (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of'0 (index_logic'1 self.t_UnionFind__root_of'0 e)
    = index_logic'1 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = index_logic'1 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'0 self.t_UnionFind__values'0 e = v
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'1 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr21] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr20] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed15] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own19] not is_null_logic'0 (ptr'0 self) /\ inv'7 (val'0 self)
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed15] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap18] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed15] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  constant self  : t_UnionFind'0
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  goal vc_domain'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__domain'0 in [%#sunion_find1] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 result e1
  /\ contains'0 result e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
end
module M_union_find__implementation__qyi1944850640244667852__root_of [#"union_find.rs" 149 8 149 63] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 147 19 147 28
  let%span sunion_find1 = "union_find.rs" 148 18 148 98
  let%span sunion_find2 = "union_find.rs" 145 8 145 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smapping4 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find5 = "union_find.rs" 82 8 82 20
  let%span sunion_find6 = "union_find.rs" 23 8 23 16
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost8 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find9 = "union_find.rs" 127 8 127 16
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil16 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil17 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr21 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find6] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap10] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap7] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost8] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil16] op <> C_None'0)
   -> ([%#sutil17] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap14] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap11] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find9] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping4] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping4] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping4] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find5] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr21] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr20] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed15] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own19] not is_null_logic'0 (ptr'0 self) /\ inv'7 (val'0 self)
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed15] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap18] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed15] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  constant self  : t_UnionFind'0
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0
  
  goal vc_root_of'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__root_of'0 in [%#sunion_find1] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 result e = index_logic'0 result (index_logic'0 result e))
end
module M_union_find__implementation__qyi1944850640244667852__values [#"union_find.rs" 158 8 158 53] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 156 19 156 28
  let%span sunion_find1 = "union_find.rs" 157 18 157 106
  let%span sunion_find2 = "union_find.rs" 154 8 154 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smapping4 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find5 = "union_find.rs" 147 19 147 28
  let%span sunion_find6 = "union_find.rs" 148 18 148 98
  let%span sunion_find7 = "union_find.rs" 145 8 145 16
  let%span sunion_find8 = "union_find.rs" 82 8 82 20
  let%span sunion_find9 = "union_find.rs" 23 8 23 16
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost11 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find12 = "union_find.rs" 127 8 127 16
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed18 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil19 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil20 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap21 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own22 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr23 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr24 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find9] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap15] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap13] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap10] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost11] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil19] op <> C_None'0)
   -> ([%#sutil20] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap17] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap16] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap14] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find12] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping4] Map.get self a
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping4] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping4] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find8] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values'0 e
    = index_logic'0 self.t_UnionFind__values'0 (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of'0 (index_logic'1 self.t_UnionFind__root_of'0 e)
    = index_logic'1 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = index_logic'1 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'0 self.t_UnionFind__values'0 e = v
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'1 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr24] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr23] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed18] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own22] not is_null_logic'0 (ptr'0 self) /\ inv'7 (val'0 self)
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed18] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap21] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed18] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find7] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find5] inv'0 self)
   -> ([%#sunion_find6] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (root_of'0 self) e = index_logic'1 (root_of'0 self) (index_logic'1 (root_of'0 self) e))
  
  constant self  : t_UnionFind'0
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0
  
  goal vc_values'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__values'0 in [%#sunion_find1] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 result e = index_logic'0 result (index_logic'1 (root_of'0 self) e))
end
module M_union_find__implementation__qyi1944850640244667852__make [#"union_find.rs" 177 8 177 54] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 178 29 178 45
  let%span sunion_find1 = "union_find.rs" 179 64 179 65
  let%span sunion_find2 = "union_find.rs" 190 26 190 64
  let%span sunion_find3 = "union_find.rs" 191 26 191 74
  let%span sunion_find4 = "union_find.rs" 192 28 192 68
  let%span sunion_find5 = "union_find.rs" 193 27 193 72
  let%span sunion_find6 = "union_find.rs" 177 25 177 29
  let%span sunion_find7 = "union_find.rs" 177 31 177 36
  let%span sunion_find8 = "union_find.rs" 173 18 173 52
  let%span sunion_find9 = "union_find.rs" 174 18 174 69
  let%span sunion_find10 = "union_find.rs" 175 18 175 76
  let%span sunion_find11 = "union_find.rs" 176 18 176 73
  let%span sptr_own12 = "../../creusot-contracts/src/ptr_own.rs" 52 15 52 16
  let%span sptr_own13 = "../../creusot-contracts/src/ptr_own.rs" 52 4 52 56
  let%span sptr_own14 = "../../creusot-contracts/src/ptr_own.rs" 51 14 51 64
  let%span sghost15 = "../../creusot-contracts/src/ghost.rs" 141 27 141 31
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 141 4 141 52
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 140 14 140 39
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 210 22 210 26
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 210 4 210 32
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 208 14 208 31
  let%span sghost21 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost22 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sghost23 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sunion_find24 = "union_find.rs" 32 18 32 46
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 349 36 349 39
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 337 4 346 11
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own31 = "../../creusot-contracts/src/ptr_own.rs" 108 26 108 30
  let%span sptr_own32 = "../../creusot-contracts/src/ptr_own.rs" 108 48 108 52
  let%span sptr_own33 = "../../creusot-contracts/src/ptr_own.rs" 105 14 105 64
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 106 14 106 28
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 414 29 414 33
  let%span sfmap36 = "../../creusot-contracts/src/logic/fmap.rs" 414 35 414 38
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 414 43 414 48
  let%span sfmap38 = "../../creusot-contracts/src/logic/fmap.rs" 414 4 416 17
  let%span sfmap39 = "../../creusot-contracts/src/logic/fmap.rs" 412 14 412 49
  let%span sfmap40 = "../../creusot-contracts/src/logic/fmap.rs" 413 14 413 40
  let%span sghost41 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost42 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost43 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sfset44 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset45 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find46 = "union_find.rs" 135 19 135 28
  let%span sunion_find47 = "union_find.rs" 136 18 136 150
  let%span sunion_find48 = "union_find.rs" 133 8 133 16
  let%span sunion_find49 = "union_find.rs" 147 19 147 28
  let%span sunion_find50 = "union_find.rs" 148 18 148 98
  let%span sunion_find51 = "union_find.rs" 145 8 145 16
  let%span sunion_find52 = "union_find.rs" 156 19 156 28
  let%span sunion_find53 = "union_find.rs" 157 18 157 106
  let%span sunion_find54 = "union_find.rs" 154 8 154 16
  let%span sghost55 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find56 = "union_find.rs" 23 8 23 16
  let%span sfmap57 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap58 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap59 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap60 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sresolve61 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap62 = "../../creusot-contracts/src/logic/fmap.rs" 67 14 67 71
  let%span sfmap63 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 61
  let%span sfmap64 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 66
  let%span sfmap65 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sresolve66 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sghost67 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span smapping68 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap69 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil70 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil71 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap72 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own73 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sinvariant74 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sutil75 = "../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span sresolve76 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sptr77 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr78 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sinvariant79 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sunion_find80 = "union_find.rs" 82 8 82 20
  let%span sboxed81 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find82 = "union_find.rs" 127 8 127 16
  let%span sfmap83 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap84 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.int.UInt64
  
  type t_T'0
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  predicate inv'8 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'8 value
    | C_Link'0 a_0 -> true
    end
  
  type t_PtrOwn'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_PtrOwn'0 }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr78] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr77] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'13 (self : t_Content'0) =
    [%#sboxed81] inv'9 self
  
  predicate inv'25 (_1 : t_Content'0)
  
  axiom inv_axiom'24 [@rewrite] : forall x : t_Content'0 [inv'25 x] . inv'25 x = invariant'13 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  predicate invariant'1 (self : t_PtrOwn'0) =
    [%#sptr_own73] not is_null_logic'0 (ptr'0 self) /\ inv'25 (val'0 self)
  
  predicate inv'3 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PtrOwn'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'12 (self : t_PtrOwn'0) =
    [%#sboxed81] inv'3 self
  
  predicate inv'24 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'23 [@rewrite] : forall x : t_PtrOwn'0 [inv'24 x] . inv'24 x = invariant'12 x
  
  predicate inv'12 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_GhostBox'0 [inv'12 x] . inv'12 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'24 a_0
    end
  
  predicate inv'10 (_1 : (Opaque.ptr, t_GhostBox'0))
  
  axiom inv_axiom'9 [@rewrite] : forall x : (Opaque.ptr, t_GhostBox'0) [inv'10 x] . inv'10 x
  = (let (x0, x1) = x in inv'12 x1)
  
  function inner_logic'0 (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost55] self.t_GhostBox__0'0
  
  let rec new'0 (v:t_Content'0) (return'  (ret:(Opaque.ptr, t_GhostBox'0)))= {[@expl:new 'v' type invariant] [%#sptr_own12] inv'9 v}
    any
    [ return' (result:(Opaque.ptr, t_GhostBox'0))-> {[%#sptr_own13] inv'10 result}
      {[%#sptr_own14] ptr'0 (inner_logic'0 (let (_, a) = result in a)) = (let (a, _) = result in a)
      /\ val'0 (inner_logic'0 (let (_, a) = result in a)) = v}
      (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  type t_FMap'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'1: t_FMap'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap72] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap59] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap57] get_unsized'0 self k <> C_None'2
  
  predicate inv'18 (_1 : int)
  
  axiom inv_axiom'17 [@rewrite] : forall x : int [inv'18 x] . inv'18 x = true
  
  function unwrap'0 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'2 . ([%#sutil70] op <> C_None'2)
   -> ([%#sutil71] C_Some'2 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap58] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'0 (self : t_FMap'0) =
    [%#sfmap69] forall k : int . contains'1 self k  -> inv'18 k /\ inv'24 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'0 x
  
  predicate invariant'10 (self : t_FMap'0) =
    [%#sboxed81] inv'2 self
  
  predicate inv'22 (_1 : t_FMap'0)
  
  axiom inv_axiom'21 [@rewrite] : forall x : t_FMap'0 [inv'22 x] . inv'22 x = invariant'10 x
  
  predicate inv'0 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'1 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'22 a_0
    end
  
  use set.Fset
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'5 (self : MutBorrow.t t_GhostBox'1) =
    [%#sinvariant74] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'11 (_1 : MutBorrow.t t_GhostBox'1)
  
  axiom inv_axiom'10 [@rewrite] : forall x : MutBorrow.t t_GhostBox'1 [inv'11 x] . inv'11 x = invariant'5 x
  
  type t_GhostBox'2  =
    { t_GhostBox__0'2: MutBorrow.t t_FMap'0 }
  
  predicate invariant'7 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant74] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'14 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'14 x] . inv'14 x = invariant'7 x
  
  predicate invariant'11 (self : MutBorrow.t t_FMap'0) =
    [%#sboxed81] inv'14 self
  
  predicate inv'23 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'22 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'23 x] . inv'23 x = invariant'11 x
  
  predicate inv'1 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'2 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'2 = a_0} -> inv'23 a_0
    end
  
  let rec borrow_mut'0 (self:MutBorrow.t t_GhostBox'1) (return'  (ret:t_GhostBox'2))= {[@expl:borrow_mut 'self' type invariant] [%#sghost15] inv'11 self}
    any
    [ return' (result:t_GhostBox'2)-> {[%#sghost16] inv'1 result}
      {[%#sghost17] result.t_GhostBox__0'2
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'1 (self.final).t_GhostBox__0'1 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  let rec into_inner'0 (self:t_GhostBox'0) (return'  (ret:t_PtrOwn'0))= {[@expl:into_inner 'self' type invariant] [%#sghost18] inv'12 self}
    any
    [ return' (result:t_PtrOwn'0)-> {[%#sghost19] inv'3 result}
      {[%#sghost20] result = self.t_GhostBox__0'0}
      (! return' {result}) ]
  
  
  predicate invariant'6 (self : MutBorrow.t t_GhostBox'2) =
    [%#sinvariant74] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'13 (_1 : MutBorrow.t t_GhostBox'2)
  
  axiom inv_axiom'12 [@rewrite] : forall x : MutBorrow.t t_GhostBox'2 [inv'13 x] . inv'13 x = invariant'6 x
  
  predicate invariant'3 (self : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    [%#sinvariant74] inv'14 self.current /\ inv'14 self.final
  
  predicate inv'5 (_1 : MutBorrow.t (MutBorrow.t t_FMap'0))
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t (MutBorrow.t t_FMap'0) [inv'5 x] . inv'5 x = invariant'3 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_GhostBox'2) (return'  (ret:MutBorrow.t (MutBorrow.t t_FMap'0)))= {[@expl:deref_mut 'self' type invariant] [%#sghost21] inv'13 self}
    any
    [ return' (result:MutBorrow.t (MutBorrow.t t_FMap'0))-> {[%#sghost22] inv'5 result}
      {[%#sghost23] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'2 (self.final).t_GhostBox__0'2 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find56] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find24] result = deep_model'0 self} (! return' {result}) ]
  
  
  predicate inv'15 (_1 : int)
  
  axiom inv_axiom'14 [@rewrite] : forall x : int [inv'15 x] . inv'15 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'2 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant74] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'2 x
  
  predicate inv'16 (_1 : t_Option'0)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_Option'0 [inv'16 x] . inv'16 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'4 a_0
    end
  
  use mach.int.Int
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap60] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap25] inv'14 self}
    {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap26] inv'15 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap27] inv'16 result}
      {[%#sfmap28] if contains'1 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap29] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap30] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:MutBorrow.t t_PtrOwn'0))= any
    [ good (field_0:MutBorrow.t t_PtrOwn'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_PtrOwn'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate invariant'8 (self : t_PtrOwn'0) =
    [%#sinvariant79] inv'3 self
  
  predicate inv'17 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_PtrOwn'0 [inv'17 x] . inv'17 x = invariant'8 x
  
  let rec disjoint_lemma'0 (own1:MutBorrow.t t_PtrOwn'0) (own2:t_PtrOwn'0) (return'  (ret:()))= {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own31] inv'4 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own32] inv'17 own2}
    any
    [ return' (result:())-> {[%#sptr_own33] addr_logic'0 (ptr'0 own1.current) <> addr_logic'0 (ptr'0 own2)}
      {[%#sptr_own34] own1.current = own1.final}
      (! return' {result}) ]
  
  
  predicate resolve'5 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve61] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'5 _1
  
  predicate resolve'6 (self : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    [%#sresolve61] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    resolve'6 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn'0
  
  predicate inv'6 (_1 : t_Option'1)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Option'1 [inv'6 x] . inv'6 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'3 a_0
    end
  
  use map.Map
  
  function make_sized'0 (self : t_PtrOwn'0) : t_PtrOwn'0
  
  axiom make_sized'0_spec : forall self : t_PtrOwn'0 . [%#sutil75] make_sized'0 self = self
  
  function insert'1 (self : t_FMap'0) (k : int) (v : t_PtrOwn'0) : t_FMap'0
  
  axiom insert'1_spec : forall self : t_FMap'0, k : int, v : t_PtrOwn'0 . ([%#sfmap62] view'0 (insert'1 self k v)
  = Map.set (view'0 self) k (C_Some'2 (make_sized'0 v)))
  && ([%#sfmap63] contains'1 self k  -> len'0 (insert'1 self k v) = len'0 self)
  && ([%#sfmap64] not contains'1 self k  -> len'0 (insert'1 self k v) = len'0 self + 1)
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'1 =
    [%#sfmap65] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  let rec insert_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (value:t_PtrOwn'0) (return'  (ret:t_Option'1))= {[@expl:insert_ghost 'self' type invariant] [%#sfmap35] inv'14 self}
    {[@expl:insert_ghost 'key' type invariant] [%#sfmap36] inv'18 key}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap37] inv'3 value}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap38] inv'6 result}
      {[%#sfmap39] self.final = insert'1 self.current key value}
      {[%#sfmap40] result = get'0 self.current key}
      (! return' {result}) ]
  
  
  predicate resolve'10 (_1 : t_PtrOwn'0) =
    true
  
  predicate resolve'7 (self : t_Option'1) =
    [%#sresolve66] match self with
      | C_Some'1 x -> resolve'10 x
      | C_None'1 -> true
      end
  
  predicate resolve'2 (_1 : t_Option'1) =
    resolve'7 _1
  
  predicate resolve'13 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve61] self.final = self.current
  
  predicate resolve'12 (_1 : MutBorrow.t t_FMap'0) =
    resolve'13 _1
  
  predicate resolve'11 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve76] resolve'12 self
  
  predicate resolve'8 (self : t_GhostBox'2) =
    [%#sghost67] resolve'11 self.t_GhostBox__0'2
  
  predicate resolve'3 (_1 : t_GhostBox'2) =
    resolve'8 _1
  
  predicate inv'19 (_1 : ())
  
  axiom inv_axiom'18 [@rewrite] : forall x : () [inv'19 x] . inv'19 x = true
  
  type t_GhostBox'3  =
    { t_GhostBox__0'3: () }
  
  predicate inv'20 (_1 : t_GhostBox'3)
  
  axiom inv_axiom'19 [@rewrite] : forall x : t_GhostBox'3 [inv'20 x] . inv'20 x = true
  
  let rec new'1 (x:()) (return'  (ret:t_GhostBox'3))= {[@expl:new 'x' type invariant] [%#sghost41] inv'19 x}
    any
    [ return' (result:t_GhostBox'3)-> {[%#sghost42] inv'20 result}
      {[%#sghost43] result.t_GhostBox__0'3 = x}
      (! return' {result}) ]
  
  
  use set.Fset
  
  function insert'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) : Fset.fset t_Element'0 =
    [%#sfset44] Fset.add e self
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset45] Fset.mem e self
  
  function inner_logic'1 (self : t_GhostBox'1) : t_FMap'0 =
    [%#sghost55] self.t_GhostBox__0'1
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap84] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap83] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find82] index_logic'3 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping68] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping68] Map.get self a
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping68] Map.get self a
  
  predicate invariant'9 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find80] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'21 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_UnionFind'0 [inv'21 x] . inv'21 x
  = (invariant'9 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'0 map
    end)
  
  predicate invariant'4 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant74] inv'21 self.current /\ inv'21 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate resolve'9 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve61] self.final = self.current
  
  predicate resolve'4 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'9 _1
  
  use creusot.prelude.Any
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find48] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find46] inv'21 self)
   -> ([%#sunion_find47] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find51] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find49] inv'21 self)
   -> ([%#sunion_find50] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find54] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find52] inv'21 self)
   -> ([%#sunion_find53] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec make'0[#"union_find.rs" 177 8 177 54] (self:MutBorrow.t t_UnionFind'0) (value:t_T'0) (return'  (ret:t_Element'0))= {[@expl:make 'self' type invariant] [%#sunion_find6] inv'7 self}
    {[@expl:make 'value' type invariant] [%#sunion_find7] inv'8 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &value_snap <- [%#sunion_find0] value ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_12 <- C_Root'0 ([%#sunion_find1] (0 : UInt64.t)) value ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new'0 {_12} (fun (_ret':(Opaque.ptr, t_GhostBox'0)) ->  [ &_11 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &ptr <- let (r'0, _) = _11 in r'0 ] s1 | s1 =  [ &perm <- let (_, r'1) = _11 in r'1 ] s2 | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 =  [ &element <- { t_Element__0'0 = ptr } ] s1
      | s1 = {inv'0 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_17 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s2)
      | s2 = borrow_mut'0 {_17} (fun (_ret':t_GhostBox'2) ->  [ &map <- _ret' ] s3)
      | s3 = bb6 ]
    
    | bb6 = s0 [ s0 = into_inner'0 {perm} (fun (_ret':t_PtrOwn'0) ->  [ &perm1 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {inv'1 map}
        MutBorrow.borrow_mut <t_GhostBox'2> {map}
          (fun (_ret':MutBorrow.t t_GhostBox'2) ->  [ &_26 <- _ret' ] -{inv'1 _ret'.final}-  [ &map <- _ret'.final ] s1)
      | s1 = deref_mut'0 {_26} (fun (_ret':MutBorrow.t (MutBorrow.t t_FMap'0)) ->  [ &_25 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 = {inv'2 (_25.current).current}
        MutBorrow.borrow_mut <t_FMap'0> {(_25.current).current}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_24 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_25 <- { _25 with current = { _25.current with current = _ret'.final } } ] 
            s1)
      | s1 = addr'0 {element} (fun (_ret':int) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &_28 <- _29 ] s1
      | s1 = get_mut_ghost'0 {_24} {_28} (fun (_ret':t_Option'0) ->  [ &_23 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_23 = C_None'0 } (! bb12) | br1 (x0:MutBorrow.t t_PtrOwn'0)-> {_23 = C_Some'0 x0} (! bb13) ] 
    | bb13 = s0
      [ s0 = v_Some'0 {_23} (fun (r0'0:MutBorrow.t t_PtrOwn'0) ->  [ &other_perm <- r0'0 ] s1)
      | s1 = {inv'3 other_perm.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {other_perm.current} {MutBorrow.get_id other_perm}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_33 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &other_perm <- { other_perm with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_35 <- perm1 ] s3
      | s3 = disjoint_lemma'0 {_33} {_35} (fun (_ret':()) ->  [ &_22 <- _ret' ] s4)
      | s4 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'4 other_perm} s1
      | s1 = -{resolve'0 other_perm}- s2
      | s2 = {[@expl:type invariant] inv'5 _25} s3
      | s3 = -{resolve'1 _25}- s4
      | s4 = bb16 ]
    
    | bb12 = bb14
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'5 _25} s1 | s1 = -{resolve'1 _25}- s2 | s2 = bb16 ] 
    | bb16 = s0
      [ s0 = {inv'1 map}
        MutBorrow.borrow_mut <t_GhostBox'2> {map}
          (fun (_ret':MutBorrow.t t_GhostBox'2) ->  [ &_39 <- _ret' ] -{inv'1 _ret'.final}-  [ &map <- _ret'.final ] s1)
      | s1 = deref_mut'0 {_39} (fun (_ret':MutBorrow.t (MutBorrow.t t_FMap'0)) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb17 ]
    
    | bb17 = s0
      [ s0 = {inv'2 (_38.current).current}
        MutBorrow.borrow_mut <t_FMap'0> {(_38.current).current}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_37 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_38 <- { _38 with current = { _38.current with current = _ret'.final } } ] 
            s1)
      | s1 = addr'0 {element} (fun (_ret':int) ->  [ &_40 <- _ret' ] s2)
      | s2 = bb18 ]
    
    | bb18 = s0
      [ s0 = insert_ghost'0 {_37} {_40} {perm1} (fun (_ret':t_Option'1) ->  [ &_36 <- _ret' ] s1)
      | s1 = {[@expl:type invariant] inv'6 _36} s2
      | s2 = -{resolve'2 _36}- s3
      | s3 = bb19 ]
    
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'5 _38} s1
      | s1 = -{resolve'1 _38}- s2
      | s2 = {[@expl:type invariant] inv'1 map} s3
      | s3 = -{resolve'3 map}- s4
      | s4 = new'1 {_19} (fun (_ret':t_GhostBox'3) ->  [ &_18 <- _ret' ] s5)
      | s5 = bb20 ]
    
    | bb20 = bb21
    | bb21 = s0
      [ s0 =  [ &_43 <- [%#sunion_find2] insert'0 (self.current).t_UnionFind__domain'0 element ] s1 | s1 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__domain'0 = _43 } } ] s1
      | s1 =  [ &_45 <- [%#sunion_find3] Map.set (self.current).t_UnionFind__values'0 element value_snap ] s2
      | s2 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _45 } } ] s1
      | s1 =  [ &_47 <- [%#sunion_find4] Map.set (self.current).t_UnionFind__distance'0 element 0 ] s2
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _47 } } ] s1
      | s1 =  [ &_49 <- [%#sunion_find5] Map.set (self.current).t_UnionFind__root_of'0 element element ] s2
      | s2 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _49 } } ] s1
      | s1 = {[@expl:type invariant] inv'7 self} s2
      | s2 = -{resolve'4 self}- s3
      | s3 =  [ &_0 <- element ] s4
      | s4 = bb26 ]
    
    | bb26 = bb27
    | bb27 = bb28
    | bb28 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & value : t_T'0 = value
    | & value_snap : t_T'0 = Any.any_l ()
    | & ptr : Opaque.ptr = Any.any_l ()
    | & perm : t_GhostBox'0 = Any.any_l ()
    | & _11 : (Opaque.ptr, t_GhostBox'0) = Any.any_l ()
    | & _12 : t_Content'0 = Any.any_l ()
    | & element : t_Element'0 = Any.any_l ()
    | & map : t_GhostBox'2 = Any.any_l ()
    | & _17 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _18 : t_GhostBox'3 = Any.any_l ()
    | & _19 : () = Any.any_l ()
    | & perm1 : t_PtrOwn'0 = Any.any_l ()
    | & _22 : () = Any.any_l ()
    | & _23 : t_Option'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _25 : MutBorrow.t (MutBorrow.t t_FMap'0) = Any.any_l ()
    | & _26 : MutBorrow.t t_GhostBox'2 = Any.any_l ()
    | & _28 : int = Any.any_l ()
    | & _29 : int = Any.any_l ()
    | & other_perm : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _33 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _35 : t_PtrOwn'0 = Any.any_l ()
    | & _36 : t_Option'1 = Any.any_l ()
    | & _37 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _38 : MutBorrow.t (MutBorrow.t t_FMap'0) = Any.any_l ()
    | & _39 : MutBorrow.t t_GhostBox'2 = Any.any_l ()
    | & _40 : int = Any.any_l ()
    | & _43 : Fset.fset t_Element'0 = Any.any_l ()
    | & _45 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _47 : Map.map t_Element'0 int = Any.any_l ()
    | & _49 : Map.map t_Element'0 t_Element'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:make ensures #0] [%#sunion_find8] not contains'0 (domain'0 self.current) result}
      {[@expl:make ensures #1] [%#sunion_find9] domain'0 self.final = insert'0 (domain'0 self.current) result}
      {[@expl:make ensures #2] [%#sunion_find10] root_of'0 self.final = Map.set (root_of'0 self.current) result result}
      {[@expl:make ensures #3] [%#sunion_find11] values'0 self.final = Map.set (values'0 self.current) result value}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find_inner [#"union_find.rs" 204 8 204 64] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 204 27 204 31
  let%span sunion_find1 = "union_find.rs" 198 19 198 47
  let%span sunion_find2 = "union_find.rs" 199 18 199 48
  let%span sunion_find3 = "union_find.rs" 200 18 200 34
  let%span sunion_find4 = "union_find.rs" 202 18 202 54
  let%span sunion_find5 = "union_find.rs" 203 18 203 62
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 127 19 127 23
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 127 4 127 40
  let%span sghost8 = "../../creusot-contracts/src/ghost.rs" 126 14 126 35
  let%span sghost9 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost10 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost11 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sunion_find12 = "union_find.rs" 32 18 32 46
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 307 4 314 11
  let%span soption17 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sptr_own21 = "../../creusot-contracts/src/ptr_own.rs" 71 34 71 37
  let%span sptr_own22 = "../../creusot-contracts/src/ptr_own.rs" 68 15 68 31
  let%span sptr_own23 = "../../creusot-contracts/src/ptr_own.rs" 71 4 71 66
  let%span sptr_own24 = "../../creusot-contracts/src/ptr_own.rs" 69 14 69 35
  let%span sghost25 = "../../creusot-contracts/src/ghost.rs" 141 27 141 31
  let%span sghost26 = "../../creusot-contracts/src/ghost.rs" 141 4 141 52
  let%span sghost27 = "../../creusot-contracts/src/ghost.rs" 140 14 140 39
  let%span sghost28 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost29 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sghost30 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 349 36 349 39
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 337 4 346 11
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap36 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own37 = "../../creusot-contracts/src/ptr_own.rs" 83 34 83 37
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 78 15 78 31
  let%span sptr_own39 = "../../creusot-contracts/src/ptr_own.rs" 83 4 83 74
  let%span sptr_own40 = "../../creusot-contracts/src/ptr_own.rs" 79 14 79 35
  let%span sptr_own41 = "../../creusot-contracts/src/ptr_own.rs" 81 14 81 53
  let%span sptr_own42 = "../../creusot-contracts/src/ptr_own.rs" 82 14 82 52
  let%span sfset43 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find44 = "union_find.rs" 135 19 135 28
  let%span sunion_find45 = "union_find.rs" 136 18 136 150
  let%span sunion_find46 = "union_find.rs" 133 8 133 16
  let%span smapping47 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find48 = "union_find.rs" 147 19 147 28
  let%span sunion_find49 = "union_find.rs" 148 18 148 98
  let%span sunion_find50 = "union_find.rs" 145 8 145 16
  let%span sunion_find51 = "union_find.rs" 167 16 169 52
  let%span sghost52 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span sunion_find53 = "union_find.rs" 23 8 23 16
  let%span sfmap54 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap55 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost56 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sfmap57 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap58 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sresolve59 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find60 = "union_find.rs" 156 19 156 28
  let%span sunion_find61 = "union_find.rs" 157 18 157 106
  let%span sunion_find62 = "union_find.rs" 154 8 154 16
  let%span sresolve63 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sutil64 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil65 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sunion_find66 = "union_find.rs" 82 8 82 20
  let%span sfmap67 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap68 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own69 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sinvariant70 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant71 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sunion_find72 = "union_find.rs" 127 8 127 16
  let%span sptr73 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr74 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sboxed75 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap76 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap77 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'2  =
    { t_GhostBox__0'1: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'2;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  type t_PtrOwn'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap68] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap57] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap54] get_unsized'0 self k <> C_None'2
  
  predicate inv'30 (_1 : int)
  
  axiom inv_axiom'29 [@rewrite] : forall x : int [inv'30 x] . inv'30 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr74] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr73] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  predicate inv'28 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'28 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'21 (self : t_Content'0) =
    [%#sboxed75] inv'8 self
  
  predicate inv'32 (_1 : t_Content'0)
  
  axiom inv_axiom'31 [@rewrite] : forall x : t_Content'0 [inv'32 x] . inv'32 x = invariant'21 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  predicate invariant'2 (self : t_PtrOwn'0) =
    [%#sptr_own69] not is_null_logic'0 (ptr'0 self) /\ inv'32 (val'0 self)
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'20 (self : t_PtrOwn'0) =
    [%#sboxed75] inv'5 self
  
  predicate inv'31 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'30 [@rewrite] : forall x : t_PtrOwn'0 [inv'31 x] . inv'31 x = invariant'20 x
  
  function unwrap'2 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'2_spec : forall op : t_Option'2 . ([%#sutil64] op <> C_None'2)
   -> ([%#sutil65] C_Some'2 (unwrap'2 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap55] unwrap'2 (get_unsized'0 self k)
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sfmap67] forall k : int . contains'1 self k  -> inv'30 k /\ inv'31 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate invariant'17 (self : t_FMap'0) =
    [%#sboxed75] inv'4 self
  
  predicate inv'26 (_1 : t_FMap'0)
  
  axiom inv_axiom'26 [@rewrite] : forall x : t_FMap'0 [inv'26 x] . inv'26 x = invariant'17 x
  
  predicate inv'2 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'2 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'26 a_0
    end
  
  predicate invariant'7 (self : t_GhostBox'2) =
    [%#sinvariant71] inv'2 self
  
  predicate inv'11 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_GhostBox'2 [inv'11 x] . inv'11 x = invariant'7 x
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  predicate invariant'10 (self : t_FMap'0) =
    [%#sinvariant71] inv'4 self
  
  predicate inv'14 (_1 : t_FMap'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_FMap'0 [inv'14 x] . inv'14 x = invariant'10 x
  
  predicate invariant'16 (self : t_FMap'0) =
    [%#sboxed75] inv'14 self
  
  predicate inv'25 (_1 : t_FMap'0)
  
  axiom inv_axiom'25 [@rewrite] : forall x : t_FMap'0 [inv'25 x] . inv'25 x = invariant'16 x
  
  predicate inv'0 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'25 a_0
    end
  
  let rec borrow'0 (self:t_GhostBox'2) (return'  (ret:t_GhostBox'0))= {[@expl:borrow 'self' type invariant] [%#sghost6] inv'11 self}
    any
    [ return' (result:t_GhostBox'0)-> {[%#sghost7] inv'0 result}
      {[%#sghost8] result.t_GhostBox__0'0 = self.t_GhostBox__0'1}
      (! return' {result}) ]
  
  
  predicate invariant'8 (self : t_GhostBox'0) =
    [%#sinvariant71] inv'0 self
  
  predicate inv'12 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_GhostBox'0 [inv'12 x] . inv'12 x = invariant'8 x
  
  predicate invariant'9 (self : t_FMap'0) =
    [%#sinvariant71] inv'14 self
  
  predicate inv'13 (_1 : t_FMap'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_FMap'0 [inv'13 x] . inv'13 x = invariant'9 x
  
  let rec deref'0 (self:t_GhostBox'0) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost9] inv'12 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost10] inv'13 result}
      {[%#sghost11] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
  
  
  predicate resolve'14 (_1 : t_FMap'0) =
    true
  
  predicate resolve'12 (self : t_FMap'0) =
    [%#sresolve63] resolve'14 self
  
  predicate resolve'6 (self : t_GhostBox'0) =
    [%#sghost52] resolve'12 self.t_GhostBox__0'0
  
  predicate resolve'0 (_1 : t_GhostBox'0) =
    resolve'6 _1
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find53] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find12] result = deep_model'0 self} (! return' {result}) ]
  
  
  predicate inv'15 (_1 : int)
  
  axiom inv_axiom'15 [@rewrite] : forall x : int [inv'15 x] . inv'15 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate invariant'11 (self : t_PtrOwn'0) =
    [%#sinvariant71] inv'5 self
  
  predicate inv'17 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_PtrOwn'0 [inv'17 x] . inv'17 x = invariant'11 x
  
  predicate inv'16 (_1 : t_Option'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_Option'0 [inv'16 x] . inv'16 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'17 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap13] inv'14 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap14] inv'15 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap15] inv'16 result}
      {[%#sfmap16] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'16 self}
    {[@expl:unwrap requires] [%#soption17] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'17 result} {[%#soption17] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_GhostBox'1  =
    { t_GhostBox__0'2: t_PtrOwn'0 }
  
  predicate invariant'19 (self : t_PtrOwn'0) =
    [%#sboxed75] inv'17 self
  
  predicate inv'29 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'28 [@rewrite] : forall x : t_PtrOwn'0 [inv'29 x] . inv'29 x = invariant'19 x
  
  predicate inv'18 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_GhostBox'1 [inv'18 x] . inv'18 x
  = match x with
    | {t_GhostBox__0'2 = a_0} -> inv'29 a_0
    end
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_GhostBox'1))= {[@expl:new 'x' type invariant] [%#sghost18] inv'17 x}
    any
    [ return' (result:t_GhostBox'1)-> {[%#sghost19] inv'18 result}
      {[%#sghost20] result.t_GhostBox__0'2 = x}
      (! return' {result}) ]
  
  
  function inner_logic'0 (self : t_GhostBox'1) : t_PtrOwn'0 =
    [%#sghost56] self.t_GhostBox__0'2
  
  predicate invariant'12 (self : t_Content'0) =
    [%#sinvariant71] inv'8 self
  
  predicate inv'19 (_1 : t_Content'0)
  
  axiom inv_axiom'19 [@rewrite] : forall x : t_Content'0 [inv'19 x] . inv'19 x = invariant'12 x
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_GhostBox'1) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own21] inv'18 own}
    {[@expl:as_ref requires] [%#sptr_own22] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own23] inv'19 result}
      {[%#sptr_own24] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  let rec v_Link'0 (input:t_Content'0) (ret  (field_0:t_Element'0))= any
    [ good (field_0:t_Element'0)-> {C_Link'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Element'0 [C_Link'0 field_0 : t_Content'0] . C_Link'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.MutBorrow
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset43] Fset.mem e self
  
  function inner_logic'2 (self : t_GhostBox'2) : t_FMap'0 =
    [%#sghost56] self.t_GhostBox__0'1
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap77] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap76] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find72] index_logic'3 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping47] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping47] Map.get self a
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping47] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find66] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'2 self.t_UnionFind__values'0 e
    = index_logic'2 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'2 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'1 self.t_UnionFind__distance'0 e < index_logic'1 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'1 self.t_UnionFind__distance'0 e
    /\ index_logic'1 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'1 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_UnionFind'0 [inv'1 x] . inv'1 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'13 (self : MutBorrow.t t_GhostBox'2) =
    [%#sinvariant70] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'20 (_1 : MutBorrow.t t_GhostBox'2)
  
  axiom inv_axiom'20 [@rewrite] : forall x : MutBorrow.t t_GhostBox'2 [inv'20 x] . inv'20 x = invariant'13 x
  
  type t_GhostBox'3  =
    { t_GhostBox__0'3: MutBorrow.t t_FMap'0 }
  
  predicate invariant'15 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant70] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'22 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'22 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'22 x] . inv'22 x = invariant'15 x
  
  predicate invariant'18 (self : MutBorrow.t t_FMap'0) =
    [%#sboxed75] inv'22 self
  
  predicate inv'27 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'27 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'27 x] . inv'27 x = invariant'18 x
  
  predicate inv'3 (_1 : t_GhostBox'3)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_GhostBox'3 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'3 = a_0} -> inv'27 a_0
    end
  
  let rec borrow_mut'0 (self:MutBorrow.t t_GhostBox'2) (return'  (ret:t_GhostBox'3))= {[@expl:borrow_mut 'self' type invariant] [%#sghost25] inv'20 self}
    any
    [ return' (result:t_GhostBox'3)-> {[%#sghost26] inv'3 result}
      {[%#sghost27] result.t_GhostBox__0'3
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'1 (self.final).t_GhostBox__0'1 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  predicate invariant'14 (self : MutBorrow.t t_GhostBox'3) =
    [%#sinvariant70] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'21 (_1 : MutBorrow.t t_GhostBox'3)
  
  axiom inv_axiom'21 [@rewrite] : forall x : MutBorrow.t t_GhostBox'3 [inv'21 x] . inv'21 x = invariant'14 x
  
  predicate invariant'3 (self : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    [%#sinvariant70] inv'22 self.current /\ inv'22 self.final
  
  predicate inv'6 (_1 : MutBorrow.t (MutBorrow.t t_FMap'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t (MutBorrow.t t_FMap'0) [inv'6 x] . inv'6 x = invariant'3 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_GhostBox'3) (return'  (ret:MutBorrow.t (MutBorrow.t t_FMap'0)))= {[@expl:deref_mut 'self' type invariant] [%#sghost28] inv'21 self}
    any
    [ return' (result:MutBorrow.t (MutBorrow.t t_FMap'0))-> {[%#sghost29] inv'6 result}
      {[%#sghost30] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'3 (self.final).t_GhostBox__0'3 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'4 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant70] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'23 (_1 : t_Option'1)
  
  axiom inv_axiom'23 [@rewrite] : forall x : t_Option'1 [inv'23 x] . inv'23 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'7 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap58] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap31] inv'22 self}
    {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap32] inv'15 key}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap33] inv'23 result}
      {[%#sfmap34] if contains'1 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap35] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap36] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'1) (return'  (ret:MutBorrow.t t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'23 self}
    {[@expl:unwrap requires] [%#soption17] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_PtrOwn'0)-> {inv'7 result}
      {[%#soption17] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  type t_GhostBox'4  =
    { t_GhostBox__0'4: MutBorrow.t t_PtrOwn'0 }
  
  predicate invariant'22 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sboxed75] inv'7 self
  
  predicate inv'33 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'32 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'33 x] . inv'33 x = invariant'22 x
  
  predicate inv'24 (_1 : t_GhostBox'4)
  
  axiom inv_axiom'24 [@rewrite] : forall x : t_GhostBox'4 [inv'24 x] . inv'24 x
  = match x with
    | {t_GhostBox__0'4 = a_0} -> inv'33 a_0
    end
  
  let rec new'1 (x:MutBorrow.t t_PtrOwn'0) (return'  (ret:t_GhostBox'4))= {[@expl:new 'x' type invariant] [%#sghost18] inv'7 x}
    any
    [ return' (result:t_GhostBox'4)-> {[%#sghost19] inv'24 result}
      {[%#sghost20] result.t_GhostBox__0'4 = x}
      (! return' {result}) ]
  
  
  predicate resolve'7 (self : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    [%#sresolve59] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    resolve'7 _1
  
  predicate resolve'8 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve59] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'8 _1
  
  function inner_logic'1 (self : t_GhostBox'4) : MutBorrow.t t_PtrOwn'0 =
    [%#sghost56] self.t_GhostBox__0'4
  
  predicate invariant'5 (self : MutBorrow.t t_Content'0) =
    [%#sinvariant70] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_1 : MutBorrow.t t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : MutBorrow.t t_Content'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  let rec as_mut'0 (ptr:Opaque.ptr) (own:t_GhostBox'4) (return'  (ret:MutBorrow.t t_Content'0))= {[@expl:as_mut 'own' type invariant] [%#sptr_own37] inv'24 own}
    {[@expl:as_mut requires] [%#sptr_own38] ptr = ptr'0 (inner_logic'1 own).current}
    any
    [ return' (result:MutBorrow.t t_Content'0)-> {[%#sptr_own39] inv'9 result}
      {[%#sptr_own40] result.current = val'0 (inner_logic'1 own).current}
      {[%#sptr_own41] ptr'0 (inner_logic'1 own).final = ptr'0 (inner_logic'1 own).current}
      {[%#sptr_own42] val'0 (inner_logic'1 own).final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'9 (self : MutBorrow.t t_Content'0) =
    [%#sresolve59] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_Content'0) =
    resolve'9 _1
  
  predicate resolve'16 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve59] self.final = self.current
  
  predicate resolve'15 (_1 : MutBorrow.t t_FMap'0) =
    resolve'16 _1
  
  predicate resolve'13 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve63] resolve'15 self
  
  predicate resolve'10 (self : t_GhostBox'3) =
    [%#sghost52] resolve'13 self.t_GhostBox__0'3
  
  predicate resolve'4 (_1 : t_GhostBox'3) =
    resolve'10 _1
  
  predicate invariant'6 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant70] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'10 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  predicate resolve'11 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve59] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'11 _1
  
  use creusot.prelude.Any
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find46] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find44] inv'1 self)
   -> ([%#sunion_find45] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find50] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find48] inv'1 self)
   -> ([%#sunion_find49] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find62] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find60] inv'1 self)
   -> ([%#sunion_find61] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'2 (values'0 self) e = index_logic'2 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find51] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  meta "compute_max_steps" 1000000
  
  let rec find_inner'0[#"union_find.rs" 204 8 204 64] (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find_inner 'self' type invariant] [%#sunion_find0] inv'10 self}
    {[@expl:find_inner requires] [%#sunion_find1] contains'0 (domain'0 self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = borrow'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_GhostBox'0) ->  [ &map <- _ret' ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = deref'0 {map} (fun (_ret':t_FMap'0) ->  [ &_14 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 map} s1
      | s1 = -{resolve'0 map}- s2
      | s2 = addr'0 {elem} (fun (_ret':int) ->  [ &_18 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_17 <- _18 ] s1
      | s1 = get_ghost'0 {_14} {_17} (fun (_ret':t_Option'0) ->  [ &_12 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = unwrap'0 {_12} (fun (_ret':t_PtrOwn'0) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = new'0 {_11} (fun (_ret':t_GhostBox'1) ->  [ &perm <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = as_ref'0 {elem.t_Element__0'0} {perm} (fun (_ret':t_Content'0) ->  [ &value <- _ret' ] s1) | s1 = bb7 ]
    
    | bb7 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {value = C_Root'0 x0 x1} (! bb9)
      | br1 (x0:t_Element'0)-> {value = C_Link'0 x0} (! bb10) ]
    
    | bb10 = s0
      [ s0 = v_Link'0 {value} (fun (r0'0:t_Element'0) ->  [ &e <- r0'0 ] s1)
      | s1 = {inv'1 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_26 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = find_inner'0 {_26} {e} (fun (_ret':t_Element'0) ->  [ &root <- _ret' ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'2>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'2) ->
             [ &_29 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = borrow_mut'0 {_29} (fun (_ret':t_GhostBox'3) ->  [ &map1 <- _ret' ] s2)
      | s2 = bb13 ]
    
    | bb13 = s0
      [ s0 = {inv'3 map1}
        MutBorrow.borrow_mut <t_GhostBox'3> {map1}
          (fun (_ret':MutBorrow.t t_GhostBox'3) ->
             [ &_36 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &map1 <- _ret'.final ] 
            s1)
      | s1 = deref_mut'0 {_36} (fun (_ret':MutBorrow.t (MutBorrow.t t_FMap'0)) ->  [ &_35 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'4 (_35.current).current}
        MutBorrow.borrow_mut <t_FMap'0> {(_35.current).current}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_34 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_35 <- { _35 with current = { _35.current with current = _ret'.final } } ] 
            s1)
      | s1 = addr'0 {elem} (fun (_ret':int) ->  [ &_39 <- _ret' ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0
      [ s0 =  [ &_38 <- _39 ] s1
      | s1 = get_mut_ghost'0 {_34} {_38} (fun (_ret':t_Option'1) ->  [ &_33 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = unwrap'1 {_33} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_32 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 = {inv'5 _32.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_32.current} {MutBorrow.get_id _32}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_31 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_32 <- { _32 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_31} (fun (_ret':t_GhostBox'4) ->  [ &mut_perm <- _ret' ] s2)
      | s2 = bb18 ]
    
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'6 _35} s1
      | s1 = -{resolve'1 _35}- s2
      | s2 = {[@expl:type invariant] inv'7 _32} s3
      | s3 = -{resolve'2 _32}- s4
      | s4 =  [ &_41 <- C_Link'0 root ] s5
      | s5 = as_mut'0 {elem.t_Element__0'0} {mut_perm} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_43 <- _ret' ] s6)
      | s6 = bb19 ]
    
    | bb19 = bb20
    | bb20 = s0
      [ s0 = {[@expl:type invariant] match _43 with
          | {current = x'0} -> inv'8 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_43 <- { _43 with current = _41 } ] s2
      | s2 = {[@expl:type invariant] inv'9 _43} s3
      | s3 = -{resolve'3 _43}- s4
      | s4 = {[@expl:type invariant] inv'3 map1} s5
      | s5 = -{resolve'4 map1}- s6
      | s6 = {[@expl:type invariant] inv'10 self} s7
      | s7 = -{resolve'5 self}- s8
      | s8 = bb22 ]
    
    | bb22 = s0 [ s0 =  [ &_0 <- root ] s1 | s1 = bb23 ] 
    | bb23 = bb24
    | bb24 = bb25
    | bb9 = bb11
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'10 self} s1
      | s1 = -{resolve'5 self}- s2
      | s2 =  [ &_0 <- elem ] s3
      | s3 = bb25 ]
    
    | bb25 = bb26
    | bb26 = bb27
    | bb27 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & map : t_GhostBox'0 = Any.any_l ()
    | & perm : t_GhostBox'1 = Any.any_l ()
    | & _11 : t_PtrOwn'0 = Any.any_l ()
    | & _12 : t_Option'0 = Any.any_l ()
    | & _14 : t_FMap'0 = Any.any_l ()
    | & _17 : int = Any.any_l ()
    | & _18 : int = Any.any_l ()
    | & value : t_Content'0 = Any.any_l ()
    | & e : t_Element'0 = Any.any_l ()
    | & root : t_Element'0 = Any.any_l ()
    | & _26 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & map1 : t_GhostBox'3 = Any.any_l ()
    | & _29 : MutBorrow.t t_GhostBox'2 = Any.any_l ()
    | & mut_perm : t_GhostBox'4 = Any.any_l ()
    | & _31 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _32 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _33 : t_Option'1 = Any.any_l ()
    | & _34 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _35 : MutBorrow.t (MutBorrow.t t_FMap'0) = Any.any_l ()
    | & _36 : MutBorrow.t t_GhostBox'3 = Any.any_l ()
    | & _38 : int = Any.any_l ()
    | & _39 : int = Any.any_l ()
    | & _41 : t_Content'0 = Any.any_l ()
    | & _43 : MutBorrow.t t_Content'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:find_inner ensures #0] [%#sunion_find2] result
      = index_logic'0 (root_of'0 self.current) elem}
      {[@expl:find_inner ensures #1] [%#sunion_find3] unchanged'0 self}
      {[@expl:find_inner ensures #2] [%#sunion_find4] (self.final).t_UnionFind__distance'0
      = (self.current).t_UnionFind__distance'0}
      {[@expl:find_inner ensures #3] [%#sunion_find5] index_logic'1 (self.current).t_UnionFind__distance'0 result
      >= index_logic'1 (self.current).t_UnionFind__distance'0 elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find [#"union_find.rs" 225 8 225 62] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 225 25 225 29
  let%span sunion_find1 = "union_find.rs" 222 19 222 47
  let%span sunion_find2 = "union_find.rs" 223 18 223 48
  let%span sunion_find3 = "union_find.rs" 224 18 224 34
  let%span sunion_find4 = "union_find.rs" 204 27 204 31
  let%span sunion_find5 = "union_find.rs" 198 19 198 47
  let%span sunion_find6 = "union_find.rs" 199 18 199 48
  let%span sunion_find7 = "union_find.rs" 200 18 200 34
  let%span sunion_find8 = "union_find.rs" 202 18 202 54
  let%span sunion_find9 = "union_find.rs" 203 18 203 62
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find11 = "union_find.rs" 135 19 135 28
  let%span sunion_find12 = "union_find.rs" 136 18 136 150
  let%span sunion_find13 = "union_find.rs" 133 8 133 16
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find15 = "union_find.rs" 147 19 147 28
  let%span sunion_find16 = "union_find.rs" 148 18 148 98
  let%span sunion_find17 = "union_find.rs" 145 8 145 16
  let%span sunion_find18 = "union_find.rs" 167 16 169 52
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find20 = "union_find.rs" 23 8 23 16
  let%span sunion_find21 = "union_find.rs" 156 19 156 28
  let%span sunion_find22 = "union_find.rs" 157 18 157 106
  let%span sunion_find23 = "union_find.rs" 154 8 154 16
  let%span sunion_find24 = "union_find.rs" 82 8 82 20
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost27 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find28 = "union_find.rs" 127 8 127 16
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed34 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil35 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr39 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr40 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset10] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find20] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap31] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap29] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost27] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil35] op <> C_None'0)
   -> ([%#sutil36] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap33] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap30] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find28] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find24] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'2 self.t_UnionFind__values'0 e
    = index_logic'2 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'2 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'1 self.t_UnionFind__distance'0 e < index_logic'1 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'1 self.t_UnionFind__distance'0 e
    /\ index_logic'1 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr40] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr39] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed34] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own38] not is_null_logic'0 (ptr'0 self) /\ inv'8 (val'0 self)
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap37] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed34] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find13] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find11] inv'0 self)
   -> ([%#sunion_find12] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find17] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find15] inv'0 self)
   -> ([%#sunion_find16] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'2 (values'0 self) e = index_logic'2 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find18] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find_inner'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find_inner 'self' type invariant] [%#sunion_find4] inv'1 self}
    {[@expl:find_inner requires] [%#sunion_find5] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find6] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find7] unchanged'0 self}
      {[%#sunion_find8] (self.final).t_UnionFind__distance'0 = (self.current).t_UnionFind__distance'0}
      {[%#sunion_find9] index_logic'1 (self.current).t_UnionFind__distance'0 result
      >= index_logic'1 (self.current).t_UnionFind__distance'0 elem}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec find'0[#"union_find.rs" 225 8 225 62] (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:find requires] [%#sunion_find1] contains'0 (domain'0 self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find_inner'0 {_6} {elem} (fun (_ret':t_Element'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & _6 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:find ensures #0] [%#sunion_find2] result
      = index_logic'0 (root_of'0 self.current) elem}
      {[@expl:find ensures #1] [%#sunion_find3] unchanged'0 self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__get [#"union_find.rs" 235 8 235 49] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 235 20 235 24
  let%span sunion_find1 = "union_find.rs" 232 19 232 47
  let%span sunion_find2 = "union_find.rs" 233 19 233 47
  let%span sunion_find3 = "union_find.rs" 235 47 235 49
  let%span sunion_find4 = "union_find.rs" 234 18 234 48
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 127 19 127 23
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 127 4 127 40
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 126 14 126 35
  let%span sghost8 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost9 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost10 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sunion_find11 = "union_find.rs" 32 18 32 46
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 307 4 314 11
  let%span soption16 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sptr_own20 = "../../creusot-contracts/src/ptr_own.rs" 71 34 71 37
  let%span sptr_own21 = "../../creusot-contracts/src/ptr_own.rs" 68 15 68 31
  let%span sptr_own22 = "../../creusot-contracts/src/ptr_own.rs" 71 4 71 66
  let%span sptr_own23 = "../../creusot-contracts/src/ptr_own.rs" 69 14 69 35
  let%span sfset24 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find25 = "union_find.rs" 135 19 135 28
  let%span sunion_find26 = "union_find.rs" 136 18 136 150
  let%span sunion_find27 = "union_find.rs" 133 8 133 16
  let%span smapping28 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find29 = "union_find.rs" 147 19 147 28
  let%span sunion_find30 = "union_find.rs" 148 18 148 98
  let%span sunion_find31 = "union_find.rs" 145 8 145 16
  let%span sunion_find32 = "union_find.rs" 156 19 156 28
  let%span sunion_find33 = "union_find.rs" 157 18 157 106
  let%span sunion_find34 = "union_find.rs" 154 8 154 16
  let%span sghost35 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span sunion_find36 = "union_find.rs" 23 8 23 16
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap38 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sresolve40 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil42 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil43 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sinvariant44 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sunion_find46 = "union_find.rs" 82 8 82 20
  let%span sboxed47 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find48 = "union_find.rs" 127 8 127 16
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap50 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own51 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sfmap52 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sptr53 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr54 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'2  =
    { t_GhostBox__0'1: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'2;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  type t_PtrOwn'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'1
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap45] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'1 =
    [%#sfmap41] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap37] get_unsized'0 self k <> C_None'1
  
  predicate inv'21 (_1 : int)
  
  axiom inv_axiom'20 [@rewrite] : forall x : int [inv'21 x] . inv'21 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr54] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr53] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  predicate inv'16 (_1 : t_T'0)
  
  predicate inv'19 (_1 : t_Content'0)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_Content'0 [inv'19 x] . inv'19 x
  = match x with
    | C_Root'0 rank value -> inv'16 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'15 (self : t_Content'0) =
    [%#sboxed47] inv'19 self
  
  predicate inv'23 (_1 : t_Content'0)
  
  axiom inv_axiom'22 [@rewrite] : forall x : t_Content'0 [inv'23 x] . inv'23 x = invariant'15 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  predicate invariant'12 (self : t_PtrOwn'0) =
    [%#sptr_own51] not is_null_logic'0 (ptr'0 self) /\ inv'23 (val'0 self)
  
  predicate inv'18 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_PtrOwn'0 [inv'18 x] . inv'18 x = invariant'12 x
  
  predicate invariant'14 (self : t_PtrOwn'0) =
    [%#sboxed47] inv'18 self
  
  predicate inv'22 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'21 [@rewrite] : forall x : t_PtrOwn'0 [inv'22 x] . inv'22 x = invariant'14 x
  
  function unwrap'1 (op : t_Option'1) : t_PtrOwn'0
  
  axiom unwrap'1_spec : forall op : t_Option'1 . ([%#sutil42] op <> C_None'1)
   -> ([%#sutil43] C_Some'1 (unwrap'1 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap38] unwrap'1 (get_unsized'0 self k)
  
  predicate invariant'11 (self : t_FMap'0) =
    [%#sfmap50] forall k : int . contains'1 self k  -> inv'21 k /\ inv'22 (lookup_unsized'0 self k)
  
  predicate inv'17 (_1 : t_FMap'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_FMap'0 [inv'17 x] . inv'17 x = invariant'11 x
  
  predicate invariant'13 (self : t_FMap'0) =
    [%#sboxed47] inv'17 self
  
  predicate inv'20 (_1 : t_FMap'0)
  
  axiom inv_axiom'19 [@rewrite] : forall x : t_FMap'0 [inv'20 x] . inv'20 x = invariant'13 x
  
  predicate inv'15 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_GhostBox'2 [inv'15 x] . inv'15 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'20 a_0
    end
  
  predicate invariant'2 (self : t_GhostBox'2) =
    [%#sinvariant44] inv'15 self
  
  predicate inv'3 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_GhostBox'2 [inv'3 x] . inv'3 x = invariant'2 x
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  predicate invariant'5 (self : t_FMap'0) =
    [%#sinvariant44] inv'17 self
  
  predicate inv'6 (_1 : t_FMap'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_FMap'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate invariant'9 (self : t_FMap'0) =
    [%#sboxed47] inv'6 self
  
  predicate inv'13 (_1 : t_FMap'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_FMap'0 [inv'13 x] . inv'13 x = invariant'9 x
  
  predicate inv'0 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'0 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'13 a_0
    end
  
  let rec borrow'0 (self:t_GhostBox'2) (return'  (ret:t_GhostBox'0))= {[@expl:borrow 'self' type invariant] [%#sghost5] inv'3 self}
    any
    [ return' (result:t_GhostBox'0)-> {[%#sghost6] inv'0 result}
      {[%#sghost7] result.t_GhostBox__0'0 = self.t_GhostBox__0'1}
      (! return' {result}) ]
  
  
  predicate invariant'3 (self : t_GhostBox'0) =
    [%#sinvariant44] inv'0 self
  
  predicate inv'4 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_GhostBox'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'4 (self : t_FMap'0) =
    [%#sinvariant44] inv'6 self
  
  predicate inv'5 (_1 : t_FMap'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_FMap'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  let rec deref'0 (self:t_GhostBox'0) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost8] inv'4 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost9] inv'5 result}
      {[%#sghost10] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
  
  
  predicate resolve'3 (_1 : t_FMap'0) =
    true
  
  predicate resolve'2 (self : t_FMap'0) =
    [%#sresolve40] resolve'3 self
  
  predicate resolve'1 (self : t_GhostBox'0) =
    [%#sghost35] resolve'2 self.t_GhostBox__0'0
  
  predicate resolve'0 (_1 : t_GhostBox'0) =
    resolve'1 _1
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find36] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find11] result = deep_model'0 self} (! return' {result}) ]
  
  
  predicate inv'7 (_1 : int)
  
  axiom inv_axiom'7 [@rewrite] : forall x : int [inv'7 x] . inv'7 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate invariant'6 (self : t_PtrOwn'0) =
    [%#sinvariant44] inv'18 self
  
  predicate inv'9 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_PtrOwn'0 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate inv'8 (_1 : t_Option'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Option'0 [inv'8 x] . inv'8 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'9 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap12] inv'6 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap13] inv'7 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap14] inv'8 result}
      {[%#sfmap15] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'8 self}
    {[@expl:unwrap requires] [%#soption16] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'9 result} {[%#soption16] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_GhostBox'1  =
    { t_GhostBox__0'2: t_PtrOwn'0 }
  
  predicate invariant'10 (self : t_PtrOwn'0) =
    [%#sboxed47] inv'9 self
  
  predicate inv'14 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_PtrOwn'0 [inv'14 x] . inv'14 x = invariant'10 x
  
  predicate inv'10 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_GhostBox'1 [inv'10 x] . inv'10 x
  = match x with
    | {t_GhostBox__0'2 = a_0} -> inv'14 a_0
    end
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_GhostBox'1))= {[@expl:new 'x' type invariant] [%#sghost17] inv'9 x}
    any
    [ return' (result:t_GhostBox'1)-> {[%#sghost18] inv'10 result}
      {[%#sghost19] result.t_GhostBox__0'2 = x}
      (! return' {result}) ]
  
  
  function inner_logic'0 (self : t_GhostBox'1) : t_PtrOwn'0 =
    [%#sghost39] self.t_GhostBox__0'2
  
  predicate invariant'7 (self : t_Content'0) =
    [%#sinvariant44] inv'19 self
  
  predicate inv'11 (_1 : t_Content'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Content'0 [inv'11 x] . inv'11 x = invariant'7 x
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_GhostBox'1) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own20] inv'10 own}
    {[@expl:as_ref requires] [%#sptr_own21] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own22] inv'11 result}
      {[%#sptr_own23] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  let rec v_Root'0 (input:t_Content'0) (ret  (rank:UInt64.t) (value:t_T'0))= any
    [ good (rank:UInt64.t) (value:t_T'0)-> {C_Root'0 rank value = input} (! ret {rank} {value})
    | bad -> {forall rank : UInt64.t, value : t_T'0 [C_Root'0 rank value : t_Content'0] . C_Root'0 rank value <> input}
      (! {false}
      any) ]
  
  
  use creusot.prelude.Any
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset24] Fset.mem e self
  
  function inner_logic'1 (self : t_GhostBox'2) : t_FMap'0 =
    [%#sghost39] self.t_GhostBox__0'1
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap52] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap49] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find48] index_logic'3 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping28] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping28] Map.get self a
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping28] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'8 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find46] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'12 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_UnionFind'0 [inv'12 x] . inv'12 x
  = (invariant'8 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'15 map
    end)
  
  predicate invariant'0 (self : t_UnionFind'0) =
    [%#sinvariant44] inv'12 self
  
  predicate inv'1 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find27] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find25] inv'12 self)
   -> ([%#sunion_find26] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find31] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find29] inv'12 self)
   -> ([%#sunion_find30] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate invariant'1 (self : t_T'0) =
    [%#sinvariant44] inv'16 self
  
  predicate inv'2 (_1 : t_T'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_T'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find34] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find32] inv'12 self)
   -> ([%#sunion_find33] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec get'0[#"union_find.rs" 235 8 235 49] (self:t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_T'0))= {[@expl:get 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:get requires #0] [%#sunion_find1] contains'0 (domain'0 self) elem}
    {[@expl:get requires #1] [%#sunion_find2] index_logic'0 (root_of'0 self) elem = elem}
    (! bb0
    [ bb0 = s0
      [ s0 = borrow'0 {self.t_UnionFind__map'0} (fun (_ret':t_GhostBox'0) ->  [ &map <- _ret' ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = deref'0 {map} (fun (_ret':t_FMap'0) ->  [ &_12 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 map} s1
      | s1 = -{resolve'0 map}- s2
      | s2 = addr'0 {elem} (fun (_ret':int) ->  [ &_16 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_15 <- _16 ] s1
      | s1 = get_ghost'0 {_12} {_15} (fun (_ret':t_Option'0) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':t_PtrOwn'0) ->  [ &_9 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = new'0 {_9} (fun (_ret':t_GhostBox'1) ->  [ &perm <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = as_ref'0 {elem.t_Element__0'0} {perm} (fun (_ret':t_Content'0) ->  [ &_18 <- _ret' ] s1) | s1 = bb7 ]
    
    | bb7 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_18 = C_Root'0 x0 x1} (! bb9)
      | br1 (x0:t_Element'0)-> {_18 = C_Link'0 x0} (! bb8) ]
    
    | bb8 = bb11
    | bb11 = bb11 [ bb11 = (! bb12) [ bb12 = bb11 ]  ] 
    | bb9 = bb10
    | bb10 = s0
      [ s0 = v_Root'0 {_18} (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->  [ &value <- rvalue'0 ] s1)
      | s1 =  [ &_0 <- value ] s2
      | s2 = bb13 ]
    
    | bb13 = bb14
    | bb14 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self : t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & map : t_GhostBox'0 = Any.any_l ()
    | & perm : t_GhostBox'1 = Any.any_l ()
    | & _9 : t_PtrOwn'0 = Any.any_l ()
    | & _10 : t_Option'0 = Any.any_l ()
    | & _12 : t_FMap'0 = Any.any_l ()
    | & _15 : int = Any.any_l ()
    | & _16 : int = Any.any_l ()
    | & _18 : t_Content'0 = Any.any_l ()
    | & value : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:get result type invariant] [%#sunion_find3] inv'2 result}
      {[@expl:get ensures] [%#sunion_find4] result = index_logic'1 (values'0 self) elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__equiv [#"union_find.rs" 249 8 249 71] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 249 26 249 30
  let%span sunion_find1 = "union_find.rs" 245 19 245 48
  let%span sunion_find2 = "union_find.rs" 246 19 246 48
  let%span sunion_find3 = "union_find.rs" 247 18 247 70
  let%span sunion_find4 = "union_find.rs" 248 18 248 34
  let%span sunion_find5 = "union_find.rs" 225 25 225 29
  let%span sunion_find6 = "union_find.rs" 222 19 222 47
  let%span sunion_find7 = "union_find.rs" 223 18 223 48
  let%span sunion_find8 = "union_find.rs" 224 18 224 34
  let%span sptr9 = "../../creusot-contracts/src/std/ptr.rs" 131 22 131 66
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find11 = "union_find.rs" 135 19 135 28
  let%span sunion_find12 = "union_find.rs" 136 18 136 150
  let%span sunion_find13 = "union_find.rs" 133 8 133 16
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find15 = "union_find.rs" 147 19 147 28
  let%span sunion_find16 = "union_find.rs" 148 18 148 98
  let%span sunion_find17 = "union_find.rs" 145 8 145 16
  let%span sunion_find18 = "union_find.rs" 167 16 169 52
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find20 = "union_find.rs" 23 8 23 16
  let%span sunion_find21 = "union_find.rs" 156 19 156 28
  let%span sunion_find22 = "union_find.rs" 157 18 157 106
  let%span sunion_find23 = "union_find.rs" 154 8 154 16
  let%span sunion_find24 = "union_find.rs" 82 8 82 20
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost27 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find28 = "union_find.rs" 127 8 127 16
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed34 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil35 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr39 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr40 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset10] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find20] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap31] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap29] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost27] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil35] op <> C_None'0)
   -> ([%#sutil36] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap33] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap30] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find28] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find24] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr40] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr39] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed34] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own38] not is_null_logic'0 (ptr'0 self) /\ inv'8 (val'0 self)
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap37] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed34] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find13] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find11] inv'0 self)
   -> ([%#sunion_find12] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find17] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find15] inv'0 self)
   -> ([%#sunion_find16] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find18] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find5] inv'1 self}
    {[@expl:find requires] [%#sunion_find6] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find7] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find8] unchanged'0 self}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  let rec addr_eq'0 (p:Opaque.ptr) (q:Opaque.ptr) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sptr9] result = (addr_logic'0 p = addr_logic'0 q)} (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec equiv'0[#"union_find.rs" 249 8 249 71] (self:MutBorrow.t t_UnionFind'0) (e1:t_Element'0) (e2:t_Element'0) (return'  (ret:bool))= {[@expl:equiv 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:equiv requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) e1}
    {[@expl:equiv requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_9} {e1} (fun (_ret':t_Element'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_12 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_12} {e2} (fun (_ret':t_Element'0) ->  [ &r2 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = addr_eq'0 {r1.t_Element__0'0} {r2.t_Element__0'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & e1 : t_Element'0 = e1
    | & e2 : t_Element'0 = e2
    | & r1 : t_Element'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & r2 : t_Element'0 = Any.any_l ()
    | & _12 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:equiv ensures #0] [%#sunion_find3] result
      = (index_logic'0 (root_of'0 self.current) e1 = index_logic'0 (root_of'0 self.current) e2)}
      {[@expl:equiv ensures #1] [%#sunion_find4] unchanged'0 self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__link [#"union_find.rs" 286 8 286 70] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 303 20 303 93
  let%span sunion_find1 = "union_find.rs" 305 20 305 94
  let%span sunion_find2 = "union_find.rs" 306 33 306 63
  let%span sunion_find3 = "union_find.rs" 308 20 308 95
  let%span sunion_find4 = "union_find.rs" 316 88 316 89
  let%span sunion_find5 = "union_find.rs" 321 20 321 93
  let%span sunion_find6 = "union_find.rs" 323 20 323 94
  let%span sunion_find7 = "union_find.rs" 324 33 324 63
  let%span sunion_find8 = "union_find.rs" 326 20 326 95
  let%span sunion_find9 = "union_find.rs" 286 21 286 25
  let%span sunion_find10 = "union_find.rs" 265 19 265 44
  let%span sunion_find11 = "union_find.rs" 266 19 266 41
  let%span sunion_find12 = "union_find.rs" 267 19 267 44
  let%span sunion_find13 = "union_find.rs" 268 19 268 41
  let%span sunion_find14 = "union_find.rs" 269 18 269 54
  let%span sunion_find15 = "union_find.rs" 270 18 270 82
  let%span sunion_find16 = "union_find.rs" 271 18 271 53
  let%span sunion_find17 = "union_find.rs" 272 18 277 13
  let%span sunion_find18 = "union_find.rs" 279 18 284 13
  let%span sunion_find19 = "union_find.rs" 16 18 16 69
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 141 27 141 31
  let%span sghost21 = "../../creusot-contracts/src/ghost.rs" 141 4 141 52
  let%span sghost22 = "../../creusot-contracts/src/ghost.rs" 140 14 140 39
  let%span sghost23 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost24 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost25 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sunion_find26 = "union_find.rs" 32 18 32 46
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 307 4 314 11
  let%span soption31 = "../../creusot-contracts/src/std/option.rs" 31 0 423 1
  let%span sghost32 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost33 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost34 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sptr_own35 = "../../creusot-contracts/src/ptr_own.rs" 71 34 71 37
  let%span sptr_own36 = "../../creusot-contracts/src/ptr_own.rs" 68 15 68 31
  let%span sptr_own37 = "../../creusot-contracts/src/ptr_own.rs" 71 4 71 66
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 69 14 69 35
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost40 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sghost41 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sfmap42 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 349 36 349 39
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 337 4 346 11
  let%span sfmap46 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap47 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own48 = "../../creusot-contracts/src/ptr_own.rs" 83 34 83 37
  let%span sptr_own49 = "../../creusot-contracts/src/ptr_own.rs" 78 15 78 31
  let%span sptr_own50 = "../../creusot-contracts/src/ptr_own.rs" 83 4 83 74
  let%span sptr_own51 = "../../creusot-contracts/src/ptr_own.rs" 79 14 79 35
  let%span sptr_own52 = "../../creusot-contracts/src/ptr_own.rs" 81 14 81 53
  let%span sptr_own53 = "../../creusot-contracts/src/ptr_own.rs" 82 14 82 52
  let%span smapping54 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find55 = "union_find.rs" 75 15 75 19
  let%span sunion_find56 = "union_find.rs" 76 14 76 32
  let%span sfset57 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find58 = "union_find.rs" 135 19 135 28
  let%span sunion_find59 = "union_find.rs" 136 18 136 150
  let%span sunion_find60 = "union_find.rs" 133 8 133 16
  let%span sunion_find61 = "union_find.rs" 147 19 147 28
  let%span sunion_find62 = "union_find.rs" 148 18 148 98
  let%span sunion_find63 = "union_find.rs" 145 8 145 16
  let%span sunion_find64 = "union_find.rs" 261 12 261 50
  let%span sunion_find65 = "union_find.rs" 156 19 156 28
  let%span sunion_find66 = "union_find.rs" 157 18 157 106
  let%span sunion_find67 = "union_find.rs" 154 8 154 16
  let%span smodel68 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sresolve69 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find70 = "union_find.rs" 23 8 23 16
  let%span sfmap71 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap72 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost73 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sghost74 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span sfmap75 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap76 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sinvariant77 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sutil78 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil79 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sresolve80 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sfmap81 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap82 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own83 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sinvariant84 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sptr85 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr86 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sunion_find87 = "union_find.rs" 82 8 82 20
  let%span sboxed88 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find89 = "union_find.rs" 127 8 127 16
  let%span sfmap90 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap91 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find70] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel68] deep_model'1 self
  
  let rec eq'0 (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sunion_find19] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset57] Fset.mem e self
  
  type t_PtrOwn'0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap82] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap75] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap71] get_unsized'0 self k <> C_None'2
  
  function inner_logic'2 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost73] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'2 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'2_spec : forall op : t_Option'2 . ([%#sutil78] op <> C_None'2)
   -> ([%#sutil79] C_Some'2 (unwrap'2 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap72] unwrap'2 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap91] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap90] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find89] index_logic'3 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'1 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping54] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping54] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping54] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'14 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find87] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'1 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'27 (_1 : int)
  
  axiom inv_axiom'26 [@rewrite] : forall x : int [inv'27 x] . inv'27 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr86] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr85] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'26 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'26 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'19 (self : t_Content'0) =
    [%#sboxed88] inv'8 self
  
  predicate inv'29 (_1 : t_Content'0)
  
  axiom inv_axiom'28 [@rewrite] : forall x : t_Content'0 [inv'29 x] . inv'29 x = invariant'19 x
  
  predicate invariant'2 (self : t_PtrOwn'0) =
    [%#sptr_own83] not is_null_logic'0 (ptr'0 self) /\ inv'29 (val'0 self)
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'2 x
  
  predicate invariant'18 (self : t_PtrOwn'0) =
    [%#sboxed88] inv'5 self
  
  predicate inv'28 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'27 [@rewrite] : forall x : t_PtrOwn'0 [inv'28 x] . inv'28 x = invariant'18 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sfmap81] forall k : int . contains'1 self k  -> inv'27 k /\ inv'28 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'1 x
  
  predicate invariant'15 (self : t_FMap'0) =
    [%#sboxed88] inv'4 self
  
  predicate inv'23 (_1 : t_FMap'0)
  
  axiom inv_axiom'23 [@rewrite] : forall x : t_FMap'0 [inv'23 x] . inv'23 x = invariant'15 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'23 a_0
    end
  
  predicate inv'22 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'22 [@rewrite] : forall x : t_UnionFind'0 [inv'22 x] . inv'22 x
  = (invariant'14 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  predicate invariant'0 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant77] inv'22 self.current /\ inv'22 self.final
  
  predicate inv'0 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'7 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve69] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'7 _1
  
  predicate invariant'6 (self : MutBorrow.t t_GhostBox'0) =
    [%#sinvariant77] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'10 (_1 : MutBorrow.t t_GhostBox'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : MutBorrow.t t_GhostBox'0 [inv'10 x] . inv'10 x = invariant'6 x
  
  type t_GhostBox'1  =
    { t_GhostBox__0'1: MutBorrow.t t_FMap'0 }
  
  predicate invariant'13 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant77] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'19 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'19 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'19 x] . inv'19 x = invariant'13 x
  
  predicate invariant'17 (self : MutBorrow.t t_FMap'0) =
    [%#sboxed88] inv'19 self
  
  predicate inv'25 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'25 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'25 x] . inv'25 x = invariant'17 x
  
  predicate inv'3 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_GhostBox'1 [inv'3 x] . inv'3 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'25 a_0
    end
  
  let rec borrow_mut'0 (self:MutBorrow.t t_GhostBox'0) (return'  (ret:t_GhostBox'1))= {[@expl:borrow_mut 'self' type invariant] [%#sghost20] inv'10 self}
    any
    [ return' (result:t_GhostBox'1)-> {[%#sghost21] inv'3 result}
      {[%#sghost22] result.t_GhostBox__0'1
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  predicate invariant'7 (self : t_GhostBox'1) =
    [%#sinvariant84] inv'3 self
  
  predicate inv'11 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_GhostBox'1 [inv'11 x] . inv'11 x = invariant'7 x
  
  predicate invariant'8 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant84] inv'19 self
  
  predicate inv'12 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'12 x] . inv'12 x = invariant'8 x
  
  let rec deref'0 (self:t_GhostBox'1) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost23] inv'11 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost24] inv'12 result}
      {[%#sghost25] self.t_GhostBox__0'1 = result}
      (! return' {result}) ]
  
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find26] result = deep_model'1 self} (! return' {result}) ]
  
  
  predicate invariant'9 (self : t_FMap'0) =
    [%#sinvariant84] inv'4 self
  
  predicate inv'13 (_1 : t_FMap'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_FMap'0 [inv'13 x] . inv'13 x = invariant'9 x
  
  predicate inv'14 (_1 : int)
  
  axiom inv_axiom'14 [@rewrite] : forall x : int [inv'14 x] . inv'14 x = true
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate invariant'10 (self : t_PtrOwn'0) =
    [%#sinvariant84] inv'5 self
  
  predicate inv'16 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_PtrOwn'0 [inv'16 x] . inv'16 x = invariant'10 x
  
  predicate inv'15 (_1 : t_Option'0)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_Option'0 [inv'15 x] . inv'15 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'16 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap27] inv'13 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap28] inv'14 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap29] inv'15 result}
      {[%#sfmap30] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'15 self}
    {[@expl:unwrap requires] [%#soption31] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'16 result} {[%#soption31] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_GhostBox'2  =
    { t_GhostBox__0'2: t_PtrOwn'0 }
  
  predicate invariant'16 (self : t_PtrOwn'0) =
    [%#sboxed88] inv'16 self
  
  predicate inv'24 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'24 [@rewrite] : forall x : t_PtrOwn'0 [inv'24 x] . inv'24 x = invariant'16 x
  
  predicate inv'2 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'2 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'2 = a_0} -> inv'24 a_0
    end
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_GhostBox'2))= {[@expl:new 'x' type invariant] [%#sghost32] inv'16 x}
    any
    [ return' (result:t_GhostBox'2)-> {[%#sghost33] inv'2 result}
      {[%#sghost34] result.t_GhostBox__0'2 = x}
      (! return' {result}) ]
  
  
  function inner_logic'0 (self : t_GhostBox'2) : t_PtrOwn'0 =
    [%#sghost73] self.t_GhostBox__0'2
  
  predicate invariant'11 (self : t_Content'0) =
    [%#sinvariant84] inv'8 self
  
  predicate inv'17 (_1 : t_Content'0)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_Content'0 [inv'17 x] . inv'17 x = invariant'11 x
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_GhostBox'2) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own35] inv'2 own}
    {[@expl:as_ref requires] [%#sptr_own36] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own37] inv'17 result}
      {[%#sptr_own38] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  predicate resolve'16 (_1 : t_PtrOwn'0) =
    true
  
  predicate resolve'14 (self : t_PtrOwn'0) =
    [%#sresolve80] resolve'16 self
  
  predicate resolve'8 (self : t_GhostBox'2) =
    [%#sghost74] resolve'14 self.t_GhostBox__0'2
  
  predicate resolve'1 (_1 : t_GhostBox'2) =
    resolve'8 _1
  
  predicate resolve'18 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve69] self.final = self.current
  
  predicate resolve'17 (_1 : MutBorrow.t t_FMap'0) =
    resolve'18 _1
  
  predicate resolve'15 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve80] resolve'17 self
  
  predicate resolve'9 (self : t_GhostBox'1) =
    [%#sghost74] resolve'15 self.t_GhostBox__0'1
  
  predicate resolve'2 (_1 : t_GhostBox'1) =
    resolve'9 _1
  
  let rec v_Root'0 (input:t_Content'0) (ret  (rank:UInt64.t) (value:t_T'0))= any
    [ good (rank:UInt64.t) (value:t_T'0)-> {C_Root'0 rank value = input} (! ret {rank} {value})
    | bad -> {forall rank : UInt64.t, value : t_T'0 [C_Root'0 rank value : t_Content'0] . C_Root'0 rank value <> input}
      (! {false}
      any) ]
  
  
  predicate invariant'12 (self : MutBorrow.t t_GhostBox'1) =
    [%#sinvariant77] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'18 (_1 : MutBorrow.t t_GhostBox'1)
  
  axiom inv_axiom'18 [@rewrite] : forall x : MutBorrow.t t_GhostBox'1 [inv'18 x] . inv'18 x = invariant'12 x
  
  predicate invariant'3 (self : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    [%#sinvariant77] inv'19 self.current /\ inv'19 self.final
  
  predicate inv'6 (_1 : MutBorrow.t (MutBorrow.t t_FMap'0))
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t (MutBorrow.t t_FMap'0) [inv'6 x] . inv'6 x = invariant'3 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_GhostBox'1) (return'  (ret:MutBorrow.t (MutBorrow.t t_FMap'0)))= {[@expl:deref_mut 'self' type invariant] [%#sghost39] inv'18 self}
    any
    [ return' (result:MutBorrow.t (MutBorrow.t t_FMap'0))-> {[%#sghost40] inv'6 result}
      {[%#sghost41] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'1 (self.final).t_GhostBox__0'1 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'4 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant77] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate inv'20 (_1 : t_Option'1)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_Option'1 [inv'20 x] . inv'20 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'7 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap76] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap42] inv'19 self}
    {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap43] inv'14 key}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap44] inv'20 result}
      {[%#sfmap45] if contains'1 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap46] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap47] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'1) (return'  (ret:MutBorrow.t t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'20 self}
    {[@expl:unwrap requires] [%#soption31] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_PtrOwn'0)-> {inv'7 result}
      {[%#soption31] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  type t_GhostBox'3  =
    { t_GhostBox__0'3: MutBorrow.t t_PtrOwn'0 }
  
  predicate invariant'20 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sboxed88] inv'7 self
  
  predicate inv'30 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'29 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'30 x] . inv'30 x = invariant'20 x
  
  predicate inv'21 (_1 : t_GhostBox'3)
  
  axiom inv_axiom'21 [@rewrite] : forall x : t_GhostBox'3 [inv'21 x] . inv'21 x
  = match x with
    | {t_GhostBox__0'3 = a_0} -> inv'30 a_0
    end
  
  let rec new'1 (x:MutBorrow.t t_PtrOwn'0) (return'  (ret:t_GhostBox'3))= {[@expl:new 'x' type invariant] [%#sghost32] inv'7 x}
    any
    [ return' (result:t_GhostBox'3)-> {[%#sghost33] inv'21 result}
      {[%#sghost34] result.t_GhostBox__0'3 = x}
      (! return' {result}) ]
  
  
  predicate resolve'10 (self : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    [%#sresolve69] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t (MutBorrow.t t_FMap'0)) =
    resolve'10 _1
  
  predicate resolve'11 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve69] self.final = self.current
  
  predicate resolve'4 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'11 _1
  
  function inner_logic'1 (self : t_GhostBox'3) : MutBorrow.t t_PtrOwn'0 =
    [%#sghost73] self.t_GhostBox__0'3
  
  predicate invariant'5 (self : MutBorrow.t t_Content'0) =
    [%#sinvariant77] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_1 : MutBorrow.t t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : MutBorrow.t t_Content'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  let rec as_mut'0 (ptr:Opaque.ptr) (own:t_GhostBox'3) (return'  (ret:MutBorrow.t t_Content'0))= {[@expl:as_mut 'own' type invariant] [%#sptr_own48] inv'21 own}
    {[@expl:as_mut requires] [%#sptr_own49] ptr = ptr'0 (inner_logic'1 own).current}
    any
    [ return' (result:MutBorrow.t t_Content'0)-> {[%#sptr_own50] inv'9 result}
      {[%#sptr_own51] result.current = val'0 (inner_logic'1 own).current}
      {[%#sptr_own52] ptr'0 (inner_logic'1 own).final = ptr'0 (inner_logic'1 own).current}
      {[%#sptr_own53] val'0 (inner_logic'1 own).final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'12 (self : MutBorrow.t t_Content'0) =
    [%#sresolve69] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_Content'0) =
    resolve'12 _1
  
  use map.Map
  
  use int.MinMax
  
  use creusot.int.UInt64
  
  let rec add_no_overflow'0 (x:UInt64.t) (y:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:add_no_overflow requires] [%#sunion_find55] true}
    any
    [ return' (result:UInt64.t)-> {[%#sunion_find56] UInt64.t'int result = UInt64.t'int x + UInt64.t'int y}
      (! return' {result}) ]
  
  
  predicate resolve'13 (self : MutBorrow.t UInt64.t) =
    [%#sresolve69] self.final = self.current
  
  predicate resolve'6 (_1 : MutBorrow.t UInt64.t) =
    resolve'13 _1
  
  use creusot.prelude.Any
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find60] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find58] inv'22 self)
   -> ([%#sunion_find59] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find63] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find61] inv'22 self)
   -> ([%#sunion_find62] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate equiv_log'0 [#"union_find.rs" 260 8 260 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find64] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find67] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find65] inv'22 self)
   -> ([%#sunion_find66] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec link'0[#"union_find.rs" 286 8 286 70] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:link 'self' type invariant] [%#sunion_find9] inv'0 self}
    {[@expl:link requires #0] [%#sunion_find10] contains'0 (domain'0 self.current) x}
    {[@expl:link requires #1] [%#sunion_find11] index_logic'0 (root_of'0 self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find12] contains'0 (domain'0 self.current) y}
    {[@expl:link requires #3] [%#sunion_find13] index_logic'0 (root_of'0 self.current) y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {x} {y} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_14 = false} (! bb3) | br1 -> {_14} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- x ] s3 | s3 = bb72 ]
    
    | bb3 = s0
      [ s0 = {inv'1 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'0>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'0) ->
             [ &_19 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = borrow_mut'0 {_19} (fun (_ret':t_GhostBox'1) ->  [ &map <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = deref'0 {map} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_24 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = addr'0 {x} (fun (_ret':int) ->  [ &_28 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_27 <- _28 ] s1
      | s1 = get_ghost'0 {_24.current} {_27} (fun (_ret':t_Option'0) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 = unwrap'0 {_22} (fun (_ret':t_PtrOwn'0) ->  [ &_21 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0 [ s0 = new'0 {_21} (fun (_ret':t_GhostBox'2) ->  [ &perm_x <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0 [ s0 = deref'0 {map} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_34 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0 [ s0 = addr'0 {y} (fun (_ret':int) ->  [ &_38 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_37 <- _38 ] s1
      | s1 = get_ghost'0 {_34.current} {_37} (fun (_ret':t_Option'0) ->  [ &_32 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap'0 {_32} (fun (_ret':t_PtrOwn'0) ->  [ &_31 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0 [ s0 = new'0 {_31} (fun (_ret':t_GhostBox'2) ->  [ &perm_y <- _ret' ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 = as_ref'0 {x.t_Element__0'0} {perm_x} (fun (_ret':t_Content'0) ->  [ &_43 <- _ret' ] s1) | s1 = bb15 ]
    
    | bb15 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_43 = C_Root'0 x0 x1} (! bb16)
      | br1 (x0:t_Element'0)-> {_43 = C_Link'0 x0} (! bb18) ]
    
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'2 perm_y} s1
      | s1 = -{resolve'1 perm_y}- s2
      | s2 = {[@expl:type invariant] inv'3 map} s3
      | s3 = -{resolve'2 map}- s4
      | s4 = {[@expl:type invariant] inv'0 self} s5
      | s5 = -{resolve'0 self}- s6
      | s6 = {false} any ]
    
    | bb16 = bb17
    | bb17 = s0
      [ s0 = v_Root'0 {_43} (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->  [ &rx <- rrank'0 ] s1)
      | s1 = v_Root'0 {_43} (fun (rrank'1:UInt64.t) (rvalue'1:t_T'0) ->  [ &vx <- rvalue'1 ] s2)
      | s2 = as_ref'0 {y.t_Element__0'0} {perm_y} (fun (_ret':t_Content'0) ->  [ &_50 <- _ret' ] s3)
      | s3 = bb19 ]
    
    | bb19 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_50 = C_Root'0 x0 x1} (! bb20)
      | br1 (x0:t_Element'0)-> {_50 = C_Link'0 x0} (! bb22) ]
    
    | bb22 = s0
      [ s0 = {[@expl:type invariant] inv'3 map} s1
      | s1 = -{resolve'2 map}- s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = {false} any ]
    
    | bb20 = bb21
    | bb21 = s0
      [ s0 = v_Root'0 {_50} (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->  [ &ry <- rrank'0 ] s1)
      | s1 = v_Root'0 {_50} (fun (rrank'1:UInt64.t) (rvalue'1:t_T'0) ->  [ &vy <- rvalue'1 ] s2)
      | s2 =  [ &_54 <- UInt64.lt rx ry ] s3
      | s3 = any [ br0 -> {_54 = false} (! bb38) | br1 -> {_54} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = {inv'3 map}
        MutBorrow.borrow_mut <t_GhostBox'1> {map}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->  [ &_63 <- _ret' ] -{inv'3 _ret'.final}-  [ &map <- _ret'.final ] s1)
      | s1 = deref_mut'0 {_63} (fun (_ret':MutBorrow.t (MutBorrow.t t_FMap'0)) ->  [ &_62 <- _ret' ] s2)
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 = {inv'4 (_62.current).current}
        MutBorrow.borrow_mut <t_FMap'0> {(_62.current).current}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_61 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_62 <- { _62 with current = { _62.current with current = _ret'.final } } ] 
            s1)
      | s1 = addr'0 {x} (fun (_ret':int) ->  [ &_66 <- _ret' ] s2)
      | s2 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &_65 <- _66 ] s1
      | s1 = get_mut_ghost'0 {_61} {_65} (fun (_ret':t_Option'1) ->  [ &_60 <- _ret' ] s2)
      | s2 = bb26 ]
    
    | bb26 = s0 [ s0 = unwrap'1 {_60} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_59 <- _ret' ] s1) | s1 = bb27 ] 
    | bb27 = s0
      [ s0 = {inv'5 _59.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_59.current} {MutBorrow.get_id _59}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_58 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_59 <- { _59 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_58} (fun (_ret':t_GhostBox'3) ->  [ &perm_mut_x <- _ret' ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'6 _62} s1
      | s1 = -{resolve'3 _62}- s2
      | s2 = {[@expl:type invariant] inv'7 _59} s3
      | s3 = -{resolve'4 _59}- s4
      | s4 =  [ &_68 <- C_Link'0 y ] s5
      | s5 = as_mut'0 {x.t_Element__0'0} {perm_mut_x} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_70 <- _ret' ] s6)
      | s6 = bb29 ]
    
    | bb29 = bb30
    | bb30 = s0
      [ s0 = {[@expl:type invariant] match _70 with
          | {current = x'0} -> inv'8 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_70 <- { _70 with current = _68 } ] s2
      | s2 = {[@expl:type invariant] inv'9 _70} s3
      | s3 = -{resolve'5 _70}- s4
      | s4 = {[@expl:type invariant] inv'3 map} s5
      | s5 = -{resolve'2 map}- s6
      | s6 = bb32 ]
    
    | bb32 = s0
      [ s0 = 
        [ &_73 <- [%#sunion_find0] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = x then
          y
        else
          index_logic'0 (self.current).t_UnionFind__root_of'0 z
         ]
        
        s1
      | s1 = bb33 ]
    
    | bb33 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _73 } } ] s1
      | s1 = 
        [ &_75 <- [%#sunion_find1] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = y then
          vy
        else
          index_logic'1 (self.current).t_UnionFind__values'0 z
         ]
        
        s2
      | s2 = bb34 ]
    
    | bb34 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _75 } } ] s1
      | s1 =  [ &_77 <- [%#sunion_find2] (self.current).t_UnionFind__max_depth'0 + 1 ] s2
      | s2 = bb35 ]
    
    | bb35 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__max_depth'0 = _77 } } ] s1
      | s1 = 
        [ &_79 <- [%#sunion_find3] Map.set (self.current).t_UnionFind__distance'0 y (1
        + MinMax.max (index_logic'2 (self.current).t_UnionFind__distance'0 x) (index_logic'2 (self.current).t_UnionFind__distance'0 y)) ]
        
        s2
      | s2 = bb36 ]
    
    | bb36 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _79 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- y ] s4
      | s4 = bb37 ]
    
    | bb37 = bb68
    | bb38 = s0
      [ s0 = {inv'3 map}
        MutBorrow.borrow_mut <t_GhostBox'1> {map}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->  [ &_87 <- _ret' ] -{inv'3 _ret'.final}-  [ &map <- _ret'.final ] s1)
      | s1 = deref_mut'0 {_87} (fun (_ret':MutBorrow.t (MutBorrow.t t_FMap'0)) ->  [ &_86 <- _ret' ] s2)
      | s2 = bb39 ]
    
    | bb39 = s0
      [ s0 = {inv'4 (_86.current).current}
        MutBorrow.borrow_mut <t_FMap'0> {(_86.current).current}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_85 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_86 <- { _86 with current = { _86.current with current = _ret'.final } } ] 
            s1)
      | s1 = addr'0 {y} (fun (_ret':int) ->  [ &_90 <- _ret' ] s2)
      | s2 = bb40 ]
    
    | bb40 = s0
      [ s0 =  [ &_89 <- _90 ] s1
      | s1 = get_mut_ghost'0 {_85} {_89} (fun (_ret':t_Option'1) ->  [ &_84 <- _ret' ] s2)
      | s2 = bb41 ]
    
    | bb41 = s0 [ s0 = unwrap'1 {_84} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_83 <- _ret' ] s1) | s1 = bb42 ] 
    | bb42 = s0
      [ s0 = {inv'5 _83.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_83.current} {MutBorrow.get_id _83}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_82 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_83 <- { _83 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_82} (fun (_ret':t_GhostBox'3) ->  [ &perm_mut_y <- _ret' ] s2)
      | s2 = bb43 ]
    
    | bb43 = s0
      [ s0 = {[@expl:type invariant] inv'6 _86} s1
      | s1 = -{resolve'3 _86}- s2
      | s2 = {[@expl:type invariant] inv'7 _83} s3
      | s3 = -{resolve'4 _83}- s4
      | s4 =  [ &_92 <- C_Link'0 x ] s5
      | s5 = as_mut'0 {y.t_Element__0'0} {perm_mut_y} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_94 <- _ret' ] s6)
      | s6 = bb44 ]
    
    | bb44 = bb45
    | bb45 = s0
      [ s0 = {[@expl:type invariant] match _94 with
          | {current = x'0} -> inv'8 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_94 <- { _94 with current = _92 } ] s2
      | s2 = {[@expl:type invariant] inv'9 _94} s3
      | s3 = -{resolve'5 _94}- s4
      | s4 = bb47 ]
    
    | bb47 = s0 [ s0 =  [ &_98 <- rx = ry ] s1 | s1 = any [ br0 -> {_98 = false} (! bb61) | br1 -> {_98} (! bb48) ]  ] 
    | bb48 = s0
      [ s0 = {inv'3 map}
        MutBorrow.borrow_mut <t_GhostBox'1> {map}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_107 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &map <- _ret'.final ] 
            s1)
      | s1 = deref_mut'0 {_107} (fun (_ret':MutBorrow.t (MutBorrow.t t_FMap'0)) ->  [ &_106 <- _ret' ] s2)
      | s2 = bb49 ]
    
    | bb49 = s0
      [ s0 = {inv'4 (_106.current).current}
        MutBorrow.borrow_mut <t_FMap'0> {(_106.current).current}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_105 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_106 <- { _106 with current = { _106.current with current = _ret'.final } } ] 
            s1)
      | s1 = addr'0 {x} (fun (_ret':int) ->  [ &_110 <- _ret' ] s2)
      | s2 = bb50 ]
    
    | bb50 = s0
      [ s0 =  [ &_109 <- _110 ] s1
      | s1 = get_mut_ghost'0 {_105} {_109} (fun (_ret':t_Option'1) ->  [ &_104 <- _ret' ] s2)
      | s2 = bb51 ]
    
    | bb51 = s0 [ s0 = unwrap'1 {_104} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_103 <- _ret' ] s1) | s1 = bb52 ] 
    | bb52 = s0
      [ s0 = {inv'5 _103.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_103.current} {MutBorrow.get_id _103}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_102 <- _ret' ] 
            -{inv'5 _ret'.final}-
             [ &_103 <- { _103 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_102} (fun (_ret':t_GhostBox'3) ->  [ &perm_mut_x1 <- _ret' ] s2)
      | s2 = bb53 ]
    
    | bb53 = s0
      [ s0 = {[@expl:type invariant] inv'6 _106} s1
      | s1 = -{resolve'3 _106}- s2
      | s2 = {[@expl:type invariant] inv'7 _103} s3
      | s3 = -{resolve'4 _103}- s4
      | s4 = as_mut'0 {x.t_Element__0'0} {perm_mut_x1} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_112 <- _ret' ] s5)
      | s5 = bb54 ]
    
    | bb54 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_112.current = C_Root'0 x0 x1} (! bb56)
      | br1 (x0:t_Element'0)-> {_112.current = C_Link'0 x0} (! bb55) ]
    
    | bb55 = s0
      [ s0 = {[@expl:type invariant] inv'9 _112} s1
      | s1 = -{resolve'5 _112}- s2
      | s2 = {[@expl:type invariant] inv'3 map} s3
      | s3 = -{resolve'2 map}- s4
      | s4 = bb59 ]
    
    | bb56 = bb57
    | bb57 = s0
      [ s0 = v_Root'0 {_112.current}
          (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->
            MutBorrow.borrow_final <UInt64.t> {rrank'0} {MutBorrow.inherit_id (MutBorrow.get_id _112) 1}
              (fun (_ret':MutBorrow.t UInt64.t) ->
                 [ &rank <- _ret' ] 
                 [ &_112 <- { _112 with current = C_Root'0 _ret'.final rvalue'0 } ] 
                s1))
      | s1 = add_no_overflow'0 {rx} {[%#sunion_find4] (1 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_117 <- _ret' ] s2)
      | s2 = bb58 ]
    
    | bb58 = s0
      [ s0 =  [ &rank <- { rank with current = _117 } ] s1
      | s1 = -{resolve'6 rank}- s2
      | s2 = {[@expl:type invariant] inv'9 _112} s3
      | s3 = -{resolve'5 _112}- s4
      | s4 = {[@expl:type invariant] inv'3 map} s5
      | s5 = -{resolve'2 map}- s6
      | s6 = bb59 ]
    
    | bb59 = bb60
    | bb60 = bb62
    | bb61 = s0 [ s0 = {[@expl:type invariant] inv'3 map} s1 | s1 = -{resolve'2 map}- s2 | s2 = bb62 ] 
    | bb62 = s0
      [ s0 = 
        [ &_119 <- [%#sunion_find5] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = y then
          x
        else
          index_logic'0 (self.current).t_UnionFind__root_of'0 z
         ]
        
        s1
      | s1 = bb63 ]
    
    | bb63 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _119 } } ] s1
      | s1 = 
        [ &_121 <- [%#sunion_find6] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = x then
          vx
        else
          index_logic'1 (self.current).t_UnionFind__values'0 z
         ]
        
        s2
      | s2 = bb64 ]
    
    | bb64 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _121 } } ] s1
      | s1 =  [ &_123 <- [%#sunion_find7] (self.current).t_UnionFind__max_depth'0 + 1 ] s2
      | s2 = bb65 ]
    
    | bb65 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__max_depth'0 = _123 } } ] s1
      | s1 = 
        [ &_125 <- [%#sunion_find8] Map.set (self.current).t_UnionFind__distance'0 x (1
        + MinMax.max (index_logic'2 (self.current).t_UnionFind__distance'0 x) (index_logic'2 (self.current).t_UnionFind__distance'0 y)) ]
        
        s2
      | s2 = bb66 ]
    
    | bb66 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _125 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- x ] s4
      | s4 = bb67 ]
    
    | bb67 = bb68
    | bb68 = bb69
    | bb69 = bb70
    | bb70 = bb71
    | bb71 = bb72
    | bb72 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & _14 : bool = Any.any_l ()
    | & map : t_GhostBox'1 = Any.any_l ()
    | & _19 : MutBorrow.t t_GhostBox'0 = Any.any_l ()
    | & perm_x : t_GhostBox'2 = Any.any_l ()
    | & _21 : t_PtrOwn'0 = Any.any_l ()
    | & _22 : t_Option'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _27 : int = Any.any_l ()
    | & _28 : int = Any.any_l ()
    | & perm_y : t_GhostBox'2 = Any.any_l ()
    | & _31 : t_PtrOwn'0 = Any.any_l ()
    | & _32 : t_Option'0 = Any.any_l ()
    | & _34 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _37 : int = Any.any_l ()
    | & _38 : int = Any.any_l ()
    | & rx : UInt64.t = Any.any_l ()
    | & vx : t_T'0 = Any.any_l ()
    | & _43 : t_Content'0 = Any.any_l ()
    | & ry : UInt64.t = Any.any_l ()
    | & vy : t_T'0 = Any.any_l ()
    | & _50 : t_Content'0 = Any.any_l ()
    | & _54 : bool = Any.any_l ()
    | & perm_mut_x : t_GhostBox'3 = Any.any_l ()
    | & _58 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _59 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _60 : t_Option'1 = Any.any_l ()
    | & _61 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _62 : MutBorrow.t (MutBorrow.t t_FMap'0) = Any.any_l ()
    | & _63 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _65 : int = Any.any_l ()
    | & _66 : int = Any.any_l ()
    | & _68 : t_Content'0 = Any.any_l ()
    | & _70 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & _73 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _75 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _77 : int = Any.any_l ()
    | & _79 : Map.map t_Element'0 int = Any.any_l ()
    | & perm_mut_y : t_GhostBox'3 = Any.any_l ()
    | & _82 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _83 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _84 : t_Option'1 = Any.any_l ()
    | & _85 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _86 : MutBorrow.t (MutBorrow.t t_FMap'0) = Any.any_l ()
    | & _87 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _89 : int = Any.any_l ()
    | & _90 : int = Any.any_l ()
    | & _92 : t_Content'0 = Any.any_l ()
    | & _94 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & _98 : bool = Any.any_l ()
    | & perm_mut_x1 : t_GhostBox'3 = Any.any_l ()
    | & _102 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _103 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _104 : t_Option'1 = Any.any_l ()
    | & _105 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _106 : MutBorrow.t (MutBorrow.t t_FMap'0) = Any.any_l ()
    | & _107 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _109 : int = Any.any_l ()
    | & _110 : int = Any.any_l ()
    | & _112 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & rank : MutBorrow.t UInt64.t = Any.any_l ()
    | & _117 : UInt64.t = Any.any_l ()
    | & _119 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _121 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _123 : int = Any.any_l ()
    | & _125 : Map.map t_Element'0 int = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:link ensures #0] [%#sunion_find14] domain'0 self.final
      = domain'0 self.current}
      {[@expl:link ensures #1] [%#sunion_find15] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[@expl:link ensures #2] [%#sunion_find16] result = index_logic'0 (root_of'0 self.final) result}
      {[@expl:link ensures #3] [%#sunion_find17] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[@expl:link ensures #4] [%#sunion_find18] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union_aux [#"union_find.rs" 350 8 350 75] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 350 26 350 30
  let%span sunion_find1 = "union_find.rs" 332 19 332 44
  let%span sunion_find2 = "union_find.rs" 333 19 333 44
  let%span sunion_find3 = "union_find.rs" 334 18 334 54
  let%span sunion_find4 = "union_find.rs" 335 18 335 82
  let%span sunion_find5 = "union_find.rs" 336 18 341 13
  let%span sunion_find6 = "union_find.rs" 343 18 348 13
  let%span sunion_find7 = "union_find.rs" 225 25 225 29
  let%span sunion_find8 = "union_find.rs" 222 19 222 47
  let%span sunion_find9 = "union_find.rs" 223 18 223 48
  let%span sunion_find10 = "union_find.rs" 224 18 224 34
  let%span sunion_find11 = "union_find.rs" 286 21 286 25
  let%span sunion_find12 = "union_find.rs" 265 19 265 44
  let%span sunion_find13 = "union_find.rs" 266 19 266 41
  let%span sunion_find14 = "union_find.rs" 267 19 267 44
  let%span sunion_find15 = "union_find.rs" 268 19 268 41
  let%span sunion_find16 = "union_find.rs" 269 18 269 54
  let%span sunion_find17 = "union_find.rs" 270 18 270 82
  let%span sunion_find18 = "union_find.rs" 271 18 271 53
  let%span sunion_find19 = "union_find.rs" 272 18 277 13
  let%span sunion_find20 = "union_find.rs" 279 18 284 13
  let%span sfset21 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find22 = "union_find.rs" 135 19 135 28
  let%span sunion_find23 = "union_find.rs" 136 18 136 150
  let%span sunion_find24 = "union_find.rs" 133 8 133 16
  let%span smapping25 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find26 = "union_find.rs" 147 19 147 28
  let%span sunion_find27 = "union_find.rs" 148 18 148 98
  let%span sunion_find28 = "union_find.rs" 145 8 145 16
  let%span sunion_find29 = "union_find.rs" 261 12 261 50
  let%span sunion_find30 = "union_find.rs" 156 19 156 28
  let%span sunion_find31 = "union_find.rs" 157 18 157 106
  let%span sunion_find32 = "union_find.rs" 154 8 154 16
  let%span sunion_find33 = "union_find.rs" 167 16 169 52
  let%span sresolve34 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find35 = "union_find.rs" 23 8 23 16
  let%span sunion_find36 = "union_find.rs" 82 8 82 20
  let%span sinvariant37 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap38 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find40 = "union_find.rs" 127 8 127 16
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap42 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed46 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil47 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil48 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own50 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr51 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr52 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset21] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find35] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap43] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap41] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap38] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost39] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil47] op <> C_None'0)
   -> ([%#sutil48] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap45] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap44] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap42] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find40] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping25] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping25] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping25] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find36] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr52] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr51] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed46] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own50] not is_null_logic'0 (ptr'0 self) /\ inv'8 (val'0 self)
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed46] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap49] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed46] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant37] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find24] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find22] inv'0 self)
   -> ([%#sunion_find23] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find28] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find26] inv'0 self)
   -> ([%#sunion_find27] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find32] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find30] inv'0 self)
   -> ([%#sunion_find31] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find33] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find7] inv'1 self}
    {[@expl:find requires] [%#sunion_find8] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find9] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find10] unchanged'0 self}
      (! return' {result}) ]
  
  
  predicate equiv_log'0 [#"union_find.rs" 260 8 260 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find29] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  let rec link'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:link 'self' type invariant] [%#sunion_find11] inv'1 self}
    {[@expl:link requires #0] [%#sunion_find12] contains'0 (domain'0 self.current) x}
    {[@expl:link requires #1] [%#sunion_find13] index_logic'0 (root_of'0 self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find14] contains'0 (domain'0 self.current) y}
    {[@expl:link requires #3] [%#sunion_find15] index_logic'0 (root_of'0 self.current) y = y}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find16] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find17] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[%#sunion_find18] result = index_logic'0 (root_of'0 self.final) result}
      {[%#sunion_find19] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[%#sunion_find20] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec union_aux'0[#"union_find.rs" 350 8 350 75] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:union_aux 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:union_aux requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_11 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_11} {x} (fun (_ret':t_Element'0) ->  [ &rx <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_14 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_14} {y} (fun (_ret':t_Element'0) ->  [ &ry <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = link'0 {_16} {rx} {ry} (fun (_ret':t_Element'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & rx : t_Element'0 = Any.any_l ()
    | & _11 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & ry : t_Element'0 = Any.any_l ()
    | & _14 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:union_aux ensures #0] [%#sunion_find3] domain'0 self.final
      = domain'0 self.current}
      {[@expl:union_aux ensures #1] [%#sunion_find4] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[@expl:union_aux ensures #2] [%#sunion_find5] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[@expl:union_aux ensures #3] [%#sunion_find6] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union [#"union_find.rs" 373 8 373 61] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 373 26 373 30
  let%span sunion_find1 = "union_find.rs" 357 19 357 44
  let%span sunion_find2 = "union_find.rs" 358 19 358 44
  let%span sunion_find3 = "union_find.rs" 359 18 359 54
  let%span sunion_find4 = "union_find.rs" 360 18 372 9
  let%span sunion_find5 = "union_find.rs" 350 26 350 30
  let%span sunion_find6 = "union_find.rs" 332 19 332 44
  let%span sunion_find7 = "union_find.rs" 333 19 333 44
  let%span sunion_find8 = "union_find.rs" 334 18 334 54
  let%span sunion_find9 = "union_find.rs" 335 18 335 82
  let%span sunion_find10 = "union_find.rs" 336 18 341 13
  let%span sunion_find11 = "union_find.rs" 343 18 348 13
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find13 = "union_find.rs" 135 19 135 28
  let%span sunion_find14 = "union_find.rs" 136 18 136 150
  let%span sunion_find15 = "union_find.rs" 133 8 133 16
  let%span smapping16 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find17 = "union_find.rs" 147 19 147 28
  let%span sunion_find18 = "union_find.rs" 148 18 148 98
  let%span sunion_find19 = "union_find.rs" 145 8 145 16
  let%span sunion_find20 = "union_find.rs" 261 12 261 50
  let%span sunion_find21 = "union_find.rs" 156 19 156 28
  let%span sunion_find22 = "union_find.rs" 157 18 157 106
  let%span sunion_find23 = "union_find.rs" 154 8 154 16
  let%span sresolve24 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find25 = "union_find.rs" 23 8 23 16
  let%span sunion_find26 = "union_find.rs" 82 8 82 20
  let%span sinvariant27 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost29 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find30 = "union_find.rs" 127 8 127 16
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed36 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil37 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil38 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap39 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own40 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr41 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr42 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset12] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find25] addr_logic'0 self.t_Element__0'0
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap33] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap31] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap28] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost29] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil37] op <> C_None'0)
   -> ([%#sutil38] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap35] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap34] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find30] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping16] Map.get self a
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping16] Map.get self a
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  use map.Map
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping16] Map.get self a
  
  use mach.int.Int
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find26] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr42] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr41] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed36] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own40] not is_null_logic'0 (ptr'0 self) /\ inv'8 (val'0 self)
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed36] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap39] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed36] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant27] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find15] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find13] inv'0 self)
   -> ([%#sunion_find14] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find19] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find17] inv'0 self)
   -> ([%#sunion_find18] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate equiv_log'0 [#"union_find.rs" 260 8 260 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find20] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  let rec union_aux'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:union_aux 'self' type invariant] [%#sunion_find5] inv'1 self}
    {[@expl:union_aux requires #0] [%#sunion_find6] contains'0 (domain'0 self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find7] contains'0 (domain'0 self.current) y}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find8] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find9] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[%#sunion_find10] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[%#sunion_find11] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec union'0[#"union_find.rs" 373 8 373 61] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:()))= {[@expl:union 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:union requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) x}
    {[@expl:union requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = union_aux'0 {_9} {x} {y} (fun (_ret':t_Element'0) ->  [ &_8 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & _8 : t_Element'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:union ensures #0] [%#sunion_find3] domain'0 self.final = domain'0 self.current}
      {[@expl:union ensures #1] [%#sunion_find4] exists r : t_Element'0 . (r = index_logic'0 (root_of'0 self.current) x
      \/ r = index_logic'0 (root_of'0 self.current) y)
      /\ (forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        r
      else
        index_logic'0 (root_of'0 self.current) z
      )
      /\ index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) r
      else
        index_logic'1 (values'0 self.current) z
      ))}
      (! return' {result}) ]

end
module M_union_find__example [#"union_find.rs" 382 0 382 16]
  let%span sunion_find0 = "union_find.rs" 383 17 383 40
  let%span sunion_find1 = "union_find.rs" 385 20 385 21
  let%span sunion_find2 = "union_find.rs" 386 20 386 21
  let%span sunion_find3 = "union_find.rs" 387 20 387 21
  let%span sunion_find4 = "union_find.rs" 389 26 389 27
  let%span sunion_find5 = "union_find.rs" 390 26 390 27
  let%span sunion_find6 = "union_find.rs" 391 26 391 27
  let%span sunion_find7 = "union_find.rs" 398 26 398 27
  let%span sunion_find8 = "union_find.rs" 398 4 398 28
  let%span sunion_find9 = "union_find.rs" 397 4 397 37
  let%span sunion_find10 = "union_find.rs" 391 4 391 28
  let%span sunion_find11 = "union_find.rs" 390 4 390 28
  let%span sunion_find12 = "union_find.rs" 389 4 389 28
  let%span sunion_find13 = "union_find.rs" 116 24 116 28
  let%span sunion_find14 = "union_find.rs" 115 8 115 44
  let%span sunion_find15 = "union_find.rs" 177 25 177 29
  let%span sunion_find16 = "union_find.rs" 177 31 177 36
  let%span sunion_find17 = "union_find.rs" 173 18 173 52
  let%span sunion_find18 = "union_find.rs" 174 18 174 69
  let%span sunion_find19 = "union_find.rs" 175 18 175 76
  let%span sunion_find20 = "union_find.rs" 176 18 176 73
  let%span sunion_find21 = "union_find.rs" 235 20 235 24
  let%span sunion_find22 = "union_find.rs" 232 19 232 47
  let%span sunion_find23 = "union_find.rs" 233 19 233 47
  let%span sunion_find24 = "union_find.rs" 235 47 235 49
  let%span sunion_find25 = "union_find.rs" 234 18 234 48
  let%span sunion_find26 = "union_find.rs" 373 26 373 30
  let%span sunion_find27 = "union_find.rs" 357 19 357 44
  let%span sunion_find28 = "union_find.rs" 358 19 358 44
  let%span sunion_find29 = "union_find.rs" 359 18 359 54
  let%span sunion_find30 = "union_find.rs" 360 18 372 9
  let%span sunion_find31 = "union_find.rs" 225 25 225 29
  let%span sunion_find32 = "union_find.rs" 222 19 222 47
  let%span sunion_find33 = "union_find.rs" 223 18 223 48
  let%span sunion_find34 = "union_find.rs" 224 18 224 34
  let%span sfset35 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find36 = "union_find.rs" 135 19 135 28
  let%span sunion_find37 = "union_find.rs" 136 18 136 150
  let%span sfset38 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sunion_find39 = "union_find.rs" 147 19 147 28
  let%span sunion_find40 = "union_find.rs" 148 18 148 98
  let%span sunion_find41 = "union_find.rs" 156 19 156 28
  let%span sunion_find42 = "union_find.rs" 157 18 157 106
  let%span smapping43 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find44 = "union_find.rs" 261 12 261 50
  let%span sunion_find45 = "union_find.rs" 167 16 169 52
  let%span sinvariant46 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant47 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  use creusot.int.Int32
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 Int32.t;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> true
    end)
  
  use set.Fset
  
  let rec new'0 (_1:()) (return'  (ret:t_UnionFind'0))= any
    [ return' (result:t_UnionFind'0)-> {[%#sunion_find13] inv'0 result}
      {[%#sunion_find14] Fset.is_empty result.t_UnionFind__domain'0}
      (! return' {result}) ]
  
  
  use creusot.prelude.MutBorrow
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant46] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 (_1 : Int32.t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Int32.t [inv'2 x] . inv'2 x = true
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset35] Fset.mem e self
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find36] inv'0 self)
   -> ([%#sunion_find37] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  use set.Fset
  
  function insert'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) : Fset.fset t_Element'0 =
    [%#sfset38] Fset.add e self
  
  use map.Map
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping43] Map.get self a
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find39] inv'0 self)
   -> ([%#sunion_find40] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  use map.Map
  
  use map.Map
  
  function index_logic'1 (self : Map.map t_Element'0 Int32.t) (a : t_Element'0) : Int32.t =
    [%#smapping43] Map.get self a
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 Int32.t
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find41] inv'0 self)
   -> ([%#sunion_find42] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  use map.Map
  
  let rec make'0 (self:MutBorrow.t t_UnionFind'0) (value:Int32.t) (return'  (ret:t_Element'0))= {[@expl:make 'self' type invariant] [%#sunion_find15] inv'1 self}
    {[@expl:make 'value' type invariant] [%#sunion_find16] inv'2 value}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find17] not contains'0 (domain'0 self.current) result}
      {[%#sunion_find18] domain'0 self.final = insert'0 (domain'0 self.current) result}
      {[%#sunion_find19] root_of'0 self.final = Map.set (root_of'0 self.current) result result}
      {[%#sunion_find20] values'0 self.final = Map.set (values'0 self.current) result value}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : t_UnionFind'0) =
    [%#sinvariant47] inv'0 self
  
  predicate inv'3 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_UnionFind'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'4 (_1 : Int32.t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Int32.t [inv'4 x] . inv'4 x = true
  
  let rec get'0 (self:t_UnionFind'0) (elem:t_Element'0) (return'  (ret:Int32.t))= {[@expl:get 'self' type invariant] [%#sunion_find21] inv'3 self}
    {[@expl:get requires #0] [%#sunion_find22] contains'0 (domain'0 self) elem}
    {[@expl:get requires #1] [%#sunion_find23] index_logic'0 (root_of'0 self) elem = elem}
    any
    [ return' (result:Int32.t)-> {[%#sunion_find24] inv'4 result}
      {[%#sunion_find25] result = index_logic'1 (values'0 self) elem}
      (! return' {result}) ]
  
  
  predicate equiv_log'0 [#"union_find.rs" 260 8 260 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find44] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  let rec union'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:()))= {[@expl:union 'self' type invariant] [%#sunion_find26] inv'1 self}
    {[@expl:union requires #0] [%#sunion_find27] contains'0 (domain'0 self.current) x}
    {[@expl:union requires #1] [%#sunion_find28] contains'0 (domain'0 self.current) y}
    any
    [ return' (result:())-> {[%#sunion_find29] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find30] exists r : t_Element'0 . (r = index_logic'0 (root_of'0 self.current) x
      \/ r = index_logic'0 (root_of'0 self.current) y)
      /\ (forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        r
      else
        index_logic'0 (root_of'0 self.current) z
      )
      /\ index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) r
      else
        index_logic'1 (values'0 self.current) z
      ))}
      (! return' {result}) ]
  
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find45] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find31] inv'1 self}
    {[@expl:find requires] [%#sunion_find32] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find33] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find34] unchanged'0 self}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec example'0[#"union_find.rs" 382 0 382 16] (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = new'0 {[%#sunion_find0] ()} (fun (_ret':t_UnionFind'0) ->  [ &uf <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_3 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_3} {[%#sunion_find1] (1 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &x <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_5 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_5} {[%#sunion_find2] (2 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &y <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_7 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_7} {[%#sunion_find3] (3 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &z <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = get'0 {uf} {x} (fun (_ret':Int32.t) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_9 <- _11 = ([%#sunion_find4] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
    
    | bb6 = s0 [ s0 = get'0 {uf} {y} (fun (_ret':Int32.t) ->  [ &_18 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_16 <- _18 = ([%#sunion_find5] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ]  ]
    
    | bb9 = s0 [ s0 = get'0 {uf} {z} (fun (_ret':Int32.t) ->  [ &_25 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_23 <- _25 = ([%#sunion_find6] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb13) | br1 -> {_23} (! bb12) ]  ]
    
    | bb12 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_30 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = union'0 {_30} {x} {y} (fun (_ret':()) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_34 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = find'0 {_34} {x} (fun (_ret':t_Element'0) ->  [ &x1 <- _ret' ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_37 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = find'0 {_37} {y} (fun (_ret':t_Element'0) ->  [ &y1 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = get'0 {uf} {x1} (fun (_ret':Int32.t) ->  [ &_42 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 = get'0 {uf} {y1} (fun (_ret':Int32.t) ->  [ &_46 <- _ret' ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 =  [ &_40 <- _42 = _46 ] s1 | s1 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ]  ]
    
    | bb19 = s0 [ s0 = get'0 {uf} {z} (fun (_ret':Int32.t) ->  [ &_53 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = s0
      [ s0 =  [ &_51 <- _53 = ([%#sunion_find7] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb23) | br1 -> {_51} (! bb22) ]  ]
    
    | bb22 = bb24
    | bb24 = return' {_0}
    | bb23 = {[%#sunion_find8] false} any
    | bb20 = {[%#sunion_find9] false} any
    | bb13 = {[%#sunion_find10] false} any
    | bb10 = {[%#sunion_find11] false} any
    | bb7 = {[%#sunion_find12] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & uf : t_UnionFind'0 = Any.any_l ()
    | & x : t_Element'0 = Any.any_l ()
    | & _3 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & y : t_Element'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & z : t_Element'0 = Any.any_l ()
    | & _7 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _11 : Int32.t = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _18 : Int32.t = Any.any_l ()
    | & _23 : bool = Any.any_l ()
    | & _25 : Int32.t = Any.any_l ()
    | & _29 : () = Any.any_l ()
    | & _30 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & x1 : t_Element'0 = Any.any_l ()
    | & _34 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & y1 : t_Element'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _40 : bool = Any.any_l ()
    | & _42 : Int32.t = Any.any_l ()
    | & _46 : Int32.t = Any.any_l ()
    | & _51 : bool = Any.any_l ()
    | & _53 : Int32.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_union_find__example_addrs_eq [#"union_find.rs" 402 0 402 77]
  let%span sunion_find0 = "union_find.rs" 406 22 406 30
  let%span sunion_find1 = "union_find.rs" 402 27 402 29
  let%span sunion_find2 = "union_find.rs" 401 11 401 63
  let%span sunion_find3 = "union_find.rs" 16 18 16 69
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find5 = "union_find.rs" 135 19 135 28
  let%span sunion_find6 = "union_find.rs" 136 18 136 150
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil14 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil15 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own17 = "../../creusot-contracts/src/ptr_own.rs" 44 20 44 66
  let%span sptr18 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr19 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel7] deep_model'1 self
  
  let rec eq'0 (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sunion_find3] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  use creusot.prelude.Any
  
  use set.Fset
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  use map.Map
  
  use map.Map
  
  use map.Map
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'1 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0)
  
  type t_PtrOwn'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  use map.Map
  
  use map.Map
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap16] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap13] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap11] get_unsized'0 self k <> C_None'0
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr19] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr18] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  use creusot.int.UInt64
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed9] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own17] not is_null_logic'0 (ptr'0 self) /\ inv'8 (val'0 self)
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed9] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil14] op <> C_None'0)
   -> ([%#sutil15] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap12] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap10] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed9] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'1 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_UnionFind'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'0 (self : t_UnionFind'0) =
    [%#sinvariant8] inv'1 self
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset4] Fset.mem e self
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find5] inv'1 self)
   -> ([%#sunion_find6] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  let rec example_addrs_eq'0[#"union_find.rs" 402 0 402 77] (uf:t_UnionFind'0) (e1:t_Element'0) (e2:t_Element'0) (return'  (ret:()))= {[@expl:example_addrs_eq 'uf' type invariant] [%#sunion_find1] inv'0 uf}
    {[@expl:example_addrs_eq requires] [%#sunion_find2] contains'0 (domain'0 uf) e1 /\ contains'0 (domain'0 uf) e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {e1} {e2} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0 [ s0 = {[@expl:assertion] [%#sunion_find0] e1 = e2} s1 | s1 = bb4 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : () = Any.any_l () | & e1 : t_Element'0 = e1 | & e2 : t_Element'0 = e2 | & _5 : bool = Any.any_l () ] 
    [ return' (result:())-> (! return' {result}) ]

end
module M_union_find__implementation__qyi17232405883558456141__eq__refines [#"union_find.rs" 17 8 17 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find0 = "union_find.rs" 17 8 17 42
  let%span smodel1 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sunion_find2 = "union_find.rs" 23 8 23 16
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  predicate inv'0 (_1 : t_Element'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Element'0 [inv'0 x] . inv'0 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find2] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel1] deep_model'1 self
  
  goal refines : [%#sunion_find0] forall self : t_Element'0 . forall other : t_Element'0 . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module M_union_find__implementation__qyi10464084137166016688__clone__refines [#"union_find.rs" 46 8 46 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find0 = "union_find.rs" 46 8 46 31
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  predicate inv'0 (_1 : t_Element'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Element'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Element'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Element'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sunion_find0] forall self : t_Element'0 . inv'0 self
   -> (forall result : t_Element'0 . self = result  -> result = self /\ inv'1 result)
end
