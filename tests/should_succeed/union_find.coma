module M_union_find__implementation__qyi17232405883558456141__eq [#"union_find.rs" 18 8 18 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find0 = "union_find.rs" 17 18 17 69
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 131 22 131 66
  let%span smodel2 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sunion_find3 = "union_find.rs" 24 8 24 16
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  let rec addr_eq'0 (p:Opaque.ptr) (q:Opaque.ptr) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sptr1] result = (addr_logic'0 p = addr_logic'0 q)} (! return' {result}) ]
  
  
  function deep_model'1 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find3] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel2] deep_model'1 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'0[#"union_find.rs" 18 8 18 42] (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = addr_eq'0 {self.t_Element__0'0} {other.t_Element__0'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = bb1 ]
    
    | bb1 = return' {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self : t_Element'0 = self | & other : t_Element'0 = other ] 
    [ return' (result:bool)-> {[@expl:eq ensures] [%#sunion_find0] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi15934775324707434347__addr [#"union_find.rs" 34 8 34 38] (* implementation::Element<T> *)
  let%span sunion_find0 = "union_find.rs" 35 12 35 40
  let%span sunion_find1 = "union_find.rs" 33 18 33 46
  let%span sunion_find2 = "union_find.rs" 24 8 24 16
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find2] addr_logic'0 self.t_Element__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec addr'0[#"union_find.rs" 34 8 34 38] (self:t_Element'0) (return'  (ret:int))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sunion_find0] deep_model'0 self ] s1 | s1 = bb1 ]  | bb1 = return' {_0} ]
    ) [ & _0 : int = Any.any_l () | & self : t_Element'0 = self ] 
    [ return' (result:int)-> {[@expl:addr ensures] [%#sunion_find1] result = deep_model'0 self} (! return' {result}) ]

end
module M_union_find__implementation__qyi10464084137166016688__clone [#"union_find.rs" 47 8 47 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find0 = "union_find.rs" 45 18 45 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"union_find.rs" 47 8 47 31] (self:t_Element'0) (return'  (ret:t_Element'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_Element__0'0 = self.t_Element__0'0 } ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_Element'0 = Any.any_l () | & self : t_Element'0 = self ] 
    [ return' (result:t_Element'0)-> {[@expl:clone ensures] [%#sunion_find0] self = result} (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__new [#"union_find.rs" 109 8 109 28] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 111 24 111 46
  let%span sunion_find1 = "union_find.rs" 113 24 113 54
  let%span sunion_find2 = "union_find.rs" 114 26 114 56
  let%span sunion_find3 = "union_find.rs" 115 25 115 55
  let%span sunion_find4 = "union_find.rs" 116 27 116 39
  let%span sunion_find5 = "union_find.rs" 109 24 109 28
  let%span sunion_find6 = "union_find.rs" 108 8 108 44
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 240 4 240 31
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 238 14 238 31
  let%span sutil9 = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil10 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span smapping12 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sunion_find18 = "union_find.rs" 75 8 75 20
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap20 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap21 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap22 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfset23 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find24 = "union_find.rs" 24 8 24 16
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find26 = "union_find.rs" 120 8 120 16
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sutil31 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil32 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed33 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr35 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr36 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use set.Fset
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_T'0
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap21] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap20] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap25] get_unsized'0 self k <> C_None'0
  
  predicate inv'3 (_1 : int)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int [inv'3 x] . inv'3 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr36] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr35] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own34] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'8 (_1 : t_T'0)
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x
  = match x with
    | C_Root'0 rank value -> inv'8 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed33] inv'7 self
  
  predicate inv'6 (_1 : t_Content'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Content'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'6 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed33] inv'5 self
  
  predicate inv'4 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil31] op <> C_None'0)
   -> ([%#sutil32] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap30] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap28] forall k : int . contains'1 self k  -> inv'3 k /\ inv'4 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  predicate invariant'1 (self : t_Ghost'0) =
    [%#sghost19] inv'2 (inner_logic'0 self)
  
  predicate inv'1 (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap15] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap13] ext_eq'0 self other  -> self = other)
  && ([%#sfmap14] (forall k : int . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap22] len'0 self >= 0
  
  function empty'0  : t_FMap'0
  
  axiom empty'0_spec : ([%#sfmap16] len'0 empty'0 = 0) && ([%#sfmap17] view'0 empty'0 = Const.const (C_None'0))
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap11] ext_eq'0 self empty'0
  
  let rec new'1 (return'  (ret:t_Ghost'0))= any
    [ return' (result:t_Ghost'0)-> {[%#sfmap7] inv'1 result}
      {[%#sfmap8] is_empty'0 (inner_logic'0 result)}
      (! return' {result}) ]
  
  
  function index_logic'0 (self : Map.map (Map.map t_Element'0 t_T'0) bool) (a : Map.map t_Element'0 t_T'0) : bool =
    [%#smapping12] Map.get self a
  
  function such_that'0 (p : Map.map (Map.map t_Element'0 t_T'0) bool) : Map.map t_Element'0 t_T'0
  
  axiom such_that'0_spec : forall p : Map.map (Map.map t_Element'0 t_T'0) bool . ([%#sutil9] exists x : Map.map t_Element'0 t_T'0 . index_logic'0 p x)
   -> ([%#sutil10] index_logic'0 p (such_that'0 p))
  
  function index_logic'1 (self : Map.map (Map.map t_Element'0 int) bool) (a : Map.map t_Element'0 int) : bool =
    [%#smapping12] Map.get self a
  
  function such_that'1 (p : Map.map (Map.map t_Element'0 int) bool) : Map.map t_Element'0 int
  
  axiom such_that'1_spec : forall p : Map.map (Map.map t_Element'0 int) bool . ([%#sutil9] exists x : Map.map t_Element'0 int . index_logic'1 p x)
   -> ([%#sutil10] index_logic'1 p (such_that'1 p))
  
  function index_logic'2 (self : Map.map (Map.map t_Element'0 t_Element'0) bool) (a : Map.map t_Element'0 t_Element'0) : bool
  
   =
    [%#smapping12] Map.get self a
  
  function such_that'2 (p : Map.map (Map.map t_Element'0 t_Element'0) bool) : Map.map t_Element'0 t_Element'0
  
  axiom such_that'2_spec : forall p : Map.map (Map.map t_Element'0 t_Element'0) bool . ([%#sutil9] exists x : Map.map t_Element'0 t_Element'0 . index_logic'2 p x)
   -> ([%#sutil10] index_logic'2 p (such_that'2 p))
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset23] Fset.mem e self
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find24] addr_logic'0 self.t_Element__0'0
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap29] lookup_unsized'0 self k
  
  function index_logic'6 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap27] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find26] index_logic'6 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'3 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping12] Map.get self a
  
  function index_logic'4 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping12] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'5 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping12] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find18] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'3 self.t_UnionFind__values'0 e
    = index_logic'3 self.t_UnionFind__values'0 (index_logic'4 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'4 self.t_UnionFind__root_of'0 (index_logic'4 self.t_UnionFind__root_of'0 e)
    = index_logic'4 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'4 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'4 self.t_UnionFind__root_of'0 e = index_logic'4 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'3 self.t_UnionFind__values'0 e = v
      /\ index_logic'4 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'5 self.t_UnionFind__distance'0 e < index_logic'5 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'5 self.t_UnionFind__distance'0 e
    /\ index_logic'5 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'4 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"union_find.rs" 109 8 109 28] (return'  (ret:t_UnionFind'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_2 <- [%#sunion_find0] Fset.empty : Fset.fset t_Element'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = new'1 (fun (_ret':t_Ghost'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_5 <- [%#sunion_find1] such_that'0 (fun (_2 : Map.map t_Element'0 t_T'0) -> true) ] s1 | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_7 <- [%#sunion_find2] such_that'1 (fun (_2 : Map.map t_Element'0 int) -> true) ] s1 | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_9 <- [%#sunion_find3] such_that'2 (fun (_2 : Map.map t_Element'0 t_Element'0) -> true) ] s1
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_11 <- [%#sunion_find4] 0 ] s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = 
        [ &_0 <- { t_UnionFind__domain'0 = _2;
                   t_UnionFind__map'0 = _4;
                   t_UnionFind__values'0 = _5;
                   t_UnionFind__distance'0 = _7;
                   t_UnionFind__root_of'0 = _9;
                   t_UnionFind__max_depth'0 = _11 } ]
        
        s1
      | s1 = return' {_0} ]
     ]
    )
    [ & _0 : t_UnionFind'0 = Any.any_l ()
    | & _2 : Fset.fset t_Element'0 = Any.any_l ()
    | & _4 : t_Ghost'0 = Any.any_l ()
    | & _5 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _7 : Map.map t_Element'0 int = Any.any_l ()
    | & _9 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _11 : int = Any.any_l () ]
    
    [ return' (result:t_UnionFind'0)-> {[@expl:new result type invariant] [%#sunion_find5] inv'0 result}
      {[@expl:new ensures] [%#sunion_find6] Fset.is_empty result.t_UnionFind__domain'0}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__domain [#"union_find.rs" 130 8 130 47] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 128 19 128 28
  let%span sunion_find1 = "union_find.rs" 129 18 129 150
  let%span sunion_find2 = "union_find.rs" 126 8 126 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find4 = "union_find.rs" 24 8 24 16
  let%span sunion_find5 = "union_find.rs" 75 8 75 20
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find7 = "union_find.rs" 120 8 120 16
  let%span smapping8 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost11 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil16 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil17 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed18 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr21 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find4] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap9] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap6] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil16] op <> C_None'0)
   -> ([%#sutil17] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap14] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap10] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find7] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'0 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping8] Map.get self a
  
  function index_logic'1 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping8] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping8] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find5] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values'0 e
    = index_logic'0 self.t_UnionFind__values'0 (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of'0 (index_logic'1 self.t_UnionFind__root_of'0 e)
    = index_logic'1 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = index_logic'1 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'0 self.t_UnionFind__values'0 e = v
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'1 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'3 (_1 : int)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int [inv'3 x] . inv'3 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr21] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr20] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own19] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'8 (_1 : t_T'0)
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x
  = match x with
    | C_Root'0 rank value -> inv'8 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed18] inv'7 self
  
  predicate inv'6 (_1 : t_Content'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Content'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'6 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed18] inv'5 self
  
  predicate inv'4 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap15] forall k : int . contains'1 self k  -> inv'3 k /\ inv'4 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : t_Ghost'0) =
    [%#sghost11] inv'2 (inner_logic'0 self)
  
  predicate inv'1 (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  constant self  : t_UnionFind'0
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  goal vc_domain'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__domain'0 in [%#sunion_find1] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 result e1
  /\ contains'0 result e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
end
module M_union_find__implementation__qyi1944850640244667852__root_of [#"union_find.rs" 142 8 142 63] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 140 19 140 28
  let%span sunion_find1 = "union_find.rs" 141 18 141 98
  let%span sunion_find2 = "union_find.rs" 138 8 138 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smapping4 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find5 = "union_find.rs" 75 8 75 20
  let%span sunion_find6 = "union_find.rs" 24 8 24 16
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find8 = "union_find.rs" 120 8 120 16
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost11 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil16 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil17 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed18 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr21 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find6] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap9] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap7] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil16] op <> C_None'0)
   -> ([%#sutil17] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap14] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap10] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find8] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping4] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping4] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping4] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find5] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'3 (_1 : int)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int [inv'3 x] . inv'3 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr21] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr20] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own19] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'8 (_1 : t_T'0)
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x
  = match x with
    | C_Root'0 rank value -> inv'8 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed18] inv'7 self
  
  predicate inv'6 (_1 : t_Content'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Content'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'6 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed18] inv'5 self
  
  predicate inv'4 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap15] forall k : int . contains'1 self k  -> inv'3 k /\ inv'4 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : t_Ghost'0) =
    [%#sghost11] inv'2 (inner_logic'0 self)
  
  predicate inv'1 (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  constant self  : t_UnionFind'0
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0
  
  goal vc_root_of'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__root_of'0 in [%#sunion_find1] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 result e = index_logic'0 result (index_logic'0 result e))
end
module M_union_find__implementation__qyi1944850640244667852__values [#"union_find.rs" 151 8 151 53] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 149 19 149 28
  let%span sunion_find1 = "union_find.rs" 150 18 150 106
  let%span sunion_find2 = "union_find.rs" 147 8 147 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smapping4 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find5 = "union_find.rs" 140 19 140 28
  let%span sunion_find6 = "union_find.rs" 141 18 141 98
  let%span sunion_find7 = "union_find.rs" 138 8 138 16
  let%span sunion_find8 = "union_find.rs" 75 8 75 20
  let%span sunion_find9 = "union_find.rs" 24 8 24 16
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find11 = "union_find.rs" 120 8 120 16
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost14 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil19 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil20 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed21 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own22 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr23 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr24 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find9] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap15] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap12] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap10] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil19] op <> C_None'0)
   -> ([%#sutil20] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap17] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap16] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find11] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'0 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping4] Map.get self a
  
  function index_logic'1 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping4] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping4] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find8] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values'0 e
    = index_logic'0 self.t_UnionFind__values'0 (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of'0 (index_logic'1 self.t_UnionFind__root_of'0 e)
    = index_logic'1 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = index_logic'1 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'0 self.t_UnionFind__values'0 e = v
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'1 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'3 (_1 : int)
  
  axiom inv_axiom'3 [@rewrite] : forall x : int [inv'3 x] . inv'3 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr24] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr23] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own22] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'8 (_1 : t_T'0)
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x
  = match x with
    | C_Root'0 rank value -> inv'8 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed21] inv'7 self
  
  predicate inv'6 (_1 : t_Content'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Content'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'6 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed21] inv'5 self
  
  predicate inv'4 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap18] forall k : int . contains'1 self k  -> inv'3 k /\ inv'4 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : t_Ghost'0) =
    [%#sghost14] inv'2 (inner_logic'0 self)
  
  predicate inv'1 (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'2 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find7] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find5] inv'0 self)
   -> ([%#sunion_find6] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (root_of'0 self) e = index_logic'1 (root_of'0 self) (index_logic'1 (root_of'0 self) e))
  
  constant self  : t_UnionFind'0
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0
  
  goal vc_values'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__values'0 in [%#sunion_find1] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 result e = index_logic'0 result (index_logic'1 (root_of'0 self) e))
end
module M_union_find__implementation__qyi1944850640244667852__make [#"union_find.rs" 170 8 170 54] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 171 29 171 45
  let%span sunion_find1 = "union_find.rs" 181 30 181 68
  let%span sunion_find2 = "union_find.rs" 182 30 182 78
  let%span sunion_find3 = "union_find.rs" 183 32 183 72
  let%span sunion_find4 = "union_find.rs" 184 31 184 76
  let%span sunion_find5 = "union_find.rs" 170 25 170 29
  let%span sunion_find6 = "union_find.rs" 170 31 170 36
  let%span sunion_find7 = "union_find.rs" 166 18 166 52
  let%span sunion_find8 = "union_find.rs" 167 18 167 69
  let%span sunion_find9 = "union_find.rs" 168 18 168 76
  let%span sunion_find10 = "union_find.rs" 169 18 169 73
  let%span speano11 = "../../creusot-contracts/src/peano.rs" 50 14 50 26
  let%span sptr_own12 = "../../creusot-contracts/src/ptr_own.rs" 59 15 59 16
  let%span sptr_own13 = "../../creusot-contracts/src/ptr_own.rs" 59 4 59 53
  let%span sptr_own14 = "../../creusot-contracts/src/ptr_own.rs" 58 14 58 64
  let%span sghost15 = "../../creusot-contracts/src/ghost.rs" 216 22 216 26
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 216 4 216 32
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 214 14 214 29
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 84 22 84 26
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 84 4 84 48
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 82 14 82 46
  let%span sghost21 = "../../creusot-contracts/src/ghost.rs" 83 14 83 46
  let%span sunion_find22 = "union_find.rs" 33 18 33 46
  let%span sfmap23 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap24 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own28 = "../../creusot-contracts/src/ptr_own.rs" 143 26 143 30
  let%span sptr_own29 = "../../creusot-contracts/src/ptr_own.rs" 143 48 143 52
  let%span sptr_own30 = "../../creusot-contracts/src/ptr_own.rs" 140 14 140 64
  let%span sptr_own31 = "../../creusot-contracts/src/ptr_own.rs" 141 14 141 28
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 414 29 414 33
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 414 43 414 48
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 414 4 416 17
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 412 14 412 49
  let%span sfmap36 = "../../creusot-contracts/src/logic/fmap.rs" 413 14 413 40
  let%span sfset37 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sghost38 = "../../creusot-contracts/src/ghost.rs" 191 4 191 28
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 189 14 189 26
  let%span sfset40 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find41 = "union_find.rs" 128 19 128 28
  let%span sunion_find42 = "union_find.rs" 129 18 129 150
  let%span sunion_find43 = "union_find.rs" 126 8 126 16
  let%span sunion_find44 = "union_find.rs" 140 19 140 28
  let%span sunion_find45 = "union_find.rs" 141 18 141 98
  let%span sunion_find46 = "union_find.rs" 138 8 138 16
  let%span sunion_find47 = "union_find.rs" 149 19 149 28
  let%span sunion_find48 = "union_find.rs" 150 18 150 106
  let%span sunion_find49 = "union_find.rs" 147 8 147 16
  let%span sunion_find50 = "union_find.rs" 24 8 24 16
  let%span sfmap51 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap52 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap53 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap54 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sresolve55 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap56 = "../../creusot-contracts/src/logic/fmap.rs" 67 14 67 71
  let%span sfmap57 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 61
  let%span sfmap58 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 66
  let%span sfmap59 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sresolve60 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span smapping61 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost62 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap63 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil64 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil65 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap66 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own67 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sinvariant68 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sutil69 = "../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span sptr70 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr71 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sinvariant72 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sunion_find73 = "union_find.rs" 75 8 75 20
  let%span sboxed74 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find75 = "union_find.rs" 120 8 120 16
  let%span sfmap76 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap77 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use set.Fset
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  function view'0 (self : t_PeanoInt'0) : int
  
  let rec new'0 (return'  (ret:t_PeanoInt'0))= any
    [ return' (result:t_PeanoInt'0)-> {[%#speano11] view'0 result = 0} (! return' {result}) ]
  
  
  type t_T'0
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Ghost'2  =
    { t_Ghost__0'2: t_PtrOwn'0 }
  
  type tuple'0  =
    { _0'0: Opaque.ptr; _1'0: t_Ghost'2 }
  
  predicate inv'7 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'7 value
    | C_Link'0 a_0 -> true
    end
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr71] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr70] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'2 (self : t_PtrOwn'0) =
    [%#sptr_own67] not is_null_logic'0 (ptr'0 self)
  
  predicate invariant'11 (self : t_Content'0) =
    [%#sboxed74] inv'8 self
  
  predicate inv'16 (_1 : t_Content'0)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_Content'0 [inv'16 x] . inv'16 x = invariant'11 x
  
  predicate inv'2 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_PtrOwn'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'16 val'
    end)
  
  function inner_logic'0 (self : t_Ghost'2) : t_PtrOwn'0
  
  predicate invariant'6 (self : t_Ghost'2) =
    [%#sghost62] inv'2 (inner_logic'0 self)
  
  predicate inv'10 (_1 : t_Ghost'2)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Ghost'2 [inv'10 x] . inv'10 x
  = (invariant'6 x
  /\ match x with
    | {t_Ghost__0'2 = a_0} -> inv'2 a_0
    end)
  
  predicate inv'9 (_1 : tuple'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : tuple'0 [inv'9 x] . inv'9 x = (let {_0'0 = x0 ; _1'0 = x1} = x in inv'10 x1)
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  let rec new'1 (v:t_Content'0) (return'  (ret:tuple'0))= {[@expl:new 'v' type invariant] [%#sptr_own12] inv'8 v}
    any
    [ return' (result:tuple'0)-> {[%#sptr_own13] inv'9 result}
      {[%#sptr_own14] ptr'0 (inner_logic'0 result._1'0) = result._0'0 /\ val'0 (inner_logic'0 result._1'0) = v}
      (! return' {result}) ]
  
  
  let rec into_inner'0 (self:t_Ghost'2) (return'  (ret:t_PtrOwn'0))= {[@expl:into_inner 'self' type invariant] [%#sghost15] inv'10 self}
    any
    [ return' (result:t_PtrOwn'0)-> {[%#sghost16] inv'2 result}
      {[%#sghost17] result = inner_logic'0 self}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  function view'1 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap66] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap53] Map.get (view'1 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap51] get_unsized'0 self k <> C_None'2
  
  predicate inv'17 (_1 : int)
  
  axiom inv_axiom'16 [@rewrite] : forall x : int [inv'17 x] . inv'17 x = true
  
  predicate invariant'12 (self : t_PtrOwn'0) =
    [%#sboxed74] inv'2 self
  
  predicate inv'18 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_PtrOwn'0 [inv'18 x] . inv'18 x = invariant'12 x
  
  function unwrap'0 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'2 . ([%#sutil64] op <> C_None'2)
   -> ([%#sutil65] C_Some'2 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap52] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sfmap63] forall k : int . contains'1 self k  -> inv'17 k /\ inv'18 (lookup_unsized'0 self k)
  
  predicate inv'1 (_1 : t_FMap'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FMap'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function inner_logic'1 (self : t_Ghost'0) : t_FMap'0
  
  predicate invariant'0 (self : t_Ghost'0) =
    [%#sghost62] inv'1 (inner_logic'1 self)
  
  predicate inv'0 (_1 : t_Ghost'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Ghost'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'1 a_0
    end)
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'7 (self : MutBorrow.t t_Ghost'0) =
    [%#sinvariant68] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'11 (_1 : MutBorrow.t t_Ghost'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : MutBorrow.t t_Ghost'0 [inv'11 x] . inv'11 x = invariant'7 x
  
  predicate invariant'4 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant68] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_Ghost'0) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost18] inv'11 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost19] inv'4 result}
      {[%#sghost20] result.current = inner_logic'1 self.current}
      {[%#sghost21] result.final = inner_logic'1 self.final}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find50] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find22] result = deep_model'0 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'3 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant68] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate inv'12 (_1 : t_Option'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Option'0 [inv'12 x] . inv'12 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap54] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap23] inv'4 self}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap24] inv'12 result}
      {[%#sfmap25] if contains'1 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap26] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap27] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:MutBorrow.t t_PtrOwn'0))= any
    [ good (field_0:MutBorrow.t t_PtrOwn'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_PtrOwn'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate invariant'8 (self : t_PtrOwn'0) =
    [%#sinvariant72] inv'2 self
  
  predicate inv'13 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_PtrOwn'0 [inv'13 x] . inv'13 x = invariant'8 x
  
  let rec disjoint_lemma'0 (own1:MutBorrow.t t_PtrOwn'0) (own2:t_PtrOwn'0) (return'  (ret:()))= {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own28] inv'3 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own29] inv'13 own2}
    any
    [ return' (result:())-> {[%#sptr_own30] addr_logic'0 (ptr'0 own1.current) <> addr_logic'0 (ptr'0 own2)}
      {[%#sptr_own31] own1.current = own1.final}
      (! return' {result}) ]
  
  
  predicate resolve'4 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve55] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'4 _1
  
  predicate resolve'5 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve55] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_FMap'0) =
    resolve'5 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn'0
  
  predicate inv'5 (_1 : t_Option'1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option'1 [inv'5 x] . inv'5 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  function make_sized'0 (self : t_PtrOwn'0) : t_PtrOwn'0
  
  axiom make_sized'0_spec : forall self : t_PtrOwn'0 . [%#sutil69] make_sized'0 self = self
  
  function insert'1 (self : t_FMap'0) (k : int) (v : t_PtrOwn'0) : t_FMap'0
  
  axiom insert'1_spec : forall self : t_FMap'0, k : int, v : t_PtrOwn'0 . ([%#sfmap56] view'1 (insert'1 self k v)
  = Map.set (view'1 self) k (C_Some'2 (make_sized'0 v)))
  && ([%#sfmap57] contains'1 self k  -> len'0 (insert'1 self k v) = len'0 self)
  && ([%#sfmap58] not contains'1 self k  -> len'0 (insert'1 self k v) = len'0 self + 1)
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'1 =
    [%#sfmap59] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  let rec insert_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (value:t_PtrOwn'0) (return'  (ret:t_Option'1))= {[@expl:insert_ghost 'self' type invariant] [%#sfmap32] inv'4 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap33] inv'2 value}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap34] inv'5 result}
      {[%#sfmap35] self.final = insert'1 self.current key value}
      {[%#sfmap36] result = get'0 self.current key}
      (! return' {result}) ]
  
  
  predicate resolve'8 (_1 : t_PtrOwn'0) =
    true
  
  predicate resolve'6 (self : t_Option'1) =
    [%#sresolve60] match self with
      | C_Some'1 x -> resolve'8 x
      | C_None'1 -> true
      end
  
  predicate resolve'2 (_1 : t_Option'1) =
    resolve'6 _1
  
  function insert'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) : Fset.fset t_Element'0 =
    [%#sfset37] Fset.add e self
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset40] Fset.mem e self
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap77] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap76] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find75] index_logic'3 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping61] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping61] Map.get self a
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping61] Map.get self a
  
  predicate invariant'10 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find73] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'15 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_UnionFind'0 [inv'15 x] . inv'15 x
  = (invariant'10 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'0 map
    end)
  
  predicate invariant'5 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant68] inv'15 self.current /\ inv'15 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  predicate resolve'7 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve55] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'7 _1
  
  type t_Ghost'1  =
    { t_Ghost__0'1: () }
  
  predicate inv'19 (_1 : ())
  
  axiom inv_axiom'18 [@rewrite] : forall x : () [inv'19 x] . inv'19 x = true
  
  function inner_logic'2 (self : t_Ghost'1) : ()
  
  predicate invariant'9 (self : t_Ghost'1) =
    [%#sghost62] inv'19 (inner_logic'2 self)
  
  predicate inv'14 (_1 : t_Ghost'1)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Ghost'1 [inv'14 x] . inv'14 x
  = (invariant'9 x
  /\ match x with
    | {t_Ghost__0'1 = a_0} -> true
    end)
  
  let rec new'2 (x:()) (return'  (ret:t_Ghost'1))= any
    [ return' (result:t_Ghost'1)-> {[%#sghost38] inv'14 result}
      {[%#sghost39] inner_logic'2 result = x}
      (! return' {result}) ]
  
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find43] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find41] inv'15 self)
   -> ([%#sunion_find42] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find46] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find44] inv'15 self)
   -> ([%#sunion_find45] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find49] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find47] inv'15 self)
   -> ([%#sunion_find48] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec make'0[#"union_find.rs" 170 8 170 54] (self:MutBorrow.t t_UnionFind'0) (value:t_T'0) (return'  (ret:t_Element'0))= {[@expl:make 'self' type invariant] [%#sunion_find5] inv'6 self}
    {[@expl:make 'value' type invariant] [%#sunion_find6] inv'7 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &value_snap <- [%#sunion_find0] value ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = new'0 (fun (_ret':t_PeanoInt'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &_12 <- C_Root'0 _13 value ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'1 {_12} (fun (_ret':tuple'0) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 =  [ &ptr <- _11._0'0 ] s1 | s1 =  [ &perm <- _11._1'0 ] s2 | s2 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &element <- { t_Element__0'0 = ptr } ] s1
      | s1 = into_inner'0 {perm} (fun (_ret':t_PtrOwn'0) ->  [ &perm1 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'0 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_mut <t_Ghost'0> {(self.current).t_UnionFind__map'0}
          (fun (_ret':MutBorrow.t t_Ghost'0) ->
             [ &_25 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_25} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 = {inv'1 _24.current}
        MutBorrow.borrow_final <t_FMap'0> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_23 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_24 <- { _24 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {element} (fun (_ret':int) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &_27 <- _28 ] s1
      | s1 = get_mut_ghost'0 {_23} {_27} (fun (_ret':t_Option'0) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = C_None'0} (! bb12) | br1 (x0:MutBorrow.t t_PtrOwn'0)-> {_22 = C_Some'0 x0} (! bb13) ] 
    | bb13 = s0
      [ s0 = v_Some'0 {_22} (fun (r0'0:MutBorrow.t t_PtrOwn'0) ->  [ &other_perm <- r0'0 ] s1)
      | s1 = {inv'2 other_perm.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {other_perm.current} {MutBorrow.get_id other_perm}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_32 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &other_perm <- { other_perm with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_34 <- perm1 ] s3
      | s3 = disjoint_lemma'0 {_32} {_34} (fun (_ret':()) ->  [ &_21 <- _ret' ] s4)
      | s4 = bb15 ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'3 other_perm} s1
      | s1 = -{resolve'0 other_perm}- s2
      | s2 = {[@expl:type invariant] inv'4 _24} s3
      | s3 = -{resolve'1 _24}- s4
      | s4 = bb16 ]
    
    | bb12 = bb14
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'4 _24} s1 | s1 = -{resolve'1 _24}- s2 | s2 = bb16 ] 
    | bb16 = s0
      [ s0 = {inv'0 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_Ghost'0>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Ghost'0) ->
             [ &_38 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_38} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_37 <- _ret' ] s2)
      | s2 = bb17 ]
    
    | bb17 = s0
      [ s0 = {inv'1 _37.current}
        MutBorrow.borrow_final <t_FMap'0> {_37.current} {MutBorrow.get_id _37}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_36 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_37 <- { _37 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {element} (fun (_ret':int) ->  [ &_39 <- _ret' ] s2)
      | s2 = bb18 ]
    
    | bb18 = s0
      [ s0 = insert_ghost'0 {_36} {_39} {perm1} (fun (_ret':t_Option'1) ->  [ &_35 <- _ret' ] s1)
      | s1 = {[@expl:type invariant] inv'5 _35} s2
      | s2 = -{resolve'2 _35}- s3
      | s3 = bb19 ]
    
    | bb19 = s0 [ s0 = {[@expl:type invariant] inv'4 _37} s1 | s1 = -{resolve'1 _37}- s2 | s2 = bb20 ] 
    | bb20 = s0
      [ s0 =  [ &_42 <- [%#sunion_find1] insert'0 (self.current).t_UnionFind__domain'0 element ] s1 | s1 = bb21 ]
    
    | bb21 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__domain'0 = _42 } } ] s1
      | s1 =  [ &_44 <- [%#sunion_find2] Map.set (self.current).t_UnionFind__values'0 element value_snap ] s2
      | s2 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _44 } } ] s1
      | s1 =  [ &_46 <- [%#sunion_find3] Map.set (self.current).t_UnionFind__distance'0 element 0 ] s2
      | s2 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _46 } } ] s1
      | s1 =  [ &_48 <- [%#sunion_find4] Map.set (self.current).t_UnionFind__root_of'0 element element ] s2
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _48 } } ] s1
      | s1 = {[@expl:type invariant] inv'6 self} s2
      | s2 = -{resolve'3 self}- s3
      | s3 = bb25 ]
    
    | bb25 = s0 [ s0 = new'2 {_18} (fun (_ret':t_Ghost'1) ->  [ &_17 <- _ret' ] s1) | s1 = bb26 ] 
    | bb26 = s0 [ s0 =  [ &_0 <- element ] s1 | s1 = bb27 ] 
    | bb27 = bb28
    | bb28 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & value : t_T'0 = value
    | & value_snap : t_T'0 = Any.any_l ()
    | & ptr : Opaque.ptr = Any.any_l ()
    | & perm : t_Ghost'2 = Any.any_l ()
    | & _11 : tuple'0 = Any.any_l ()
    | & _12 : t_Content'0 = Any.any_l ()
    | & _13 : t_PeanoInt'0 = Any.any_l ()
    | & element : t_Element'0 = Any.any_l ()
    | & _17 : t_Ghost'1 = Any.any_l ()
    | & _18 : () = Any.any_l ()
    | & perm1 : t_PtrOwn'0 = Any.any_l ()
    | & _21 : () = Any.any_l ()
    | & _22 : t_Option'0 = Any.any_l ()
    | & _23 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _25 : MutBorrow.t t_Ghost'0 = Any.any_l ()
    | & _27 : int = Any.any_l ()
    | & _28 : int = Any.any_l ()
    | & other_perm : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _32 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _34 : t_PtrOwn'0 = Any.any_l ()
    | & _35 : t_Option'1 = Any.any_l ()
    | & _36 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _38 : MutBorrow.t t_Ghost'0 = Any.any_l ()
    | & _39 : int = Any.any_l ()
    | & _42 : Fset.fset t_Element'0 = Any.any_l ()
    | & _44 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _46 : Map.map t_Element'0 int = Any.any_l ()
    | & _48 : Map.map t_Element'0 t_Element'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:make ensures #0] [%#sunion_find7] not contains'0 (domain'0 self.current) result}
      {[@expl:make ensures #1] [%#sunion_find8] domain'0 self.final = insert'0 (domain'0 self.current) result}
      {[@expl:make ensures #2] [%#sunion_find9] root_of'0 self.final = Map.set (root_of'0 self.current) result result}
      {[@expl:make ensures #3] [%#sunion_find10] values'0 self.final = Map.set (values'0 self.current) result value}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find_inner [#"union_find.rs" 196 8 196 64] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 196 27 196 31
  let%span sunion_find1 = "union_find.rs" 190 19 190 47
  let%span sunion_find2 = "union_find.rs" 191 18 191 48
  let%span sunion_find3 = "union_find.rs" 192 18 192 34
  let%span sunion_find4 = "union_find.rs" 194 18 194 54
  let%span sunion_find5 = "union_find.rs" 195 18 195 62
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 67 14 67 18
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 67 4 67 36
  let%span sghost8 = "../../creusot-contracts/src/ghost.rs" 66 14 66 46
  let%span sunion_find9 = "union_find.rs" 33 18 33 46
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span sghost15 = "../../creusot-contracts/src/ghost.rs" 191 15 191 16
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 191 4 191 28
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 189 14 189 26
  let%span sptr_own18 = "../../creusot-contracts/src/ptr_own.rs" 85 41 85 44
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 82 15 82 31
  let%span sptr_own20 = "../../creusot-contracts/src/ptr_own.rs" 85 4 85 70
  let%span sptr_own21 = "../../creusot-contracts/src/ptr_own.rs" 83 14 83 35
  let%span sghost22 = "../../creusot-contracts/src/ghost.rs" 84 22 84 26
  let%span sghost23 = "../../creusot-contracts/src/ghost.rs" 84 4 84 48
  let%span sghost24 = "../../creusot-contracts/src/ghost.rs" 82 14 82 46
  let%span sghost25 = "../../creusot-contracts/src/ghost.rs" 83 14 83 46
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own31 = "../../creusot-contracts/src/ptr_own.rs" 104 41 104 44
  let%span sptr_own32 = "../../creusot-contracts/src/ptr_own.rs" 99 15 99 31
  let%span sptr_own33 = "../../creusot-contracts/src/ptr_own.rs" 104 4 104 78
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 100 14 100 35
  let%span sptr_own35 = "../../creusot-contracts/src/ptr_own.rs" 102 14 102 53
  let%span sptr_own36 = "../../creusot-contracts/src/ptr_own.rs" 103 14 103 52
  let%span sfset37 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find38 = "union_find.rs" 128 19 128 28
  let%span sunion_find39 = "union_find.rs" 129 18 129 150
  let%span sunion_find40 = "union_find.rs" 126 8 126 16
  let%span smapping41 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find42 = "union_find.rs" 140 19 140 28
  let%span sunion_find43 = "union_find.rs" 141 18 141 98
  let%span sunion_find44 = "union_find.rs" 138 8 138 16
  let%span sunion_find45 = "union_find.rs" 160 16 162 52
  let%span sunion_find46 = "union_find.rs" 24 8 24 16
  let%span sfmap47 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap48 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap50 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sresolve51 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find52 = "union_find.rs" 149 19 149 28
  let%span sunion_find53 = "union_find.rs" 150 18 150 106
  let%span sunion_find54 = "union_find.rs" 147 8 147 16
  let%span sutil55 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil56 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sunion_find57 = "union_find.rs" 75 8 75 20
  let%span sghost58 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap59 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap60 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own61 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sinvariant62 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant63 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sunion_find64 = "union_find.rs" 120 8 120 16
  let%span sptr65 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr66 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sfmap67 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sboxed68 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap69 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'1  =
    { t_Ghost__0'1: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap60] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap49] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap47] get_unsized'0 self k <> C_None'2
  
  predicate inv'20 (_1 : int)
  
  axiom inv_axiom'19 [@rewrite] : forall x : int [inv'20 x] . inv'20 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr66] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr65] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sptr_own61] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'19 (_1 : t_T'0)
  
  predicate inv'6 (_1 : t_Content'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Content'0 [inv'6 x] . inv'6 x
  = match x with
    | C_Root'0 rank value -> inv'19 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'15 (self : t_Content'0) =
    [%#sboxed68] inv'6 self
  
  predicate inv'18 (_1 : t_Content'0)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_Content'0 [inv'18 x] . inv'18 x = invariant'15 x
  
  predicate inv'3 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PtrOwn'0 [inv'3 x] . inv'3 x
  = (invariant'3 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'18 val'
    end)
  
  predicate invariant'16 (self : t_PtrOwn'0) =
    [%#sboxed68] inv'3 self
  
  predicate inv'21 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_PtrOwn'0 [inv'21 x] . inv'21 x = invariant'16 x
  
  function unwrap'2 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'2_spec : forall op : t_Option'2 . ([%#sutil55] op <> C_None'2)
   -> ([%#sutil56] C_Some'2 (unwrap'2 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap48] unwrap'2 (get_unsized'0 self k)
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap59] forall k : int . contains'1 self k  -> inv'20 k /\ inv'21 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  function inner_logic'0 (self : t_Ghost'1) : t_FMap'0
  
  predicate invariant'1 (self : t_Ghost'1) =
    [%#sghost58] inv'2 (inner_logic'0 self)
  
  predicate inv'1 (_1 : t_Ghost'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'1 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'1 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant'8 (self : t_Ghost'1) =
    [%#sinvariant63] inv'1 self
  
  predicate inv'9 (_1 : t_Ghost'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Ghost'1 [inv'9 x] . inv'9 x = invariant'8 x
  
  predicate invariant'9 (self : t_FMap'0) =
    [%#sinvariant63] inv'2 self
  
  predicate inv'10 (_1 : t_FMap'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_FMap'0 [inv'10 x] . inv'10 x = invariant'9 x
  
  let rec deref'0 (self:t_Ghost'1) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost6] inv'9 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost7] inv'10 result}
      {[%#sghost8] inner_logic'0 self = result}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find46] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find9] result = deep_model'0 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate invariant'10 (self : t_PtrOwn'0) =
    [%#sinvariant63] inv'3 self
  
  predicate inv'12 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_PtrOwn'0 [inv'12 x] . inv'12 x = invariant'10 x
  
  predicate inv'11 (_1 : t_Option'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Option'0 [inv'11 x] . inv'11 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'12 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap10] inv'10 self}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap11] inv'11 result}
      {[%#sfmap12] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'11 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'12 result} {[%#soption14] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_PtrOwn'0 }
  
  function inner_logic'1 (self : t_Ghost'0) : t_PtrOwn'0
  
  predicate invariant'11 (self : t_Ghost'0) =
    [%#sghost58] inv'12 (inner_logic'1 self)
  
  predicate inv'13 (_1 : t_Ghost'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Ghost'0 [inv'13 x] . inv'13 x
  = (invariant'11 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'12 a_0
    end)
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_Ghost'0))= {[@expl:new 'x' type invariant] [%#sghost15] inv'12 x}
    any
    [ return' (result:t_Ghost'0)-> {[%#sghost16] inv'13 result}
      {[%#sghost17] inner_logic'1 result = x}
      (! return' {result}) ]
  
  
  predicate invariant'12 (self : t_Content'0) =
    [%#sinvariant63] inv'6 self
  
  predicate inv'14 (_1 : t_Content'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_Content'0 [inv'14 x] . inv'14 x = invariant'12 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_Ghost'0) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own18] inv'13 own}
    {[@expl:as_ref requires] [%#sptr_own19] ptr = ptr'0 (inner_logic'1 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own20] inv'14 result}
      {[%#sptr_own21] result = val'0 (inner_logic'1 own)}
      (! return' {result}) ]
  
  
  let rec v_Link'0 (input:t_Content'0) (ret  (field_0:t_Element'0))= any
    [ good (field_0:t_Element'0)-> {C_Link'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Element'0 [C_Link'0 field_0 : t_Content'0] . C_Link'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset37] Fset.mem e self
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap69] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap67] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find64] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'2 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping41] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping41] Map.get self a
  
  function index_logic'1 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping41] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find57] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'2 self.t_UnionFind__values'0 e
    = index_logic'2 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'2 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'1 self.t_UnionFind__distance'0 e < index_logic'1 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'1 self.t_UnionFind__distance'0 e
    /\ index_logic'1 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  predicate invariant'13 (self : MutBorrow.t t_Ghost'1) =
    [%#sinvariant62] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'15 (_1 : MutBorrow.t t_Ghost'1)
  
  axiom inv_axiom'15 [@rewrite] : forall x : MutBorrow.t t_Ghost'1 [inv'15 x] . inv'15 x = invariant'13 x
  
  predicate invariant'4 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant62] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_Ghost'1) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost22] inv'15 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost23] inv'4 result}
      {[%#sghost24] result.current = inner_logic'0 self.current}
      {[%#sghost25] result.final = inner_logic'0 self.final}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'5 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant62] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'5 x
  
  predicate inv'16 (_1 : t_Option'1)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_Option'1 [inv'16 x] . inv'16 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap50] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap26] inv'4 self}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap27] inv'16 result}
      {[%#sfmap28] if contains'1 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap29] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap30] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'1) (return'  (ret:MutBorrow.t t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'16 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_PtrOwn'0)-> {inv'5 result}
      {[%#soption14] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  type t_Ghost'2  =
    { t_Ghost__0'2: MutBorrow.t t_PtrOwn'0 }
  
  function inner_logic'2 (self : t_Ghost'2) : MutBorrow.t t_PtrOwn'0
  
  predicate invariant'14 (self : t_Ghost'2) =
    [%#sghost58] inv'5 (inner_logic'2 self)
  
  predicate inv'17 (_1 : t_Ghost'2)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_Ghost'2 [inv'17 x] . inv'17 x
  = (invariant'14 x
  /\ match x with
    | {t_Ghost__0'2 = a_0} -> inv'5 a_0
    end)
  
  let rec new'1 (x:MutBorrow.t t_PtrOwn'0) (return'  (ret:t_Ghost'2))= {[@expl:new 'x' type invariant] [%#sghost15] inv'5 x}
    any
    [ return' (result:t_Ghost'2)-> {[%#sghost16] inv'17 result}
      {[%#sghost17] inner_logic'2 result = x}
      (! return' {result}) ]
  
  
  predicate resolve'4 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_FMap'0) =
    resolve'4 _1
  
  predicate resolve'5 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'5 _1
  
  predicate invariant'6 (self : MutBorrow.t t_Content'0) =
    [%#sinvariant62] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  let rec as_mut'0 (ptr:Opaque.ptr) (own:t_Ghost'2) (return'  (ret:MutBorrow.t t_Content'0))= {[@expl:as_mut 'own' type invariant] [%#sptr_own31] inv'17 own}
    {[@expl:as_mut requires] [%#sptr_own32] ptr = ptr'0 (inner_logic'2 own).current}
    any
    [ return' (result:MutBorrow.t t_Content'0)-> {[%#sptr_own33] inv'7 result}
      {[%#sptr_own34] result.current = val'0 (inner_logic'2 own).current}
      {[%#sptr_own35] ptr'0 (inner_logic'2 own).final = ptr'0 (inner_logic'2 own).current}
      {[%#sptr_own36] val'0 (inner_logic'2 own).final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t t_Content'0) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Content'0) =
    resolve'6 _1
  
  predicate invariant'7 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant62] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'8 x] . inv'8 x = invariant'7 x
  
  predicate resolve'7 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve51] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'7 _1
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find40] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find38] inv'0 self)
   -> ([%#sunion_find39] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find44] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find42] inv'0 self)
   -> ([%#sunion_find43] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find54] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find52] inv'0 self)
   -> ([%#sunion_find53] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'2 (values'0 self) e = index_logic'2 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 158 8 158 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find45] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  meta "compute_max_steps" 1000000
  
  let rec find_inner'0[#"union_find.rs" 196 8 196 64] (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find_inner 'self' type invariant] [%#sunion_find0] inv'8 self}
    {[@expl:find_inner requires] [%#sunion_find1] contains'0 (domain'0 self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = deref'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_12 <- _ret' ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = addr'0 {elem} (fun (_ret':int) ->  [ &_16 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_15 <- _16 ] s1
      | s1 = get_ghost'0 {_12} {_15} (fun (_ret':t_Option'0) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':t_PtrOwn'0) ->  [ &_9 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'0 {_9} (fun (_ret':t_Ghost'0) ->  [ &perm <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = as_ref'0 {elem.t_Element__0'0} {perm} (fun (_ret':t_Content'0) ->  [ &value <- _ret' ] s1) | s1 = bb6 ]
    
    | bb6 = any
      [ br0 (x0:t_PeanoInt'0) (x1:t_T'0)-> {value = C_Root'0 x0 x1} (! bb8)
      | br1 (x0:t_Element'0)-> {value = C_Link'0 x0} (! bb9) ]
    
    | bb9 = s0
      [ s0 = v_Link'0 {value} (fun (r0'0:t_Element'0) ->  [ &e <- r0'0 ] s1)
      | s1 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_24 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = find_inner'0 {_24} {e} (fun (_ret':t_Element'0) ->  [ &root <- _ret' ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'1 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_Ghost'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Ghost'1) ->
             [ &_32 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_32} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0
      [ s0 = {inv'2 _31.current}
        MutBorrow.borrow_final <t_FMap'0> {_31.current} {MutBorrow.get_id _31}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_30 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_31 <- { _31 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {elem} (fun (_ret':int) ->  [ &_35 <- _ret' ] s2)
      | s2 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_34 <- _35 ] s1
      | s1 = get_mut_ghost'0 {_30} {_34} (fun (_ret':t_Option'1) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'1 {_29} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_28 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = {inv'3 _28.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_27 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_28 <- { _28 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_27} (fun (_ret':t_Ghost'2) ->  [ &mut_perm <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'4 _31} s1
      | s1 = -{resolve'0 _31}- s2
      | s2 = {[@expl:type invariant] inv'5 _28} s3
      | s3 = -{resolve'1 _28}- s4
      | s4 =  [ &_38 <- C_Link'0 root ] s5
      | s5 = as_mut'0 {elem.t_Element__0'0} {mut_perm} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_40 <- _ret' ] s6)
      | s6 = bb17 ]
    
    | bb17 = bb18
    | bb18 = s0
      [ s0 = {[@expl:type invariant] match _40 with
          | {current = x'0} -> inv'6 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_40 <- { _40 with current = _38 } ] s2
      | s2 = {[@expl:type invariant] inv'7 _40} s3
      | s3 = -{resolve'2 _40}- s4
      | s4 = {[@expl:type invariant] inv'8 self} s5
      | s5 = -{resolve'3 self}- s6
      | s6 = bb20 ]
    
    | bb20 = s0 [ s0 =  [ &_0 <- root ] s1 | s1 = bb21 ] 
    | bb8 = bb10
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'8 self} s1
      | s1 = -{resolve'3 self}- s2
      | s2 =  [ &_0 <- elem ] s3
      | s3 = bb21 ]
    
    | bb21 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & perm : t_Ghost'0 = Any.any_l ()
    | & _9 : t_PtrOwn'0 = Any.any_l ()
    | & _10 : t_Option'0 = Any.any_l ()
    | & _12 : t_FMap'0 = Any.any_l ()
    | & _15 : int = Any.any_l ()
    | & _16 : int = Any.any_l ()
    | & value : t_Content'0 = Any.any_l ()
    | & e : t_Element'0 = Any.any_l ()
    | & root : t_Element'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & mut_perm : t_Ghost'2 = Any.any_l ()
    | & _27 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _28 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _29 : t_Option'1 = Any.any_l ()
    | & _30 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _31 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _32 : MutBorrow.t t_Ghost'1 = Any.any_l ()
    | & _34 : int = Any.any_l ()
    | & _35 : int = Any.any_l ()
    | & _38 : t_Content'0 = Any.any_l ()
    | & _40 : MutBorrow.t t_Content'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:find_inner ensures #0] [%#sunion_find2] result
      = index_logic'0 (root_of'0 self.current) elem}
      {[@expl:find_inner ensures #1] [%#sunion_find3] unchanged'0 self}
      {[@expl:find_inner ensures #2] [%#sunion_find4] (self.final).t_UnionFind__distance'0
      = (self.current).t_UnionFind__distance'0}
      {[@expl:find_inner ensures #3] [%#sunion_find5] index_logic'1 (self.current).t_UnionFind__distance'0 result
      >= index_logic'1 (self.current).t_UnionFind__distance'0 elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find [#"union_find.rs" 215 8 215 62] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 215 25 215 29
  let%span sunion_find1 = "union_find.rs" 212 19 212 47
  let%span sunion_find2 = "union_find.rs" 213 18 213 48
  let%span sunion_find3 = "union_find.rs" 214 18 214 34
  let%span sunion_find4 = "union_find.rs" 196 27 196 31
  let%span sunion_find5 = "union_find.rs" 190 19 190 47
  let%span sunion_find6 = "union_find.rs" 191 18 191 48
  let%span sunion_find7 = "union_find.rs" 192 18 192 34
  let%span sunion_find8 = "union_find.rs" 194 18 194 54
  let%span sunion_find9 = "union_find.rs" 195 18 195 62
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find11 = "union_find.rs" 128 19 128 28
  let%span sunion_find12 = "union_find.rs" 129 18 129 150
  let%span sunion_find13 = "union_find.rs" 126 8 126 16
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find15 = "union_find.rs" 140 19 140 28
  let%span sunion_find16 = "union_find.rs" 141 18 141 98
  let%span sunion_find17 = "union_find.rs" 138 8 138 16
  let%span sunion_find18 = "union_find.rs" 160 16 162 52
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find20 = "union_find.rs" 24 8 24 16
  let%span sunion_find21 = "union_find.rs" 149 19 149 28
  let%span sunion_find22 = "union_find.rs" 150 18 150 106
  let%span sunion_find23 = "union_find.rs" 147 8 147 16
  let%span sunion_find24 = "union_find.rs" 75 8 75 20
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find27 = "union_find.rs" 120 8 120 16
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost30 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil35 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed37 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr39 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr40 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset10] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find20] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap31] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap28] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil35] op <> C_None'0)
   -> ([%#sutil36] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap33] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap29] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find27] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'2 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'1 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find24] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'2 self.t_UnionFind__values'0 e
    = index_logic'2 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'2 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'1 self.t_UnionFind__distance'0 e < index_logic'1 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'1 self.t_UnionFind__distance'0 e
    /\ index_logic'1 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr40] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr39] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own38] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed37] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed37] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap34] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Ghost'0) =
    [%#sghost30] inv'3 (inner_logic'0 self)
  
  predicate inv'2 (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find13] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find11] inv'0 self)
   -> ([%#sunion_find12] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find17] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find15] inv'0 self)
   -> ([%#sunion_find16] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'2 (values'0 self) e = index_logic'2 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 158 8 158 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find18] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find_inner'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find_inner 'self' type invariant] [%#sunion_find4] inv'1 self}
    {[@expl:find_inner requires] [%#sunion_find5] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find6] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find7] unchanged'0 self}
      {[%#sunion_find8] (self.final).t_UnionFind__distance'0 = (self.current).t_UnionFind__distance'0}
      {[%#sunion_find9] index_logic'1 (self.current).t_UnionFind__distance'0 result
      >= index_logic'1 (self.current).t_UnionFind__distance'0 elem}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec find'0[#"union_find.rs" 215 8 215 62] (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:find requires] [%#sunion_find1] contains'0 (domain'0 self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find_inner'0 {_6} {elem} (fun (_ret':t_Element'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & _6 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:find ensures #0] [%#sunion_find2] result
      = index_logic'0 (root_of'0 self.current) elem}
      {[@expl:find ensures #1] [%#sunion_find3] unchanged'0 self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__get [#"union_find.rs" 225 8 225 49] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 225 20 225 24
  let%span sunion_find1 = "union_find.rs" 222 19 222 47
  let%span sunion_find2 = "union_find.rs" 223 19 223 47
  let%span sunion_find3 = "union_find.rs" 225 47 225 49
  let%span sunion_find4 = "union_find.rs" 224 18 224 48
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 67 14 67 18
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 67 4 67 36
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 66 14 66 46
  let%span sunion_find8 = "union_find.rs" 33 18 33 46
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span sghost14 = "../../creusot-contracts/src/ghost.rs" 191 15 191 16
  let%span sghost15 = "../../creusot-contracts/src/ghost.rs" 191 4 191 28
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 189 14 189 26
  let%span sptr_own17 = "../../creusot-contracts/src/ptr_own.rs" 85 41 85 44
  let%span sptr_own18 = "../../creusot-contracts/src/ptr_own.rs" 82 15 82 31
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 85 4 85 70
  let%span sptr_own20 = "../../creusot-contracts/src/ptr_own.rs" 83 14 83 35
  let%span sfset21 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find22 = "union_find.rs" 128 19 128 28
  let%span sunion_find23 = "union_find.rs" 129 18 129 150
  let%span sunion_find24 = "union_find.rs" 126 8 126 16
  let%span smapping25 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find26 = "union_find.rs" 140 19 140 28
  let%span sunion_find27 = "union_find.rs" 141 18 141 98
  let%span sunion_find28 = "union_find.rs" 138 8 138 16
  let%span sunion_find29 = "union_find.rs" 149 19 149 28
  let%span sunion_find30 = "union_find.rs" 150 18 150 106
  let%span sunion_find31 = "union_find.rs" 147 8 147 16
  let%span sunion_find32 = "union_find.rs" 24 8 24 16
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil37 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sinvariant38 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap39 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sghost40 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sunion_find41 = "union_find.rs" 75 8 75 20
  let%span sunion_find42 = "union_find.rs" 120 8 120 16
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own45 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sfmap46 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sptr47 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr48 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sboxed49 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'1  =
    { t_Ghost__0'1: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'1
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap39] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'1 =
    [%#sfmap35] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap33] get_unsized'0 self k <> C_None'1
  
  predicate inv'15 (_1 : int)
  
  axiom inv_axiom'14 [@rewrite] : forall x : int [inv'15 x] . inv'15 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr48] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr47] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'10 (self : t_PtrOwn'0) =
    [%#sptr_own45] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'13 (_1 : t_Content'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Content'0 [inv'13 x] . inv'13 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'11 (self : t_Content'0) =
    [%#sboxed49] inv'13 self
  
  predicate inv'14 (_1 : t_Content'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Content'0 [inv'14 x] . inv'14 x = invariant'11 x
  
  predicate inv'12 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_PtrOwn'0 [inv'12 x] . inv'12 x
  = (invariant'10 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'14 val'
    end)
  
  predicate invariant'12 (self : t_PtrOwn'0) =
    [%#sboxed49] inv'12 self
  
  predicate inv'16 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_PtrOwn'0 [inv'16 x] . inv'16 x = invariant'12 x
  
  function unwrap'1 (op : t_Option'1) : t_PtrOwn'0
  
  axiom unwrap'1_spec : forall op : t_Option'1 . ([%#sutil36] op <> C_None'1)
   -> ([%#sutil37] C_Some'1 (unwrap'1 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap34] unwrap'1 (get_unsized'0 self k)
  
  predicate invariant'9 (self : t_FMap'0) =
    [%#sfmap44] forall k : int . contains'1 self k  -> inv'15 k /\ inv'16 (lookup_unsized'0 self k)
  
  predicate inv'11 (_1 : t_FMap'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_FMap'0 [inv'11 x] . inv'11 x = invariant'9 x
  
  function inner_logic'0 (self : t_Ghost'1) : t_FMap'0
  
  predicate invariant'8 (self : t_Ghost'1) =
    [%#sghost40] inv'11 (inner_logic'0 self)
  
  predicate inv'9 (_1 : t_Ghost'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Ghost'1 [inv'9 x] . inv'9 x
  = (invariant'8 x
  /\ match x with
    | {t_Ghost__0'1 = a_0} -> inv'11 a_0
    end)
  
  predicate invariant'2 (self : t_Ghost'1) =
    [%#sinvariant38] inv'9 self
  
  predicate inv'2 (_1 : t_Ghost'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'1 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sinvariant38] inv'11 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  let rec deref'0 (self:t_Ghost'1) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost5] inv'2 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost6] inv'3 result}
      {[%#sghost7] inner_logic'0 self = result}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find32] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find8] result = deep_model'0 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sinvariant38] inv'12 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate inv'4 (_1 : t_Option'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_Option'0 [inv'4 x] . inv'4 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'5 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap9] inv'3 self}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap10] inv'4 result}
      {[%#sfmap11] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'4 self}
    {[@expl:unwrap requires] [%#soption12] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'5 result} {[%#soption13] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_PtrOwn'0 }
  
  function inner_logic'1 (self : t_Ghost'0) : t_PtrOwn'0
  
  predicate invariant'5 (self : t_Ghost'0) =
    [%#sghost40] inv'5 (inner_logic'1 self)
  
  predicate inv'6 (_1 : t_Ghost'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Ghost'0 [inv'6 x] . inv'6 x
  = (invariant'5 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'5 a_0
    end)
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_Ghost'0))= {[@expl:new 'x' type invariant] [%#sghost14] inv'5 x}
    any
    [ return' (result:t_Ghost'0)-> {[%#sghost15] inv'6 result}
      {[%#sghost16] inner_logic'1 result = x}
      (! return' {result}) ]
  
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sinvariant38] inv'13 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_Ghost'0) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own17] inv'6 own}
    {[@expl:as_ref requires] [%#sptr_own18] ptr = ptr'0 (inner_logic'1 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own19] inv'7 result}
      {[%#sptr_own20] result = val'0 (inner_logic'1 own)}
      (! return' {result}) ]
  
  
  let rec v_Root'0 (input:t_Content'0) (ret  (rank:t_PeanoInt'0) (value:t_T'0))= any
    [ good (rank:t_PeanoInt'0) (value:t_T'0)-> {C_Root'0 rank value = input} (! ret {rank} {value})
    | bad -> {forall rank : t_PeanoInt'0, value : t_T'0 [C_Root'0 rank value : t_Content'0] . C_Root'0 rank value
      <> input}
      (! {false}
      any) ]
  
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset21] Fset.mem e self
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap46] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap43] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find42] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping25] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping25] Map.get self a
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping25] Map.get self a
  
  predicate invariant'7 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find41] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'8 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_UnionFind'0 [inv'8 x] . inv'8 x
  = (invariant'7 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'9 map
    end)
  
  predicate invariant'0 (self : t_UnionFind'0) =
    [%#sinvariant38] inv'8 self
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find24] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find22] inv'8 self)
   -> ([%#sunion_find23] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find28] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find26] inv'8 self)
   -> ([%#sunion_find27] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate invariant'1 (self : t_T'0) =
    [%#sinvariant38] inv'10 self
  
  predicate inv'1 (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find31] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find29] inv'8 self)
   -> ([%#sunion_find30] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec get'0[#"union_find.rs" 225 8 225 49] (self:t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_T'0))= {[@expl:get 'self' type invariant] [%#sunion_find0] inv'0 self}
    {[@expl:get requires #0] [%#sunion_find1] contains'0 (domain'0 self) elem}
    {[@expl:get requires #1] [%#sunion_find2] index_logic'0 (root_of'0 self) elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref'0 {self.t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_10 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = addr'0 {elem} (fun (_ret':int) ->  [ &_14 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_13 <- _14 ] s1
      | s1 = get_ghost'0 {_10} {_13} (fun (_ret':t_Option'0) ->  [ &_8 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_8} (fun (_ret':t_PtrOwn'0) ->  [ &_7 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'0 {_7} (fun (_ret':t_Ghost'0) ->  [ &perm <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = as_ref'0 {elem.t_Element__0'0} {perm} (fun (_ret':t_Content'0) ->  [ &_16 <- _ret' ] s1) | s1 = bb6 ]
    
    | bb6 = any
      [ br0 (x0:t_PeanoInt'0) (x1:t_T'0)-> {_16 = C_Root'0 x0 x1} (! bb8)
      | br1 (x0:t_Element'0)-> {_16 = C_Link'0 x0} (! bb7) ]
    
    | bb7 = bb10
    | bb10 = bb10 [ bb10 = (! bb11) [ bb11 = bb10 ]  ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = v_Root'0 {_16} (fun (rrank'0:t_PeanoInt'0) (rvalue'0:t_T'0) ->  [ &value <- rvalue'0 ] s1)
      | s1 =  [ &_0 <- value ] s2
      | s2 = return' {_0} ]
     ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self : t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & perm : t_Ghost'0 = Any.any_l ()
    | & _7 : t_PtrOwn'0 = Any.any_l ()
    | & _8 : t_Option'0 = Any.any_l ()
    | & _10 : t_FMap'0 = Any.any_l ()
    | & _13 : int = Any.any_l ()
    | & _14 : int = Any.any_l ()
    | & _16 : t_Content'0 = Any.any_l ()
    | & value : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:get result type invariant] [%#sunion_find3] inv'1 result}
      {[@expl:get ensures] [%#sunion_find4] result = index_logic'1 (values'0 self) elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__equiv [#"union_find.rs" 238 8 238 71] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 238 26 238 30
  let%span sunion_find1 = "union_find.rs" 234 19 234 48
  let%span sunion_find2 = "union_find.rs" 235 19 235 48
  let%span sunion_find3 = "union_find.rs" 236 18 236 70
  let%span sunion_find4 = "union_find.rs" 237 18 237 34
  let%span sunion_find5 = "union_find.rs" 215 25 215 29
  let%span sunion_find6 = "union_find.rs" 212 19 212 47
  let%span sunion_find7 = "union_find.rs" 213 18 213 48
  let%span sunion_find8 = "union_find.rs" 214 18 214 34
  let%span sptr9 = "../../creusot-contracts/src/std/ptr.rs" 131 22 131 66
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find11 = "union_find.rs" 128 19 128 28
  let%span sunion_find12 = "union_find.rs" 129 18 129 150
  let%span sunion_find13 = "union_find.rs" 126 8 126 16
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find15 = "union_find.rs" 140 19 140 28
  let%span sunion_find16 = "union_find.rs" 141 18 141 98
  let%span sunion_find17 = "union_find.rs" 138 8 138 16
  let%span sunion_find18 = "union_find.rs" 160 16 162 52
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find20 = "union_find.rs" 24 8 24 16
  let%span sunion_find21 = "union_find.rs" 149 19 149 28
  let%span sunion_find22 = "union_find.rs" 150 18 150 106
  let%span sunion_find23 = "union_find.rs" 147 8 147 16
  let%span sunion_find24 = "union_find.rs" 75 8 75 20
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find27 = "union_find.rs" 120 8 120 16
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost30 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil35 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed37 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr39 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr40 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset10] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find20] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap31] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap28] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil35] op <> C_None'0)
   -> ([%#sutil36] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap33] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap29] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find27] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find24] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr40] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr39] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own38] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed37] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed37] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap34] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Ghost'0) =
    [%#sghost30] inv'3 (inner_logic'0 self)
  
  predicate inv'2 (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find13] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find11] inv'0 self)
   -> ([%#sunion_find12] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find17] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find15] inv'0 self)
   -> ([%#sunion_find16] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 158 8 158 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find18] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find5] inv'1 self}
    {[@expl:find requires] [%#sunion_find6] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find7] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find8] unchanged'0 self}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  let rec addr_eq'0 (p:Opaque.ptr) (q:Opaque.ptr) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sptr9] result = (addr_logic'0 p = addr_logic'0 q)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec equiv'0[#"union_find.rs" 238 8 238 71] (self:MutBorrow.t t_UnionFind'0) (e1:t_Element'0) (e2:t_Element'0) (return'  (ret:bool))= {[@expl:equiv 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:equiv requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) e1}
    {[@expl:equiv requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_9} {e1} (fun (_ret':t_Element'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_12 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_12} {e2} (fun (_ret':t_Element'0) ->  [ &r2 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = addr_eq'0 {r1.t_Element__0'0} {r2.t_Element__0'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & e1 : t_Element'0 = e1
    | & e2 : t_Element'0 = e2
    | & r1 : t_Element'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & r2 : t_Element'0 = Any.any_l ()
    | & _12 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:equiv ensures #0] [%#sunion_find3] result
      = (index_logic'0 (root_of'0 self.current) e1 = index_logic'0 (root_of'0 self.current) e2)}
      {[@expl:equiv ensures #1] [%#sunion_find4] unchanged'0 self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__link [#"union_find.rs" 275 8 275 70] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 293 20 293 93
  let%span sunion_find1 = "union_find.rs" 295 20 295 94
  let%span sunion_find2 = "union_find.rs" 296 33 296 63
  let%span sunion_find3 = "union_find.rs" 298 20 298 95
  let%span sunion_find4 = "union_find.rs" 311 20 311 93
  let%span sunion_find5 = "union_find.rs" 313 20 313 94
  let%span sunion_find6 = "union_find.rs" 314 33 314 63
  let%span sunion_find7 = "union_find.rs" 316 20 316 95
  let%span sunion_find8 = "union_find.rs" 275 21 275 25
  let%span sunion_find9 = "union_find.rs" 254 19 254 44
  let%span sunion_find10 = "union_find.rs" 255 19 255 41
  let%span sunion_find11 = "union_find.rs" 256 19 256 44
  let%span sunion_find12 = "union_find.rs" 257 19 257 41
  let%span sunion_find13 = "union_find.rs" 258 18 258 54
  let%span sunion_find14 = "union_find.rs" 259 18 259 82
  let%span sunion_find15 = "union_find.rs" 260 18 260 53
  let%span sunion_find16 = "union_find.rs" 261 18 266 13
  let%span sunion_find17 = "union_find.rs" 268 18 273 13
  let%span sunion_find18 = "union_find.rs" 17 18 17 69
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 67 14 67 18
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 67 4 67 36
  let%span sghost21 = "../../creusot-contracts/src/ghost.rs" 66 14 66 46
  let%span sunion_find22 = "union_find.rs" 33 18 33 46
  let%span sfmap23 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap24 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption27 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span sghost28 = "../../creusot-contracts/src/ghost.rs" 191 15 191 16
  let%span sghost29 = "../../creusot-contracts/src/ghost.rs" 191 4 191 28
  let%span sghost30 = "../../creusot-contracts/src/ghost.rs" 189 14 189 26
  let%span sptr_own31 = "../../creusot-contracts/src/ptr_own.rs" 85 41 85 44
  let%span sptr_own32 = "../../creusot-contracts/src/ptr_own.rs" 82 15 82 31
  let%span sptr_own33 = "../../creusot-contracts/src/ptr_own.rs" 85 4 85 70
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 83 14 83 35
  let%span speano35 = "../../creusot-contracts/src/peano.rs" 80 14 80 30
  let%span sghost36 = "../../creusot-contracts/src/ghost.rs" 84 22 84 26
  let%span sghost37 = "../../creusot-contracts/src/ghost.rs" 84 4 84 48
  let%span sghost38 = "../../creusot-contracts/src/ghost.rs" 82 14 82 46
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 83 14 83 46
  let%span sfmap40 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap42 = "../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own45 = "../../creusot-contracts/src/ptr_own.rs" 104 41 104 44
  let%span sptr_own46 = "../../creusot-contracts/src/ptr_own.rs" 99 15 99 31
  let%span sptr_own47 = "../../creusot-contracts/src/ptr_own.rs" 104 4 104 78
  let%span sptr_own48 = "../../creusot-contracts/src/ptr_own.rs" 100 14 100 35
  let%span sptr_own49 = "../../creusot-contracts/src/ptr_own.rs" 102 14 102 53
  let%span sptr_own50 = "../../creusot-contracts/src/ptr_own.rs" 103 14 103 52
  let%span smapping51 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span speano52 = "../../creusot-contracts/src/peano.rs" 70 14 70 38
  let%span sfset53 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find54 = "union_find.rs" 128 19 128 28
  let%span sunion_find55 = "union_find.rs" 129 18 129 150
  let%span sunion_find56 = "union_find.rs" 126 8 126 16
  let%span sunion_find57 = "union_find.rs" 140 19 140 28
  let%span sunion_find58 = "union_find.rs" 141 18 141 98
  let%span sunion_find59 = "union_find.rs" 138 8 138 16
  let%span sunion_find60 = "union_find.rs" 250 12 250 50
  let%span sunion_find61 = "union_find.rs" 149 19 149 28
  let%span sunion_find62 = "union_find.rs" 150 18 150 106
  let%span sunion_find63 = "union_find.rs" 147 8 147 16
  let%span smodel64 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sresolve65 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find66 = "union_find.rs" 24 8 24 16
  let%span sfmap67 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap68 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost69 = "../../creusot-contracts/src/ghost.rs" 117 8 117 36
  let%span sfmap70 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap71 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sinvariant72 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sutil73 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil74 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sghost75 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap76 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap77 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own78 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sinvariant79 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sptr80 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr81 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sunion_find82 = "union_find.rs" 75 8 75 20
  let%span sboxed83 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find84 = "union_find.rs" 120 8 120 16
  let%span sfmap85 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap86 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'1 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find66] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel64] deep_model'1 self
  
  let rec eq'0 (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sunion_find18] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_Ghost'1  =
    { t_Ghost__0'1: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset53] Fset.mem e self
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  function view'1 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'1_spec : forall self : t_FMap'0 . [%#sfmap77] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap70] Map.get (view'1 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap67] get_unsized'0 self k <> C_None'2
  
  function inner_logic'0 (self : t_Ghost'1) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'2 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'2_spec : forall op : t_Option'2 . ([%#sutil73] op <> C_None'2)
   -> ([%#sutil74] C_Some'2 (unwrap'2 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap68] unwrap'2 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap86] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap85] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find84] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'1 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping51] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping51] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping51] Map.get self a
  
  predicate invariant'14 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find82] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'1 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'20 (_1 : int)
  
  axiom inv_axiom'19 [@rewrite] : forall x : int [inv'20 x] . inv'20 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr81] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr80] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own78] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'19 (_1 : t_T'0)
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x
  = match x with
    | C_Root'0 rank value -> inv'19 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'15 (self : t_Content'0) =
    [%#sboxed83] inv'7 self
  
  predicate inv'18 (_1 : t_Content'0)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_Content'0 [inv'18 x] . inv'18 x = invariant'15 x
  
  predicate inv'4 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'18 val'
    end)
  
  predicate invariant'16 (self : t_PtrOwn'0) =
    [%#sboxed83] inv'4 self
  
  predicate inv'21 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_PtrOwn'0 [inv'21 x] . inv'21 x = invariant'16 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap76] forall k : int . contains'1 self k  -> inv'20 k /\ inv'21 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Ghost'1) =
    [%#sghost75] inv'3 (inner_logic'0 self)
  
  predicate inv'2 (_1 : t_Ghost'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'1 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'1 = a_0} -> inv'3 a_0
    end)
  
  predicate inv'17 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_UnionFind'0 [inv'17 x] . inv'17 x
  = (invariant'14 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'0 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant72] inv'17 self.current /\ inv'17 self.final
  
  predicate inv'0 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'6 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve65] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'6 _1
  
  predicate invariant'8 (self : t_Ghost'1) =
    [%#sinvariant79] inv'2 self
  
  predicate inv'9 (_1 : t_Ghost'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Ghost'1 [inv'9 x] . inv'9 x = invariant'8 x
  
  predicate invariant'9 (self : t_FMap'0) =
    [%#sinvariant79] inv'3 self
  
  predicate inv'10 (_1 : t_FMap'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_FMap'0 [inv'10 x] . inv'10 x = invariant'9 x
  
  let rec deref'0 (self:t_Ghost'1) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost19] inv'9 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost20] inv'10 result}
      {[%#sghost21] inner_logic'0 self = result}
      (! return' {result}) ]
  
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find22] result = deep_model'1 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate invariant'10 (self : t_PtrOwn'0) =
    [%#sinvariant79] inv'4 self
  
  predicate inv'12 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_PtrOwn'0 [inv'12 x] . inv'12 x = invariant'10 x
  
  predicate inv'11 (_1 : t_Option'0)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_Option'0 [inv'11 x] . inv'11 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'12 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap23] inv'10 self}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap24] inv'11 result}
      {[%#sfmap25] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'11 self}
    {[@expl:unwrap requires] [%#soption26] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'12 result} {[%#soption27] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_PtrOwn'0 }
  
  function inner_logic'1 (self : t_Ghost'0) : t_PtrOwn'0
  
  predicate invariant'1 (self : t_Ghost'0) =
    [%#sghost75] inv'12 (inner_logic'1 self)
  
  predicate inv'1 (_1 : t_Ghost'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Ghost'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'12 a_0
    end)
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_Ghost'0))= {[@expl:new 'x' type invariant] [%#sghost28] inv'12 x}
    any
    [ return' (result:t_Ghost'0)-> {[%#sghost29] inv'1 result}
      {[%#sghost30] inner_logic'1 result = x}
      (! return' {result}) ]
  
  
  predicate invariant'11 (self : t_Content'0) =
    [%#sinvariant79] inv'7 self
  
  predicate inv'13 (_1 : t_Content'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_Content'0 [inv'13 x] . inv'13 x = invariant'11 x
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_Ghost'0) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own31] inv'1 own}
    {[@expl:as_ref requires] [%#sptr_own32] ptr = ptr'0 (inner_logic'1 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own33] inv'13 result}
      {[%#sptr_own34] result = val'0 (inner_logic'1 own)}
      (! return' {result}) ]
  
  
  predicate resolve'12 (_1 : t_PtrOwn'0) =
    true
  
  predicate resolve'7 (self : t_Ghost'0) =
    [%#sghost69] resolve'12 (inner_logic'1 self)
  
  predicate resolve'1 (_1 : t_Ghost'0) =
    resolve'7 _1
  
  let rec v_Root'0 (input:t_Content'0) (ret  (rank:t_PeanoInt'0) (value:t_T'0))= any
    [ good (rank:t_PeanoInt'0) (value:t_T'0)-> {C_Root'0 rank value = input} (! ret {rank} {value})
    | bad -> {forall rank : t_PeanoInt'0, value : t_T'0 [C_Root'0 rank value : t_Content'0] . C_Root'0 rank value
      <> input}
      (! {false}
      any) ]
  
  
  function view'0 (self : t_PeanoInt'0) : int
  
  let rec to_u64'0 (self:t_PeanoInt'0) (return'  (ret:UInt64.t))= any
    [ return' (result:UInt64.t)-> {[%#speano35] UInt64.t'int result = view'0 self} (! return' {result}) ]
  
  
  type tuple'0  =
    { _0'0: UInt64.t; _1'0: t_T'0 }
  
  predicate invariant'12 (self : MutBorrow.t t_Ghost'1) =
    [%#sinvariant72] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'14 (_1 : MutBorrow.t t_Ghost'1)
  
  axiom inv_axiom'14 [@rewrite] : forall x : MutBorrow.t t_Ghost'1 [inv'14 x] . inv'14 x = invariant'12 x
  
  predicate invariant'5 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant72] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'5 x] . inv'5 x = invariant'5 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_Ghost'1) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost36] inv'14 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost37] inv'5 result}
      {[%#sghost38] result.current = inner_logic'0 self.current}
      {[%#sghost39] result.final = inner_logic'0 self.final}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'6 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant72] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'6 x
  
  predicate inv'15 (_1 : t_Option'1)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_Option'1 [inv'15 x] . inv'15 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'6 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap71] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap40] inv'5 self}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap41] inv'15 result}
      {[%#sfmap42] if contains'1 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap43] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap44] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'1) (return'  (ret:MutBorrow.t t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'15 self}
    {[@expl:unwrap requires] [%#soption26] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_PtrOwn'0)-> {inv'6 result}
      {[%#soption27] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  type t_Ghost'2  =
    { t_Ghost__0'2: MutBorrow.t t_PtrOwn'0 }
  
  function inner_logic'2 (self : t_Ghost'2) : MutBorrow.t t_PtrOwn'0
  
  predicate invariant'13 (self : t_Ghost'2) =
    [%#sghost75] inv'6 (inner_logic'2 self)
  
  predicate inv'16 (_1 : t_Ghost'2)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_Ghost'2 [inv'16 x] . inv'16 x
  = (invariant'13 x
  /\ match x with
    | {t_Ghost__0'2 = a_0} -> inv'6 a_0
    end)
  
  let rec new'1 (x:MutBorrow.t t_PtrOwn'0) (return'  (ret:t_Ghost'2))= {[@expl:new 'x' type invariant] [%#sghost28] inv'6 x}
    any
    [ return' (result:t_Ghost'2)-> {[%#sghost29] inv'16 result}
      {[%#sghost30] inner_logic'2 result = x}
      (! return' {result}) ]
  
  
  predicate resolve'8 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve65] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_FMap'0) =
    resolve'8 _1
  
  predicate resolve'9 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve65] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'9 _1
  
  predicate invariant'7 (self : MutBorrow.t t_Content'0) =
    [%#sinvariant72] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Content'0 [inv'8 x] . inv'8 x = invariant'7 x
  
  let rec as_mut'0 (ptr:Opaque.ptr) (own:t_Ghost'2) (return'  (ret:MutBorrow.t t_Content'0))= {[@expl:as_mut 'own' type invariant] [%#sptr_own45] inv'16 own}
    {[@expl:as_mut requires] [%#sptr_own46] ptr = ptr'0 (inner_logic'2 own).current}
    any
    [ return' (result:MutBorrow.t t_Content'0)-> {[%#sptr_own47] inv'8 result}
      {[%#sptr_own48] result.current = val'0 (inner_logic'2 own).current}
      {[%#sptr_own49] ptr'0 (inner_logic'2 own).final = ptr'0 (inner_logic'2 own).current}
      {[%#sptr_own50] val'0 (inner_logic'2 own).final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'10 (self : MutBorrow.t t_Content'0) =
    [%#sresolve65] self.final = self.current
  
  predicate resolve'4 (_1 : MutBorrow.t t_Content'0) =
    resolve'10 _1
  
  let rec incr'0 (self:MutBorrow.t t_PeanoInt'0) (return'  (ret:()))= any
    [ return' (result:())-> {[%#speano52] view'0 self.final = view'0 self.current + 1} (! return' {result}) ]
  
  
  predicate resolve'11 (self : MutBorrow.t t_PeanoInt'0) =
    [%#sresolve65] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t t_PeanoInt'0) =
    resolve'11 _1
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find56] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find54] inv'17 self)
   -> ([%#sunion_find55] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find59] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find57] inv'17 self)
   -> ([%#sunion_find58] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate equiv_log'0 [#"union_find.rs" 249 8 249 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find60] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find63] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find61] inv'17 self)
   -> ([%#sunion_find62] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec link'0[#"union_find.rs" 275 8 275 70] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:link 'self' type invariant] [%#sunion_find8] inv'0 self}
    {[@expl:link requires #0] [%#sunion_find9] contains'0 (domain'0 self.current) x}
    {[@expl:link requires #1] [%#sunion_find10] index_logic'0 (root_of'0 self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find11] contains'0 (domain'0 self.current) y}
    {[@expl:link requires #3] [%#sunion_find12] index_logic'0 (root_of'0 self.current) y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {x} {y} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_14 = false} (! bb3) | br1 -> {_14} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- x ] s3 | s3 = bb67 ]
    
    | bb3 = s0
      [ s0 = deref'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_22 <- _ret' ] s1) | s1 = bb4 ]
    
    | bb4 = s0 [ s0 = addr'0 {x} (fun (_ret':int) ->  [ &_26 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_25 <- _26 ] s1
      | s1 = get_ghost'0 {_22} {_25} (fun (_ret':t_Option'0) ->  [ &_20 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = unwrap'0 {_20} (fun (_ret':t_PtrOwn'0) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 = new'0 {_19} (fun (_ret':t_Ghost'0) ->  [ &perm_x <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = deref'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_32 <- _ret' ] s1) | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = addr'0 {y} (fun (_ret':int) ->  [ &_36 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_35 <- _36 ] s1
      | s1 = get_ghost'0 {_32} {_35} (fun (_ret':t_Option'0) ->  [ &_30 <- _ret' ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = unwrap'0 {_30} (fun (_ret':t_PtrOwn'0) ->  [ &_29 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 = new'0 {_29} (fun (_ret':t_Ghost'0) ->  [ &perm_y <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = as_ref'0 {x.t_Element__0'0} {perm_x} (fun (_ret':t_Content'0) ->  [ &_41 <- _ret' ] s1) | s1 = bb14 ]
    
    | bb14 = any
      [ br0 (x0:t_PeanoInt'0) (x1:t_T'0)-> {_41 = C_Root'0 x0 x1} (! bb16)
      | br1 (x0:t_Element'0)-> {_41 = C_Link'0 x0} (! bb15) ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'1 perm_y} s1
      | s1 = -{resolve'1 perm_y}- s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = {false} any ]
    
    | bb16 = bb17
    | bb17 = s0
      [ s0 = v_Root'0 {_41} (fun (rrank'0:t_PeanoInt'0) (rvalue'0:t_T'0) ->  [ &rank <- rrank'0 ] s1)
      | s1 = v_Root'0 {_41} (fun (rrank'1:t_PeanoInt'0) (rvalue'1:t_T'0) ->  [ &value <- rvalue'1 ] s2)
      | s2 = to_u64'0 {rank} (fun (_ret':UInt64.t) ->  [ &_47 <- _ret' ] s3)
      | s3 = bb18 ]
    
    | bb18 = s0
      [ s0 =  [ &_40 <- { _0'0 = _47; _1'0 = value } ] s1
      | s1 =  [ &rx <- _40._0'0 ] s2
      | s2 =  [ &vx <- _40._1'0 ] s3
      | s3 = as_ref'0 {y.t_Element__0'0} {perm_y} (fun (_ret':t_Content'0) ->  [ &_54 <- _ret' ] s4)
      | s4 = bb19 ]
    
    | bb19 = any
      [ br0 (x0:t_PeanoInt'0) (x1:t_T'0)-> {_54 = C_Root'0 x0 x1} (! bb21)
      | br1 (x0:t_Element'0)-> {_54 = C_Link'0 x0} (! bb20) ]
    
    | bb20 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {false} any ] 
    | bb21 = bb22
    | bb22 = s0
      [ s0 = v_Root'0 {_54} (fun (rrank'0:t_PeanoInt'0) (rvalue'0:t_T'0) ->  [ &rank1 <- rrank'0 ] s1)
      | s1 = v_Root'0 {_54} (fun (rrank'1:t_PeanoInt'0) (rvalue'1:t_T'0) ->  [ &value1 <- rvalue'1 ] s2)
      | s2 = to_u64'0 {rank1} (fun (_ret':UInt64.t) ->  [ &_60 <- _ret' ] s3)
      | s3 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &_53 <- { _0'0 = _60; _1'0 = value1 } ] s1
      | s1 =  [ &ry <- _53._0'0 ] s2
      | s2 =  [ &vy <- _53._1'0 ] s3
      | s3 =  [ &_64 <- UInt64.lt rx ry ] s4
      | s4 = any [ br0 -> {_64 = false} (! bb25) | br1 -> {_64} (! bb24) ]  ]
    
    | bb24 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_Ghost'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Ghost'1) ->
             [ &_73 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_73} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_72 <- _ret' ] s2)
      | s2 = bb26 ]
    
    | bb26 = s0
      [ s0 = {inv'3 _72.current}
        MutBorrow.borrow_final <t_FMap'0> {_72.current} {MutBorrow.get_id _72}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_71 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_72 <- { _72 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {x} (fun (_ret':int) ->  [ &_76 <- _ret' ] s2)
      | s2 = bb27 ]
    
    | bb27 = s0
      [ s0 =  [ &_75 <- _76 ] s1
      | s1 = get_mut_ghost'0 {_71} {_75} (fun (_ret':t_Option'1) ->  [ &_70 <- _ret' ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0 [ s0 = unwrap'1 {_70} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_69 <- _ret' ] s1) | s1 = bb29 ] 
    | bb29 = s0
      [ s0 = {inv'4 _69.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_69.current} {MutBorrow.get_id _69}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_68 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_69 <- { _69 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_68} (fun (_ret':t_Ghost'2) ->  [ &perm_mut_x <- _ret' ] s2)
      | s2 = bb30 ]
    
    | bb30 = s0
      [ s0 = {[@expl:type invariant] inv'5 _72} s1
      | s1 = -{resolve'2 _72}- s2
      | s2 = {[@expl:type invariant] inv'6 _69} s3
      | s3 = -{resolve'3 _69}- s4
      | s4 =  [ &_79 <- C_Link'0 y ] s5
      | s5 = as_mut'0 {x.t_Element__0'0} {perm_mut_x} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_81 <- _ret' ] s6)
      | s6 = bb31 ]
    
    | bb31 = bb32
    | bb32 = s0
      [ s0 = {[@expl:type invariant] match _81 with
          | {current = x'0} -> inv'7 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_81 <- { _81 with current = _79 } ] s2
      | s2 = {[@expl:type invariant] inv'8 _81} s3
      | s3 = -{resolve'4 _81}- s4
      | s4 = bb34 ]
    
    | bb34 = s0
      [ s0 = 
        [ &_84 <- [%#sunion_find0] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = x then
          y
        else
          index_logic'0 (self.current).t_UnionFind__root_of'0 z
         ]
        
        s1
      | s1 = bb35 ]
    
    | bb35 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _84 } } ] s1
      | s1 = 
        [ &_86 <- [%#sunion_find1] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = y then
          vy
        else
          index_logic'1 (self.current).t_UnionFind__values'0 z
         ]
        
        s2
      | s2 = bb36 ]
    
    | bb36 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _86 } } ] s1
      | s1 =  [ &_88 <- [%#sunion_find2] (self.current).t_UnionFind__max_depth'0 + 1 ] s2
      | s2 = bb37 ]
    
    | bb37 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__max_depth'0 = _88 } } ] s1
      | s1 = 
        [ &_90 <- [%#sunion_find3] Map.set (self.current).t_UnionFind__distance'0 y (1
        + MinMax.max (index_logic'2 (self.current).t_UnionFind__distance'0 x) (index_logic'2 (self.current).t_UnionFind__distance'0 y)) ]
        
        s2
      | s2 = bb38 ]
    
    | bb38 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _90 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- y ] s4
      | s4 = bb66 ]
    
    | bb25 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_mut <t_Ghost'1> {(self.current).t_UnionFind__map'0}
          (fun (_ret':MutBorrow.t t_Ghost'1) ->
             [ &_98 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_98} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_97 <- _ret' ] s2)
      | s2 = bb39 ]
    
    | bb39 = s0
      [ s0 = {inv'3 _97.current}
        MutBorrow.borrow_final <t_FMap'0> {_97.current} {MutBorrow.get_id _97}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_96 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_97 <- { _97 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {y} (fun (_ret':int) ->  [ &_101 <- _ret' ] s2)
      | s2 = bb40 ]
    
    | bb40 = s0
      [ s0 =  [ &_100 <- _101 ] s1
      | s1 = get_mut_ghost'0 {_96} {_100} (fun (_ret':t_Option'1) ->  [ &_95 <- _ret' ] s2)
      | s2 = bb41 ]
    
    | bb41 = s0 [ s0 = unwrap'1 {_95} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_94 <- _ret' ] s1) | s1 = bb42 ] 
    | bb42 = s0
      [ s0 = {inv'4 _94.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_94.current} {MutBorrow.get_id _94}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_93 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_94 <- { _94 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_93} (fun (_ret':t_Ghost'2) ->  [ &perm_mut_y <- _ret' ] s2)
      | s2 = bb43 ]
    
    | bb43 = s0
      [ s0 = {[@expl:type invariant] inv'5 _97} s1
      | s1 = -{resolve'2 _97}- s2
      | s2 = {[@expl:type invariant] inv'6 _94} s3
      | s3 = -{resolve'3 _94}- s4
      | s4 =  [ &_104 <- C_Link'0 x ] s5
      | s5 = as_mut'0 {y.t_Element__0'0} {perm_mut_y} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_106 <- _ret' ] s6)
      | s6 = bb44 ]
    
    | bb44 = bb45
    | bb45 = s0
      [ s0 = {[@expl:type invariant] match _106 with
          | {current = x'0} -> inv'7 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_106 <- { _106 with current = _104 } ] s2
      | s2 = {[@expl:type invariant] inv'8 _106} s3
      | s3 = -{resolve'4 _106}- s4
      | s4 = bb47 ]
    
    | bb47 = s0
      [ s0 =  [ &_110 <- rx = ry ] s1 | s1 = any [ br0 -> {_110 = false} (! bb60) | br1 -> {_110} (! bb48) ]  ]
    
    | bb48 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_Ghost'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_Ghost'1) ->
             [ &_119 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_119} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_118 <- _ret' ] s2)
      | s2 = bb49 ]
    
    | bb49 = s0
      [ s0 = {inv'3 _118.current}
        MutBorrow.borrow_final <t_FMap'0> {_118.current} {MutBorrow.get_id _118}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_117 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_118 <- { _118 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {x} (fun (_ret':int) ->  [ &_122 <- _ret' ] s2)
      | s2 = bb50 ]
    
    | bb50 = s0
      [ s0 =  [ &_121 <- _122 ] s1
      | s1 = get_mut_ghost'0 {_117} {_121} (fun (_ret':t_Option'1) ->  [ &_116 <- _ret' ] s2)
      | s2 = bb51 ]
    
    | bb51 = s0 [ s0 = unwrap'1 {_116} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_115 <- _ret' ] s1) | s1 = bb52 ] 
    | bb52 = s0
      [ s0 = {inv'4 _115.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_115.current} {MutBorrow.get_id _115}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_114 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_115 <- { _115 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_114} (fun (_ret':t_Ghost'2) ->  [ &perm_mut_x1 <- _ret' ] s2)
      | s2 = bb53 ]
    
    | bb53 = s0
      [ s0 = {[@expl:type invariant] inv'5 _118} s1
      | s1 = -{resolve'2 _118}- s2
      | s2 = {[@expl:type invariant] inv'6 _115} s3
      | s3 = -{resolve'3 _115}- s4
      | s4 = as_mut'0 {x.t_Element__0'0} {perm_mut_x1} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_124 <- _ret' ] s5)
      | s5 = bb54 ]
    
    | bb54 = any
      [ br0 (x0:t_PeanoInt'0) (x1:t_T'0)-> {_124.current = C_Root'0 x0 x1} (! bb56)
      | br1 (x0:t_Element'0)-> {_124.current = C_Link'0 x0} (! bb55) ]
    
    | bb55 = s0 [ s0 = {[@expl:type invariant] inv'8 _124} s1 | s1 = -{resolve'4 _124}- s2 | s2 = bb59 ] 
    | bb56 = bb57
    | bb57 = s0
      [ s0 = v_Root'0 {_124.current}
          (fun (rrank'0:t_PeanoInt'0) (rvalue'0:t_T'0) ->
            MutBorrow.borrow_final <t_PeanoInt'0> {rrank'0} {MutBorrow.inherit_id (MutBorrow.get_id _124) 1}
              (fun (_ret':MutBorrow.t t_PeanoInt'0) ->
                 [ &rank2 <- _ret' ] 
                 [ &_124 <- { _124 with current = C_Root'0 _ret'.final rvalue'0 } ] 
                s1))
      | s1 = MutBorrow.borrow_final <t_PeanoInt'0> {rank2.current} {MutBorrow.get_id rank2}
          (fun (_ret':MutBorrow.t t_PeanoInt'0) ->
             [ &_129 <- _ret' ] 
             [ &rank2 <- { rank2 with current = _ret'.final } ] 
            s2)
      | s2 = incr'0 {_129} (fun (_ret':()) ->  [ &_109 <- _ret' ] s3)
      | s3 = bb58 ]
    
    | bb58 = s0
      [ s0 = -{resolve'5 rank2}- s1
      | s1 = {[@expl:type invariant] inv'8 _124} s2
      | s2 = -{resolve'4 _124}- s3
      | s3 = bb59 ]
    
    | bb59 = bb61
    | bb60 = bb61
    | bb61 = s0
      [ s0 = 
        [ &_130 <- [%#sunion_find4] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = y then
          x
        else
          index_logic'0 (self.current).t_UnionFind__root_of'0 z
         ]
        
        s1
      | s1 = bb62 ]
    
    | bb62 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _130 } } ] s1
      | s1 = 
        [ &_132 <- [%#sunion_find5] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = x then
          vx
        else
          index_logic'1 (self.current).t_UnionFind__values'0 z
         ]
        
        s2
      | s2 = bb63 ]
    
    | bb63 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _132 } } ] s1
      | s1 =  [ &_134 <- [%#sunion_find6] (self.current).t_UnionFind__max_depth'0 + 1 ] s2
      | s2 = bb64 ]
    
    | bb64 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__max_depth'0 = _134 } } ] s1
      | s1 = 
        [ &_136 <- [%#sunion_find7] Map.set (self.current).t_UnionFind__distance'0 x (1
        + MinMax.max (index_logic'2 (self.current).t_UnionFind__distance'0 x) (index_logic'2 (self.current).t_UnionFind__distance'0 y)) ]
        
        s2
      | s2 = bb65 ]
    
    | bb65 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _136 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- x ] s4
      | s4 = bb66 ]
    
    | bb66 = bb67
    | bb67 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & _14 : bool = Any.any_l ()
    | & perm_x : t_Ghost'0 = Any.any_l ()
    | & _19 : t_PtrOwn'0 = Any.any_l ()
    | & _20 : t_Option'0 = Any.any_l ()
    | & _22 : t_FMap'0 = Any.any_l ()
    | & _25 : int = Any.any_l ()
    | & _26 : int = Any.any_l ()
    | & perm_y : t_Ghost'0 = Any.any_l ()
    | & _29 : t_PtrOwn'0 = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _32 : t_FMap'0 = Any.any_l ()
    | & _35 : int = Any.any_l ()
    | & _36 : int = Any.any_l ()
    | & rx : UInt64.t = Any.any_l ()
    | & vx : t_T'0 = Any.any_l ()
    | & _40 : tuple'0 = Any.any_l ()
    | & _41 : t_Content'0 = Any.any_l ()
    | & rank : t_PeanoInt'0 = Any.any_l ()
    | & value : t_T'0 = Any.any_l ()
    | & _47 : UInt64.t = Any.any_l ()
    | & ry : UInt64.t = Any.any_l ()
    | & vy : t_T'0 = Any.any_l ()
    | & _53 : tuple'0 = Any.any_l ()
    | & _54 : t_Content'0 = Any.any_l ()
    | & rank1 : t_PeanoInt'0 = Any.any_l ()
    | & value1 : t_T'0 = Any.any_l ()
    | & _60 : UInt64.t = Any.any_l ()
    | & _64 : bool = Any.any_l ()
    | & perm_mut_x : t_Ghost'2 = Any.any_l ()
    | & _68 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _69 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _70 : t_Option'1 = Any.any_l ()
    | & _71 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _72 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _73 : MutBorrow.t t_Ghost'1 = Any.any_l ()
    | & _75 : int = Any.any_l ()
    | & _76 : int = Any.any_l ()
    | & _79 : t_Content'0 = Any.any_l ()
    | & _81 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & _84 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _86 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _88 : int = Any.any_l ()
    | & _90 : Map.map t_Element'0 int = Any.any_l ()
    | & perm_mut_y : t_Ghost'2 = Any.any_l ()
    | & _93 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _94 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _95 : t_Option'1 = Any.any_l ()
    | & _96 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _97 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _98 : MutBorrow.t t_Ghost'1 = Any.any_l ()
    | & _100 : int = Any.any_l ()
    | & _101 : int = Any.any_l ()
    | & _104 : t_Content'0 = Any.any_l ()
    | & _106 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & _109 : () = Any.any_l ()
    | & _110 : bool = Any.any_l ()
    | & perm_mut_x1 : t_Ghost'2 = Any.any_l ()
    | & _114 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _115 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _116 : t_Option'1 = Any.any_l ()
    | & _117 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _118 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _119 : MutBorrow.t t_Ghost'1 = Any.any_l ()
    | & _121 : int = Any.any_l ()
    | & _122 : int = Any.any_l ()
    | & _124 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & rank2 : MutBorrow.t t_PeanoInt'0 = Any.any_l ()
    | & _129 : MutBorrow.t t_PeanoInt'0 = Any.any_l ()
    | & _130 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _132 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _134 : int = Any.any_l ()
    | & _136 : Map.map t_Element'0 int = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:link ensures #0] [%#sunion_find13] domain'0 self.final
      = domain'0 self.current}
      {[@expl:link ensures #1] [%#sunion_find14] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[@expl:link ensures #2] [%#sunion_find15] result = index_logic'0 (root_of'0 self.final) result}
      {[@expl:link ensures #3] [%#sunion_find16] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[@expl:link ensures #4] [%#sunion_find17] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union_aux [#"union_find.rs" 340 8 340 75] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 340 26 340 30
  let%span sunion_find1 = "union_find.rs" 322 19 322 44
  let%span sunion_find2 = "union_find.rs" 323 19 323 44
  let%span sunion_find3 = "union_find.rs" 324 18 324 54
  let%span sunion_find4 = "union_find.rs" 325 18 325 82
  let%span sunion_find5 = "union_find.rs" 326 18 331 13
  let%span sunion_find6 = "union_find.rs" 333 18 338 13
  let%span sunion_find7 = "union_find.rs" 215 25 215 29
  let%span sunion_find8 = "union_find.rs" 212 19 212 47
  let%span sunion_find9 = "union_find.rs" 213 18 213 48
  let%span sunion_find10 = "union_find.rs" 214 18 214 34
  let%span sunion_find11 = "union_find.rs" 275 21 275 25
  let%span sunion_find12 = "union_find.rs" 254 19 254 44
  let%span sunion_find13 = "union_find.rs" 255 19 255 41
  let%span sunion_find14 = "union_find.rs" 256 19 256 44
  let%span sunion_find15 = "union_find.rs" 257 19 257 41
  let%span sunion_find16 = "union_find.rs" 258 18 258 54
  let%span sunion_find17 = "union_find.rs" 259 18 259 82
  let%span sunion_find18 = "union_find.rs" 260 18 260 53
  let%span sunion_find19 = "union_find.rs" 261 18 266 13
  let%span sunion_find20 = "union_find.rs" 268 18 273 13
  let%span sfset21 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find22 = "union_find.rs" 128 19 128 28
  let%span sunion_find23 = "union_find.rs" 129 18 129 150
  let%span sunion_find24 = "union_find.rs" 126 8 126 16
  let%span smapping25 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find26 = "union_find.rs" 140 19 140 28
  let%span sunion_find27 = "union_find.rs" 141 18 141 98
  let%span sunion_find28 = "union_find.rs" 138 8 138 16
  let%span sunion_find29 = "union_find.rs" 250 12 250 50
  let%span sunion_find30 = "union_find.rs" 149 19 149 28
  let%span sunion_find31 = "union_find.rs" 150 18 150 106
  let%span sunion_find32 = "union_find.rs" 147 8 147 16
  let%span sunion_find33 = "union_find.rs" 160 16 162 52
  let%span sresolve34 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find35 = "union_find.rs" 24 8 24 16
  let%span sunion_find36 = "union_find.rs" 75 8 75 20
  let%span sinvariant37 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap38 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find39 = "union_find.rs" 120 8 120 16
  let%span sfmap40 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost42 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap46 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil47 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil48 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed49 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own50 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr51 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr52 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset21] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find35] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap43] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap40] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap38] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil47] op <> C_None'0)
   -> ([%#sutil48] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap45] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap44] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap41] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find39] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping25] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping25] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping25] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find36] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr52] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr51] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own50] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed49] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed49] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap46] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Ghost'0) =
    [%#sghost42] inv'3 (inner_logic'0 self)
  
  predicate inv'2 (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant37] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find24] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find22] inv'0 self)
   -> ([%#sunion_find23] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find28] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find26] inv'0 self)
   -> ([%#sunion_find27] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find32] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find30] inv'0 self)
   -> ([%#sunion_find31] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 158 8 158 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find33] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find7] inv'1 self}
    {[@expl:find requires] [%#sunion_find8] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find9] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find10] unchanged'0 self}
      (! return' {result}) ]
  
  
  predicate equiv_log'0 [#"union_find.rs" 249 8 249 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find29] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  let rec link'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:link 'self' type invariant] [%#sunion_find11] inv'1 self}
    {[@expl:link requires #0] [%#sunion_find12] contains'0 (domain'0 self.current) x}
    {[@expl:link requires #1] [%#sunion_find13] index_logic'0 (root_of'0 self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find14] contains'0 (domain'0 self.current) y}
    {[@expl:link requires #3] [%#sunion_find15] index_logic'0 (root_of'0 self.current) y = y}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find16] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find17] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[%#sunion_find18] result = index_logic'0 (root_of'0 self.final) result}
      {[%#sunion_find19] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[%#sunion_find20] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec union_aux'0[#"union_find.rs" 340 8 340 75] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:union_aux 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:union_aux requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_11 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_11} {x} (fun (_ret':t_Element'0) ->  [ &rx <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_14 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_14} {y} (fun (_ret':t_Element'0) ->  [ &ry <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = link'0 {_16} {rx} {ry} (fun (_ret':t_Element'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & rx : t_Element'0 = Any.any_l ()
    | & _11 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & ry : t_Element'0 = Any.any_l ()
    | & _14 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:union_aux ensures #0] [%#sunion_find3] domain'0 self.final
      = domain'0 self.current}
      {[@expl:union_aux ensures #1] [%#sunion_find4] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[@expl:union_aux ensures #2] [%#sunion_find5] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[@expl:union_aux ensures #3] [%#sunion_find6] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union [#"union_find.rs" 363 8 363 61] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 363 26 363 30
  let%span sunion_find1 = "union_find.rs" 347 19 347 44
  let%span sunion_find2 = "union_find.rs" 348 19 348 44
  let%span sunion_find3 = "union_find.rs" 349 18 349 54
  let%span sunion_find4 = "union_find.rs" 350 18 362 9
  let%span sunion_find5 = "union_find.rs" 340 26 340 30
  let%span sunion_find6 = "union_find.rs" 322 19 322 44
  let%span sunion_find7 = "union_find.rs" 323 19 323 44
  let%span sunion_find8 = "union_find.rs" 324 18 324 54
  let%span sunion_find9 = "union_find.rs" 325 18 325 82
  let%span sunion_find10 = "union_find.rs" 326 18 331 13
  let%span sunion_find11 = "union_find.rs" 333 18 338 13
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find13 = "union_find.rs" 128 19 128 28
  let%span sunion_find14 = "union_find.rs" 129 18 129 150
  let%span sunion_find15 = "union_find.rs" 126 8 126 16
  let%span smapping16 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find17 = "union_find.rs" 140 19 140 28
  let%span sunion_find18 = "union_find.rs" 141 18 141 98
  let%span sunion_find19 = "union_find.rs" 138 8 138 16
  let%span sunion_find20 = "union_find.rs" 250 12 250 50
  let%span sunion_find21 = "union_find.rs" 149 19 149 28
  let%span sunion_find22 = "union_find.rs" 150 18 150 106
  let%span sunion_find23 = "union_find.rs" 147 8 147 16
  let%span sresolve24 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find25 = "union_find.rs" 24 8 24 16
  let%span sunion_find26 = "union_find.rs" 75 8 75 20
  let%span sinvariant27 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find29 = "union_find.rs" 120 8 120 16
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sghost32 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap36 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil37 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil38 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sboxed39 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own40 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr41 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr42 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset12] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find25] addr_logic'0 self.t_Element__0'0
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap33] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap30] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap28] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil37] op <> C_None'0)
   -> ([%#sutil38] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap35] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap34] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap31] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 121 8 121 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find29] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping16] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping16] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping16] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0) =
    [%#sunion_find26] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr42] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr41] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own40] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed39] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed39] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap36] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  predicate invariant'2 (self : t_Ghost'0) =
    [%#sghost32] inv'3 (inner_logic'0 self)
  
  predicate inv'2 (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant27] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find15] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find13] inv'0 self)
   -> ([%#sunion_find14] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find19] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find17] inv'0 self)
   -> ([%#sunion_find18] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate equiv_log'0 [#"union_find.rs" 249 8 249 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find20] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  let rec union_aux'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:union_aux 'self' type invariant] [%#sunion_find5] inv'1 self}
    {[@expl:union_aux requires #0] [%#sunion_find6] contains'0 (domain'0 self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find7] contains'0 (domain'0 self.current) y}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find8] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find9] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[%#sunion_find10] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[%#sunion_find11] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec union'0[#"union_find.rs" 363 8 363 61] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:()))= {[@expl:union 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:union requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) x}
    {[@expl:union requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = union_aux'0 {_9} {x} {y} (fun (_ret':t_Element'0) ->  [ &_8 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & _8 : t_Element'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:union ensures #0] [%#sunion_find3] domain'0 self.final = domain'0 self.current}
      {[@expl:union ensures #1] [%#sunion_find4] exists r : t_Element'0 . (r = index_logic'0 (root_of'0 self.current) x
      \/ r = index_logic'0 (root_of'0 self.current) y)
      /\ (forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        r
      else
        index_logic'0 (root_of'0 self.current) z
      )
      /\ index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) r
      else
        index_logic'1 (values'0 self.current) z
      ))}
      (! return' {result}) ]

end
module M_union_find__example [#"union_find.rs" 372 0 372 16]
  let%span sunion_find0 = "union_find.rs" 375 20 375 21
  let%span sunion_find1 = "union_find.rs" 376 20 376 21
  let%span sunion_find2 = "union_find.rs" 377 20 377 21
  let%span sunion_find3 = "union_find.rs" 379 26 379 27
  let%span sunion_find4 = "union_find.rs" 380 26 380 27
  let%span sunion_find5 = "union_find.rs" 381 26 381 27
  let%span sunion_find6 = "union_find.rs" 388 26 388 27
  let%span sunion_find7 = "union_find.rs" 388 4 388 28
  let%span sunion_find8 = "union_find.rs" 387 4 387 37
  let%span sunion_find9 = "union_find.rs" 381 4 381 28
  let%span sunion_find10 = "union_find.rs" 380 4 380 28
  let%span sunion_find11 = "union_find.rs" 379 4 379 28
  let%span sunion_find12 = "union_find.rs" 109 24 109 28
  let%span sunion_find13 = "union_find.rs" 108 8 108 44
  let%span sunion_find14 = "union_find.rs" 170 25 170 29
  let%span sunion_find15 = "union_find.rs" 166 18 166 52
  let%span sunion_find16 = "union_find.rs" 167 18 167 69
  let%span sunion_find17 = "union_find.rs" 168 18 168 76
  let%span sunion_find18 = "union_find.rs" 169 18 169 73
  let%span sunion_find19 = "union_find.rs" 225 20 225 24
  let%span sunion_find20 = "union_find.rs" 222 19 222 47
  let%span sunion_find21 = "union_find.rs" 223 19 223 47
  let%span sunion_find22 = "union_find.rs" 224 18 224 48
  let%span sunion_find23 = "union_find.rs" 363 26 363 30
  let%span sunion_find24 = "union_find.rs" 347 19 347 44
  let%span sunion_find25 = "union_find.rs" 348 19 348 44
  let%span sunion_find26 = "union_find.rs" 349 18 349 54
  let%span sunion_find27 = "union_find.rs" 350 18 362 9
  let%span sunion_find28 = "union_find.rs" 215 25 215 29
  let%span sunion_find29 = "union_find.rs" 212 19 212 47
  let%span sunion_find30 = "union_find.rs" 213 18 213 48
  let%span sunion_find31 = "union_find.rs" 214 18 214 34
  let%span sfset32 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find33 = "union_find.rs" 128 19 128 28
  let%span sunion_find34 = "union_find.rs" 129 18 129 150
  let%span sfset35 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sunion_find36 = "union_find.rs" 140 19 140 28
  let%span sunion_find37 = "union_find.rs" 141 18 141 98
  let%span sunion_find38 = "union_find.rs" 149 19 149 28
  let%span sunion_find39 = "union_find.rs" 150 18 150 106
  let%span smapping40 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find41 = "union_find.rs" 250 12 250 50
  let%span sunion_find42 = "union_find.rs" 160 16 162 52
  let%span sinvariant43 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant44 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost45 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap46 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap47 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap48 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil50 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil51 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap52 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sboxed53 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own54 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr55 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr56 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use creusot.int.Int32
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 Int32.t;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0)
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 Int32.t
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap52] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap49] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap47] get_unsized'0 self k <> C_None'0
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr56] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr55] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'6 (self : t_PtrOwn'0) =
    [%#sptr_own54] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x
  = (invariant'6 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> true
    end)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sboxed53] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'5 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil50] op <> C_None'0)
   -> ([%#sutil51] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap48] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'4 (self : t_FMap'0) =
    [%#sfmap46] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'4 x
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  predicate invariant'3 (self : t_Ghost'0) =
    [%#sghost45] inv'4 (inner_logic'0 self)
  
  predicate inv'3 (_1 : t_Ghost'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_Ghost'0 [inv'3 x] . inv'3 x
  = (invariant'3 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'4 a_0
    end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'3 map
    end)
  
  let rec new'0 (return'  (ret:t_UnionFind'0))= any
    [ return' (result:t_UnionFind'0)-> {[%#sunion_find12] inv'0 result}
      {[%#sunion_find13] Fset.is_empty result.t_UnionFind__domain'0}
      (! return' {result}) ]
  
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant43] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset32] Fset.mem e self
  
  function deep_model'0 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find33] inv'0 self)
   -> ([%#sunion_find34] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function insert'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) : Fset.fset t_Element'0 =
    [%#sfset35] Fset.add e self
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping40] Map.get self a
  
  function root_of'0 [#"union_find.rs" 142 8 142 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find36] inv'0 self)
   -> ([%#sunion_find37] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function index_logic'1 (self : Map.map t_Element'0 Int32.t) (a : t_Element'0) : Int32.t =
    [%#smapping40] Map.get self a
  
  function values'0 [#"union_find.rs" 151 8 151 53] (self : t_UnionFind'0) : Map.map t_Element'0 Int32.t
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find38] inv'0 self)
   -> ([%#sunion_find39] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  let rec make'0 (self:MutBorrow.t t_UnionFind'0) (value:Int32.t) (return'  (ret:t_Element'0))= {[@expl:make 'self' type invariant] [%#sunion_find14] inv'1 self}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find15] not contains'0 (domain'0 self.current) result}
      {[%#sunion_find16] domain'0 self.final = insert'0 (domain'0 self.current) result}
      {[%#sunion_find17] root_of'0 self.final = Map.set (root_of'0 self.current) result result}
      {[%#sunion_find18] values'0 self.final = Map.set (values'0 self.current) result value}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : t_UnionFind'0) =
    [%#sinvariant44] inv'0 self
  
  predicate inv'2 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_UnionFind'0 [inv'2 x] . inv'2 x = invariant'2 x
  
  let rec get'0 (self:t_UnionFind'0) (elem:t_Element'0) (return'  (ret:Int32.t))= {[@expl:get 'self' type invariant] [%#sunion_find19] inv'2 self}
    {[@expl:get requires #0] [%#sunion_find20] contains'0 (domain'0 self) elem}
    {[@expl:get requires #1] [%#sunion_find21] index_logic'0 (root_of'0 self) elem = elem}
    any
    [ return' (result:Int32.t)-> {[%#sunion_find22] result = index_logic'1 (values'0 self) elem} (! return' {result}) ]
  
  
  predicate equiv_log'0 [#"union_find.rs" 249 8 249 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find41] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  let rec union'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:()))= {[@expl:union 'self' type invariant] [%#sunion_find23] inv'1 self}
    {[@expl:union requires #0] [%#sunion_find24] contains'0 (domain'0 self.current) x}
    {[@expl:union requires #1] [%#sunion_find25] contains'0 (domain'0 self.current) y}
    any
    [ return' (result:())-> {[%#sunion_find26] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find27] exists r : t_Element'0 . (r = index_logic'0 (root_of'0 self.current) x
      \/ r = index_logic'0 (root_of'0 self.current) y)
      /\ (forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        r
      else
        index_logic'0 (root_of'0 self.current) z
      )
      /\ index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) r
      else
        index_logic'1 (values'0 self.current) z
      ))}
      (! return' {result}) ]
  
  
  predicate unchanged'0 [#"union_find.rs" 158 8 158 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find42] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find28] inv'1 self}
    {[@expl:find requires] [%#sunion_find29] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find30] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find31] unchanged'0 self}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec example'0[#"union_find.rs" 372 0 372 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = new'0 (fun (_ret':t_UnionFind'0) ->  [ &uf <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_3 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_3} {[%#sunion_find0] (1 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &x <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_5 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_5} {[%#sunion_find1] (2 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &y <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_7 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_7} {[%#sunion_find2] (3 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &z <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = get'0 {uf} {x} (fun (_ret':Int32.t) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_9 <- _11 = ([%#sunion_find3] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
    
    | bb6 = s0 [ s0 = get'0 {uf} {y} (fun (_ret':Int32.t) ->  [ &_18 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_16 <- _18 = ([%#sunion_find4] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ]  ]
    
    | bb9 = s0 [ s0 = get'0 {uf} {z} (fun (_ret':Int32.t) ->  [ &_25 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_23 <- _25 = ([%#sunion_find5] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb13) | br1 -> {_23} (! bb12) ]  ]
    
    | bb12 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_30 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = union'0 {_30} {x} {y} (fun (_ret':()) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_34 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = find'0 {_34} {x} (fun (_ret':t_Element'0) ->  [ &x1 <- _ret' ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_37 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = find'0 {_37} {y} (fun (_ret':t_Element'0) ->  [ &y1 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = get'0 {uf} {x1} (fun (_ret':Int32.t) ->  [ &_42 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 = get'0 {uf} {y1} (fun (_ret':Int32.t) ->  [ &_46 <- _ret' ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 =  [ &_40 <- _42 = _46 ] s1 | s1 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ]  ]
    
    | bb19 = s0 [ s0 = get'0 {uf} {z} (fun (_ret':Int32.t) ->  [ &_53 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = s0
      [ s0 =  [ &_51 <- _53 = ([%#sunion_find6] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb23) | br1 -> {_51} (! bb22) ]  ]
    
    | bb22 = return' {_0}
    | bb23 = {[%#sunion_find7] false} any
    | bb20 = {[%#sunion_find8] false} any
    | bb13 = {[%#sunion_find9] false} any
    | bb10 = {[%#sunion_find10] false} any
    | bb7 = {[%#sunion_find11] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & uf : t_UnionFind'0 = Any.any_l ()
    | & x : t_Element'0 = Any.any_l ()
    | & _3 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & y : t_Element'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & z : t_Element'0 = Any.any_l ()
    | & _7 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _11 : Int32.t = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _18 : Int32.t = Any.any_l ()
    | & _23 : bool = Any.any_l ()
    | & _25 : Int32.t = Any.any_l ()
    | & _29 : () = Any.any_l ()
    | & _30 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & x1 : t_Element'0 = Any.any_l ()
    | & _34 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & y1 : t_Element'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _40 : bool = Any.any_l ()
    | & _42 : Int32.t = Any.any_l ()
    | & _46 : Int32.t = Any.any_l ()
    | & _51 : bool = Any.any_l ()
    | & _53 : Int32.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_union_find__example_addrs_eq [#"union_find.rs" 392 0 392 77]
  let%span sunion_find0 = "union_find.rs" 396 22 396 30
  let%span sunion_find1 = "union_find.rs" 392 27 392 29
  let%span sunion_find2 = "union_find.rs" 391 11 391 63
  let%span sunion_find3 = "union_find.rs" 17 18 17 69
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find5 = "union_find.rs" 128 19 128 28
  let%span sunion_find6 = "union_find.rs" 129 18 129 150
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sghost9 = "../../creusot-contracts/src/ghost.rs" 109 8 109 31
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil14 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil15 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sboxed17 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own18 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr19 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function deep_model'1 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel7] deep_model'1 self
  
  let rec eq'0 (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sunion_find3] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_Ghost'0  =
    { t_Ghost__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_Ghost'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'1 [@inline:trivial] [#"union_find.rs" 78 8 78 34] (self : t_UnionFind'0)
  
  type t_PeanoInt'0  =
    { t_PeanoInt__0'0: UInt64.t }
  
  type t_Content'0  =
    | C_Root'0 t_PeanoInt'0 t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap16] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap13] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap11] get_unsized'0 self k <> C_None'0
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr20] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr19] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own18] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed17] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'6 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed17] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil14] op <> C_None'0)
   -> ([%#sutil15] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap12] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap10] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  function inner_logic'0 (self : t_Ghost'0) : t_FMap'0
  
  predicate invariant'2 (self : t_Ghost'0) =
    [%#sghost9] inv'3 (inner_logic'0 self)
  
  predicate inv'2 (_1 : t_Ghost'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_Ghost'0 [inv'2 x] . inv'2 x
  = (invariant'2 x
  /\ match x with
    | {t_Ghost__0'0 = a_0} -> inv'3 a_0
    end)
  
  predicate inv'1 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_UnionFind'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'0 (self : t_UnionFind'0) =
    [%#sinvariant8] inv'1 self
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset4] Fset.mem e self
  
  function domain'0 [#"union_find.rs" 130 8 130 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find5] inv'1 self)
   -> ([%#sunion_find6] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  let rec example_addrs_eq'0[#"union_find.rs" 392 0 392 77] (uf:t_UnionFind'0) (e1:t_Element'0) (e2:t_Element'0) (return'  (ret:()))= {[@expl:example_addrs_eq 'uf' type invariant] [%#sunion_find1] inv'0 uf}
    {[@expl:example_addrs_eq requires] [%#sunion_find2] contains'0 (domain'0 uf) e1 /\ contains'0 (domain'0 uf) e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {e1} {e2} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0 [ s0 = {[@expl:assertion] [%#sunion_find0] e1 = e2} s1 | s1 = bb4 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : () = Any.any_l () | & e1 : t_Element'0 = e1 | & e2 : t_Element'0 = e2 | & _5 : bool = Any.any_l () ] 
    [ return' (result:())-> (! return' {result}) ]

end
module M_union_find__implementation__qyi17232405883558456141__eq__refines [#"union_find.rs" 18 8 18 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find0 = "union_find.rs" 18 8 18 42
  let%span smodel1 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sunion_find2 = "union_find.rs" 24 8 24 16
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'1 [#"union_find.rs" 26 8 26 34] (self : t_Element'0) : int =
    [%#sunion_find2] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel1] deep_model'1 self
  
  goal refines : [%#sunion_find0] forall self : t_Element'0 . forall other : t_Element'0 . forall result : bool . result
  = (deep_model'0 self = deep_model'0 other)  -> result = (deep_model'0 self = deep_model'0 other)
end
module M_union_find__implementation__qyi10464084137166016688__clone__refines [#"union_find.rs" 47 8 47 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find0 = "union_find.rs" 47 8 47 31
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  goal refines : [%#sunion_find0] forall self : t_Element'0 . forall result : t_Element'0 . self = result
   -> result = self
end
