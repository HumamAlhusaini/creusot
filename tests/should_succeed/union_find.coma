module M_union_find__implementation__qyi17232405883558456141__eq [#"union_find.rs" 17 8 17 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find0 = "union_find.rs" 16 18 16 69
  let%span sptr1 = "../../creusot-contracts/src/std/ptr.rs" 131 22 131 66
  let%span smodel2 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sunion_find3 = "union_find.rs" 23 8 23 16
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  let rec addr_eq'0 (p:Opaque.ptr) (q:Opaque.ptr) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sptr1] result = (addr_logic'0 p = addr_logic'0 q)} (! return' {result}) ]
  
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find3] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel2] deep_model'1 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'0[#"union_find.rs" 17 8 17 42] (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= (! bb0
    [ bb0 = s0
      [ s0 = addr_eq'0 {self.t_Element__0'0} {other.t_Element__0'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1)
      | s1 = bb1 ]
    
    | bb1 = return' {_0} ]
    ) [ & _0 : bool = Any.any_l () | & self : t_Element'0 = self | & other : t_Element'0 = other ] 
    [ return' (result:bool)-> {[@expl:eq ensures] [%#sunion_find0] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi15934775324707434347__addr [#"union_find.rs" 33 8 33 38] (* implementation::Element<T> *)
  let%span sunion_find0 = "union_find.rs" 34 12 34 40
  let%span sunion_find1 = "union_find.rs" 32 18 32 46
  let%span sunion_find2 = "union_find.rs" 23 8 23 16
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find2] addr_logic'0 self.t_Element__0'0
  
  meta "compute_max_steps" 1000000
  
  let rec addr'0[#"union_find.rs" 33 8 33 38] (self:t_Element'0) (return'  (ret:int))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sunion_find0] deep_model'0 self ] s1 | s1 = bb1 ]  | bb1 = return' {_0} ]
    ) [ & _0 : int = Any.any_l () | & self : t_Element'0 = self ] 
    [ return' (result:int)-> {[@expl:addr ensures] [%#sunion_find1] result = deep_model'0 self} (! return' {result}) ]

end
module M_union_find__implementation__qyi10464084137166016688__clone [#"union_find.rs" 46 8 46 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find0 = "union_find.rs" 44 18 44 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  let rec clone'0[#"union_find.rs" 46 8 46 31] (self:t_Element'0) (return'  (ret:t_Element'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_Element__0'0 = self.t_Element__0'0 } ] s1 | s1 = return' {_0} ]  ]
    ) [ & _0 : t_Element'0 = Any.any_l () | & self : t_Element'0 = self ] 
    [ return' (result:t_Element'0)-> {[@expl:clone ensures] [%#sunion_find0] self = result} (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__new [#"union_find.rs" 116 8 116 28] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 118 24 118 46
  let%span sunion_find1 = "union_find.rs" 120 24 120 54
  let%span sunion_find2 = "union_find.rs" 121 26 121 56
  let%span sunion_find3 = "union_find.rs" 122 25 122 55
  let%span sunion_find4 = "union_find.rs" 123 27 123 39
  let%span sunion_find5 = "union_find.rs" 116 24 116 28
  let%span sunion_find6 = "union_find.rs" 115 8 115 44
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 240 4 240 34
  let%span sfmap8 = "../../creusot-contracts/src/logic/fmap.rs" 238 14 238 31
  let%span sutil9 = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil10 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sghost12 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span smapping13 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sunion_find19 = "union_find.rs" 82 8 82 20
  let%span sfmap20 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap21 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap22 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfset23 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find24 = "union_find.rs" 23 8 23 16
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sunion_find26 = "union_find.rs" 127 8 127 16
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sboxed28 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sutil31 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil32 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr35 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr36 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use set.Fset
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap21] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap20] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap25] get_unsized'0 self k <> C_None'0
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr36] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr35] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own34] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed28] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed28] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil31] op <> C_None'0)
   -> ([%#sutil32] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap30] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap33] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed28] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  function ext_eq'0 (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap16] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap14] ext_eq'0 self other  -> self = other)
  && ([%#sfmap15] (forall k : int . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq'0 self other)
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap22] len'0 self >= 0
  
  function empty'0  : t_FMap'0
  
  axiom empty'0_spec : ([%#sfmap17] len'0 empty'0 = 0) && ([%#sfmap18] view'0 empty'0 = Const.const (C_None'0))
  
  function is_empty'0 (self : t_FMap'0) : bool =
    [%#sfmap11] ext_eq'0 self empty'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost12] self.t_GhostBox__0'0
  
  let rec new'1 (return'  (ret:t_GhostBox'0))= any
    [ return' (result:t_GhostBox'0)-> {[%#sfmap7] inv'1 result}
      {[%#sfmap8] is_empty'0 (inner_logic'0 result)}
      (! return' {result}) ]
  
  
  function index_logic'0 (self : Map.map (Map.map t_Element'0 t_T'0) bool) (a : Map.map t_Element'0 t_T'0) : bool =
    [%#smapping13] Map.get self a
  
  function such_that'0 (p : Map.map (Map.map t_Element'0 t_T'0) bool) : Map.map t_Element'0 t_T'0
  
  axiom such_that'0_spec : forall p : Map.map (Map.map t_Element'0 t_T'0) bool . ([%#sutil9] exists x : Map.map t_Element'0 t_T'0 . index_logic'0 p x)
   -> ([%#sutil10] index_logic'0 p (such_that'0 p))
  
  function index_logic'1 (self : Map.map (Map.map t_Element'0 int) bool) (a : Map.map t_Element'0 int) : bool =
    [%#smapping13] Map.get self a
  
  function such_that'1 (p : Map.map (Map.map t_Element'0 int) bool) : Map.map t_Element'0 int
  
  axiom such_that'1_spec : forall p : Map.map (Map.map t_Element'0 int) bool . ([%#sutil9] exists x : Map.map t_Element'0 int . index_logic'1 p x)
   -> ([%#sutil10] index_logic'1 p (such_that'1 p))
  
  function index_logic'2 (self : Map.map (Map.map t_Element'0 t_Element'0) bool) (a : Map.map t_Element'0 t_Element'0) : bool
  
   =
    [%#smapping13] Map.get self a
  
  function such_that'2 (p : Map.map (Map.map t_Element'0 t_Element'0) bool) : Map.map t_Element'0 t_Element'0
  
  axiom such_that'2_spec : forall p : Map.map (Map.map t_Element'0 t_Element'0) bool . ([%#sutil9] exists x : Map.map t_Element'0 t_Element'0 . index_logic'2 p x)
   -> ([%#sutil10] index_logic'2 p (such_that'2 p))
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset23] Fset.mem e self
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find24] addr_logic'0 self.t_Element__0'0
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap29] lookup_unsized'0 self k
  
  function index_logic'6 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap27] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find26] index_logic'6 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'3 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping13] Map.get self a
  
  function index_logic'4 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping13] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'5 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping13] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find19] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'3 self.t_UnionFind__values'0 e
    = index_logic'3 self.t_UnionFind__values'0 (index_logic'4 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'4 self.t_UnionFind__root_of'0 (index_logic'4 self.t_UnionFind__root_of'0 e)
    = index_logic'4 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'4 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'4 self.t_UnionFind__root_of'0 e = index_logic'4 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'3 self.t_UnionFind__values'0 e = v
      /\ index_logic'4 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'5 self.t_UnionFind__distance'0 e < index_logic'5 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'5 self.t_UnionFind__distance'0 e
    /\ index_logic'5 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'4 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"union_find.rs" 116 8 116 28] (return'  (ret:t_UnionFind'0))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_2 <- [%#sunion_find0] Fset.empty : Fset.fset t_Element'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = new'1 (fun (_ret':t_GhostBox'0) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_5 <- [%#sunion_find1] such_that'0 (fun (_2 : Map.map t_Element'0 t_T'0) -> true) ] s1 | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_7 <- [%#sunion_find2] such_that'1 (fun (_2 : Map.map t_Element'0 int) -> true) ] s1 | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_9 <- [%#sunion_find3] such_that'2 (fun (_2 : Map.map t_Element'0 t_Element'0) -> true) ] s1
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_11 <- [%#sunion_find4] 0 ] s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = 
        [ &_0 <- { t_UnionFind__domain'0 = _2;
                   t_UnionFind__map'0 = _4;
                   t_UnionFind__values'0 = _5;
                   t_UnionFind__distance'0 = _7;
                   t_UnionFind__root_of'0 = _9;
                   t_UnionFind__max_depth'0 = _11 } ]
        
        s1
      | s1 = bb7 ]
    
    | bb7 = return' {_0} ]
    )
    [ & _0 : t_UnionFind'0 = Any.any_l ()
    | & _2 : Fset.fset t_Element'0 = Any.any_l ()
    | & _4 : t_GhostBox'0 = Any.any_l ()
    | & _5 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _7 : Map.map t_Element'0 int = Any.any_l ()
    | & _9 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _11 : int = Any.any_l () ]
    
    [ return' (result:t_UnionFind'0)-> {[@expl:new result type invariant] [%#sunion_find5] inv'0 result}
      {[@expl:new ensures] [%#sunion_find6] Fset.is_empty result.t_UnionFind__domain'0}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__domain [#"union_find.rs" 137 8 137 47] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 135 19 135 28
  let%span sunion_find1 = "union_find.rs" 136 18 136 150
  let%span sunion_find2 = "union_find.rs" 133 8 133 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find4 = "union_find.rs" 23 8 23 16
  let%span sunion_find5 = "union_find.rs" 82 8 82 20
  let%span sfmap6 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find8 = "union_find.rs" 127 8 127 16
  let%span smapping9 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil16 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil17 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr21 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find4] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap10] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap6] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost7] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil16] op <> C_None'0)
   -> ([%#sutil17] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap14] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap11] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find8] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'0 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping9] Map.get self a
  
  function index_logic'1 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping9] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping9] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find5] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values'0 e
    = index_logic'0 self.t_UnionFind__values'0 (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of'0 (index_logic'1 self.t_UnionFind__root_of'0 e)
    = index_logic'1 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = index_logic'1 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'0 self.t_UnionFind__values'0 e = v
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'1 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr21] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr20] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own19] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed15] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed15] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap18] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed15] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  constant self  : t_UnionFind'0
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  goal vc_domain'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__domain'0 in [%#sunion_find1] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 result e1
  /\ contains'0 result e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
end
module M_union_find__implementation__qyi1944850640244667852__root_of [#"union_find.rs" 149 8 149 63] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 147 19 147 28
  let%span sunion_find1 = "union_find.rs" 148 18 148 98
  let%span sunion_find2 = "union_find.rs" 145 8 145 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smapping4 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find5 = "union_find.rs" 82 8 82 20
  let%span sunion_find6 = "union_find.rs" 23 8 23 16
  let%span sfmap7 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost8 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find9 = "union_find.rs" 127 8 127 16
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed15 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil16 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil17 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap18 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr20 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr21 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find6] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap12] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap10] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap7] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost8] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil16] op <> C_None'0)
   -> ([%#sutil17] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap14] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap13] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap11] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find9] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping4] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping4] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping4] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find5] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr21] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr20] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own19] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed15] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed15] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap18] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed15] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  constant self  : t_UnionFind'0
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0
  
  goal vc_root_of'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__root_of'0 in [%#sunion_find1] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 result e = index_logic'0 result (index_logic'0 result e))
end
module M_union_find__implementation__qyi1944850640244667852__values [#"union_find.rs" 158 8 158 53] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 156 19 156 28
  let%span sunion_find1 = "union_find.rs" 157 18 157 106
  let%span sunion_find2 = "union_find.rs" 154 8 154 16
  let%span sfset3 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span smapping4 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find5 = "union_find.rs" 147 19 147 28
  let%span sunion_find6 = "union_find.rs" 148 18 148 98
  let%span sunion_find7 = "union_find.rs" 145 8 145 16
  let%span sunion_find8 = "union_find.rs" 82 8 82 20
  let%span sunion_find9 = "union_find.rs" 23 8 23 16
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost11 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find12 = "union_find.rs" 127 8 127 16
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap14 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap15 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap17 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed18 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil19 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil20 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap21 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own22 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr23 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr24 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset3] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find9] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap15] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap13] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap10] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost11] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil19] op <> C_None'0)
   -> ([%#sutil20] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap17] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap16] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap14] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find12] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'0 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping4] Map.get self a
  
  function index_logic'1 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping4] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping4] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find8] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values'0 e
    = index_logic'0 self.t_UnionFind__values'0 (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of'0 (index_logic'1 self.t_UnionFind__root_of'0 e)
    = index_logic'1 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = index_logic'1 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'0 self.t_UnionFind__values'0 e = v
      /\ index_logic'1 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'1 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr24] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr23] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sptr_own22] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'9 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'9 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sboxed18] inv'8 self
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x
  = (invariant'4 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'7 val'
    end)
  
  predicate invariant'3 (self : t_PtrOwn'0) =
    [%#sboxed18] inv'6 self
  
  predicate inv'5 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sfmap21] forall k : int . contains'1 self k  -> inv'4 k /\ inv'5 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sboxed18] inv'3 self
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'2 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find7] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find5] inv'0 self)
   -> ([%#sunion_find6] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (root_of'0 self) e = index_logic'1 (root_of'0 self) (index_logic'1 (root_of'0 self) e))
  
  constant self  : t_UnionFind'0
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0
  
  goal vc_values'0 : ([%#sunion_find0] inv'0 self)
   -> (let result = self.t_UnionFind__values'0 in [%#sunion_find1] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 result e = index_logic'0 result (index_logic'1 (root_of'0 self) e))
end
module M_union_find__implementation__qyi1944850640244667852__make [#"union_find.rs" 177 8 177 54] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 178 29 178 45
  let%span sunion_find1 = "union_find.rs" 179 64 179 65
  let%span sunion_find2 = "union_find.rs" 189 26 189 64
  let%span sunion_find3 = "union_find.rs" 190 26 190 74
  let%span sunion_find4 = "union_find.rs" 191 28 191 68
  let%span sunion_find5 = "union_find.rs" 192 27 192 72
  let%span sunion_find6 = "union_find.rs" 177 25 177 29
  let%span sunion_find7 = "union_find.rs" 177 31 177 36
  let%span sunion_find8 = "union_find.rs" 173 18 173 52
  let%span sunion_find9 = "union_find.rs" 174 18 174 69
  let%span sunion_find10 = "union_find.rs" 175 18 175 76
  let%span sunion_find11 = "union_find.rs" 176 18 176 73
  let%span sptr_own12 = "../../creusot-contracts/src/ptr_own.rs" 59 15 59 16
  let%span sptr_own13 = "../../creusot-contracts/src/ptr_own.rs" 59 4 59 56
  let%span sptr_own14 = "../../creusot-contracts/src/ptr_own.rs" 58 14 58 64
  let%span sghost15 = "../../creusot-contracts/src/ghost.rs" 210 22 210 26
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 210 4 210 32
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 208 14 208 31
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost19 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sunion_find21 = "union_find.rs" 32 18 32 46
  let%span sfmap22 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap23 = "../../creusot-contracts/src/logic/fmap.rs" 349 36 349 39
  let%span sfmap24 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own28 = "../../creusot-contracts/src/ptr_own.rs" 143 26 143 30
  let%span sptr_own29 = "../../creusot-contracts/src/ptr_own.rs" 143 48 143 52
  let%span sptr_own30 = "../../creusot-contracts/src/ptr_own.rs" 140 14 140 64
  let%span sptr_own31 = "../../creusot-contracts/src/ptr_own.rs" 141 14 141 28
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 414 29 414 33
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 414 35 414 38
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 414 43 414 48
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 414 4 416 17
  let%span sfmap36 = "../../creusot-contracts/src/logic/fmap.rs" 412 14 412 49
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 413 14 413 40
  let%span sghost38 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost40 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sfset41 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset42 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find43 = "union_find.rs" 135 19 135 28
  let%span sunion_find44 = "union_find.rs" 136 18 136 150
  let%span sunion_find45 = "union_find.rs" 133 8 133 16
  let%span sunion_find46 = "union_find.rs" 147 19 147 28
  let%span sunion_find47 = "union_find.rs" 148 18 148 98
  let%span sunion_find48 = "union_find.rs" 145 8 145 16
  let%span sunion_find49 = "union_find.rs" 156 19 156 28
  let%span sunion_find50 = "union_find.rs" 157 18 157 106
  let%span sunion_find51 = "union_find.rs" 154 8 154 16
  let%span sghost52 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find53 = "union_find.rs" 23 8 23 16
  let%span sfmap54 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap55 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap56 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap57 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sresolve58 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sfmap59 = "../../creusot-contracts/src/logic/fmap.rs" 67 14 67 71
  let%span sfmap60 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 61
  let%span sfmap61 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 66
  let%span sfmap62 = "../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sresolve63 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span smapping64 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sfmap65 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sutil66 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil67 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap68 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own69 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sinvariant70 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sutil71 = "../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span sptr72 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr73 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sinvariant74 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sunion_find75 = "union_find.rs" 82 8 82 20
  let%span sboxed76 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find77 = "union_find.rs" 127 8 127 16
  let%span sfmap78 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap79 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use set.Fset
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T'0
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_PtrOwn'0 }
  
  predicate inv'7 (_1 : t_T'0)
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x
  = match x with
    | C_Root'0 rank value -> inv'7 value
    | C_Link'0 a_0 -> true
    end
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr73] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr72] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'1 (self : t_PtrOwn'0) =
    [%#sptr_own69] not is_null_logic'0 (ptr'0 self)
  
  predicate invariant'9 (self : t_Content'0) =
    [%#sboxed76] inv'8 self
  
  predicate inv'20 (_1 : t_Content'0)
  
  axiom inv_axiom'19 [@rewrite] : forall x : t_Content'0 [inv'20 x] . inv'20 x = invariant'9 x
  
  predicate inv'2 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_PtrOwn'0 [inv'2 x] . inv'2 x
  = (invariant'1 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'20 val'
    end)
  
  predicate invariant'10 (self : t_PtrOwn'0) =
    [%#sboxed76] inv'2 self
  
  predicate inv'21 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_PtrOwn'0 [inv'21 x] . inv'21 x = invariant'10 x
  
  predicate inv'10 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_GhostBox'0 [inv'10 x] . inv'10 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'21 a_0
    end
  
  predicate inv'9 (_1 : (Opaque.ptr, t_GhostBox'0))
  
  axiom inv_axiom'8 [@rewrite] : forall x : (Opaque.ptr, t_GhostBox'0) [inv'9 x] . inv'9 x
  = (let (x0, x1) = x in inv'10 x1)
  
  function inner_logic'0 (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost52] self.t_GhostBox__0'0
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  let rec new'0 (v:t_Content'0) (return'  (ret:(Opaque.ptr, t_GhostBox'0)))= {[@expl:new 'v' type invariant] [%#sptr_own12] inv'8 v}
    any
    [ return' (result:(Opaque.ptr, t_GhostBox'0))-> {[%#sptr_own13] inv'9 result}
      {[%#sptr_own14] ptr'0 (inner_logic'0 (let (_, a) = result in a)) = (let (a, _) = result in a)
      /\ val'0 (inner_logic'0 (let (_, a) = result in a)) = v}
      (! return' {result}) ]
  
  
  let rec into_inner'0 (self:t_GhostBox'0) (return'  (ret:t_PtrOwn'0))= {[@expl:into_inner 'self' type invariant] [%#sghost15] inv'10 self}
    any
    [ return' (result:t_PtrOwn'0)-> {[%#sghost16] inv'2 result}
      {[%#sghost17] result = self.t_GhostBox__0'0}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'1: t_FMap'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap68] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap56] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap54] get_unsized'0 self k <> C_None'2
  
  predicate inv'15 (_1 : int)
  
  axiom inv_axiom'14 [@rewrite] : forall x : int [inv'15 x] . inv'15 x = true
  
  function unwrap'0 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'2 . ([%#sutil66] op <> C_None'2)
   -> ([%#sutil67] C_Some'2 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap55] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'0 (self : t_FMap'0) =
    [%#sfmap65] forall k : int . contains'1 self k  -> inv'15 k /\ inv'21 (lookup_unsized'0 self k)
  
  predicate inv'1 (_1 : t_FMap'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_FMap'0 [inv'1 x] . inv'1 x = invariant'0 x
  
  predicate invariant'8 (self : t_FMap'0) =
    [%#sboxed76] inv'1 self
  
  predicate inv'19 (_1 : t_FMap'0)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_FMap'0 [inv'19 x] . inv'19 x = invariant'8 x
  
  predicate inv'0 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_GhostBox'1 [inv'0 x] . inv'0 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'19 a_0
    end
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'5 (self : MutBorrow.t t_GhostBox'1) =
    [%#sinvariant70] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'11 (_1 : MutBorrow.t t_GhostBox'1)
  
  axiom inv_axiom'10 [@rewrite] : forall x : MutBorrow.t t_GhostBox'1 [inv'11 x] . inv'11 x = invariant'5 x
  
  predicate invariant'3 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant70] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_GhostBox'1) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost18] inv'11 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost19] inv'4 result}
      {[%#sghost20] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'1 (self.final).t_GhostBox__0'1 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find53] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find21] result = deep_model'0 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_PtrOwn'0)
  
  predicate inv'12 (_1 : int)
  
  axiom inv_axiom'11 [@rewrite] : forall x : int [inv'12 x] . inv'12 x = true
  
  predicate invariant'2 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant70] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'3 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'13 (_1 : t_Option'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Option'0 [inv'13 x] . inv'13 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'3 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap57] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap22] inv'4 self}
    {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap23] inv'12 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap24] inv'13 result}
      {[%#sfmap25] if contains'1 self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap26] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap27] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec v_Some'0 (input:t_Option'0) (ret  (field_0:MutBorrow.t t_PtrOwn'0))= any
    [ good (field_0:MutBorrow.t t_PtrOwn'0)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : MutBorrow.t t_PtrOwn'0 [C_Some'0 field_0 : t_Option'0] . C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate invariant'6 (self : t_PtrOwn'0) =
    [%#sinvariant74] inv'2 self
  
  predicate inv'14 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_PtrOwn'0 [inv'14 x] . inv'14 x = invariant'6 x
  
  let rec disjoint_lemma'0 (own1:MutBorrow.t t_PtrOwn'0) (own2:t_PtrOwn'0) (return'  (ret:()))= {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own28] inv'3 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own29] inv'14 own2}
    any
    [ return' (result:())-> {[%#sptr_own30] addr_logic'0 (ptr'0 own1.current) <> addr_logic'0 (ptr'0 own2)}
      {[%#sptr_own31] own1.current = own1.final}
      (! return' {result}) ]
  
  
  predicate resolve'4 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'4 _1
  
  predicate resolve'5 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_FMap'0) =
    resolve'5 _1
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn'0
  
  predicate inv'5 (_1 : t_Option'1)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option'1 [inv'5 x] . inv'5 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  function make_sized'0 (self : t_PtrOwn'0) : t_PtrOwn'0
  
  axiom make_sized'0_spec : forall self : t_PtrOwn'0 . [%#sutil71] make_sized'0 self = self
  
  function insert'1 (self : t_FMap'0) (k : int) (v : t_PtrOwn'0) : t_FMap'0
  
  axiom insert'1_spec : forall self : t_FMap'0, k : int, v : t_PtrOwn'0 . ([%#sfmap59] view'0 (insert'1 self k v)
  = Map.set (view'0 self) k (C_Some'2 (make_sized'0 v)))
  && ([%#sfmap60] contains'1 self k  -> len'0 (insert'1 self k v) = len'0 self)
  && ([%#sfmap61] not contains'1 self k  -> len'0 (insert'1 self k v) = len'0 self + 1)
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'1 =
    [%#sfmap62] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  let rec insert_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (value:t_PtrOwn'0) (return'  (ret:t_Option'1))= {[@expl:insert_ghost 'self' type invariant] [%#sfmap32] inv'4 self}
    {[@expl:insert_ghost 'key' type invariant] [%#sfmap33] inv'15 key}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap34] inv'2 value}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap35] inv'5 result}
      {[%#sfmap36] self.final = insert'1 self.current key value}
      {[%#sfmap37] result = get'0 self.current key}
      (! return' {result}) ]
  
  
  predicate resolve'8 (_1 : t_PtrOwn'0) =
    true
  
  predicate resolve'6 (self : t_Option'1) =
    [%#sresolve63] match self with
      | C_Some'1 x -> resolve'8 x
      | C_None'1 -> true
      end
  
  predicate resolve'2 (_1 : t_Option'1) =
    resolve'6 _1
  
  type t_GhostBox'2  =
    { t_GhostBox__0'2: () }
  
  predicate inv'16 (_1 : ())
  
  axiom inv_axiom'15 [@rewrite] : forall x : () [inv'16 x] . inv'16 x = true
  
  predicate inv'17 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_GhostBox'2 [inv'17 x] . inv'17 x = true
  
  let rec new'1 (x:()) (return'  (ret:t_GhostBox'2))= {[@expl:new 'x' type invariant] [%#sghost38] inv'16 x}
    any
    [ return' (result:t_GhostBox'2)-> {[%#sghost39] inv'17 result}
      {[%#sghost40] result.t_GhostBox__0'2 = x}
      (! return' {result}) ]
  
  
  function insert'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) : Fset.fset t_Element'0 =
    [%#sfset41] Fset.add e self
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset42] Fset.mem e self
  
  function inner_logic'1 (self : t_GhostBox'1) : t_FMap'0 =
    [%#sghost52] self.t_GhostBox__0'1
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap79] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap78] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find77] index_logic'3 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping64] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping64] Map.get self a
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping64] Map.get self a
  
  predicate invariant'7 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find75] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'18 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_UnionFind'0 [inv'18 x] . inv'18 x
  = (invariant'7 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'0 map
    end)
  
  predicate invariant'4 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant70] inv'18 self.current /\ inv'18 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate resolve'7 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve58] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'7 _1
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find45] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find43] inv'18 self)
   -> ([%#sunion_find44] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find48] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find46] inv'18 self)
   -> ([%#sunion_find47] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find51] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find49] inv'18 self)
   -> ([%#sunion_find50] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec make'0[#"union_find.rs" 177 8 177 54] (self:MutBorrow.t t_UnionFind'0) (value:t_T'0) (return'  (ret:t_Element'0))= {[@expl:make 'self' type invariant] [%#sunion_find6] inv'6 self}
    {[@expl:make 'value' type invariant] [%#sunion_find7] inv'7 value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &value_snap <- [%#sunion_find0] value ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_12 <- C_Root'0 ([%#sunion_find1] (0 : UInt64.t)) value ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new'0 {_12} (fun (_ret':(Opaque.ptr, t_GhostBox'0)) ->  [ &_11 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &ptr <- let (r'0, _) = _11 in r'0 ] s1 | s1 =  [ &perm <- let (_, r'1) = _11 in r'1 ] s2 | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 =  [ &element <- { t_Element__0'0 = ptr } ] s1
      | s1 = into_inner'0 {perm} (fun (_ret':t_PtrOwn'0) ->  [ &perm1 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0
      [ s0 = {inv'0 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_mut <t_GhostBox'1> {(self.current).t_UnionFind__map'0}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_24 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_24} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_23 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'1 _23.current}
        MutBorrow.borrow_final <t_FMap'0> {_23.current} {MutBorrow.get_id _23}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_22 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_23 <- { _23 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {element} (fun (_ret':int) ->  [ &_27 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_26 <- _27 ] s1
      | s1 = get_mut_ghost'0 {_22} {_26} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = any [ br0 -> {_21 = C_None'0} (! bb11) | br1 (x0:MutBorrow.t t_PtrOwn'0)-> {_21 = C_Some'0 x0} (! bb12) ] 
    | bb12 = s0
      [ s0 = v_Some'0 {_21} (fun (r0'0:MutBorrow.t t_PtrOwn'0) ->  [ &other_perm <- r0'0 ] s1)
      | s1 = {inv'2 other_perm.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {other_perm.current} {MutBorrow.get_id other_perm}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_31 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &other_perm <- { other_perm with current = _ret'.final } ] 
            s2)
      | s2 =  [ &_33 <- perm1 ] s3
      | s3 = disjoint_lemma'0 {_31} {_33} (fun (_ret':()) ->  [ &_20 <- _ret' ] s4)
      | s4 = bb14 ]
    
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'3 other_perm} s1
      | s1 = -{resolve'0 other_perm}- s2
      | s2 = {[@expl:type invariant] inv'4 _23} s3
      | s3 = -{resolve'1 _23}- s4
      | s4 = bb15 ]
    
    | bb11 = bb13
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'4 _23} s1 | s1 = -{resolve'1 _23}- s2 | s2 = bb15 ] 
    | bb15 = s0
      [ s0 = {inv'0 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_37 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_37} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_36 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0
      [ s0 = {inv'1 _36.current}
        MutBorrow.borrow_final <t_FMap'0> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_35 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &_36 <- { _36 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {element} (fun (_ret':int) ->  [ &_38 <- _ret' ] s2)
      | s2 = bb17 ]
    
    | bb17 = s0
      [ s0 = insert_ghost'0 {_35} {_38} {perm1} (fun (_ret':t_Option'1) ->  [ &_34 <- _ret' ] s1)
      | s1 = {[@expl:type invariant] inv'5 _34} s2
      | s2 = -{resolve'2 _34}- s3
      | s3 = bb18 ]
    
    | bb18 = s0 [ s0 = {[@expl:type invariant] inv'4 _36} s1 | s1 = -{resolve'1 _36}- s2 | s2 = bb19 ] 
    | bb19 = bb20
    | bb20 = s0 [ s0 = new'1 {_17} (fun (_ret':t_GhostBox'2) ->  [ &_16 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = bb22
    | bb22 = s0
      [ s0 =  [ &_41 <- [%#sunion_find2] insert'0 (self.current).t_UnionFind__domain'0 element ] s1 | s1 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__domain'0 = _41 } } ] s1
      | s1 =  [ &_43 <- [%#sunion_find3] Map.set (self.current).t_UnionFind__values'0 element value_snap ] s2
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _43 } } ] s1
      | s1 =  [ &_45 <- [%#sunion_find4] Map.set (self.current).t_UnionFind__distance'0 element 0 ] s2
      | s2 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _45 } } ] s1
      | s1 =  [ &_47 <- [%#sunion_find5] Map.set (self.current).t_UnionFind__root_of'0 element element ] s2
      | s2 = bb26 ]
    
    | bb26 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _47 } } ] s1
      | s1 = {[@expl:type invariant] inv'6 self} s2
      | s2 = -{resolve'3 self}- s3
      | s3 =  [ &_0 <- element ] s4
      | s4 = bb27 ]
    
    | bb27 = bb28
    | bb28 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & value : t_T'0 = value
    | & value_snap : t_T'0 = Any.any_l ()
    | & ptr : Opaque.ptr = Any.any_l ()
    | & perm : t_GhostBox'0 = Any.any_l ()
    | & _11 : (Opaque.ptr, t_GhostBox'0) = Any.any_l ()
    | & _12 : t_Content'0 = Any.any_l ()
    | & element : t_Element'0 = Any.any_l ()
    | & _16 : t_GhostBox'2 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & perm1 : t_PtrOwn'0 = Any.any_l ()
    | & _20 : () = Any.any_l ()
    | & _21 : t_Option'0 = Any.any_l ()
    | & _22 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _23 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _26 : int = Any.any_l ()
    | & _27 : int = Any.any_l ()
    | & other_perm : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _31 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _33 : t_PtrOwn'0 = Any.any_l ()
    | & _34 : t_Option'1 = Any.any_l ()
    | & _35 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _36 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _38 : int = Any.any_l ()
    | & _41 : Fset.fset t_Element'0 = Any.any_l ()
    | & _43 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _45 : Map.map t_Element'0 int = Any.any_l ()
    | & _47 : Map.map t_Element'0 t_Element'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:make ensures #0] [%#sunion_find8] not contains'0 (domain'0 self.current) result}
      {[@expl:make ensures #1] [%#sunion_find9] domain'0 self.final = insert'0 (domain'0 self.current) result}
      {[@expl:make ensures #2] [%#sunion_find10] root_of'0 self.final = Map.set (root_of'0 self.current) result result}
      {[@expl:make ensures #3] [%#sunion_find11] values'0 self.final = Map.set (values'0 self.current) result value}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find_inner [#"union_find.rs" 203 8 203 64] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 203 27 203 31
  let%span sunion_find1 = "union_find.rs" 197 19 197 47
  let%span sunion_find2 = "union_find.rs" 198 18 198 48
  let%span sunion_find3 = "union_find.rs" 199 18 199 34
  let%span sunion_find4 = "union_find.rs" 201 18 201 54
  let%span sunion_find5 = "union_find.rs" 202 18 202 62
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost8 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sunion_find9 = "union_find.rs" 32 18 32 46
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost18 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 85 41 85 44
  let%span sptr_own20 = "../../creusot-contracts/src/ptr_own.rs" 82 15 82 31
  let%span sptr_own21 = "../../creusot-contracts/src/ptr_own.rs" 85 4 85 73
  let%span sptr_own22 = "../../creusot-contracts/src/ptr_own.rs" 83 14 83 35
  let%span sghost23 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost24 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sghost25 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 349 36 349 39
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own32 = "../../creusot-contracts/src/ptr_own.rs" 104 41 104 44
  let%span sptr_own33 = "../../creusot-contracts/src/ptr_own.rs" 99 15 99 31
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 104 4 104 81
  let%span sptr_own35 = "../../creusot-contracts/src/ptr_own.rs" 100 14 100 35
  let%span sptr_own36 = "../../creusot-contracts/src/ptr_own.rs" 102 14 102 53
  let%span sptr_own37 = "../../creusot-contracts/src/ptr_own.rs" 103 14 103 52
  let%span sfset38 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find39 = "union_find.rs" 135 19 135 28
  let%span sunion_find40 = "union_find.rs" 136 18 136 150
  let%span sunion_find41 = "union_find.rs" 133 8 133 16
  let%span smapping42 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find43 = "union_find.rs" 147 19 147 28
  let%span sunion_find44 = "union_find.rs" 148 18 148 98
  let%span sunion_find45 = "union_find.rs" 145 8 145 16
  let%span sunion_find46 = "union_find.rs" 167 16 169 52
  let%span sunion_find47 = "union_find.rs" 23 8 23 16
  let%span sfmap48 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost50 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sfmap51 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap52 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sresolve53 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find54 = "union_find.rs" 156 19 156 28
  let%span sunion_find55 = "union_find.rs" 157 18 157 106
  let%span sunion_find56 = "union_find.rs" 154 8 154 16
  let%span sutil57 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil58 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sunion_find59 = "union_find.rs" 82 8 82 20
  let%span sfmap60 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap61 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own62 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sinvariant63 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant64 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sunion_find65 = "union_find.rs" 127 8 127 16
  let%span sptr66 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr67 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sfmap68 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sboxed69 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap70 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap61] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap51] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap48] get_unsized'0 self k <> C_None'2
  
  predicate inv'23 (_1 : int)
  
  axiom inv_axiom'22 [@rewrite] : forall x : int [inv'23 x] . inv'23 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr67] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr66] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'2 (self : t_PtrOwn'0) =
    [%#sptr_own62] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'21 (_1 : t_T'0)
  
  predicate inv'6 (_1 : t_Content'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_Content'0 [inv'6 x] . inv'6 x
  = match x with
    | C_Root'0 rank value -> inv'21 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'13 (self : t_Content'0) =
    [%#sboxed69] inv'6 self
  
  predicate inv'20 (_1 : t_Content'0)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_Content'0 [inv'20 x] . inv'20 x = invariant'13 x
  
  predicate inv'3 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_PtrOwn'0 [inv'3 x] . inv'3 x
  = (invariant'2 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'20 val'
    end)
  
  predicate invariant'15 (self : t_PtrOwn'0) =
    [%#sboxed69] inv'3 self
  
  predicate inv'24 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'23 [@rewrite] : forall x : t_PtrOwn'0 [inv'24 x] . inv'24 x = invariant'15 x
  
  function unwrap'2 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'2_spec : forall op : t_Option'2 . ([%#sutil57] op <> C_None'2)
   -> ([%#sutil58] C_Some'2 (unwrap'2 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap49] unwrap'2 (get_unsized'0 self k)
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sfmap60] forall k : int . contains'1 self k  -> inv'23 k /\ inv'24 (lookup_unsized'0 self k)
  
  predicate inv'2 (_1 : t_FMap'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_FMap'0 [inv'2 x] . inv'2 x = invariant'1 x
  
  predicate invariant'12 (self : t_FMap'0) =
    [%#sboxed69] inv'2 self
  
  predicate inv'19 (_1 : t_FMap'0)
  
  axiom inv_axiom'19 [@rewrite] : forall x : t_FMap'0 [inv'19 x] . inv'19 x = invariant'12 x
  
  predicate inv'1 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'1 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'19 a_0
    end
  
  predicate invariant'7 (self : t_GhostBox'1) =
    [%#sinvariant64] inv'1 self
  
  predicate inv'9 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_GhostBox'1 [inv'9 x] . inv'9 x = invariant'7 x
  
  predicate invariant'8 (self : t_FMap'0) =
    [%#sinvariant64] inv'2 self
  
  predicate inv'10 (_1 : t_FMap'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_FMap'0 [inv'10 x] . inv'10 x = invariant'8 x
  
  let rec deref'0 (self:t_GhostBox'1) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost6] inv'9 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost7] inv'10 result}
      {[%#sghost8] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find47] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find9] result = deep_model'0 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate inv'11 (_1 : int)
  
  axiom inv_axiom'11 [@rewrite] : forall x : int [inv'11 x] . inv'11 x = true
  
  predicate invariant'9 (self : t_PtrOwn'0) =
    [%#sinvariant64] inv'3 self
  
  predicate inv'13 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_PtrOwn'0 [inv'13 x] . inv'13 x = invariant'9 x
  
  predicate inv'12 (_1 : t_Option'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Option'0 [inv'12 x] . inv'12 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'13 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap10] inv'10 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap11] inv'11 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap12] inv'12 result}
      {[%#sfmap13] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'12 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'13 result} {[%#soption15] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: t_PtrOwn'0 }
  
  predicate invariant'14 (self : t_PtrOwn'0) =
    [%#sboxed69] inv'13 self
  
  predicate inv'22 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'21 [@rewrite] : forall x : t_PtrOwn'0 [inv'22 x] . inv'22 x = invariant'14 x
  
  predicate inv'14 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_GhostBox'0 [inv'14 x] . inv'14 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'22 a_0
    end
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_GhostBox'0))= {[@expl:new 'x' type invariant] [%#sghost16] inv'13 x}
    any
    [ return' (result:t_GhostBox'0)-> {[%#sghost17] inv'14 result}
      {[%#sghost18] result.t_GhostBox__0'1 = x}
      (! return' {result}) ]
  
  
  function inner_logic'0 (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost50] self.t_GhostBox__0'1
  
  predicate invariant'10 (self : t_Content'0) =
    [%#sinvariant64] inv'6 self
  
  predicate inv'15 (_1 : t_Content'0)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_Content'0 [inv'15 x] . inv'15 x = invariant'10 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_GhostBox'0) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own19] inv'14 own}
    {[@expl:as_ref requires] [%#sptr_own20] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own21] inv'15 result}
      {[%#sptr_own22] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  let rec v_Link'0 (input:t_Content'0) (ret  (field_0:t_Element'0))= any
    [ good (field_0:t_Element'0)-> {C_Link'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Element'0 [C_Link'0 field_0 : t_Content'0] . C_Link'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset38] Fset.mem e self
  
  function inner_logic'2 (self : t_GhostBox'1) : t_FMap'0 =
    [%#sghost50] self.t_GhostBox__0'0
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap70] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap68] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find65] index_logic'3 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'2 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping42] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping42] Map.get self a
  
  function index_logic'1 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping42] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find59] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'2 self.t_UnionFind__values'0 e
    = index_logic'2 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'2 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'1 self.t_UnionFind__distance'0 e < index_logic'1 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'1 self.t_UnionFind__distance'0 e
    /\ index_logic'1 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'1 map
    end)
  
  predicate invariant'11 (self : MutBorrow.t t_GhostBox'1) =
    [%#sinvariant63] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'16 (_1 : MutBorrow.t t_GhostBox'1)
  
  axiom inv_axiom'16 [@rewrite] : forall x : MutBorrow.t t_GhostBox'1 [inv'16 x] . inv'16 x = invariant'11 x
  
  predicate invariant'3 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant63] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'4 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_GhostBox'1) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost23] inv'16 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost24] inv'4 result}
      {[%#sghost25] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'4 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant63] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'5 x] . inv'5 x = invariant'4 x
  
  predicate inv'17 (_1 : t_Option'1)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_Option'1 [inv'17 x] . inv'17 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'5 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap52] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap26] inv'4 self}
    {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap27] inv'11 key}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap28] inv'17 result}
      {[%#sfmap29] if contains'1 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap30] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap31] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'1) (return'  (ret:MutBorrow.t t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'17 self}
    {[@expl:unwrap requires] [%#soption14] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_PtrOwn'0)-> {inv'5 result}
      {[%#soption15] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  type t_GhostBox'2  =
    { t_GhostBox__0'2: MutBorrow.t t_PtrOwn'0 }
  
  predicate invariant'16 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sboxed69] inv'5 self
  
  predicate inv'25 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'24 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'25 x] . inv'25 x = invariant'16 x
  
  predicate inv'18 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_GhostBox'2 [inv'18 x] . inv'18 x
  = match x with
    | {t_GhostBox__0'2 = a_0} -> inv'25 a_0
    end
  
  let rec new'1 (x:MutBorrow.t t_PtrOwn'0) (return'  (ret:t_GhostBox'2))= {[@expl:new 'x' type invariant] [%#sghost16] inv'5 x}
    any
    [ return' (result:t_GhostBox'2)-> {[%#sghost17] inv'18 result}
      {[%#sghost18] result.t_GhostBox__0'2 = x}
      (! return' {result}) ]
  
  
  predicate resolve'4 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve53] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_FMap'0) =
    resolve'4 _1
  
  predicate resolve'5 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve53] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'5 _1
  
  function inner_logic'1 (self : t_GhostBox'2) : MutBorrow.t t_PtrOwn'0 =
    [%#sghost50] self.t_GhostBox__0'2
  
  predicate invariant'5 (self : MutBorrow.t t_Content'0) =
    [%#sinvariant63] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_1 : MutBorrow.t t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t t_Content'0 [inv'7 x] . inv'7 x = invariant'5 x
  
  let rec as_mut'0 (ptr:Opaque.ptr) (own:t_GhostBox'2) (return'  (ret:MutBorrow.t t_Content'0))= {[@expl:as_mut 'own' type invariant] [%#sptr_own32] inv'18 own}
    {[@expl:as_mut requires] [%#sptr_own33] ptr = ptr'0 (inner_logic'1 own).current}
    any
    [ return' (result:MutBorrow.t t_Content'0)-> {[%#sptr_own34] inv'7 result}
      {[%#sptr_own35] result.current = val'0 (inner_logic'1 own).current}
      {[%#sptr_own36] ptr'0 (inner_logic'1 own).final = ptr'0 (inner_logic'1 own).current}
      {[%#sptr_own37] val'0 (inner_logic'1 own).final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self : MutBorrow.t t_Content'0) =
    [%#sresolve53] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_Content'0) =
    resolve'6 _1
  
  predicate invariant'6 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant63] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate resolve'7 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve53] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'7 _1
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find41] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find39] inv'0 self)
   -> ([%#sunion_find40] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find45] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find43] inv'0 self)
   -> ([%#sunion_find44] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find56] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find54] inv'0 self)
   -> ([%#sunion_find55] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'2 (values'0 self) e = index_logic'2 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find46] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  meta "compute_max_steps" 1000000
  
  let rec find_inner'0[#"union_find.rs" 203 8 203 64] (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find_inner 'self' type invariant] [%#sunion_find0] inv'8 self}
    {[@expl:find_inner requires] [%#sunion_find1] contains'0 (domain'0 self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = deref'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_12 <- _ret' ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = addr'0 {elem} (fun (_ret':int) ->  [ &_16 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_15 <- _16 ] s1
      | s1 = get_ghost'0 {_12} {_15} (fun (_ret':t_Option'0) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':t_PtrOwn'0) ->  [ &_9 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'0 {_9} (fun (_ret':t_GhostBox'0) ->  [ &perm <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = as_ref'0 {elem.t_Element__0'0} {perm} (fun (_ret':t_Content'0) ->  [ &value <- _ret' ] s1) | s1 = bb6 ]
    
    | bb6 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {value = C_Root'0 x0 x1} (! bb8)
      | br1 (x0:t_Element'0)-> {value = C_Link'0 x0} (! bb9) ]
    
    | bb9 = s0
      [ s0 = v_Link'0 {value} (fun (r0'0:t_Element'0) ->  [ &e <- r0'0 ] s1)
      | s1 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_24 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s2)
      | s2 = find_inner'0 {_24} {e} (fun (_ret':t_Element'0) ->  [ &root <- _ret' ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'1 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_32 <- _ret' ] 
            -{inv'1 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_32} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0
      [ s0 = {inv'2 _31.current}
        MutBorrow.borrow_final <t_FMap'0> {_31.current} {MutBorrow.get_id _31}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_30 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &_31 <- { _31 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {elem} (fun (_ret':int) ->  [ &_35 <- _ret' ] s2)
      | s2 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_34 <- _35 ] s1
      | s1 = get_mut_ghost'0 {_30} {_34} (fun (_ret':t_Option'1) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'1 {_29} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_28 <- _ret' ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = {inv'3 _28.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_27 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_28 <- { _28 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_27} (fun (_ret':t_GhostBox'2) ->  [ &mut_perm <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'4 _31} s1
      | s1 = -{resolve'0 _31}- s2
      | s2 = {[@expl:type invariant] inv'5 _28} s3
      | s3 = -{resolve'1 _28}- s4
      | s4 =  [ &_38 <- C_Link'0 root ] s5
      | s5 = as_mut'0 {elem.t_Element__0'0} {mut_perm} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_40 <- _ret' ] s6)
      | s6 = bb17 ]
    
    | bb17 = bb18
    | bb18 = s0
      [ s0 = {[@expl:type invariant] match _40 with
          | {current = x'0} -> inv'6 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_40 <- { _40 with current = _38 } ] s2
      | s2 = {[@expl:type invariant] inv'7 _40} s3
      | s3 = -{resolve'2 _40}- s4
      | s4 = {[@expl:type invariant] inv'8 self} s5
      | s5 = -{resolve'3 self}- s6
      | s6 = bb20 ]
    
    | bb20 = s0 [ s0 =  [ &_0 <- root ] s1 | s1 = bb21 ] 
    | bb21 = bb22
    | bb8 = bb10
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'8 self} s1
      | s1 = -{resolve'3 self}- s2
      | s2 =  [ &_0 <- elem ] s3
      | s3 = bb22 ]
    
    | bb22 = bb23
    | bb23 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & perm : t_GhostBox'0 = Any.any_l ()
    | & _9 : t_PtrOwn'0 = Any.any_l ()
    | & _10 : t_Option'0 = Any.any_l ()
    | & _12 : t_FMap'0 = Any.any_l ()
    | & _15 : int = Any.any_l ()
    | & _16 : int = Any.any_l ()
    | & value : t_Content'0 = Any.any_l ()
    | & e : t_Element'0 = Any.any_l ()
    | & root : t_Element'0 = Any.any_l ()
    | & _24 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & mut_perm : t_GhostBox'2 = Any.any_l ()
    | & _27 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _28 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _29 : t_Option'1 = Any.any_l ()
    | & _30 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _31 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _32 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _34 : int = Any.any_l ()
    | & _35 : int = Any.any_l ()
    | & _38 : t_Content'0 = Any.any_l ()
    | & _40 : MutBorrow.t t_Content'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:find_inner ensures #0] [%#sunion_find2] result
      = index_logic'0 (root_of'0 self.current) elem}
      {[@expl:find_inner ensures #1] [%#sunion_find3] unchanged'0 self}
      {[@expl:find_inner ensures #2] [%#sunion_find4] (self.final).t_UnionFind__distance'0
      = (self.current).t_UnionFind__distance'0}
      {[@expl:find_inner ensures #3] [%#sunion_find5] index_logic'1 (self.current).t_UnionFind__distance'0 result
      >= index_logic'1 (self.current).t_UnionFind__distance'0 elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find [#"union_find.rs" 222 8 222 62] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 222 25 222 29
  let%span sunion_find1 = "union_find.rs" 219 19 219 47
  let%span sunion_find2 = "union_find.rs" 220 18 220 48
  let%span sunion_find3 = "union_find.rs" 221 18 221 34
  let%span sunion_find4 = "union_find.rs" 203 27 203 31
  let%span sunion_find5 = "union_find.rs" 197 19 197 47
  let%span sunion_find6 = "union_find.rs" 198 18 198 48
  let%span sunion_find7 = "union_find.rs" 199 18 199 34
  let%span sunion_find8 = "union_find.rs" 201 18 201 54
  let%span sunion_find9 = "union_find.rs" 202 18 202 62
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find11 = "union_find.rs" 135 19 135 28
  let%span sunion_find12 = "union_find.rs" 136 18 136 150
  let%span sunion_find13 = "union_find.rs" 133 8 133 16
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find15 = "union_find.rs" 147 19 147 28
  let%span sunion_find16 = "union_find.rs" 148 18 148 98
  let%span sunion_find17 = "union_find.rs" 145 8 145 16
  let%span sunion_find18 = "union_find.rs" 167 16 169 52
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find20 = "union_find.rs" 23 8 23 16
  let%span sunion_find21 = "union_find.rs" 156 19 156 28
  let%span sunion_find22 = "union_find.rs" 157 18 157 106
  let%span sunion_find23 = "union_find.rs" 154 8 154 16
  let%span sunion_find24 = "union_find.rs" 82 8 82 20
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost27 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find28 = "union_find.rs" 127 8 127 16
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed34 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil35 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr39 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr40 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset10] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find20] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap31] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap29] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost27] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil35] op <> C_None'0)
   -> ([%#sutil36] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap33] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap30] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find28] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'2 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'1 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find24] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'2 self.t_UnionFind__values'0 e
    = index_logic'2 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'2 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'1 self.t_UnionFind__distance'0 e < index_logic'1 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'1 self.t_UnionFind__distance'0 e
    /\ index_logic'1 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr40] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr39] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own38] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed34] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'8 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap37] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed34] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find13] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find11] inv'0 self)
   -> ([%#sunion_find12] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find17] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find15] inv'0 self)
   -> ([%#sunion_find16] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'2 (values'0 self) e = index_logic'2 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find18] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find_inner'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find_inner 'self' type invariant] [%#sunion_find4] inv'1 self}
    {[@expl:find_inner requires] [%#sunion_find5] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find6] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find7] unchanged'0 self}
      {[%#sunion_find8] (self.final).t_UnionFind__distance'0 = (self.current).t_UnionFind__distance'0}
      {[%#sunion_find9] index_logic'1 (self.current).t_UnionFind__distance'0 result
      >= index_logic'1 (self.current).t_UnionFind__distance'0 elem}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec find'0[#"union_find.rs" 222 8 222 62] (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:find requires] [%#sunion_find1] contains'0 (domain'0 self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_6 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find_inner'0 {_6} {elem} (fun (_ret':t_Element'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & _6 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:find ensures #0] [%#sunion_find2] result
      = index_logic'0 (root_of'0 self.current) elem}
      {[@expl:find ensures #1] [%#sunion_find3] unchanged'0 self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__get [#"union_find.rs" 232 8 232 49] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 232 20 232 24
  let%span sunion_find1 = "union_find.rs" 229 19 229 47
  let%span sunion_find2 = "union_find.rs" 230 19 230 47
  let%span sunion_find3 = "union_find.rs" 232 47 232 49
  let%span sunion_find4 = "union_find.rs" 231 18 231 48
  let%span sghost5 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost6 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost7 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sunion_find8 = "union_find.rs" 32 18 32 46
  let%span sfmap9 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sghost15 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost16 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost17 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sptr_own18 = "../../creusot-contracts/src/ptr_own.rs" 85 41 85 44
  let%span sptr_own19 = "../../creusot-contracts/src/ptr_own.rs" 82 15 82 31
  let%span sptr_own20 = "../../creusot-contracts/src/ptr_own.rs" 85 4 85 73
  let%span sptr_own21 = "../../creusot-contracts/src/ptr_own.rs" 83 14 83 35
  let%span sfset22 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find23 = "union_find.rs" 135 19 135 28
  let%span sunion_find24 = "union_find.rs" 136 18 136 150
  let%span sunion_find25 = "union_find.rs" 133 8 133 16
  let%span smapping26 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find27 = "union_find.rs" 147 19 147 28
  let%span sunion_find28 = "union_find.rs" 148 18 148 98
  let%span sunion_find29 = "union_find.rs" 145 8 145 16
  let%span sunion_find30 = "union_find.rs" 156 19 156 28
  let%span sunion_find31 = "union_find.rs" 157 18 157 106
  let%span sunion_find32 = "union_find.rs" 154 8 154 16
  let%span sunion_find33 = "union_find.rs" 23 8 23 16
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost36 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil38 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil39 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sinvariant40 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sunion_find42 = "union_find.rs" 82 8 82 20
  let%span sunion_find43 = "union_find.rs" 127 8 127 16
  let%span sboxed44 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap46 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own47 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sfmap48 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sptr49 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr50 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'1
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap41] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'1 =
    [%#sfmap37] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap34] get_unsized'0 self k <> C_None'1
  
  predicate inv'18 (_1 : int)
  
  axiom inv_axiom'17 [@rewrite] : forall x : int [inv'18 x] . inv'18 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr50] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr49] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'9 (self : t_PtrOwn'0) =
    [%#sptr_own47] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'12 (_1 : t_T'0)
  
  predicate inv'15 (_1 : t_Content'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_Content'0 [inv'15 x] . inv'15 x
  = match x with
    | C_Root'0 rank value -> inv'12 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'11 (self : t_Content'0) =
    [%#sboxed44] inv'15 self
  
  predicate inv'17 (_1 : t_Content'0)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_Content'0 [inv'17 x] . inv'17 x = invariant'11 x
  
  predicate inv'14 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_PtrOwn'0 [inv'14 x] . inv'14 x
  = (invariant'9 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'17 val'
    end)
  
  predicate invariant'12 (self : t_PtrOwn'0) =
    [%#sboxed44] inv'14 self
  
  predicate inv'19 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_PtrOwn'0 [inv'19 x] . inv'19 x = invariant'12 x
  
  function unwrap'1 (op : t_Option'1) : t_PtrOwn'0
  
  axiom unwrap'1_spec : forall op : t_Option'1 . ([%#sutil38] op <> C_None'1)
   -> ([%#sutil39] C_Some'1 (unwrap'1 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap35] unwrap'1 (get_unsized'0 self k)
  
  predicate invariant'8 (self : t_FMap'0) =
    [%#sfmap46] forall k : int . contains'1 self k  -> inv'18 k /\ inv'19 (lookup_unsized'0 self k)
  
  predicate inv'13 (_1 : t_FMap'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_FMap'0 [inv'13 x] . inv'13 x = invariant'8 x
  
  predicate invariant'10 (self : t_FMap'0) =
    [%#sboxed44] inv'13 self
  
  predicate inv'16 (_1 : t_FMap'0)
  
  axiom inv_axiom'15 [@rewrite] : forall x : t_FMap'0 [inv'16 x] . inv'16 x = invariant'10 x
  
  predicate inv'11 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'11 [@rewrite] : forall x : t_GhostBox'1 [inv'11 x] . inv'11 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'16 a_0
    end
  
  predicate invariant'2 (self : t_GhostBox'1) =
    [%#sinvariant40] inv'11 self
  
  predicate inv'2 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'1 [inv'2 x] . inv'2 x = invariant'2 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sinvariant40] inv'13 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'3 x
  
  let rec deref'0 (self:t_GhostBox'1) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost5] inv'2 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost6] inv'3 result}
      {[%#sghost7] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
  
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find33] addr_logic'0 self.t_Element__0'0
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find8] result = deep_model'0 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate inv'4 (_1 : int)
  
  axiom inv_axiom'4 [@rewrite] : forall x : int [inv'4 x] . inv'4 x = true
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sinvariant40] inv'14 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate inv'5 (_1 : t_Option'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_Option'0 [inv'5 x] . inv'5 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap9] inv'3 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap10] inv'4 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap11] inv'5 result}
      {[%#sfmap12] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'5 self}
    {[@expl:unwrap requires] [%#soption13] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'6 result} {[%#soption14] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: t_PtrOwn'0 }
  
  predicate invariant'7 (self : t_PtrOwn'0) =
    [%#sboxed44] inv'6 self
  
  predicate inv'10 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_PtrOwn'0 [inv'10 x] . inv'10 x = invariant'7 x
  
  predicate inv'7 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_GhostBox'0 [inv'7 x] . inv'7 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'10 a_0
    end
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_GhostBox'0))= {[@expl:new 'x' type invariant] [%#sghost15] inv'6 x}
    any
    [ return' (result:t_GhostBox'0)-> {[%#sghost16] inv'7 result}
      {[%#sghost17] result.t_GhostBox__0'1 = x}
      (! return' {result}) ]
  
  
  function inner_logic'0 (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost36] self.t_GhostBox__0'1
  
  predicate invariant'5 (self : t_Content'0) =
    [%#sinvariant40] inv'15 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_GhostBox'0) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own18] inv'7 own}
    {[@expl:as_ref requires] [%#sptr_own19] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own20] inv'8 result}
      {[%#sptr_own21] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  let rec v_Root'0 (input:t_Content'0) (ret  (rank:UInt64.t) (value:t_T'0))= any
    [ good (rank:UInt64.t) (value:t_T'0)-> {C_Root'0 rank value = input} (! ret {rank} {value})
    | bad -> {forall rank : UInt64.t, value : t_T'0 [C_Root'0 rank value : t_Content'0] . C_Root'0 rank value <> input}
      (! {false}
      any) ]
  
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset22] Fset.mem e self
  
  function inner_logic'1 (self : t_GhostBox'1) : t_FMap'0 =
    [%#sghost36] self.t_GhostBox__0'0
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap48] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap45] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find43] index_logic'3 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping26] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping26] Map.get self a
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping26] Map.get self a
  
  predicate invariant'6 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find42] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'1 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'9 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_UnionFind'0 [inv'9 x] . inv'9 x
  = (invariant'6 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'11 map
    end)
  
  predicate invariant'0 (self : t_UnionFind'0) =
    [%#sinvariant40] inv'9 self
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find25] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find23] inv'9 self)
   -> ([%#sunion_find24] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find29] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find27] inv'9 self)
   -> ([%#sunion_find28] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate invariant'1 (self : t_T'0) =
    [%#sinvariant40] inv'12 self
  
  predicate inv'1 (_1 : t_T'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_T'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find32] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find30] inv'9 self)
   -> ([%#sunion_find31] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec get'0[#"union_find.rs" 232 8 232 49] (self:t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_T'0))= {[@expl:get 'self' type invariant] [%#sunion_find0] inv'0 self}
    {[@expl:get requires #0] [%#sunion_find1] contains'0 (domain'0 self) elem}
    {[@expl:get requires #1] [%#sunion_find2] index_logic'0 (root_of'0 self) elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref'0 {self.t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_10 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = addr'0 {elem} (fun (_ret':int) ->  [ &_14 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_13 <- _14 ] s1
      | s1 = get_ghost'0 {_10} {_13} (fun (_ret':t_Option'0) ->  [ &_8 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_8} (fun (_ret':t_PtrOwn'0) ->  [ &_7 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'0 {_7} (fun (_ret':t_GhostBox'0) ->  [ &perm <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = as_ref'0 {elem.t_Element__0'0} {perm} (fun (_ret':t_Content'0) ->  [ &_16 <- _ret' ] s1) | s1 = bb6 ]
    
    | bb6 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_16 = C_Root'0 x0 x1} (! bb8)
      | br1 (x0:t_Element'0)-> {_16 = C_Link'0 x0} (! bb7) ]
    
    | bb7 = bb10
    | bb10 = bb10 [ bb10 = (! bb11) [ bb11 = bb10 ]  ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = v_Root'0 {_16} (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->  [ &value <- rvalue'0 ] s1)
      | s1 =  [ &_0 <- value ] s2
      | s2 = bb12 ]
    
    | bb12 = return' {_0} ]
    )
    [ & _0 : t_T'0 = Any.any_l ()
    | & self : t_UnionFind'0 = self
    | & elem : t_Element'0 = elem
    | & perm : t_GhostBox'0 = Any.any_l ()
    | & _7 : t_PtrOwn'0 = Any.any_l ()
    | & _8 : t_Option'0 = Any.any_l ()
    | & _10 : t_FMap'0 = Any.any_l ()
    | & _13 : int = Any.any_l ()
    | & _14 : int = Any.any_l ()
    | & _16 : t_Content'0 = Any.any_l ()
    | & value : t_T'0 = Any.any_l () ]
    
    [ return' (result:t_T'0)-> {[@expl:get result type invariant] [%#sunion_find3] inv'1 result}
      {[@expl:get ensures] [%#sunion_find4] result = index_logic'1 (values'0 self) elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__equiv [#"union_find.rs" 245 8 245 71] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 245 26 245 30
  let%span sunion_find1 = "union_find.rs" 241 19 241 48
  let%span sunion_find2 = "union_find.rs" 242 19 242 48
  let%span sunion_find3 = "union_find.rs" 243 18 243 70
  let%span sunion_find4 = "union_find.rs" 244 18 244 34
  let%span sunion_find5 = "union_find.rs" 222 25 222 29
  let%span sunion_find6 = "union_find.rs" 219 19 219 47
  let%span sunion_find7 = "union_find.rs" 220 18 220 48
  let%span sunion_find8 = "union_find.rs" 221 18 221 34
  let%span sptr9 = "../../creusot-contracts/src/std/ptr.rs" 131 22 131 66
  let%span sfset10 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find11 = "union_find.rs" 135 19 135 28
  let%span sunion_find12 = "union_find.rs" 136 18 136 150
  let%span sunion_find13 = "union_find.rs" 133 8 133 16
  let%span smapping14 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find15 = "union_find.rs" 147 19 147 28
  let%span sunion_find16 = "union_find.rs" 148 18 148 98
  let%span sunion_find17 = "union_find.rs" 145 8 145 16
  let%span sunion_find18 = "union_find.rs" 167 16 169 52
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find20 = "union_find.rs" 23 8 23 16
  let%span sunion_find21 = "union_find.rs" 156 19 156 28
  let%span sunion_find22 = "union_find.rs" 157 18 157 106
  let%span sunion_find23 = "union_find.rs" 154 8 154 16
  let%span sunion_find24 = "union_find.rs" 82 8 82 20
  let%span sinvariant25 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost27 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find28 = "union_find.rs" 127 8 127 16
  let%span sfmap29 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap30 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed34 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil35 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil36 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap37 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own38 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr39 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr40 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset10] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find20] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap31] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap29] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap26] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost27] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil35] op <> C_None'0)
   -> ([%#sutil36] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap33] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap30] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find28] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping14] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping14] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping14] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find24] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr40] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr39] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own38] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed34] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'8 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed34] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap37] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed34] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant25] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find13] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find11] inv'0 self)
   -> ([%#sunion_find12] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find17] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find15] inv'0 self)
   -> ([%#sunion_find16] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find18] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find5] inv'1 self}
    {[@expl:find requires] [%#sunion_find6] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find7] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find8] unchanged'0 self}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve19] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  let rec addr_eq'0 (p:Opaque.ptr) (q:Opaque.ptr) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sptr9] result = (addr_logic'0 p = addr_logic'0 q)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec equiv'0[#"union_find.rs" 245 8 245 71] (self:MutBorrow.t t_UnionFind'0) (e1:t_Element'0) (e2:t_Element'0) (return'  (ret:bool))= {[@expl:equiv 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:equiv requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) e1}
    {[@expl:equiv requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_9} {e1} (fun (_ret':t_Element'0) ->  [ &r1 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_12 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_12} {e2} (fun (_ret':t_Element'0) ->  [ &r2 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'1 self} s1
      | s1 = -{resolve'0 self}- s2
      | s2 = addr_eq'0 {r1.t_Element__0'0} {r2.t_Element__0'0} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = return' {_0} ]
    )
    [ & _0 : bool = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & e1 : t_Element'0 = e1
    | & e2 : t_Element'0 = e2
    | & r1 : t_Element'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & r2 : t_Element'0 = Any.any_l ()
    | & _12 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:bool)-> {[@expl:equiv ensures #0] [%#sunion_find3] result
      = (index_logic'0 (root_of'0 self.current) e1 = index_logic'0 (root_of'0 self.current) e2)}
      {[@expl:equiv ensures #1] [%#sunion_find4] unchanged'0 self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__link [#"union_find.rs" 282 8 282 70] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 300 20 300 93
  let%span sunion_find1 = "union_find.rs" 302 20 302 94
  let%span sunion_find2 = "union_find.rs" 303 33 303 63
  let%span sunion_find3 = "union_find.rs" 305 20 305 95
  let%span sunion_find4 = "union_find.rs" 313 88 313 89
  let%span sunion_find5 = "union_find.rs" 318 20 318 93
  let%span sunion_find6 = "union_find.rs" 320 20 320 94
  let%span sunion_find7 = "union_find.rs" 321 33 321 63
  let%span sunion_find8 = "union_find.rs" 323 20 323 95
  let%span sunion_find9 = "union_find.rs" 282 21 282 25
  let%span sunion_find10 = "union_find.rs" 261 19 261 44
  let%span sunion_find11 = "union_find.rs" 262 19 262 41
  let%span sunion_find12 = "union_find.rs" 263 19 263 44
  let%span sunion_find13 = "union_find.rs" 264 19 264 41
  let%span sunion_find14 = "union_find.rs" 265 18 265 54
  let%span sunion_find15 = "union_find.rs" 266 18 266 82
  let%span sunion_find16 = "union_find.rs" 267 18 267 53
  let%span sunion_find17 = "union_find.rs" 268 18 273 13
  let%span sunion_find18 = "union_find.rs" 275 18 280 13
  let%span sunion_find19 = "union_find.rs" 16 18 16 69
  let%span sghost20 = "../../creusot-contracts/src/ghost.rs" 69 14 69 18
  let%span sghost21 = "../../creusot-contracts/src/ghost.rs" 69 4 69 36
  let%span sghost22 = "../../creusot-contracts/src/ghost.rs" 68 14 68 35
  let%span sunion_find23 = "union_find.rs" 32 18 32 46
  let%span sfmap24 = "../../creusot-contracts/src/logic/fmap.rs" 315 22 315 26
  let%span sfmap25 = "../../creusot-contracts/src/logic/fmap.rs" 315 28 315 31
  let%span sfmap26 = "../../creusot-contracts/src/logic/fmap.rs" 315 4 315 50
  let%span sfmap27 = "../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span soption28 = "../../creusot-contracts/src/std/option.rs" 89 27 89 39
  let%span soption29 = "../../creusot-contracts/src/std/option.rs" 90 26 90 46
  let%span sghost30 = "../../creusot-contracts/src/ghost.rs" 185 15 185 16
  let%span sghost31 = "../../creusot-contracts/src/ghost.rs" 185 4 185 28
  let%span sghost32 = "../../creusot-contracts/src/ghost.rs" 183 14 183 28
  let%span sptr_own33 = "../../creusot-contracts/src/ptr_own.rs" 85 41 85 44
  let%span sptr_own34 = "../../creusot-contracts/src/ptr_own.rs" 82 15 82 31
  let%span sptr_own35 = "../../creusot-contracts/src/ptr_own.rs" 85 4 85 73
  let%span sptr_own36 = "../../creusot-contracts/src/ptr_own.rs" 83 14 83 35
  let%span sghost37 = "../../creusot-contracts/src/ghost.rs" 85 22 85 26
  let%span sghost38 = "../../creusot-contracts/src/ghost.rs" 85 4 85 48
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 84 14 84 36
  let%span sfmap40 = "../../creusot-contracts/src/logic/fmap.rs" 349 30 349 34
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 349 36 349 39
  let%span sfmap42 = "../../creusot-contracts/src/logic/fmap.rs" 349 4 349 62
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sptr_own46 = "../../creusot-contracts/src/ptr_own.rs" 104 41 104 44
  let%span sptr_own47 = "../../creusot-contracts/src/ptr_own.rs" 99 15 99 31
  let%span sptr_own48 = "../../creusot-contracts/src/ptr_own.rs" 104 4 104 81
  let%span sptr_own49 = "../../creusot-contracts/src/ptr_own.rs" 100 14 100 35
  let%span sptr_own50 = "../../creusot-contracts/src/ptr_own.rs" 102 14 102 53
  let%span sptr_own51 = "../../creusot-contracts/src/ptr_own.rs" 103 14 103 52
  let%span smapping52 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find53 = "union_find.rs" 75 15 75 19
  let%span sunion_find54 = "union_find.rs" 76 14 76 32
  let%span sfset55 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find56 = "union_find.rs" 135 19 135 28
  let%span sunion_find57 = "union_find.rs" 136 18 136 150
  let%span sunion_find58 = "union_find.rs" 133 8 133 16
  let%span sunion_find59 = "union_find.rs" 147 19 147 28
  let%span sunion_find60 = "union_find.rs" 148 18 148 98
  let%span sunion_find61 = "union_find.rs" 145 8 145 16
  let%span sunion_find62 = "union_find.rs" 257 12 257 50
  let%span sunion_find63 = "union_find.rs" 156 19 156 28
  let%span sunion_find64 = "union_find.rs" 157 18 157 106
  let%span sunion_find65 = "union_find.rs" 154 8 154 16
  let%span smodel66 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sresolve67 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find68 = "union_find.rs" 23 8 23 16
  let%span sfmap69 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap70 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sghost71 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sghost72 = "../../creusot-contracts/src/ghost.rs" 108 4 108 27
  let%span sfmap73 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap74 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sinvariant75 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sutil76 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil77 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sresolve78 = "../../creusot-contracts/src/resolve.rs" 68 8 68 23
  let%span sfmap79 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap80 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own81 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sinvariant82 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sptr83 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr84 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  let%span sunion_find85 = "union_find.rs" 82 8 82 20
  let%span sboxed86 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sunion_find87 = "union_find.rs" 127 8 127 16
  let%span sfmap88 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap89 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find68] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel66] deep_model'1 self
  
  let rec eq'0 (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sunion_find19] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_GhostBox'1  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'1;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset55] Fset.mem e self
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'2
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap80] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'2 =
    [%#sfmap73] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap69] get_unsized'0 self k <> C_None'2
  
  function inner_logic'2 (self : t_GhostBox'1) : t_FMap'0 =
    [%#sghost71] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'2 (op : t_Option'2) : t_PtrOwn'0
  
  axiom unwrap'2_spec : forall op : t_Option'2 . ([%#sutil76] op <> C_None'2)
   -> ([%#sutil77] C_Some'2 (unwrap'2 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap70] unwrap'2 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap89] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap88] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find87] index_logic'3 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'1 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping52] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping52] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping52] Map.get self a
  
  predicate invariant'11 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find85] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'2 self.t_UnionFind__map'0) (deep_model'1 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'23 (_1 : int)
  
  axiom inv_axiom'22 [@rewrite] : forall x : int [inv'23 x] . inv'23 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr84] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr83] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'2 (self : t_PtrOwn'0) =
    [%#sptr_own81] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'22 (_1 : t_T'0)
  
  predicate inv'7 (_1 : t_Content'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_Content'0 [inv'7 x] . inv'7 x
  = match x with
    | C_Root'0 rank value -> inv'22 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'14 (self : t_Content'0) =
    [%#sboxed86] inv'7 self
  
  predicate inv'21 (_1 : t_Content'0)
  
  axiom inv_axiom'21 [@rewrite] : forall x : t_Content'0 [inv'21 x] . inv'21 x = invariant'14 x
  
  predicate inv'4 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn'0 [inv'4 x] . inv'4 x
  = (invariant'2 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'21 val'
    end)
  
  predicate invariant'15 (self : t_PtrOwn'0) =
    [%#sboxed86] inv'4 self
  
  predicate inv'24 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'23 [@rewrite] : forall x : t_PtrOwn'0 [inv'24 x] . inv'24 x = invariant'15 x
  
  predicate invariant'1 (self : t_FMap'0) =
    [%#sfmap79] forall k : int . contains'1 self k  -> inv'23 k /\ inv'24 (lookup_unsized'0 self k)
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'1 x
  
  predicate invariant'13 (self : t_FMap'0) =
    [%#sboxed86] inv'3 self
  
  predicate inv'20 (_1 : t_FMap'0)
  
  axiom inv_axiom'20 [@rewrite] : forall x : t_FMap'0 [inv'20 x] . inv'20 x = invariant'13 x
  
  predicate inv'2 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'1 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'20 a_0
    end
  
  predicate inv'18 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'18 [@rewrite] : forall x : t_UnionFind'0 [inv'18 x] . inv'18 x
  = (invariant'11 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'0 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant75] inv'18 self.current /\ inv'18 self.final
  
  predicate inv'0 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate resolve'6 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'6 _1
  
  predicate invariant'6 (self : t_GhostBox'1) =
    [%#sinvariant82] inv'2 self
  
  predicate inv'9 (_1 : t_GhostBox'1)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_GhostBox'1 [inv'9 x] . inv'9 x = invariant'6 x
  
  predicate invariant'7 (self : t_FMap'0) =
    [%#sinvariant82] inv'3 self
  
  predicate inv'10 (_1 : t_FMap'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_FMap'0 [inv'10 x] . inv'10 x = invariant'7 x
  
  let rec deref'0 (self:t_GhostBox'1) (return'  (ret:t_FMap'0))= {[@expl:deref 'self' type invariant] [%#sghost20] inv'9 self}
    any
    [ return' (result:t_FMap'0)-> {[%#sghost21] inv'10 result}
      {[%#sghost22] self.t_GhostBox__0'0 = result}
      (! return' {result}) ]
  
  
  let rec addr'0 (self:t_Element'0) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#sunion_find23] result = deep_model'1 self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  predicate inv'11 (_1 : int)
  
  axiom inv_axiom'11 [@rewrite] : forall x : int [inv'11 x] . inv'11 x = true
  
  predicate invariant'8 (self : t_PtrOwn'0) =
    [%#sinvariant82] inv'4 self
  
  predicate inv'13 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'13 [@rewrite] : forall x : t_PtrOwn'0 [inv'13 x] . inv'13 x = invariant'8 x
  
  predicate inv'12 (_1 : t_Option'0)
  
  axiom inv_axiom'12 [@rewrite] : forall x : t_Option'0 [inv'12 x] . inv'12 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'13 a_0
    end
  
  let rec get_ghost'0 (self:t_FMap'0) (key:int) (return'  (ret:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap24] inv'10 self}
    {[@expl:get_ghost 'key' type invariant] [%#sfmap25] inv'11 key}
    any
    [ return' (result:t_Option'0)-> {[%#sfmap26] inv'12 result}
      {[%#sfmap27] if contains'1 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized'0 self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'12 self}
    {[@expl:unwrap requires] [%#soption28] self <> C_None'0}
    any [ return' (result:t_PtrOwn'0)-> {inv'13 result} {[%#soption29] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_GhostBox'0  =
    { t_GhostBox__0'1: t_PtrOwn'0 }
  
  predicate invariant'12 (self : t_PtrOwn'0) =
    [%#sboxed86] inv'13 self
  
  predicate inv'19 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'19 [@rewrite] : forall x : t_PtrOwn'0 [inv'19 x] . inv'19 x = invariant'12 x
  
  predicate inv'1 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_GhostBox'0 [inv'1 x] . inv'1 x
  = match x with
    | {t_GhostBox__0'1 = a_0} -> inv'19 a_0
    end
  
  let rec new'0 (x:t_PtrOwn'0) (return'  (ret:t_GhostBox'0))= {[@expl:new 'x' type invariant] [%#sghost30] inv'13 x}
    any
    [ return' (result:t_GhostBox'0)-> {[%#sghost31] inv'1 result}
      {[%#sghost32] result.t_GhostBox__0'1 = x}
      (! return' {result}) ]
  
  
  function inner_logic'0 (self : t_GhostBox'0) : t_PtrOwn'0 =
    [%#sghost71] self.t_GhostBox__0'1
  
  predicate invariant'9 (self : t_Content'0) =
    [%#sinvariant82] inv'7 self
  
  predicate inv'14 (_1 : t_Content'0)
  
  axiom inv_axiom'14 [@rewrite] : forall x : t_Content'0 [inv'14 x] . inv'14 x = invariant'9 x
  
  let rec as_ref'0 (ptr:Opaque.ptr) (own:t_GhostBox'0) (return'  (ret:t_Content'0))= {[@expl:as_ref 'own' type invariant] [%#sptr_own33] inv'1 own}
    {[@expl:as_ref requires] [%#sptr_own34] ptr = ptr'0 (inner_logic'0 own)}
    any
    [ return' (result:t_Content'0)-> {[%#sptr_own35] inv'14 result}
      {[%#sptr_own36] result = val'0 (inner_logic'0 own)}
      (! return' {result}) ]
  
  
  predicate resolve'13 (_1 : t_PtrOwn'0) =
    true
  
  predicate resolve'12 (self : t_PtrOwn'0) =
    [%#sresolve78] resolve'13 self
  
  predicate resolve'7 (self : t_GhostBox'0) =
    [%#sghost72] resolve'12 self.t_GhostBox__0'1
  
  predicate resolve'1 (_1 : t_GhostBox'0) =
    resolve'7 _1
  
  let rec v_Root'0 (input:t_Content'0) (ret  (rank:UInt64.t) (value:t_T'0))= any
    [ good (rank:UInt64.t) (value:t_T'0)-> {C_Root'0 rank value = input} (! ret {rank} {value})
    | bad -> {forall rank : UInt64.t, value : t_T'0 [C_Root'0 rank value : t_Content'0] . C_Root'0 rank value <> input}
      (! {false}
      any) ]
  
  
  predicate invariant'10 (self : MutBorrow.t t_GhostBox'1) =
    [%#sinvariant75] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'15 (_1 : MutBorrow.t t_GhostBox'1)
  
  axiom inv_axiom'15 [@rewrite] : forall x : MutBorrow.t t_GhostBox'1 [inv'15 x] . inv'15 x = invariant'10 x
  
  predicate invariant'3 (self : MutBorrow.t t_FMap'0) =
    [%#sinvariant75] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'5 (_1 : MutBorrow.t t_FMap'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : MutBorrow.t t_FMap'0 [inv'5 x] . inv'5 x = invariant'3 x
  
  let rec deref_mut'0 (self:MutBorrow.t t_GhostBox'1) (return'  (ret:MutBorrow.t t_FMap'0))= {[@expl:deref_mut 'self' type invariant] [%#sghost37] inv'15 self}
    any
    [ return' (result:MutBorrow.t t_FMap'0)-> {[%#sghost38] inv'5 result}
      {[%#sghost39] result
      = MutBorrow.borrow_logic (self.current).t_GhostBox__0'0 (self.final).t_GhostBox__0'0 (MutBorrow.inherit_id (MutBorrow.get_id self) 1)}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn'0)
  
  predicate invariant'4 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sinvariant75] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate inv'16 (_1 : t_Option'1)
  
  axiom inv_axiom'16 [@rewrite] : forall x : t_Option'1 [inv'16 x] . inv'16 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'6 a_0
    end
  
  function len'0 (self : t_FMap'0) : int
  
  axiom len'0_spec : forall self : t_FMap'0 . [%#sfmap74] len'0 self >= 0
  
  let rec get_mut_ghost'0 (self:MutBorrow.t t_FMap'0) (key:int) (return'  (ret:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap40] inv'5 self}
    {[@expl:get_mut_ghost 'key' type invariant] [%#sfmap41] inv'11 key}
    any
    [ return' (result:t_Option'1)-> {[%#sfmap42] inv'16 result}
      {[%#sfmap43] if contains'1 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'1 self.final key
          /\ lookup_unsized'0 self.current key = r.current /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap44] forall k : int . k <> key  -> get_unsized'0 self.current k = get_unsized'0 self.final k}
      {[%#sfmap45] len'0 self.current = len'0 self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self:t_Option'1) (return'  (ret:MutBorrow.t t_PtrOwn'0))= {[@expl:unwrap 'self' type invariant] inv'16 self}
    {[@expl:unwrap requires] [%#soption28] self <> C_None'1}
    any
    [ return' (result:MutBorrow.t t_PtrOwn'0)-> {inv'6 result}
      {[%#soption29] C_Some'1 result = self}
      (! return' {result}) ]
  
  
  type t_GhostBox'2  =
    { t_GhostBox__0'2: MutBorrow.t t_PtrOwn'0 }
  
  predicate invariant'16 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sboxed86] inv'6 self
  
  predicate inv'25 (_1 : MutBorrow.t t_PtrOwn'0)
  
  axiom inv_axiom'24 [@rewrite] : forall x : MutBorrow.t t_PtrOwn'0 [inv'25 x] . inv'25 x = invariant'16 x
  
  predicate inv'17 (_1 : t_GhostBox'2)
  
  axiom inv_axiom'17 [@rewrite] : forall x : t_GhostBox'2 [inv'17 x] . inv'17 x
  = match x with
    | {t_GhostBox__0'2 = a_0} -> inv'25 a_0
    end
  
  let rec new'1 (x:MutBorrow.t t_PtrOwn'0) (return'  (ret:t_GhostBox'2))= {[@expl:new 'x' type invariant] [%#sghost30] inv'6 x}
    any
    [ return' (result:t_GhostBox'2)-> {[%#sghost31] inv'17 result}
      {[%#sghost32] result.t_GhostBox__0'2 = x}
      (! return' {result}) ]
  
  
  predicate resolve'8 (self : MutBorrow.t t_FMap'0) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t t_FMap'0) =
    resolve'8 _1
  
  predicate resolve'9 (self : MutBorrow.t t_PtrOwn'0) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t t_PtrOwn'0) =
    resolve'9 _1
  
  function inner_logic'1 (self : t_GhostBox'2) : MutBorrow.t t_PtrOwn'0 =
    [%#sghost71] self.t_GhostBox__0'2
  
  predicate invariant'5 (self : MutBorrow.t t_Content'0) =
    [%#sinvariant75] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_1 : MutBorrow.t t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t t_Content'0 [inv'8 x] . inv'8 x = invariant'5 x
  
  let rec as_mut'0 (ptr:Opaque.ptr) (own:t_GhostBox'2) (return'  (ret:MutBorrow.t t_Content'0))= {[@expl:as_mut 'own' type invariant] [%#sptr_own46] inv'17 own}
    {[@expl:as_mut requires] [%#sptr_own47] ptr = ptr'0 (inner_logic'1 own).current}
    any
    [ return' (result:MutBorrow.t t_Content'0)-> {[%#sptr_own48] inv'8 result}
      {[%#sptr_own49] result.current = val'0 (inner_logic'1 own).current}
      {[%#sptr_own50] ptr'0 (inner_logic'1 own).final = ptr'0 (inner_logic'1 own).current}
      {[%#sptr_own51] val'0 (inner_logic'1 own).final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'10 (self : MutBorrow.t t_Content'0) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'4 (_1 : MutBorrow.t t_Content'0) =
    resolve'10 _1
  
  let rec add_no_overflow'0 (x:UInt64.t) (y:UInt64.t) (return'  (ret:UInt64.t))= {[@expl:add_no_overflow requires] [%#sunion_find53] true}
    any
    [ return' (result:UInt64.t)-> {[%#sunion_find54] UInt64.t'int result = UInt64.t'int x + UInt64.t'int y}
      (! return' {result}) ]
  
  
  predicate resolve'11 (self : MutBorrow.t UInt64.t) =
    [%#sresolve67] self.final = self.current
  
  predicate resolve'5 (_1 : MutBorrow.t UInt64.t) =
    resolve'11 _1
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find58] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find56] inv'18 self)
   -> ([%#sunion_find57] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find61] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find59] inv'18 self)
   -> ([%#sunion_find60] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate equiv_log'0 [#"union_find.rs" 256 8 256 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find62] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find65] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find63] inv'18 self)
   -> ([%#sunion_find64] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec link'0[#"union_find.rs" 282 8 282 70] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:link 'self' type invariant] [%#sunion_find9] inv'0 self}
    {[@expl:link requires #0] [%#sunion_find10] contains'0 (domain'0 self.current) x}
    {[@expl:link requires #1] [%#sunion_find11] index_logic'0 (root_of'0 self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find12] contains'0 (domain'0 self.current) y}
    {[@expl:link requires #3] [%#sunion_find13] index_logic'0 (root_of'0 self.current) y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {x} {y} (fun (_ret':bool) ->  [ &_14 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_14 = false} (! bb3) | br1 -> {_14} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 =  [ &_0 <- x ] s3 | s3 = bb70 ]
    
    | bb3 = s0
      [ s0 = deref'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_22 <- _ret' ] s1) | s1 = bb4 ]
    
    | bb4 = s0 [ s0 = addr'0 {x} (fun (_ret':int) ->  [ &_26 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_25 <- _26 ] s1
      | s1 = get_ghost'0 {_22} {_25} (fun (_ret':t_Option'0) ->  [ &_20 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = unwrap'0 {_20} (fun (_ret':t_PtrOwn'0) ->  [ &_19 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 = new'0 {_19} (fun (_ret':t_GhostBox'0) ->  [ &perm_x <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = deref'0 {(self.current).t_UnionFind__map'0} (fun (_ret':t_FMap'0) ->  [ &_32 <- _ret' ] s1) | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = addr'0 {y} (fun (_ret':int) ->  [ &_36 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_35 <- _36 ] s1
      | s1 = get_ghost'0 {_32} {_35} (fun (_ret':t_Option'0) ->  [ &_30 <- _ret' ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = unwrap'0 {_30} (fun (_ret':t_PtrOwn'0) ->  [ &_29 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 = new'0 {_29} (fun (_ret':t_GhostBox'0) ->  [ &perm_y <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = as_ref'0 {x.t_Element__0'0} {perm_x} (fun (_ret':t_Content'0) ->  [ &_41 <- _ret' ] s1) | s1 = bb14 ]
    
    | bb14 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_41 = C_Root'0 x0 x1} (! bb16)
      | br1 (x0:t_Element'0)-> {_41 = C_Link'0 x0} (! bb15) ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'1 perm_y} s1
      | s1 = -{resolve'1 perm_y}- s2
      | s2 = {[@expl:type invariant] inv'0 self} s3
      | s3 = -{resolve'0 self}- s4
      | s4 = {false} any ]
    
    | bb16 = bb17
    | bb17 = s0
      [ s0 = v_Root'0 {_41} (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->  [ &rank <- rrank'0 ] s1)
      | s1 = v_Root'0 {_41} (fun (rrank'1:UInt64.t) (rvalue'1:t_T'0) ->  [ &value <- rvalue'1 ] s2)
      | s2 =  [ &_40 <- (rank, value) ] s3
      | s3 =  [ &rx <- let (r'0, _) = _40 in r'0 ] s4
      | s4 =  [ &vx <- let (_, r'1) = _40 in r'1 ] s5
      | s5 = as_ref'0 {y.t_Element__0'0} {perm_y} (fun (_ret':t_Content'0) ->  [ &_53 <- _ret' ] s6)
      | s6 = bb18 ]
    
    | bb18 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_53 = C_Root'0 x0 x1} (! bb20)
      | br1 (x0:t_Element'0)-> {_53 = C_Link'0 x0} (! bb19) ]
    
    | bb19 = s0 [ s0 = {[@expl:type invariant] inv'0 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = {false} any ] 
    | bb20 = bb21
    | bb21 = s0
      [ s0 = v_Root'0 {_53} (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->  [ &rank1 <- rrank'0 ] s1)
      | s1 = v_Root'0 {_53} (fun (rrank'1:UInt64.t) (rvalue'1:t_T'0) ->  [ &value1 <- rvalue'1 ] s2)
      | s2 =  [ &_52 <- (rank1, value1) ] s3
      | s3 =  [ &ry <- let (r'0, _) = _52 in r'0 ] s4
      | s4 =  [ &vy <- let (_, r'1) = _52 in r'1 ] s5
      | s5 =  [ &_62 <- UInt64.lt rx ry ] s6
      | s6 = any [ br0 -> {_62 = false} (! bb23) | br1 -> {_62} (! bb22) ]  ]
    
    | bb22 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_71 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_71} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_70 <- _ret' ] s2)
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 = {inv'3 _70.current}
        MutBorrow.borrow_final <t_FMap'0> {_70.current} {MutBorrow.get_id _70}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_69 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_70 <- { _70 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {x} (fun (_ret':int) ->  [ &_74 <- _ret' ] s2)
      | s2 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &_73 <- _74 ] s1
      | s1 = get_mut_ghost'0 {_69} {_73} (fun (_ret':t_Option'1) ->  [ &_68 <- _ret' ] s2)
      | s2 = bb26 ]
    
    | bb26 = s0 [ s0 = unwrap'1 {_68} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_67 <- _ret' ] s1) | s1 = bb27 ] 
    | bb27 = s0
      [ s0 = {inv'4 _67.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_67.current} {MutBorrow.get_id _67}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_66 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_67 <- { _67 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_66} (fun (_ret':t_GhostBox'2) ->  [ &perm_mut_x <- _ret' ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'5 _70} s1
      | s1 = -{resolve'2 _70}- s2
      | s2 = {[@expl:type invariant] inv'6 _67} s3
      | s3 = -{resolve'3 _67}- s4
      | s4 =  [ &_77 <- C_Link'0 y ] s5
      | s5 = as_mut'0 {x.t_Element__0'0} {perm_mut_x} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_79 <- _ret' ] s6)
      | s6 = bb29 ]
    
    | bb29 = bb30
    | bb30 = s0
      [ s0 = {[@expl:type invariant] match _79 with
          | {current = x'0} -> inv'7 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_79 <- { _79 with current = _77 } ] s2
      | s2 = {[@expl:type invariant] inv'8 _79} s3
      | s3 = -{resolve'4 _79}- s4
      | s4 = bb32 ]
    
    | bb32 = s0
      [ s0 = 
        [ &_82 <- [%#sunion_find0] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = x then
          y
        else
          index_logic'0 (self.current).t_UnionFind__root_of'0 z
         ]
        
        s1
      | s1 = bb33 ]
    
    | bb33 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _82 } } ] s1
      | s1 = 
        [ &_84 <- [%#sunion_find1] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = y then
          vy
        else
          index_logic'1 (self.current).t_UnionFind__values'0 z
         ]
        
        s2
      | s2 = bb34 ]
    
    | bb34 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _84 } } ] s1
      | s1 =  [ &_86 <- [%#sunion_find2] (self.current).t_UnionFind__max_depth'0 + 1 ] s2
      | s2 = bb35 ]
    
    | bb35 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__max_depth'0 = _86 } } ] s1
      | s1 = 
        [ &_88 <- [%#sunion_find3] Map.set (self.current).t_UnionFind__distance'0 y (1
        + MinMax.max (index_logic'2 (self.current).t_UnionFind__distance'0 x) (index_logic'2 (self.current).t_UnionFind__distance'0 y)) ]
        
        s2
      | s2 = bb36 ]
    
    | bb36 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _88 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- y ] s4
      | s4 = bb37 ]
    
    | bb37 = bb67
    | bb23 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_mut <t_GhostBox'1> {(self.current).t_UnionFind__map'0}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_96 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_96} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_95 <- _ret' ] s2)
      | s2 = bb38 ]
    
    | bb38 = s0
      [ s0 = {inv'3 _95.current}
        MutBorrow.borrow_final <t_FMap'0> {_95.current} {MutBorrow.get_id _95}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_94 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_95 <- { _95 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {y} (fun (_ret':int) ->  [ &_99 <- _ret' ] s2)
      | s2 = bb39 ]
    
    | bb39 = s0
      [ s0 =  [ &_98 <- _99 ] s1
      | s1 = get_mut_ghost'0 {_94} {_98} (fun (_ret':t_Option'1) ->  [ &_93 <- _ret' ] s2)
      | s2 = bb40 ]
    
    | bb40 = s0 [ s0 = unwrap'1 {_93} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_92 <- _ret' ] s1) | s1 = bb41 ] 
    | bb41 = s0
      [ s0 = {inv'4 _92.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_92.current} {MutBorrow.get_id _92}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_91 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_92 <- { _92 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_91} (fun (_ret':t_GhostBox'2) ->  [ &perm_mut_y <- _ret' ] s2)
      | s2 = bb42 ]
    
    | bb42 = s0
      [ s0 = {[@expl:type invariant] inv'5 _95} s1
      | s1 = -{resolve'2 _95}- s2
      | s2 = {[@expl:type invariant] inv'6 _92} s3
      | s3 = -{resolve'3 _92}- s4
      | s4 =  [ &_102 <- C_Link'0 x ] s5
      | s5 = as_mut'0 {y.t_Element__0'0} {perm_mut_y} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_104 <- _ret' ] s6)
      | s6 = bb43 ]
    
    | bb43 = bb44
    | bb44 = s0
      [ s0 = {[@expl:type invariant] match _104 with
          | {current = x'0} -> inv'7 x'0
          | _ -> true
          end}
        s1
      | s1 =  [ &_104 <- { _104 with current = _102 } ] s2
      | s2 = {[@expl:type invariant] inv'8 _104} s3
      | s3 = -{resolve'4 _104}- s4
      | s4 = bb46 ]
    
    | bb46 = s0
      [ s0 =  [ &_108 <- rx = ry ] s1 | s1 = any [ br0 -> {_108 = false} (! bb60) | br1 -> {_108} (! bb47) ]  ]
    
    | bb47 = s0
      [ s0 = {inv'2 (self.current).t_UnionFind__map'0}
        MutBorrow.borrow_final
          <t_GhostBox'1>
          {(self.current).t_UnionFind__map'0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret':MutBorrow.t t_GhostBox'1) ->
             [ &_117 <- _ret' ] 
            -{inv'2 _ret'.final}-
             [ &self <- { self with current = { self.current with t_UnionFind__map'0 = _ret'.final } } ] 
            s1)
      | s1 = deref_mut'0 {_117} (fun (_ret':MutBorrow.t t_FMap'0) ->  [ &_116 <- _ret' ] s2)
      | s2 = bb48 ]
    
    | bb48 = s0
      [ s0 = {inv'3 _116.current}
        MutBorrow.borrow_final <t_FMap'0> {_116.current} {MutBorrow.get_id _116}
          (fun (_ret':MutBorrow.t t_FMap'0) ->
             [ &_115 <- _ret' ] 
            -{inv'3 _ret'.final}-
             [ &_116 <- { _116 with current = _ret'.final } ] 
            s1)
      | s1 = addr'0 {x} (fun (_ret':int) ->  [ &_120 <- _ret' ] s2)
      | s2 = bb49 ]
    
    | bb49 = s0
      [ s0 =  [ &_119 <- _120 ] s1
      | s1 = get_mut_ghost'0 {_115} {_119} (fun (_ret':t_Option'1) ->  [ &_114 <- _ret' ] s2)
      | s2 = bb50 ]
    
    | bb50 = s0 [ s0 = unwrap'1 {_114} (fun (_ret':MutBorrow.t t_PtrOwn'0) ->  [ &_113 <- _ret' ] s1) | s1 = bb51 ] 
    | bb51 = s0
      [ s0 = {inv'4 _113.current}
        MutBorrow.borrow_final <t_PtrOwn'0> {_113.current} {MutBorrow.get_id _113}
          (fun (_ret':MutBorrow.t t_PtrOwn'0) ->
             [ &_112 <- _ret' ] 
            -{inv'4 _ret'.final}-
             [ &_113 <- { _113 with current = _ret'.final } ] 
            s1)
      | s1 = new'1 {_112} (fun (_ret':t_GhostBox'2) ->  [ &perm_mut_x1 <- _ret' ] s2)
      | s2 = bb52 ]
    
    | bb52 = s0
      [ s0 = {[@expl:type invariant] inv'5 _116} s1
      | s1 = -{resolve'2 _116}- s2
      | s2 = {[@expl:type invariant] inv'6 _113} s3
      | s3 = -{resolve'3 _113}- s4
      | s4 = as_mut'0 {x.t_Element__0'0} {perm_mut_x1} (fun (_ret':MutBorrow.t t_Content'0) ->  [ &_122 <- _ret' ] s5)
      | s5 = bb53 ]
    
    | bb53 = any
      [ br0 (x0:UInt64.t) (x1:t_T'0)-> {_122.current = C_Root'0 x0 x1} (! bb55)
      | br1 (x0:t_Element'0)-> {_122.current = C_Link'0 x0} (! bb54) ]
    
    | bb54 = s0 [ s0 = {[@expl:type invariant] inv'8 _122} s1 | s1 = -{resolve'4 _122}- s2 | s2 = bb58 ] 
    | bb55 = bb56
    | bb56 = s0
      [ s0 = v_Root'0 {_122.current}
          (fun (rrank'0:UInt64.t) (rvalue'0:t_T'0) ->
            MutBorrow.borrow_final <UInt64.t> {rrank'0} {MutBorrow.inherit_id (MutBorrow.get_id _122) 1}
              (fun (_ret':MutBorrow.t UInt64.t) ->
                 [ &rank2 <- _ret' ] 
                 [ &_122 <- { _122 with current = C_Root'0 _ret'.final rvalue'0 } ] 
                s1))
      | s1 = add_no_overflow'0 {rx} {[%#sunion_find4] (1 : UInt64.t)} (fun (_ret':UInt64.t) ->  [ &_127 <- _ret' ] s2)
      | s2 = bb57 ]
    
    | bb57 = s0
      [ s0 =  [ &rank2 <- { rank2 with current = _127 } ] s1
      | s1 = -{resolve'5 rank2}- s2
      | s2 = {[@expl:type invariant] inv'8 _122} s3
      | s3 = -{resolve'4 _122}- s4
      | s4 = bb58 ]
    
    | bb58 = bb59
    | bb59 = bb61
    | bb60 = bb61
    | bb61 = s0
      [ s0 = 
        [ &_129 <- [%#sunion_find5] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = y then
          x
        else
          index_logic'0 (self.current).t_UnionFind__root_of'0 z
         ]
        
        s1
      | s1 = bb62 ]
    
    | bb62 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__root_of'0 = _129 } } ] s1
      | s1 = 
        [ &_131 <- [%#sunion_find6] fun (z : t_Element'0) -> if index_logic'0 (self.current).t_UnionFind__root_of'0 z
        = x then
          vx
        else
          index_logic'1 (self.current).t_UnionFind__values'0 z
         ]
        
        s2
      | s2 = bb63 ]
    
    | bb63 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__values'0 = _131 } } ] s1
      | s1 =  [ &_133 <- [%#sunion_find7] (self.current).t_UnionFind__max_depth'0 + 1 ] s2
      | s2 = bb64 ]
    
    | bb64 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__max_depth'0 = _133 } } ] s1
      | s1 = 
        [ &_135 <- [%#sunion_find8] Map.set (self.current).t_UnionFind__distance'0 x (1
        + MinMax.max (index_logic'2 (self.current).t_UnionFind__distance'0 x) (index_logic'2 (self.current).t_UnionFind__distance'0 y)) ]
        
        s2
      | s2 = bb65 ]
    
    | bb65 = s0
      [ s0 =  [ &self <- { self with current = { self.current with t_UnionFind__distance'0 = _135 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self} s2
      | s2 = -{resolve'0 self}- s3
      | s3 =  [ &_0 <- x ] s4
      | s4 = bb66 ]
    
    | bb66 = bb67
    | bb67 = bb68
    | bb68 = bb69
    | bb69 = bb70
    | bb70 = return' {_0} ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & _14 : bool = Any.any_l ()
    | & perm_x : t_GhostBox'0 = Any.any_l ()
    | & _19 : t_PtrOwn'0 = Any.any_l ()
    | & _20 : t_Option'0 = Any.any_l ()
    | & _22 : t_FMap'0 = Any.any_l ()
    | & _25 : int = Any.any_l ()
    | & _26 : int = Any.any_l ()
    | & perm_y : t_GhostBox'0 = Any.any_l ()
    | & _29 : t_PtrOwn'0 = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _32 : t_FMap'0 = Any.any_l ()
    | & _35 : int = Any.any_l ()
    | & _36 : int = Any.any_l ()
    | & rx : UInt64.t = Any.any_l ()
    | & vx : t_T'0 = Any.any_l ()
    | & _40 : (UInt64.t, t_T'0) = Any.any_l ()
    | & _41 : t_Content'0 = Any.any_l ()
    | & rank : UInt64.t = Any.any_l ()
    | & value : t_T'0 = Any.any_l ()
    | & ry : UInt64.t = Any.any_l ()
    | & vy : t_T'0 = Any.any_l ()
    | & _52 : (UInt64.t, t_T'0) = Any.any_l ()
    | & _53 : t_Content'0 = Any.any_l ()
    | & rank1 : UInt64.t = Any.any_l ()
    | & value1 : t_T'0 = Any.any_l ()
    | & _62 : bool = Any.any_l ()
    | & perm_mut_x : t_GhostBox'2 = Any.any_l ()
    | & _66 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _67 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _68 : t_Option'1 = Any.any_l ()
    | & _69 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _70 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _71 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _73 : int = Any.any_l ()
    | & _74 : int = Any.any_l ()
    | & _77 : t_Content'0 = Any.any_l ()
    | & _79 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & _82 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _84 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _86 : int = Any.any_l ()
    | & _88 : Map.map t_Element'0 int = Any.any_l ()
    | & perm_mut_y : t_GhostBox'2 = Any.any_l ()
    | & _91 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _92 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _93 : t_Option'1 = Any.any_l ()
    | & _94 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _95 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _96 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _98 : int = Any.any_l ()
    | & _99 : int = Any.any_l ()
    | & _102 : t_Content'0 = Any.any_l ()
    | & _104 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & _108 : bool = Any.any_l ()
    | & perm_mut_x1 : t_GhostBox'2 = Any.any_l ()
    | & _112 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _113 : MutBorrow.t t_PtrOwn'0 = Any.any_l ()
    | & _114 : t_Option'1 = Any.any_l ()
    | & _115 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _116 : MutBorrow.t t_FMap'0 = Any.any_l ()
    | & _117 : MutBorrow.t t_GhostBox'1 = Any.any_l ()
    | & _119 : int = Any.any_l ()
    | & _120 : int = Any.any_l ()
    | & _122 : MutBorrow.t t_Content'0 = Any.any_l ()
    | & rank2 : MutBorrow.t UInt64.t = Any.any_l ()
    | & _127 : UInt64.t = Any.any_l ()
    | & _129 : Map.map t_Element'0 t_Element'0 = Any.any_l ()
    | & _131 : Map.map t_Element'0 t_T'0 = Any.any_l ()
    | & _133 : int = Any.any_l ()
    | & _135 : Map.map t_Element'0 int = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:link ensures #0] [%#sunion_find14] domain'0 self.final
      = domain'0 self.current}
      {[@expl:link ensures #1] [%#sunion_find15] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[@expl:link ensures #2] [%#sunion_find16] result = index_logic'0 (root_of'0 self.final) result}
      {[@expl:link ensures #3] [%#sunion_find17] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[@expl:link ensures #4] [%#sunion_find18] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union_aux [#"union_find.rs" 347 8 347 75] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 347 26 347 30
  let%span sunion_find1 = "union_find.rs" 329 19 329 44
  let%span sunion_find2 = "union_find.rs" 330 19 330 44
  let%span sunion_find3 = "union_find.rs" 331 18 331 54
  let%span sunion_find4 = "union_find.rs" 332 18 332 82
  let%span sunion_find5 = "union_find.rs" 333 18 338 13
  let%span sunion_find6 = "union_find.rs" 340 18 345 13
  let%span sunion_find7 = "union_find.rs" 222 25 222 29
  let%span sunion_find8 = "union_find.rs" 219 19 219 47
  let%span sunion_find9 = "union_find.rs" 220 18 220 48
  let%span sunion_find10 = "union_find.rs" 221 18 221 34
  let%span sunion_find11 = "union_find.rs" 282 21 282 25
  let%span sunion_find12 = "union_find.rs" 261 19 261 44
  let%span sunion_find13 = "union_find.rs" 262 19 262 41
  let%span sunion_find14 = "union_find.rs" 263 19 263 44
  let%span sunion_find15 = "union_find.rs" 264 19 264 41
  let%span sunion_find16 = "union_find.rs" 265 18 265 54
  let%span sunion_find17 = "union_find.rs" 266 18 266 82
  let%span sunion_find18 = "union_find.rs" 267 18 267 53
  let%span sunion_find19 = "union_find.rs" 268 18 273 13
  let%span sunion_find20 = "union_find.rs" 275 18 280 13
  let%span sfset21 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find22 = "union_find.rs" 135 19 135 28
  let%span sunion_find23 = "union_find.rs" 136 18 136 150
  let%span sunion_find24 = "union_find.rs" 133 8 133 16
  let%span smapping25 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find26 = "union_find.rs" 147 19 147 28
  let%span sunion_find27 = "union_find.rs" 148 18 148 98
  let%span sunion_find28 = "union_find.rs" 145 8 145 16
  let%span sunion_find29 = "union_find.rs" 257 12 257 50
  let%span sunion_find30 = "union_find.rs" 156 19 156 28
  let%span sunion_find31 = "union_find.rs" 157 18 157 106
  let%span sunion_find32 = "union_find.rs" 154 8 154 16
  let%span sunion_find33 = "union_find.rs" 167 16 169 52
  let%span sresolve34 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find35 = "union_find.rs" 23 8 23 16
  let%span sunion_find36 = "union_find.rs" 82 8 82 20
  let%span sinvariant37 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap38 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost39 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find40 = "union_find.rs" 127 8 127 16
  let%span sfmap41 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap42 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap43 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap44 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap45 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed46 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil47 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil48 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own50 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr51 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr52 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset21] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find35] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap43] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap41] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap38] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost39] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil47] op <> C_None'0)
   -> ([%#sutil48] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap45] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap44] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap42] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find40] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping25] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping25] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping25] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find36] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr52] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr51] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own50] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed46] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'8 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed46] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap49] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed46] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant37] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find24] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find22] inv'0 self)
   -> ([%#sunion_find23] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find28] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find26] inv'0 self)
   -> ([%#sunion_find27] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find32] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find30] inv'0 self)
   -> ([%#sunion_find31] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find33] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find7] inv'1 self}
    {[@expl:find requires] [%#sunion_find8] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find9] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find10] unchanged'0 self}
      (! return' {result}) ]
  
  
  predicate equiv_log'0 [#"union_find.rs" 256 8 256 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find29] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  let rec link'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:link 'self' type invariant] [%#sunion_find11] inv'1 self}
    {[@expl:link requires #0] [%#sunion_find12] contains'0 (domain'0 self.current) x}
    {[@expl:link requires #1] [%#sunion_find13] index_logic'0 (root_of'0 self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find14] contains'0 (domain'0 self.current) y}
    {[@expl:link requires #3] [%#sunion_find15] index_logic'0 (root_of'0 self.current) y = y}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find16] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find17] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[%#sunion_find18] result = index_logic'0 (root_of'0 self.final) result}
      {[%#sunion_find19] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[%#sunion_find20] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve34] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec union_aux'0[#"union_find.rs" 347 8 347 75] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:union_aux 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:union_aux requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_11 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_11} {x} (fun (_ret':t_Element'0) ->  [ &rx <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_mut <t_UnionFind'0> {self.current}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_14 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = find'0 {_14} {y} (fun (_ret':t_Element'0) ->  [ &ry <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_16 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = link'0 {_16} {rx} {ry} (fun (_ret':t_Element'0) ->  [ &_0 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : t_Element'0 = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & rx : t_Element'0 = Any.any_l ()
    | & _11 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & ry : t_Element'0 = Any.any_l ()
    | & _14 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:t_Element'0)-> {[@expl:union_aux ensures #0] [%#sunion_find3] domain'0 self.final
      = domain'0 self.current}
      {[@expl:union_aux ensures #1] [%#sunion_find4] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[@expl:union_aux ensures #2] [%#sunion_find5] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[@expl:union_aux ensures #3] [%#sunion_find6] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union [#"union_find.rs" 370 8 370 61] (* implementation::UnionFind<T> *)
  let%span sunion_find0 = "union_find.rs" 370 26 370 30
  let%span sunion_find1 = "union_find.rs" 354 19 354 44
  let%span sunion_find2 = "union_find.rs" 355 19 355 44
  let%span sunion_find3 = "union_find.rs" 356 18 356 54
  let%span sunion_find4 = "union_find.rs" 357 18 369 9
  let%span sunion_find5 = "union_find.rs" 347 26 347 30
  let%span sunion_find6 = "union_find.rs" 329 19 329 44
  let%span sunion_find7 = "union_find.rs" 330 19 330 44
  let%span sunion_find8 = "union_find.rs" 331 18 331 54
  let%span sunion_find9 = "union_find.rs" 332 18 332 82
  let%span sunion_find10 = "union_find.rs" 333 18 338 13
  let%span sunion_find11 = "union_find.rs" 340 18 345 13
  let%span sfset12 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find13 = "union_find.rs" 135 19 135 28
  let%span sunion_find14 = "union_find.rs" 136 18 136 150
  let%span sunion_find15 = "union_find.rs" 133 8 133 16
  let%span smapping16 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find17 = "union_find.rs" 147 19 147 28
  let%span sunion_find18 = "union_find.rs" 148 18 148 98
  let%span sunion_find19 = "union_find.rs" 145 8 145 16
  let%span sunion_find20 = "union_find.rs" 257 12 257 50
  let%span sunion_find21 = "union_find.rs" 156 19 156 28
  let%span sunion_find22 = "union_find.rs" 157 18 157 106
  let%span sunion_find23 = "union_find.rs" 154 8 154 16
  let%span sresolve24 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sunion_find25 = "union_find.rs" 23 8 23 16
  let%span sunion_find26 = "union_find.rs" 82 8 82 20
  let%span sinvariant27 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfmap28 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sghost29 = "../../creusot-contracts/src/ghost.rs" 224 4 224 12
  let%span sunion_find30 = "union_find.rs" 127 8 127 16
  let%span sfmap31 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap32 = "../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap33 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap34 = "../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap35 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sboxed36 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sutil37 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil38 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap39 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sptr_own40 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr41 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr42 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset12] Fset.mem e self
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find25] addr_logic'0 self.t_Element__0'0
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap33] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap31] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap28] get_unsized'0 self k <> C_None'0
  
  function inner_logic'0 (self : t_GhostBox'0) : t_FMap'0 =
    [%#sghost29] self.t_GhostBox__0'0
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil37] op <> C_None'0)
   -> ([%#sutil38] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap35] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap34] lookup_unsized'0 self k
  
  function index_logic'3 [@inline:trivial] (self : t_FMap'0) (key : int) : t_PtrOwn'0 =
    [%#sfmap32] lookup'0 self key
  
  function get_perm'0 [#"union_find.rs" 128 8 128 62] (self : t_UnionFind'0) (e : t_Element'0) : t_PtrOwn'0 =
    [%#sunion_find30] index_logic'3 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e)
  
  function index_logic'1 (self : Map.map t_Element'0 t_T'0) (a : t_Element'0) : t_T'0 =
    [%#smapping16] Map.get self a
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping16] Map.get self a
  
  function val'0 (self : t_PtrOwn'0) : t_Content'0
  
  function index_logic'2 (self : Map.map t_Element'0 int) (a : t_Element'0) : int =
    [%#smapping16] Map.get self a
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0) =
    [%#sunion_find26] let domain = self.t_UnionFind__domain'0 in (forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'1 (inner_logic'0 self.t_UnionFind__map'0) (deep_model'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e  -> e.t_Element__0'0 = ptr'0 (get_perm'0 self e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'1 self.t_UnionFind__values'0 e
    = index_logic'1 self.t_UnionFind__values'0 (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> index_logic'0 self.t_UnionFind__root_of'0 (index_logic'0 self.t_UnionFind__root_of'0 e)
    = index_logic'0 self.t_UnionFind__root_of'0 e)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> contains'0 domain (index_logic'0 self.t_UnionFind__root_of'0 e))
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> e <> e2
      /\ contains'0 domain e2
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = index_logic'0 self.t_UnionFind__root_of'0 e2
      | C_Root'0 _ v -> index_logic'1 self.t_UnionFind__values'0 e = v
      /\ index_logic'0 self.t_UnionFind__root_of'0 e = e
      end)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self e) with
      | C_Link'0 e2 -> index_logic'2 self.t_UnionFind__distance'0 e < index_logic'2 self.t_UnionFind__distance'0 e2
      | C_Root'0 _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth'0 >= 0
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance'0 e
    /\ index_logic'2 self.t_UnionFind__distance'0 e <= self.t_UnionFind__max_depth'0)
    /\ (forall e : t_Element'0 . contains'0 domain e
     -> match val'0 (get_perm'0 self (index_logic'0 self.t_UnionFind__root_of'0 e)) with
      | C_Root'0 _ _ -> true
      | C_Link'0 _ -> false
      end)
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr42] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr41] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own40] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed36] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'8 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed36] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap39] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed36] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant27] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0 =
    [%#sunion_find15] self.t_UnionFind__domain'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find13] inv'0 self)
   -> ([%#sunion_find14] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0 =
    [%#sunion_find19] self.t_UnionFind__root_of'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find17] inv'0 self)
   -> ([%#sunion_find18] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  predicate equiv_log'0 [#"union_find.rs" 256 8 256 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find20] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 t_T'0 =
    [%#sunion_find23] self.t_UnionFind__values'0
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find21] inv'0 self)
   -> ([%#sunion_find22] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  let rec union_aux'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:union_aux 'self' type invariant] [%#sunion_find5] inv'1 self}
    {[@expl:union_aux requires #0] [%#sunion_find6] contains'0 (domain'0 self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find7] contains'0 (domain'0 self.current) y}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find8] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find9] result = index_logic'0 (root_of'0 self.current) x
      \/ result = index_logic'0 (root_of'0 self.current) y}
      {[%#sunion_find10] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        result
      else
        index_logic'0 (root_of'0 self.current) z
      )}
      {[%#sunion_find11] forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) result
      else
        index_logic'1 (values'0 self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sresolve24] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t t_UnionFind'0) =
    resolve'1 _1
  
  meta "compute_max_steps" 1000000
  
  let rec union'0[#"union_find.rs" 370 8 370 61] (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:()))= {[@expl:union 'self' type invariant] [%#sunion_find0] inv'1 self}
    {[@expl:union requires #0] [%#sunion_find1] contains'0 (domain'0 self.current) x}
    {[@expl:union requires #1] [%#sunion_find2] contains'0 (domain'0 self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'0 self.current}
        MutBorrow.borrow_final <t_UnionFind'0> {self.current} {MutBorrow.get_id self}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->
             [ &_9 <- _ret' ] 
            -{inv'0 _ret'.final}-
             [ &self <- { self with current = _ret'.final } ] 
            s1)
      | s1 = union_aux'0 {_9} {x} {y} (fun (_ret':t_Element'0) ->  [ &_8 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'1 self} s1 | s1 = -{resolve'0 self}- s2 | s2 = return' {_0} ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & self : MutBorrow.t t_UnionFind'0 = self
    | & x : t_Element'0 = x
    | & y : t_Element'0 = y
    | & _8 : t_Element'0 = Any.any_l ()
    | & _9 : MutBorrow.t t_UnionFind'0 = Any.any_l () ]
    
    [ return' (result:())-> {[@expl:union ensures #0] [%#sunion_find3] domain'0 self.final = domain'0 self.current}
      {[@expl:union ensures #1] [%#sunion_find4] exists r : t_Element'0 . (r = index_logic'0 (root_of'0 self.current) x
      \/ r = index_logic'0 (root_of'0 self.current) y)
      /\ (forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        r
      else
        index_logic'0 (root_of'0 self.current) z
      )
      /\ index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) r
      else
        index_logic'1 (values'0 self.current) z
      ))}
      (! return' {result}) ]

end
module M_union_find__example [#"union_find.rs" 379 0 379 16]
  let%span sunion_find0 = "union_find.rs" 382 20 382 21
  let%span sunion_find1 = "union_find.rs" 383 20 383 21
  let%span sunion_find2 = "union_find.rs" 384 20 384 21
  let%span sunion_find3 = "union_find.rs" 386 26 386 27
  let%span sunion_find4 = "union_find.rs" 387 26 387 27
  let%span sunion_find5 = "union_find.rs" 388 26 388 27
  let%span sunion_find6 = "union_find.rs" 395 26 395 27
  let%span sunion_find7 = "union_find.rs" 395 4 395 28
  let%span sunion_find8 = "union_find.rs" 394 4 394 37
  let%span sunion_find9 = "union_find.rs" 388 4 388 28
  let%span sunion_find10 = "union_find.rs" 387 4 387 28
  let%span sunion_find11 = "union_find.rs" 386 4 386 28
  let%span sunion_find12 = "union_find.rs" 116 24 116 28
  let%span sunion_find13 = "union_find.rs" 115 8 115 44
  let%span sunion_find14 = "union_find.rs" 177 25 177 29
  let%span sunion_find15 = "union_find.rs" 177 31 177 36
  let%span sunion_find16 = "union_find.rs" 173 18 173 52
  let%span sunion_find17 = "union_find.rs" 174 18 174 69
  let%span sunion_find18 = "union_find.rs" 175 18 175 76
  let%span sunion_find19 = "union_find.rs" 176 18 176 73
  let%span sunion_find20 = "union_find.rs" 232 20 232 24
  let%span sunion_find21 = "union_find.rs" 229 19 229 47
  let%span sunion_find22 = "union_find.rs" 230 19 230 47
  let%span sunion_find23 = "union_find.rs" 232 47 232 49
  let%span sunion_find24 = "union_find.rs" 231 18 231 48
  let%span sunion_find25 = "union_find.rs" 370 26 370 30
  let%span sunion_find26 = "union_find.rs" 354 19 354 44
  let%span sunion_find27 = "union_find.rs" 355 19 355 44
  let%span sunion_find28 = "union_find.rs" 356 18 356 54
  let%span sunion_find29 = "union_find.rs" 357 18 369 9
  let%span sunion_find30 = "union_find.rs" 222 25 222 29
  let%span sunion_find31 = "union_find.rs" 219 19 219 47
  let%span sunion_find32 = "union_find.rs" 220 18 220 48
  let%span sunion_find33 = "union_find.rs" 221 18 221 34
  let%span sfset34 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find35 = "union_find.rs" 135 19 135 28
  let%span sunion_find36 = "union_find.rs" 136 18 136 150
  let%span sfset37 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sunion_find38 = "union_find.rs" 147 19 147 28
  let%span sunion_find39 = "union_find.rs" 148 18 148 98
  let%span sunion_find40 = "union_find.rs" 156 19 156 28
  let%span sunion_find41 = "union_find.rs" 157 18 157 106
  let%span smapping42 = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sunion_find43 = "union_find.rs" 257 12 257 50
  let%span sunion_find44 = "union_find.rs" 167 16 169 52
  let%span sinvariant45 = "../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sinvariant46 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed47 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap48 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap49 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap50 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap51 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil52 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil53 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap54 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own55 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr56 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr57 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use set.Fset
  use creusot.int.Int32
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 Int32.t;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'0 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0)
  
  type t_Content'0  =
    | C_Root'0 UInt64.t Int32.t
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap54] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap51] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap49] get_unsized'0 self k <> C_None'0
  
  predicate inv'8 (_1 : int)
  
  axiom inv_axiom'8 [@rewrite] : forall x : int [inv'8 x] . inv'8 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr57] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr56] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'6 (self : t_PtrOwn'0) =
    [%#sptr_own55] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'10 [@rewrite] : forall x : t_PtrOwn'0 [inv'10 x] . inv'10 x
  = (invariant'6 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> true
    end)
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sboxed47] inv'10 self
  
  predicate inv'9 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_PtrOwn'0 [inv'9 x] . inv'9 x = invariant'5 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil52] op <> C_None'0)
   -> ([%#sutil53] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap50] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'4 (self : t_FMap'0) =
    [%#sfmap48] forall k : int . contains'1 self k  -> inv'8 k /\ inv'9 (lookup_unsized'0 self k)
  
  predicate inv'7 (_1 : t_FMap'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_FMap'0 [inv'7 x] . inv'7 x = invariant'4 x
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sboxed47] inv'7 self
  
  predicate inv'6 (_1 : t_FMap'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_FMap'0 [inv'6 x] . inv'6 x = invariant'3 x
  
  predicate inv'5 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'5 [@rewrite] : forall x : t_GhostBox'0 [inv'5 x] . inv'5 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'6 a_0
    end
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x
  = (invariant'0 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'5 map
    end)
  
  let rec new'0 (return'  (ret:t_UnionFind'0))= any
    [ return' (result:t_UnionFind'0)-> {[%#sunion_find12] inv'0 result}
      {[%#sunion_find13] Fset.is_empty result.t_UnionFind__domain'0}
      (! return' {result}) ]
  
  
  predicate invariant'1 (self : MutBorrow.t t_UnionFind'0) =
    [%#sinvariant45] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'1 (_1 : MutBorrow.t t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : MutBorrow.t t_UnionFind'0 [inv'1 x] . inv'1 x = invariant'1 x
  
  predicate inv'2 (_1 : Int32.t)
  
  axiom inv_axiom'2 [@rewrite] : forall x : Int32.t [inv'2 x] . inv'2 x = true
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset34] Fset.mem e self
  
  function deep_model'0 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find35] inv'0 self)
   -> ([%#sunion_find36] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'0 e1 = deep_model'0 e2  -> e1 = e2)
  
  function insert'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) : Fset.fset t_Element'0 =
    [%#sfset37] Fset.add e self
  
  function index_logic'0 (self : Map.map t_Element'0 t_Element'0) (a : t_Element'0) : t_Element'0 =
    [%#smapping42] Map.get self a
  
  function root_of'0 [#"union_find.rs" 149 8 149 63] (self : t_UnionFind'0) : Map.map t_Element'0 t_Element'0
  
  axiom root_of'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find38] inv'0 self)
   -> ([%#sunion_find39] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'0 (root_of'0 self) e = index_logic'0 (root_of'0 self) (index_logic'0 (root_of'0 self) e))
  
  function index_logic'1 (self : Map.map t_Element'0 Int32.t) (a : t_Element'0) : Int32.t =
    [%#smapping42] Map.get self a
  
  function values'0 [#"union_find.rs" 158 8 158 53] (self : t_UnionFind'0) : Map.map t_Element'0 Int32.t
  
  axiom values'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find40] inv'0 self)
   -> ([%#sunion_find41] forall e : t_Element'0 . contains'0 self.t_UnionFind__domain'0 e
   -> index_logic'1 (values'0 self) e = index_logic'1 (values'0 self) (index_logic'0 (root_of'0 self) e))
  
  let rec make'0 (self:MutBorrow.t t_UnionFind'0) (value:Int32.t) (return'  (ret:t_Element'0))= {[@expl:make 'self' type invariant] [%#sunion_find14] inv'1 self}
    {[@expl:make 'value' type invariant] [%#sunion_find15] inv'2 value}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find16] not contains'0 (domain'0 self.current) result}
      {[%#sunion_find17] domain'0 self.final = insert'0 (domain'0 self.current) result}
      {[%#sunion_find18] root_of'0 self.final = Map.set (root_of'0 self.current) result result}
      {[%#sunion_find19] values'0 self.final = Map.set (values'0 self.current) result value}
      (! return' {result}) ]
  
  
  predicate invariant'2 (self : t_UnionFind'0) =
    [%#sinvariant46] inv'0 self
  
  predicate inv'3 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_UnionFind'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'4 (_1 : Int32.t)
  
  axiom inv_axiom'4 [@rewrite] : forall x : Int32.t [inv'4 x] . inv'4 x = true
  
  let rec get'0 (self:t_UnionFind'0) (elem:t_Element'0) (return'  (ret:Int32.t))= {[@expl:get 'self' type invariant] [%#sunion_find20] inv'3 self}
    {[@expl:get requires #0] [%#sunion_find21] contains'0 (domain'0 self) elem}
    {[@expl:get requires #1] [%#sunion_find22] index_logic'0 (root_of'0 self) elem = elem}
    any
    [ return' (result:Int32.t)-> {[%#sunion_find23] inv'4 result}
      {[%#sunion_find24] result = index_logic'1 (values'0 self) elem}
      (! return' {result}) ]
  
  
  predicate equiv_log'0 [#"union_find.rs" 256 8 256 68] (self : t_UnionFind'0) (x : t_Element'0) (y : t_Element'0) =
    [%#sunion_find43] index_logic'0 (root_of'0 self) x = index_logic'0 (root_of'0 self) y
  
  let rec union'0 (self:MutBorrow.t t_UnionFind'0) (x:t_Element'0) (y:t_Element'0) (return'  (ret:()))= {[@expl:union 'self' type invariant] [%#sunion_find25] inv'1 self}
    {[@expl:union requires #0] [%#sunion_find26] contains'0 (domain'0 self.current) x}
    {[@expl:union requires #1] [%#sunion_find27] contains'0 (domain'0 self.current) y}
    any
    [ return' (result:())-> {[%#sunion_find28] domain'0 self.final = domain'0 self.current}
      {[%#sunion_find29] exists r : t_Element'0 . (r = index_logic'0 (root_of'0 self.current) x
      \/ r = index_logic'0 (root_of'0 self.current) y)
      /\ (forall z : t_Element'0 . contains'0 (domain'0 self.current) z
       -> index_logic'0 (root_of'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        r
      else
        index_logic'0 (root_of'0 self.current) z
      )
      /\ index_logic'1 (values'0 self.final) z
      = (if equiv_log'0 self.current z x \/ equiv_log'0 self.current z y then
        index_logic'1 (values'0 self.final) r
      else
        index_logic'1 (values'0 self.current) z
      ))}
      (! return' {result}) ]
  
  
  predicate unchanged'0 [#"union_find.rs" 165 8 165 43] (self : MutBorrow.t t_UnionFind'0) =
    [%#sunion_find44] domain'0 self.current = domain'0 self.final
    /\ root_of'0 self.current = root_of'0 self.final /\ values'0 self.current = values'0 self.final
  
  let rec find'0 (self:MutBorrow.t t_UnionFind'0) (elem:t_Element'0) (return'  (ret:t_Element'0))= {[@expl:find 'self' type invariant] [%#sunion_find30] inv'1 self}
    {[@expl:find requires] [%#sunion_find31] contains'0 (domain'0 self.current) elem}
    any
    [ return' (result:t_Element'0)-> {[%#sunion_find32] result = index_logic'0 (root_of'0 self.current) elem}
      {[%#sunion_find33] unchanged'0 self}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec example'0[#"union_find.rs" 379 0 379 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0 [ s0 = new'0 (fun (_ret':t_UnionFind'0) ->  [ &uf <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_3 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_3} {[%#sunion_find0] (1 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &x <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_5 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_5} {[%#sunion_find1] (2 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &y <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_7 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = make'0 {_7} {[%#sunion_find2] (3 : Int32.t)} (fun (_ret':t_Element'0) ->  [ &z <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = get'0 {uf} {x} (fun (_ret':Int32.t) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_9 <- _11 = ([%#sunion_find3] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
    
    | bb6 = s0 [ s0 = get'0 {uf} {y} (fun (_ret':Int32.t) ->  [ &_18 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_16 <- _18 = ([%#sunion_find4] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ]  ]
    
    | bb9 = s0 [ s0 = get'0 {uf} {z} (fun (_ret':Int32.t) ->  [ &_25 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_23 <- _25 = ([%#sunion_find5] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb13) | br1 -> {_23} (! bb12) ]  ]
    
    | bb12 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_30 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = union'0 {_30} {x} {y} (fun (_ret':()) ->  [ &_29 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_34 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = find'0 {_34} {x} (fun (_ret':t_Element'0) ->  [ &x1 <- _ret' ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0
      [ s0 = {inv'0 uf}
        MutBorrow.borrow_mut <t_UnionFind'0> {uf}
          (fun (_ret':MutBorrow.t t_UnionFind'0) ->  [ &_37 <- _ret' ] -{inv'0 _ret'.final}-  [ &uf <- _ret'.final ] s1)
      | s1 = find'0 {_37} {y} (fun (_ret':t_Element'0) ->  [ &y1 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = get'0 {uf} {x1} (fun (_ret':Int32.t) ->  [ &_42 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 = get'0 {uf} {y1} (fun (_ret':Int32.t) ->  [ &_46 <- _ret' ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 =  [ &_40 <- _42 = _46 ] s1 | s1 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ]  ]
    
    | bb19 = s0 [ s0 = get'0 {uf} {z} (fun (_ret':Int32.t) ->  [ &_53 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = s0
      [ s0 =  [ &_51 <- _53 = ([%#sunion_find6] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb23) | br1 -> {_51} (! bb22) ]  ]
    
    | bb22 = bb24
    | bb24 = return' {_0}
    | bb23 = {[%#sunion_find7] false} any
    | bb20 = {[%#sunion_find8] false} any
    | bb13 = {[%#sunion_find9] false} any
    | bb10 = {[%#sunion_find10] false} any
    | bb7 = {[%#sunion_find11] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & uf : t_UnionFind'0 = Any.any_l ()
    | & x : t_Element'0 = Any.any_l ()
    | & _3 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & y : t_Element'0 = Any.any_l ()
    | & _5 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & z : t_Element'0 = Any.any_l ()
    | & _7 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _11 : Int32.t = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _18 : Int32.t = Any.any_l ()
    | & _23 : bool = Any.any_l ()
    | & _25 : Int32.t = Any.any_l ()
    | & _29 : () = Any.any_l ()
    | & _30 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & x1 : t_Element'0 = Any.any_l ()
    | & _34 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & y1 : t_Element'0 = Any.any_l ()
    | & _37 : MutBorrow.t t_UnionFind'0 = Any.any_l ()
    | & _40 : bool = Any.any_l ()
    | & _42 : Int32.t = Any.any_l ()
    | & _46 : Int32.t = Any.any_l ()
    | & _51 : bool = Any.any_l ()
    | & _53 : Int32.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_union_find__example_addrs_eq [#"union_find.rs" 399 0 399 77]
  let%span sunion_find0 = "union_find.rs" 403 22 403 30
  let%span sunion_find1 = "union_find.rs" 399 27 399 29
  let%span sunion_find2 = "union_find.rs" 398 11 398 63
  let%span sunion_find3 = "union_find.rs" 16 18 16 69
  let%span sfset4 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sunion_find5 = "union_find.rs" 135 19 135 28
  let%span sunion_find6 = "union_find.rs" 136 18 136 150
  let%span smodel7 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sinvariant8 = "../../creusot-contracts/src/invariant.rs" 25 8 25 18
  let%span sboxed9 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sfmap10 = "../../creusot-contracts/src/logic/fmap.rs" 490 20 490 91
  let%span sfmap11 = "../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap12 = "../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap13 = "../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sutil14 = "../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil15 = "../../creusot-contracts/src/util.rs" 56 10 56 28
  let%span sfmap16 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sptr_own17 = "../../creusot-contracts/src/ptr_own.rs" 51 8 51 35
  let%span sptr18 = "../../creusot-contracts/src/std/ptr.rs" 80 14 80 48
  let%span sptr19 = "../../creusot-contracts/src/std/ptr.rs" 82 8 82 30
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel7] deep_model'1 self
  
  let rec eq'0 (self:t_Element'0) (other:t_Element'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#sunion_find3] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  type t_FMap'0
  
  type t_GhostBox'0  =
    { t_GhostBox__0'0: t_FMap'0 }
  
  type t_T'0
  
  type t_UnionFind'0  =
    { t_UnionFind__domain'0: Fset.fset t_Element'0;
      t_UnionFind__map'0: t_GhostBox'0;
      t_UnionFind__values'0: Map.map t_Element'0 t_T'0;
      t_UnionFind__distance'0: Map.map t_Element'0 int;
      t_UnionFind__root_of'0: Map.map t_Element'0 t_Element'0;
      t_UnionFind__max_depth'0: int }
  
  predicate invariant'1 [@inline:trivial] [#"union_find.rs" 85 8 85 34] (self : t_UnionFind'0)
  
  type t_Content'0  =
    | C_Root'0 UInt64.t t_T'0
    | C_Link'0 t_Element'0
  
  type t_PtrOwn'0  =
    { t_PtrOwn__ptr'0: Opaque.ptr; t_PtrOwn__val'0: t_Content'0 }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn'0
  
  function view'0 (self : t_FMap'0) : Map.map int t_Option'0
  
  axiom view'0_spec : forall self : t_FMap'0 . [%#sfmap16] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'0 m1 <> view'0 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_Option'0 =
    [%#sfmap13] Map.get (view'0 self) k
  
  function contains'1 [@inline:trivial] (self : t_FMap'0) (k : int) : bool =
    [%#sfmap11] get_unsized'0 self k <> C_None'0
  
  predicate inv'5 (_1 : int)
  
  axiom inv_axiom'5 [@rewrite] : forall x : int [inv'5 x] . inv'5 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function is_null_logic'0 (self : Opaque.ptr) : bool =
    [%#sptr19] addr_logic'0 self = 0
  
  axiom is_null_logic'0_spec : forall self : Opaque.ptr . [%#sptr18] is_null_logic'0 self = (addr_logic'0 self = 0)
  
  function ptr'0 (self : t_PtrOwn'0) : Opaque.ptr
  
  predicate invariant'5 (self : t_PtrOwn'0) =
    [%#sptr_own17] not is_null_logic'0 (ptr'0 self)
  
  predicate inv'10 (_1 : t_T'0)
  
  predicate inv'9 (_1 : t_Content'0)
  
  axiom inv_axiom'9 [@rewrite] : forall x : t_Content'0 [inv'9 x] . inv'9 x
  = match x with
    | C_Root'0 rank value -> inv'10 value
    | C_Link'0 a_0 -> true
    end
  
  predicate invariant'6 (self : t_Content'0) =
    [%#sboxed9] inv'9 self
  
  predicate inv'8 (_1 : t_Content'0)
  
  axiom inv_axiom'8 [@rewrite] : forall x : t_Content'0 [inv'8 x] . inv'8 x = invariant'6 x
  
  predicate inv'7 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'7 [@rewrite] : forall x : t_PtrOwn'0 [inv'7 x] . inv'7 x
  = (invariant'5 x
  /\ match x with
    | {t_PtrOwn__ptr'0 = ptr ; t_PtrOwn__val'0 = val'} -> inv'8 val'
    end)
  
  predicate invariant'4 (self : t_PtrOwn'0) =
    [%#sboxed9] inv'7 self
  
  predicate inv'6 (_1 : t_PtrOwn'0)
  
  axiom inv_axiom'6 [@rewrite] : forall x : t_PtrOwn'0 [inv'6 x] . inv'6 x = invariant'4 x
  
  function unwrap'0 (op : t_Option'0) : t_PtrOwn'0
  
  axiom unwrap'0_spec : forall op : t_Option'0 . ([%#sutil14] op <> C_None'0)
   -> ([%#sutil15] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : int) : t_PtrOwn'0 =
    [%#sfmap12] unwrap'0 (get_unsized'0 self k)
  
  predicate invariant'3 (self : t_FMap'0) =
    [%#sfmap10] forall k : int . contains'1 self k  -> inv'5 k /\ inv'6 (lookup_unsized'0 self k)
  
  predicate inv'4 (_1 : t_FMap'0)
  
  axiom inv_axiom'4 [@rewrite] : forall x : t_FMap'0 [inv'4 x] . inv'4 x = invariant'3 x
  
  predicate invariant'2 (self : t_FMap'0) =
    [%#sboxed9] inv'4 self
  
  predicate inv'3 (_1 : t_FMap'0)
  
  axiom inv_axiom'3 [@rewrite] : forall x : t_FMap'0 [inv'3 x] . inv'3 x = invariant'2 x
  
  predicate inv'2 (_1 : t_GhostBox'0)
  
  axiom inv_axiom'2 [@rewrite] : forall x : t_GhostBox'0 [inv'2 x] . inv'2 x
  = match x with
    | {t_GhostBox__0'0 = a_0} -> inv'3 a_0
    end
  
  predicate inv'1 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_UnionFind'0 [inv'1 x] . inv'1 x
  = (invariant'1 x
  /\ match x with
    | {t_UnionFind__domain'0 = domain ; t_UnionFind__map'0 = map ; t_UnionFind__values'0 = values ; t_UnionFind__distance'0 = distance ; t_UnionFind__root_of'0 = root_of ; t_UnionFind__max_depth'0 = max_depth} -> inv'2 map
    end)
  
  predicate invariant'0 (self : t_UnionFind'0) =
    [%#sinvariant8] inv'1 self
  
  predicate inv'0 (_1 : t_UnionFind'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_UnionFind'0 [inv'0 x] . inv'0 x = invariant'0 x
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset t_Element'0) (e : t_Element'0) =
    [%#sfset4] Fset.mem e self
  
  function domain'0 [#"union_find.rs" 137 8 137 47] (self : t_UnionFind'0) : Fset.fset t_Element'0
  
  axiom domain'0_spec : forall self : t_UnionFind'0 . ([%#sunion_find5] inv'1 self)
   -> ([%#sunion_find6] forall e1 : t_Element'0, e2 : t_Element'0 . contains'0 (domain'0 self) e1
  /\ contains'0 (domain'0 self) e2 /\ deep_model'1 e1 = deep_model'1 e2  -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  let rec example_addrs_eq'0[#"union_find.rs" 399 0 399 77] (uf:t_UnionFind'0) (e1:t_Element'0) (e2:t_Element'0) (return'  (ret:()))= {[@expl:example_addrs_eq 'uf' type invariant] [%#sunion_find1] inv'0 uf}
    {[@expl:example_addrs_eq requires] [%#sunion_find2] contains'0 (domain'0 uf) e1 /\ contains'0 (domain'0 uf) e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq'0 {e1} {e2} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0 [ s0 = {[@expl:assertion] [%#sunion_find0] e1 = e2} s1 | s1 = bb4 ] 
    | bb3 = bb4
    | bb4 = return' {_0} ]
    ) [ & _0 : () = Any.any_l () | & e1 : t_Element'0 = e1 | & e2 : t_Element'0 = e2 | & _5 : bool = Any.any_l () ] 
    [ return' (result:())-> (! return' {result}) ]

end
module M_union_find__implementation__qyi17232405883558456141__eq__refines [#"union_find.rs" 17 8 17 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find0 = "union_find.rs" 17 8 17 42
  let%span smodel1 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span sunion_find2 = "union_find.rs" 23 8 23 16
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  predicate inv'0 (_1 : t_Element'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Element'0 [inv'0 x] . inv'0 x = true
  
  function addr_logic'0 (self : Opaque.ptr) : int
  
  function deep_model'1 [#"union_find.rs" 25 8 25 34] (self : t_Element'0) : int =
    [%#sunion_find2] addr_logic'0 self.t_Element__0'0
  
  function deep_model'0 (self : t_Element'0) : int =
    [%#smodel1] deep_model'1 self
  
  goal refines : [%#sunion_find0] forall self : t_Element'0 . forall other : t_Element'0 . inv'0 other /\ inv'0 self
   -> (forall result : bool . result = (deep_model'0 self = deep_model'0 other)
   -> result = (deep_model'0 self = deep_model'0 other))
end
module M_union_find__implementation__qyi10464084137166016688__clone__refines [#"union_find.rs" 46 8 46 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find0 = "union_find.rs" 46 8 46 31
  
  use creusot.prelude.Opaque
  
  type t_Element'0  =
    { t_Element__0'0: Opaque.ptr }
  
  predicate inv'0 (_1 : t_Element'0)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Element'0 [inv'0 x] . inv'0 x = true
  
  predicate inv'1 (_1 : t_Element'0)
  
  axiom inv_axiom'1 [@rewrite] : forall x : t_Element'0 [inv'1 x] . inv'1 x = true
  
  goal refines : [%#sunion_find0] forall self : t_Element'0 . inv'0 self
   -> (forall result : t_Element'0 . self = result  -> result = self /\ inv'1 result)
end
