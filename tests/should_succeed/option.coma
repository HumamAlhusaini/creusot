module M_option__is_some_none [#"option.rs" 4 0 4 21]
  let%span soption0 = "option.rs" 6 33 6 34
  let%span soption1 = "option.rs" 9 4 9 46
  let%span soption2 = "option.rs" 8 4 8 46
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 41 26 41 51
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec is_some'0 (self:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption3] result = (self <> C_None'0)} (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption4] result = (self = C_None'0)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec is_some_none'0[#"option.rs" 4 0 4 21] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = is_some'0 {some} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = any [ br0 -> {_4 = false} (! bb6) | br1 -> {_4} (! bb2) ] 
    | bb2 = s0 [ s0 = is_some'0 {none} (fun (_ret':bool) ->  [ &_6 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = any [ br0 -> {_6 = false} (! bb5) | br1 -> {_6} (! bb4) ] 
    | bb4 = bb7
    | bb5 = s0 [ s0 = is_none'0 {some} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb9) ] 
    | bb9 = bb14
    | bb10 = s0 [ s0 = is_none'0 {none} (fun (_ret':bool) ->  [ &_12 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = any [ br0 -> {_12 = false} (! bb13) | br1 -> {_12} (! bb12) ] 
    | bb12 = return' {_0}
    | bb13 = bb14
    | bb14 = {[%#soption1] false} any
    | bb6 = bb7
    | bb7 = {[%#soption2] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _12 : bool = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__unwrap [#"option.rs" 12 0 12 15]
  let%span soption0 = "option.rs" 14 33 14 34
  let%span soption1 = "option.rs" 16 29 16 30
  let%span soption2 = "option.rs" 17 24 17 32
  let%span soption3 = "option.rs" 17 37 17 38
  let%span soption4 = "option.rs" 19 27 19 28
  let%span soption5 = "option.rs" 19 33 19 34
  let%span soption6 = "option.rs" 20 27 20 28
  let%span soption7 = "option.rs" 20 33 20 34
  let%span soption8 = "option.rs" 22 40 22 41
  let%span soption9 = "option.rs" 23 40 23 41
  let%span soption10 = "option.rs" 25 48 25 49
  let%span soption11 = "option.rs" 26 41 26 42
  let%span soption12 = "option.rs" 28 50 28 51
  let%span soption13 = "option.rs" 28 4 28 52
  let%span soption14 = "option.rs" 26 4 26 43
  let%span soption15 = "option.rs" 25 4 25 50
  let%span soption16 = "option.rs" 23 4 23 42
  let%span soption17 = "option.rs" 22 4 22 42
  let%span soption18 = "option.rs" 20 4 20 35
  let%span soption19 = "option.rs" 19 4 19 35
  let%span soption20 = "option.rs" 17 4 17 39
  let%span soption21 = "option.rs" 16 4 16 31
  let%span soption22 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption23 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span soption24 = "../../creusot-contracts/src/std/option.rs" 126 27 126 39
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 127 26 127 46
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 146 26 146 60
  let%span soption27 = "../../creusot-contracts/src/std/option.rs" 147 26 147 85
  let%span soption28 = "../../creusot-contracts/src/std/option.rs" 169 26 169 62
  let%span soption29 = "../../creusot-contracts/src/std/option.rs" 170 26 170 62
  let%span soption30 = "../../creusot-contracts/src/std/option.rs" 155 27 155 62
  let%span soption31 = "../../creusot-contracts/src/std/option.rs" 156 26 159 17
  let%span soption32 = "option.rs" 26 35 26 36
  let%span soption33 = "../../creusot-contracts/src/std/option.rs" 181 27 181 39
  let%span soption34 = "../../creusot-contracts/src/std/option.rs" 182 26 182 46
  let%span snum35 = "../../creusot-contracts/src/std/num.rs" 33 28 33 41
  let%span soption36 = "option.rs" 25 32 25 34
  let%span soption37 = "option.rs" 26 32 26 34
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec unwrap'1 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption22] self <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption23] C_Some'0 result = self} (! return' {result}) ] 
  
  let rec expect'0 (self:t_Option'0) (msg:string) (return'  (ret:Int32.t))= {[@expl:expect requires] [%#soption24] self
    <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption25] C_Some'0 result = self} (! return' {result}) ] 
  
  predicate resolve'0 (_1 : Int32.t) =
    true
  
  let rec unwrap_or'0 (self:t_Option'0) (default:Int32.t) (return'  (ret:Int32.t))= any
    [ return' (result:Int32.t)-> {[%#soption26] self = C_None'0  -> result = default}
      {[%#soption27] self = C_None'0 \/ self = C_Some'0 result /\ resolve'0 default}
      (! return' {result}) ]
  
  
  predicate is_default'0 (self : Int32.t) =
    [%#snum35] self = (0 : Int32.t)
  
  let rec unwrap_or_default'0 (self:t_Option'0) (return'  (ret:Int32.t))= any
    [ return' (result:Int32.t)-> {[%#soption28] self = C_None'0  -> is_default'0 result}
      {[%#soption29] self = C_None'0 \/ self = C_Some'0 result}
      (! return' {result}) ]
  
  
  let rec closure0'0[#"option.rs" 25 32 25 34] [@coma:extspec] (_1:()) (return'  (ret:Int32.t))= bb0
    [ bb0 = {false} any ]
     [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : ()) =
    [%#soption36] let () = args in closure0'0'pre self
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : Int32.t) =
    [%#soption36] let () = args in closure0'0'post'return' self result
  
  let rec unwrap_or_else'0 (self:t_Option'0) (f:()) (return'  (ret:Int32.t))= {[@expl:unwrap_or_else requires] [%#soption30] self
    = C_None'0  -> precondition'0 f ()}
    any
    [ return' (result:Int32.t)-> {[%#soption31] match self with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = t
        end}
      (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 26 32 26 34] [@coma:extspec] (_1:()) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption32] (3 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : ()) =
    [%#soption37] let () = args in closure1'0'pre self
  
  predicate postcondition_once'1 (self : ()) (args : ()) (result : Int32.t) =
    [%#soption37] let () = args in closure1'0'post'return' self result
  
  let rec unwrap_or_else'1 (self:t_Option'0) (f:()) (return'  (ret:Int32.t))= {[@expl:unwrap_or_else requires] [%#soption30] self
    = C_None'0  -> precondition'1 f ()}
    any
    [ return' (result:Int32.t)-> {[%#soption31] match self with
        | C_None'0 -> postcondition_once'1 f () result
        | C_Some'0 t -> result = t
        end}
      (! return' {result}) ]
  
  
  let rec unwrap_unchecked'0 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap_unchecked requires] [%#soption33] self
    <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption34] C_Some'0 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec unwrap'0[#"option.rs" 12 0 12 15] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = unwrap'1 {some} (fun (_ret':Int32.t) ->  [ &_5 <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_4 <- _5 = ([%#soption1] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ]  ]
    
    | bb2 = s0
      [ s0 =  [ &_13 <- [%#soption2] "failed" ] s1
      | s1 = expect'0 {some} {_13} (fun (_ret':Int32.t) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_9 <- _10 = ([%#soption3] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = unwrap_or'0 {some} {[%#soption4] (2 : Int32.t)} (fun (_ret':Int32.t) ->  [ &_17 <- _ret' ] s1) | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_16 <- _17 = ([%#soption5] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 = unwrap_or'0 {none} {[%#soption6] (2 : Int32.t)} (fun (_ret':Int32.t) ->  [ &_22 <- _ret' ] s1)
      | s1 = bb10 ]
    
    | bb10 = s0
      [ s0 =  [ &_21 <- _22 = ([%#soption7] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb12) | br1 -> {_21} (! bb11) ]  ]
    
    | bb11 = s0 [ s0 = unwrap_or_default'0 {some} (fun (_ret':Int32.t) ->  [ &_27 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_26 <- _27 = ([%#soption8] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb14) ]  ]
    
    | bb14 = s0 [ s0 = unwrap_or_default'0 {none} (fun (_ret':Int32.t) ->  [ &_32 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &_31 <- _32 = ([%#soption9] (0 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb18) | br1 -> {_31} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 =  [ &_39 <- () ] s1
      | s1 = unwrap_or_else'0 {some} {_39} (fun (_ret':Int32.t) ->  [ &_37 <- _ret' ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0
      [ s0 =  [ &_36 <- _37 = ([%#soption10] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_36 = false} (! bb21) | br1 -> {_36} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 =  [ &_45 <- () ] s1
      | s1 = unwrap_or_else'1 {none} {_45} (fun (_ret':Int32.t) ->  [ &_43 <- _ret' ] s2)
      | s2 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &_42 <- _43 = ([%#soption11] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_42 = false} (! bb24) | br1 -> {_42} (! bb23) ]  ]
    
    | bb23 = s0 [ s0 = unwrap_unchecked'0 {some} (fun (_ret':Int32.t) ->  [ &_49 <- _ret' ] s1) | s1 = bb25 ] 
    | bb25 = s0
      [ s0 =  [ &_48 <- _49 = ([%#soption12] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_48 = false} (! bb27) | br1 -> {_48} (! bb26) ]  ]
    
    | bb26 = return' {_0}
    | bb27 = {[%#soption13] false} any
    | bb24 = {[%#soption14] false} any
    | bb21 = {[%#soption15] false} any
    | bb18 = {[%#soption16] false} any
    | bb15 = {[%#soption17] false} any
    | bb12 = {[%#soption18] false} any
    | bb9 = {[%#soption19] false} any
    | bb6 = {[%#soption20] false} any
    | bb3 = {[%#soption21] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _5 : Int32.t = Any.any_l ()
    | & _9 : bool = Any.any_l ()
    | & _10 : Int32.t = Any.any_l ()
    | & _13 : string = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _17 : Int32.t = Any.any_l ()
    | & _21 : bool = Any.any_l ()
    | & _22 : Int32.t = Any.any_l ()
    | & _26 : bool = Any.any_l ()
    | & _27 : Int32.t = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & _32 : Int32.t = Any.any_l ()
    | & _36 : bool = Any.any_l ()
    | & _37 : Int32.t = Any.any_l ()
    | & _39 : () = Any.any_l ()
    | & _42 : bool = Any.any_l ()
    | & _43 : Int32.t = Any.any_l ()
    | & _45 : () = Any.any_l ()
    | & _48 : bool = Any.any_l ()
    | & _49 : Int32.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__map [#"option.rs" 31 0 31 12]
  let%span soption0 = "option.rs" 33 33 33 34
  let%span soption1 = "option.rs" 37 4 37 43
  let%span soption2 = "option.rs" 36 4 36 39
  let%span soption3 = "option.rs" 35 4 35 43
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 190 27 193 17
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 194 26 197 17
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption7 = "option.rs" 36 25 36 26
  let%span soption8 = "option.rs" 36 36 36 37
  let%span soption9 = "option.rs" 37 29 37 30
  let%span soption10 = "option.rs" 37 40 37 41
  let%span soption11 = "option.rs" 35 21 35 24
  let%span smodel12 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption13 = "option.rs" 36 21 36 24
  let%span soption14 = "option.rs" 37 21 37 24
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span stuples16 = "../../creusot-contracts/src/std/tuples.rs" 9 20 9 22
  let%span snum17 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 35 21 35 24] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:()))= bb0
    [ bb0 = {false} any ]
     [ return' (result:())-> return' {result} ] 
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 ()
  
  predicate precondition'0 (self : ()) (args : Int32.t) =
    [%#soption11] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : Int32.t) (result : ()) =
    [%#soption11] let _2 = args in closure0'0'post'return' self _2 result
  
  let rec map'1 (self:t_Option'1) (f:()) (return'  (ret:t_Option'0))= {[@expl:map requires] [%#soption4] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption5] match self with
        | C_None'0 -> result = C_None'1
        | C_Some'0 t -> exists r : () . result = C_Some'1 r /\ postcondition_once'0 f t r
        end}
      (! return' {result}) ]
  
  
  let rec promoted2__map'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'1 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  function deep_model'4 (self : ()) : () =
    [%#stuples16] ()
  
  function deep_model'2 (self : t_Option'0) : t_Option'0 =
    [%#soption15] match self with
      | C_Some'1 t -> C_Some'1 (deep_model'4 t)
      | C_None'1 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'0 =
    [%#smodel12] deep_model'2 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption6] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 36 21 36 24] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption7] (3 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : Int32.t) =
    [%#soption13] let _2 = args in closure1'0'pre self _2
  
  predicate postcondition_once'1 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption13] let _2 = args in closure1'0'post'return' self _2 result
  
  let rec map'2 (self:t_Option'1) (f:()) (return'  (ret:t_Option'1))= {[@expl:map requires] [%#soption4] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'1 f t
      end}
    any
    [ return' (result:t_Option'1)-> {[%#soption5] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> exists r : Int32.t . result = C_Some'0 r /\ postcondition_once'1 f t r
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__map'0 (return'  (ret:t_Option'1))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption8] (3 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'1 = Any.any_l () | & _1 : t_Option'1 = Any.any_l () ] 
    [ return' (result:t_Option'1)-> return' {result} ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 int
  
  function deep_model'5 (self : Int32.t) : int =
    [%#snum17] Int32.to_int self
  
  function deep_model'3 (self : t_Option'1) : t_Option'2 =
    [%#soption15] match self with
      | C_Some'0 t -> C_Some'2 (deep_model'5 t)
      | C_None'0 -> C_None'2
      end
  
  function deep_model'1 (self : t_Option'1) : t_Option'2 =
    [%#smodel12] deep_model'3 self
  
  let rec eq'1 (self:t_Option'1) (other:t_Option'1) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption6] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
  
  
  let rec closure2'0[#"option.rs" 37 21 37 24] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0
      [ s0 = Int32.add {x} {[%#soption9] (1 : Int32.t)} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
     ]
     [ & _0 : Int32.t = Any.any_l () | & x : Int32.t = x ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'2 (self : ()) (args : Int32.t) =
    [%#soption14] let x = args in closure2'0'pre self x
  
  predicate postcondition_once'2 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption14] let x = args in closure2'0'post'return' self x result
  
  let rec map'3 (self:t_Option'1) (f:()) (return'  (ret:t_Option'1))= {[@expl:map requires] [%#soption4] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'2 f t
      end}
    any
    [ return' (result:t_Option'1)-> {[%#soption5] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> exists r : Int32.t . result = C_Some'0 r /\ postcondition_once'2 f t r
        end}
      (! return' {result}) ]
  
  
  let rec promoted0__map'0 (return'  (ret:t_Option'1))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption10] (2 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'1 = Any.any_l () | & _1 : t_Option'1 = Any.any_l () ] 
    [ return' (result:t_Option'1)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec map'0[#"option.rs" 31 0 31 12] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &_8 <- () ] s3
      | s3 = map'1 {none} {_8} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted2__map'0 (fun (pr2:t_Option'0) ->  [ &_32 <- pr2 ] s1)
      | s1 = eq'0 {_6} {_32} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- () ] s1 | s1 = map'2 {some} {_17} (fun (_ret':t_Option'1) ->  [ &_15 <- _ret' ] s2) | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted1__map'0 (fun (pr1:t_Option'1) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'1 {_15} {_31} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_26 <- () ] s1 | s1 = map'3 {some} {_26} (fun (_ret':t_Option'1) ->  [ &_24 <- _ret' ] s2) | s2 = bb9 ]
    
    | bb9 = s0
      [ s0 = promoted0__map'0 (fun (pr0:t_Option'1) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'1 {_24} {_30} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption1] false} any
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'1 = Any.any_l ()
    | & some : t_Option'1 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : t_Option'1 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _24 : t_Option'1 = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _30 : t_Option'1 = Any.any_l ()
    | & _31 : t_Option'1 = Any.any_l ()
    | & _32 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__inspect [#"option.rs" 40 0 40 16]
  let%span soption0 = "option.rs" 42 33 42 34
  let%span soption1 = "option.rs" 45 4 45 44
  let%span soption2 = "option.rs" 44 4 44 47
  let%span soption3 = "../../creusot-contracts/src/std/option.rs" 207 27 210 17
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 211 26 211 40
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 212 26 215 17
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption7 = "option.rs" 45 41 45 42
  let%span soption8 = "option.rs" 44 25 44 28
  let%span smodel9 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption10 = "option.rs" 45 25 45 28
  let%span soption11 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum12 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 44 25 44 28] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:()))= bb0
    [ bb0 = {false} any ]
     [ return' (result:())-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : Int32.t) =
    [%#soption8] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : Int32.t) (result : ()) =
    [%#soption8] let _2 = args in closure0'0'post'return' self _2 result
  
  let rec inspect'1 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:inspect requires] [%#soption3] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption4] result = self}
      {[%#soption5] match self with
        | C_None'0 -> true
        | C_Some'0 t -> postcondition_once'0 f t ()
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__inspect'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum12] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption11] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel9] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption6] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 45 25 45 28] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:()))= bb0
    [ bb0 = return' {_0} ]
     [ & _0 : () = Any.any_l () ]  [ return' (result:())-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : Int32.t) =
    [%#soption10] let _2 = args in closure1'0'pre self _2
  
  predicate postcondition_once'1 (self : ()) (args : Int32.t) (result : ()) =
    [%#soption10] let _2 = args in closure1'0'post'return' self _2 result
  
  let rec inspect'2 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:inspect requires] [%#soption3] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'1 f t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption4] result = self}
      {[%#soption5] match self with
        | C_None'0 -> true
        | C_Some'0 t -> postcondition_once'1 f t ()
        end}
      (! return' {result}) ]
  
  
  let rec promoted0__inspect'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption7] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec inspect'0[#"option.rs" 40 0 40 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &_8 <- () ] s3
      | s3 = inspect'1 {none} {_8} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted1__inspect'0 (fun (pr1:t_Option'0) ->  [ &_22 <- pr1 ] s1)
      | s1 = eq'0 {_6} {_22} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- () ] s1
      | s1 = inspect'2 {some} {_17} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted0__inspect'0 (fun (pr0:t_Option'0) ->  [ &_21 <- pr0 ] s1)
      | s1 = eq'0 {_15} {_21} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = return' {_0}
    | bb8 = {[%#soption1] false} any
    | bb4 = {[%#soption2] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : t_Option'0 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _21 : t_Option'0 = Any.any_l ()
    | & _22 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__map_or [#"option.rs" 48 0 48 15]
  let%span soption0 = "option.rs" 50 33 50 34
  let%span soption1 = "option.rs" 53 24 53 25
  let%span soption2 = "option.rs" 53 44 53 45
  let%span soption3 = "option.rs" 54 24 54 26
  let%span soption4 = "option.rs" 54 38 54 39
  let%span soption5 = "option.rs" 55 24 55 26
  let%span soption6 = "option.rs" 55 42 55 43
  let%span soption7 = "option.rs" 58 52 58 53
  let%span soption8 = "option.rs" 59 56 59 57
  let%span soption9 = "option.rs" 59 4 59 58
  let%span soption10 = "option.rs" 58 4 58 54
  let%span soption11 = "option.rs" 55 4 55 44
  let%span soption12 = "option.rs" 54 4 54 40
  let%span soption13 = "option.rs" 53 4 53 46
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 225 27 228 17
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 229 26 232 17
  let%span soption16 = "option.rs" 54 32 54 33
  let%span soption17 = "option.rs" 55 36 55 37
  let%span soption18 = "option.rs" 58 32 58 33
  let%span soption19 = "../../creusot-contracts/src/std/option.rs" 242 27 245 17
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 246 26 249 17
  let%span soption21 = "option.rs" 59 50 59 51
  let%span soption22 = "option.rs" 53 27 53 30
  let%span soption23 = "option.rs" 54 28 54 31
  let%span soption24 = "option.rs" 55 28 55 31
  let%span soption25 = "option.rs" 58 29 58 31
  let%span soption26 = "option.rs" 58 35 58 38
  let%span soption27 = "option.rs" 59 29 59 31
  let%span soption28 = "option.rs" 59 42 59 45
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 53 27 53 30] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = {false} any ]
     [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : Int32.t) =
    [%#soption22] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption22] let _2 = args in closure0'0'post'return' self _2 result
  
  let rec map_or'1 (self:t_Option'0) (default:Int32.t) (f:()) (return'  (ret:Int32.t))= {[@expl:map_or requires] [%#soption14] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    any
    [ return' (result:Int32.t)-> {[%#soption15] match self with
        | C_None'0 -> result = default
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 54 28 54 31] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption16] (3 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : Int32.t) =
    [%#soption23] let _2 = args in closure1'0'pre self _2
  
  predicate postcondition_once'1 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption23] let _2 = args in closure1'0'post'return' self _2 result
  
  let rec map_or'2 (self:t_Option'0) (default:Int32.t) (f:()) (return'  (ret:Int32.t))= {[@expl:map_or requires] [%#soption14] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'1 f t
      end}
    any
    [ return' (result:Int32.t)-> {[%#soption15] match self with
        | C_None'0 -> result = default
        | C_Some'0 t -> postcondition_once'1 f t result
        end}
      (! return' {result}) ]
  
  
  let rec closure2'0[#"option.rs" 55 28 55 31] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0
      [ s0 = Int32.add {x} {[%#soption17] (1 : Int32.t)} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
     ]
     [ & _0 : Int32.t = Any.any_l () | & x : Int32.t = x ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'2 (self : ()) (args : Int32.t) =
    [%#soption24] let x = args in closure2'0'pre self x
  
  predicate postcondition_once'2 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption24] let x = args in closure2'0'post'return' self x result
  
  let rec map_or'3 (self:t_Option'0) (default:Int32.t) (f:()) (return'  (ret:Int32.t))= {[@expl:map_or requires] [%#soption14] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'2 f t
      end}
    any
    [ return' (result:Int32.t)-> {[%#soption15] match self with
        | C_None'0 -> result = default
        | C_Some'0 t -> postcondition_once'2 f t result
        end}
      (! return' {result}) ]
  
  
  let rec closure3'0[#"option.rs" 58 29 58 31] [@coma:extspec] (_1:()) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption18] (2 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  let rec closure4'0[#"option.rs" 58 35 58 38] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = {false} any ]
     [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'3 (self : ()) (args : ()) =
    [%#soption25] let () = args in closure3'0'pre self
  
  predicate precondition'4 (self : ()) (args : Int32.t) =
    [%#soption26] let _2 = args in closure4'0'pre self _2
  
  predicate postcondition_once'3 (self : ()) (args : ()) (result : Int32.t) =
    [%#soption25] let () = args in closure3'0'post'return' self result
  
  predicate postcondition_once'4 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption26] let _2 = args in closure4'0'post'return' self _2 result
  
  let rec map_or_else'0 (self:t_Option'0) (default:()) (f:()) (return'  (ret:Int32.t))= {[@expl:map_or_else requires] [%#soption19] match self with
      | C_None'0 -> precondition'3 default ()
      | C_Some'0 t -> precondition'4 f t
      end}
    any
    [ return' (result:Int32.t)-> {[%#soption20] match self with
        | C_None'0 -> postcondition_once'3 default () result
        | C_Some'0 t -> postcondition_once'4 f t result
        end}
      (! return' {result}) ]
  
  
  let rec closure5'0[#"option.rs" 59 29 59 31] [@coma:extspec] (_1:()) (return'  (ret:Int32.t))= bb0
    [ bb0 = {false} any ]
     [ return' (result:Int32.t)-> return' {result} ] 
  
  let rec closure6'0[#"option.rs" 59 42 59 45] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0
      [ s0 = Int32.add {x} {[%#soption21] (1 : Int32.t)} (fun (_ret':Int32.t) ->  [ &_0 <- _ret' ] s1)
      | s1 = return' {_0} ]
     ]
     [ & _0 : Int32.t = Any.any_l () | & x : Int32.t = x ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'5 (self : ()) (args : ()) =
    [%#soption27] let () = args in closure5'0'pre self
  
  predicate precondition'6 (self : ()) (args : Int32.t) =
    [%#soption28] let x = args in closure6'0'pre self x
  
  predicate postcondition_once'5 (self : ()) (args : ()) (result : Int32.t) =
    [%#soption27] let () = args in closure5'0'post'return' self result
  
  predicate postcondition_once'6 (self : ()) (args : Int32.t) (result : Int32.t) =
    [%#soption28] let x = args in closure6'0'post'return' self x result
  
  let rec map_or_else'1 (self:t_Option'0) (default:()) (f:()) (return'  (ret:Int32.t))= {[@expl:map_or_else requires] [%#soption19] match self with
      | C_None'0 -> precondition'5 default ()
      | C_Some'0 t -> precondition'6 f t
      end}
    any
    [ return' (result:Int32.t)-> {[%#soption20] match self with
        | C_None'0 -> postcondition_once'5 default () result
        | C_Some'0 t -> postcondition_once'6 f t result
        end}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec map_or'0[#"option.rs" 48 0 48 15] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &_7 <- () ] s3
      | s3 = map_or'1 {none} {[%#soption1] (2 : Int32.t)} {_7} (fun (_ret':Int32.t) ->  [ &_5 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_4 <- _5 = ([%#soption2] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ]  ]
    
    | bb2 = s0
      [ s0 =  [ &_13 <- () ] s1
      | s1 = map_or'2 {some} {[%#soption3] (-1 : Int32.t)} {_13} (fun (_ret':Int32.t) ->  [ &_11 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_10 <- _11 = ([%#soption4] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 =  [ &_19 <- () ] s1
      | s1 = map_or'3 {some} {[%#soption5] (-1 : Int32.t)} {_19} (fun (_ret':Int32.t) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_16 <- _17 = ([%#soption6] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 =  [ &_25 <- () ] s1
      | s1 =  [ &_26 <- () ] s2
      | s2 = map_or_else'0 {none} {_25} {_26} (fun (_ret':Int32.t) ->  [ &_23 <- _ret' ] s3)
      | s3 = bb10 ]
    
    | bb10 = s0
      [ s0 =  [ &_22 <- _23 = ([%#soption7] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 =  [ &_32 <- () ] s1
      | s1 =  [ &_33 <- () ] s2
      | s2 = map_or_else'1 {some} {_32} {_33} (fun (_ret':Int32.t) ->  [ &_30 <- _ret' ] s3)
      | s3 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_29 <- _30 = ([%#soption8] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb15) | br1 -> {_29} (! bb14) ]  ]
    
    | bb14 = return' {_0}
    | bb15 = {[%#soption9] false} any
    | bb12 = {[%#soption10] false} any
    | bb9 = {[%#soption11] false} any
    | bb6 = {[%#soption12] false} any
    | bb3 = {[%#soption13] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _5 : Int32.t = Any.any_l ()
    | & _7 : () = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : Int32.t = Any.any_l ()
    | & _13 : () = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _17 : Int32.t = Any.any_l ()
    | & _19 : () = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _23 : Int32.t = Any.any_l ()
    | & _25 : () = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _29 : bool = Any.any_l ()
    | & _30 : Int32.t = Any.any_l ()
    | & _32 : () = Any.any_l ()
    | & _33 : () = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__ok_or [#"option.rs" 62 0 62 14]
  let%span soption0 = "option.rs" 64 33 64 34
  let%span soption1 = "option.rs" 66 25 66 29
  let%span soption2 = "option.rs" 67 18 67 34
  let%span soption3 = "option.rs" 68 24 68 29
  let%span soption4 = "option.rs" 69 18 69 32
  let%span soption5 = "option.rs" 72 18 72 34
  let%span soption6 = "option.rs" 74 18 74 32
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 261 26 264 17
  let%span soption8 = "option.rs" 71 33 71 37
  let%span soption9 = "../../creusot-contracts/src/std/option.rs" 272 27 272 64
  let%span soption10 = "../../creusot-contracts/src/std/option.rs" 273 26 276 17
  let%span soption11 = "option.rs" 73 32 73 37
  let%span soption12 = "option.rs" 71 30 71 32
  let%span soption13 = "option.rs" 73 29 73 31
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  type t_Result'0  =
    | C_Ok'0 Int32.t
    | C_Err'0 bool
  
  predicate resolve'0 (_1 : bool) =
    true
  
  let rec ok_or'1 (self:t_Option'0) (err:bool) (return'  (ret:t_Result'0))= any
    [ return' (result:t_Result'0)-> {[%#soption7] match self with
        | C_None'0 -> result = C_Err'0 err
        | C_Some'0 t -> result = C_Ok'0 t /\ resolve'0 err
        end}
      (! return' {result}) ]
  
  
  let rec closure0'0[#"option.rs" 71 30 71 32] [@coma:extspec] (_1:()) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption8] true ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : ()) =
    [%#soption12] let () = args in closure0'0'pre self
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : bool) =
    [%#soption12] let () = args in closure0'0'post'return' self result
  
  let rec ok_or_else'0 (self:t_Option'0) (err:()) (return'  (ret:t_Result'0))= {[@expl:ok_or_else requires] [%#soption9] self
    = C_None'0  -> precondition'0 err ()}
    any
    [ return' (result:t_Result'0)-> {[%#soption10] match self with
        | C_None'0 -> exists r : bool . result = C_Err'0 r /\ postcondition_once'0 err () r
        | C_Some'0 t -> result = C_Ok'0 t
        end}
      (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 73 29 73 31] [@coma:extspec] (_1:()) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption11] false ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : ()) =
    [%#soption13] let () = args in closure1'0'pre self
  
  predicate postcondition_once'1 (self : ()) (args : ()) (result : bool) =
    [%#soption13] let () = args in closure1'0'post'return' self result
  
  let rec ok_or_else'1 (self:t_Option'0) (err:()) (return'  (ret:t_Result'0))= {[@expl:ok_or_else requires] [%#soption9] self
    = C_None'0  -> precondition'1 err ()}
    any
    [ return' (result:t_Result'0)-> {[%#soption10] match self with
        | C_None'0 -> exists r : bool . result = C_Err'0 r /\ postcondition_once'1 err () r
        | C_Some'0 t -> result = C_Ok'0 t
        end}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec ok_or'0[#"option.rs" 62 0 62 14] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = ok_or'1 {none} {[%#soption1] true} (fun (_ret':t_Result'0) ->  [ &err <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#soption2] err = C_Err'0 true} s1
      | s1 = ok_or'1 {some} {[%#soption3] false} (fun (_ret':t_Result'0) ->  [ &ok <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:assertion] [%#soption4] ok = C_Ok'0 (1 : Int32.t)} s1
      | s1 =  [ &_13 <- () ] s2
      | s2 = ok_or_else'0 {none} {_13} (fun (_ret':t_Result'0) ->  [ &err1 <- _ret' ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#soption5] err1 = C_Err'0 true} s1
      | s1 =  [ &_18 <- () ] s2
      | s2 = ok_or_else'1 {some} {_18} (fun (_ret':t_Result'0) ->  [ &ok1 <- _ret' ] s3)
      | s3 = bb4 ]
    
    | bb4 = s0 [ s0 = {[@expl:assertion] [%#soption6] ok1 = C_Ok'0 (1 : Int32.t)} s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & err : t_Result'0 = Any.any_l ()
    | & ok : t_Result'0 = Any.any_l ()
    | & err1 : t_Result'0 = Any.any_l ()
    | & _13 : () = Any.any_l ()
    | & ok1 : t_Result'0 = Any.any_l ()
    | & _18 : () = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__as_mut [#"option.rs" 77 0 77 15]
  let%span soption0 = "option.rs" 79 37 79 38
  let%span soption1 = "option.rs" 82 30 82 31
  let%span soption2 = "option.rs" 83 29 83 30
  let%span soption3 = "option.rs" 84 30 84 31
  let%span soption4 = "option.rs" 85 29 85 30
  let%span soption5 = "option.rs" 85 4 85 31
  let%span soption6 = "option.rs" 83 4 83 31
  let%span soption7 = "option.rs" 81 4 81 36
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 86 26 86 75
  let%span soption9 = "../../creusot-contracts/src/std/option.rs" 88 20 89 100
  let%span soption10 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span soption11 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span sresolve13 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span sresolve14 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t Int32.t)
  
  let rec as_mut'1 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption8] self.current = C_None'0
       -> result = C_None'1 /\ self.final = C_None'0}
      {[%#soption9] self.current = C_None'0
      \/ (exists r : MutBorrow.t Int32.t . result = C_Some'1 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'1) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption10] result = (self = C_None'1)} (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t Int32.t) =
    [%#sresolve14] self.final = self.current
  
  predicate resolve'1 (_1 : MutBorrow.t Int32.t) =
    resolve'3 _1
  
  predicate resolve'2 (self : t_Option'1) =
    [%#sresolve13] match self with
      | C_Some'1 x -> resolve'1 x
      | C_None'1 -> true
      end
  
  predicate resolve'0 (_1 : t_Option'1) =
    resolve'2 _1
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:MutBorrow.t Int32.t))= {[@expl:unwrap requires] [%#soption11] self
    <> C_None'1}
    any [ return' (result:MutBorrow.t Int32.t)-> {[%#soption12] C_Some'1 result = self} (! return' {result}) ] 
  
  let rec unwrap'1 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption11] self <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption12] C_Some'0 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec as_mut'0[#"option.rs" 77 0 77 15] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = as_mut'1 {_7} (fun (_ret':t_Option'1) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = -{resolve'0 _6}- s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_11 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'1 {_11} (fun (_ret':t_Option'1) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':MutBorrow.t Int32.t) ->  [ &_9 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_9 <- { _9 with current = ([%#soption1] (2 : Int32.t)) } ] s1
      | s1 = -{resolve'1 _9}- s2
      | s2 = unwrap'1 {some} (fun (_ret':Int32.t) ->  [ &_14 <- _ret' ] s3)
      | s3 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_13 <- _14 = ([%#soption2] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_13 = false} (! bb9) | br1 -> {_13} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_19 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'1 {_19} (fun (_ret':t_Option'1) ->  [ &_18 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = s0 [ s0 = unwrap'0 {_18} (fun (_ret':MutBorrow.t Int32.t) ->  [ &_17 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_17 <- { _17 with current = ([%#soption3] (1 : Int32.t)) } ] s1
      | s1 = -{resolve'1 _17}- s2
      | s2 = unwrap'1 {some} (fun (_ret':Int32.t) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0
      [ s0 =  [ &_21 <- _22 = ([%#soption4] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb13) ]  ]
    
    | bb13 = return' {_0}
    | bb14 = {[%#soption5] false} any
    | bb9 = {[%#soption6] false} any
    | bb4 = {[%#soption7] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'1 = Any.any_l ()
    | & _7 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _9 : MutBorrow.t Int32.t = Any.any_l ()
    | & _10 : t_Option'1 = Any.any_l ()
    | & _11 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _14 : Int32.t = Any.any_l ()
    | & _17 : MutBorrow.t Int32.t = Any.any_l ()
    | & _18 : t_Option'1 = Any.any_l ()
    | & _19 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _21 : bool = Any.any_l ()
    | & _22 : Int32.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__as_ref [#"option.rs" 88 0 88 15]
  let%span soption0 = "option.rs" 90 33 90 34
  let%span soption1 = "option.rs" 93 39 93 40
  let%span soption2 = "option.rs" 93 4 93 41
  let%span soption3 = "option.rs" 92 4 92 36
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 74 26 74 58
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 76 20 76 89
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 Int32.t
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 Int32.t
  
  let rec as_ref'1 (self:t_Option'1) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption4] self = C_None'0  -> result = C_None'1}
      {[%#soption5] self = C_None'0 \/ (exists r : Int32.t . result = C_Some'1 r /\ self = C_Some'0 r)}
      (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption6] result = (self = C_None'1)} (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption7] self <> C_None'1}
    any [ return' (result:Int32.t)-> {[%#soption8] C_Some'1 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec as_ref'0[#"option.rs" 88 0 88 15] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = as_ref'1 {none} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0 [ s0 = as_ref'1 {some} (fun (_ret':t_Option'0) ->  [ &_13 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = unwrap'0 {_13} (fun (_ret':Int32.t) ->  [ &_12 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_10 <- _12 = ([%#soption1] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb8) | br1 -> {_10} (! bb7) ]  ]
    
    | bb7 = return' {_0}
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'1 = Any.any_l ()
    | & some : t_Option'1 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _12 : Int32.t = Any.any_l ()
    | & _13 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__replace [#"option.rs" 96 0 96 16]
  let%span soption0 = "option.rs" 98 37 98 38
  let%span soption1 = "option.rs" 100 25 100 26
  let%span soption2 = "option.rs" 101 29 101 30
  let%span soption3 = "option.rs" 102 25 102 26
  let%span soption4 = "option.rs" 102 40 102 41
  let%span soption5 = "option.rs" 103 29 103 30
  let%span soption6 = "option.rs" 104 25 104 26
  let%span soption7 = "option.rs" 104 40 104 41
  let%span soption8 = "option.rs" 105 29 105 30
  let%span soption9 = "option.rs" 105 4 105 31
  let%span soption10 = "option.rs" 104 4 104 42
  let%span soption11 = "option.rs" 103 4 103 31
  let%span soption12 = "option.rs" 102 4 102 42
  let%span soption13 = "option.rs" 101 4 101 31
  let%span soption14 = "option.rs" 100 4 100 38
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 445 26 445 65
  let%span soption16 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span soption17 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption18 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec replace'1 (self:MutBorrow.t t_Option'0) (value:Int32.t) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption15] result = self.current /\ self.final = C_Some'0 value}
      (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption16] result = (self = C_None'0)} (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption17] self <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption18] C_Some'0 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec replace'0[#"option.rs" 96 0 96 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = replace'1 {_7} {[%#soption1] (2 : Int32.t)} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0 [ s0 = unwrap'0 {none} (fun (_ret':Int32.t) ->  [ &_11 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_10 <- _11 = ([%#soption2] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_18 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = replace'1 {_18} {[%#soption3] (2 : Int32.t)} (fun (_ret':t_Option'0) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0 [ s0 = unwrap'0 {_17} (fun (_ret':Int32.t) ->  [ &_16 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 =  [ &_15 <- _16 = ([%#soption4] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_15 = false} (! bb11) | br1 -> {_15} (! bb10) ]  ]
    
    | bb10 = s0 [ s0 = unwrap'0 {some} (fun (_ret':Int32.t) ->  [ &_22 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 =  [ &_21 <- _22 = ([%#soption5] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_29 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = replace'1 {_29} {[%#soption6] (1 : Int32.t)} (fun (_ret':t_Option'0) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0 [ s0 = unwrap'0 {_28} (fun (_ret':Int32.t) ->  [ &_27 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 =  [ &_26 <- _27 = ([%#soption7] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_26 = false} (! bb18) | br1 -> {_26} (! bb17) ]  ]
    
    | bb17 = s0 [ s0 = unwrap'0 {some} (fun (_ret':Int32.t) ->  [ &_33 <- _ret' ] s1) | s1 = bb19 ] 
    | bb19 = s0
      [ s0 =  [ &_32 <- _33 = ([%#soption8] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_32 = false} (! bb21) | br1 -> {_32} (! bb20) ]  ]
    
    | bb20 = return' {_0}
    | bb21 = {[%#soption9] false} any
    | bb18 = {[%#soption10] false} any
    | bb14 = {[%#soption11] false} any
    | bb11 = {[%#soption12] false} any
    | bb7 = {[%#soption13] false} any
    | bb4 = {[%#soption14] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _7 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _11 : Int32.t = Any.any_l ()
    | & _15 : bool = Any.any_l ()
    | & _16 : Int32.t = Any.any_l ()
    | & _17 : t_Option'0 = Any.any_l ()
    | & _18 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _21 : bool = Any.any_l ()
    | & _22 : Int32.t = Any.any_l ()
    | & _26 : bool = Any.any_l ()
    | & _27 : Int32.t = Any.any_l ()
    | & _28 : t_Option'0 = Any.any_l ()
    | & _29 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _32 : bool = Any.any_l ()
    | & _33 : Int32.t = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__and_or_xor [#"option.rs" 108 0 108 19]
  let%span soption0 = "option.rs" 110 33 110 34
  let%span soption1 = "option.rs" 114 26 114 27
  let%span soption2 = "option.rs" 116 26 116 27
  let%span soption3 = "option.rs" 119 25 119 26
  let%span soption4 = "option.rs" 121 25 121 26
  let%span soption5 = "option.rs" 124 26 124 27
  let%span soption6 = "option.rs" 126 26 126 27
  let%span soption7 = "option.rs" 126 4 126 38
  let%span soption8 = "option.rs" 125 4 125 38
  let%span soption9 = "option.rs" 124 4 124 41
  let%span soption10 = "option.rs" 123 4 123 35
  let%span soption11 = "option.rs" 121 4 121 40
  let%span soption12 = "option.rs" 120 4 120 37
  let%span soption13 = "option.rs" 119 4 119 40
  let%span soption14 = "option.rs" 118 4 118 34
  let%span soption15 = "option.rs" 116 4 116 41
  let%span soption16 = "option.rs" 115 4 115 35
  let%span soption17 = "option.rs" 114 4 114 38
  let%span soption18 = "option.rs" 113 4 113 35
  let%span soption19 = "../../creusot-contracts/src/std/option.rs" 287 26 287 75
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 288 26 288 76
  let%span soption21 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption22 = "option.rs" 116 38 116 39
  let%span soption23 = "../../creusot-contracts/src/std/option.rs" 334 26 334 57
  let%span soption24 = "../../creusot-contracts/src/std/option.rs" 335 26 335 76
  let%span soption25 = "option.rs" 119 37 119 38
  let%span soption26 = "option.rs" 120 34 120 35
  let%span soption27 = "option.rs" 121 37 121 38
  let%span soption28 = "../../creusot-contracts/src/std/option.rs" 358 26 363 17
  let%span soption29 = "option.rs" 124 38 124 39
  let%span soption30 = "option.rs" 125 35 125 36
  let%span sresolve31 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span smodel32 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption33 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum34 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  predicate resolve'1 (_1 : Int32.t) =
    true
  
  predicate resolve'0 (self : t_Option'0) =
    [%#sresolve31] match self with
      | C_Some'0 x -> resolve'1 x
      | C_None'0 -> true
      end
  
  let rec and'0 (self:t_Option'0) (optb:t_Option'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption19] self = C_None'0  -> result = C_None'0 /\ resolve'0 optb}
      {[%#soption20] self = C_None'0 \/ result = optb /\ resolve'0 self}
      (! return' {result}) ]
  
  
  let rec promoted11__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum34] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption33] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel32] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption21] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec promoted10__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted9__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted8__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption22] (2 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec or'0 (self:t_Option'0) (optb:t_Option'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption23] self = C_None'0  -> result = optb}
      {[%#soption24] self = C_None'0 \/ result = self /\ resolve'0 optb}
      (! return' {result}) ]
  
  
  let rec promoted7__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted6__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption25] (2 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted5__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption26] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted4__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption27] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type tuple'0  =
    { _0'0: t_Option'0; _1'0: t_Option'0 }
  
  let rec xor'0 (self:t_Option'0) (optb:t_Option'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption28] match { _0'0 = self; _1'0 = optb } with
        | {_0'0 = C_None'0 ; _1'0 = C_None'0} -> result = C_None'0
        | {_0'0 = C_Some'0 t1 ; _1'0 = C_Some'0 t2} -> result = C_None'0 /\ resolve'1 t1 /\ resolve'1 t2
        | {_0'0 = C_Some'0 t ; _1'0 = C_None'0} -> result = C_Some'0 t
        | {_0'0 = C_None'0 ; _1'0 = C_Some'0 t} -> result = C_Some'0 t
        end}
      (! return' {result}) ]
  
  
  let rec promoted3__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted2__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption29] (2 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted1__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption30] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted0__and_or_xor'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec and_or_xor'0[#"option.rs" 108 0 108 19] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = and'0 {none} {none} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted11__and_or_xor'0 (fun (pr11:t_Option'0) ->  [ &_122 <- pr11 ] s1)
      | s1 = eq'0 {_6} {_122} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- C_Some'0 ([%#soption1] (2 : Int32.t)) ] s1
      | s1 = and'0 {none} {_17} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted10__and_or_xor'0 (fun (pr10:t_Option'0) ->  [ &_121 <- pr10 ] s1)
      | s1 = eq'0 {_15} {_121} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0 [ s0 = and'0 {some} {none} (fun (_ret':t_Option'0) ->  [ &_24 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = promoted9__and_or_xor'0 (fun (pr9:t_Option'0) ->  [ &_120 <- pr9 ] s1)
      | s1 = eq'0 {_24} {_120} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_35 <- C_Some'0 ([%#soption2] (2 : Int32.t)) ] s1
      | s1 = and'0 {some} {_35} (fun (_ret':t_Option'0) ->  [ &_33 <- _ret' ] s2)
      | s2 = bb13 ]
    
    | bb13 = s0
      [ s0 = promoted8__and_or_xor'0 (fun (pr8:t_Option'0) ->  [ &_119 <- pr8 ] s1)
      | s1 = eq'0 {_33} {_119} (fun (_ret':bool) ->  [ &_31 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb15) ] 
    | bb15 = s0 [ s0 = or'0 {none} {none} (fun (_ret':t_Option'0) ->  [ &_42 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 = promoted7__and_or_xor'0 (fun (pr7:t_Option'0) ->  [ &_118 <- pr7 ] s1)
      | s1 = eq'0 {_42} {_118} (fun (_ret':bool) ->  [ &_40 <- _ret' ] s2)
      | s2 = bb18 ]
    
    | bb18 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ] 
    | bb19 = s0
      [ s0 =  [ &_53 <- C_Some'0 ([%#soption3] (2 : Int32.t)) ] s1
      | s1 = or'0 {none} {_53} (fun (_ret':t_Option'0) ->  [ &_51 <- _ret' ] s2)
      | s2 = bb21 ]
    
    | bb21 = s0
      [ s0 = promoted6__and_or_xor'0 (fun (pr6:t_Option'0) ->  [ &_117 <- pr6 ] s1)
      | s1 = eq'0 {_51} {_117} (fun (_ret':bool) ->  [ &_49 <- _ret' ] s2)
      | s2 = bb22 ]
    
    | bb22 = any [ br0 -> {_49 = false} (! bb24) | br1 -> {_49} (! bb23) ] 
    | bb23 = s0 [ s0 = or'0 {some} {none} (fun (_ret':t_Option'0) ->  [ &_60 <- _ret' ] s1) | s1 = bb25 ] 
    | bb25 = s0
      [ s0 = promoted5__and_or_xor'0 (fun (pr5:t_Option'0) ->  [ &_116 <- pr5 ] s1)
      | s1 = eq'0 {_60} {_116} (fun (_ret':bool) ->  [ &_58 <- _ret' ] s2)
      | s2 = bb26 ]
    
    | bb26 = any [ br0 -> {_58 = false} (! bb28) | br1 -> {_58} (! bb27) ] 
    | bb27 = s0
      [ s0 =  [ &_71 <- C_Some'0 ([%#soption4] (2 : Int32.t)) ] s1
      | s1 = or'0 {some} {_71} (fun (_ret':t_Option'0) ->  [ &_69 <- _ret' ] s2)
      | s2 = bb29 ]
    
    | bb29 = s0
      [ s0 = promoted4__and_or_xor'0 (fun (pr4:t_Option'0) ->  [ &_115 <- pr4 ] s1)
      | s1 = eq'0 {_69} {_115} (fun (_ret':bool) ->  [ &_67 <- _ret' ] s2)
      | s2 = bb30 ]
    
    | bb30 = any [ br0 -> {_67 = false} (! bb32) | br1 -> {_67} (! bb31) ] 
    | bb31 = s0 [ s0 = xor'0 {none} {none} (fun (_ret':t_Option'0) ->  [ &_78 <- _ret' ] s1) | s1 = bb33 ] 
    | bb33 = s0
      [ s0 = promoted3__and_or_xor'0 (fun (pr3:t_Option'0) ->  [ &_114 <- pr3 ] s1)
      | s1 = eq'0 {_78} {_114} (fun (_ret':bool) ->  [ &_76 <- _ret' ] s2)
      | s2 = bb34 ]
    
    | bb34 = any [ br0 -> {_76 = false} (! bb36) | br1 -> {_76} (! bb35) ] 
    | bb35 = s0
      [ s0 =  [ &_89 <- C_Some'0 ([%#soption5] (2 : Int32.t)) ] s1
      | s1 = xor'0 {none} {_89} (fun (_ret':t_Option'0) ->  [ &_87 <- _ret' ] s2)
      | s2 = bb37 ]
    
    | bb37 = s0
      [ s0 = promoted2__and_or_xor'0 (fun (pr2:t_Option'0) ->  [ &_113 <- pr2 ] s1)
      | s1 = eq'0 {_87} {_113} (fun (_ret':bool) ->  [ &_85 <- _ret' ] s2)
      | s2 = bb38 ]
    
    | bb38 = any [ br0 -> {_85 = false} (! bb40) | br1 -> {_85} (! bb39) ] 
    | bb39 = s0 [ s0 = xor'0 {some} {none} (fun (_ret':t_Option'0) ->  [ &_96 <- _ret' ] s1) | s1 = bb41 ] 
    | bb41 = s0
      [ s0 = promoted1__and_or_xor'0 (fun (pr1:t_Option'0) ->  [ &_112 <- pr1 ] s1)
      | s1 = eq'0 {_96} {_112} (fun (_ret':bool) ->  [ &_94 <- _ret' ] s2)
      | s2 = bb42 ]
    
    | bb42 = any [ br0 -> {_94 = false} (! bb44) | br1 -> {_94} (! bb43) ] 
    | bb43 = s0
      [ s0 =  [ &_107 <- C_Some'0 ([%#soption6] (2 : Int32.t)) ] s1
      | s1 = xor'0 {some} {_107} (fun (_ret':t_Option'0) ->  [ &_105 <- _ret' ] s2)
      | s2 = bb45 ]
    
    | bb45 = s0
      [ s0 = promoted0__and_or_xor'0 (fun (pr0:t_Option'0) ->  [ &_111 <- pr0 ] s1)
      | s1 = eq'0 {_105} {_111} (fun (_ret':bool) ->  [ &_103 <- _ret' ] s2)
      | s2 = bb46 ]
    
    | bb46 = any [ br0 -> {_103 = false} (! bb48) | br1 -> {_103} (! bb47) ] 
    | bb47 = return' {_0}
    | bb48 = {[%#soption7] false} any
    | bb44 = {[%#soption8] false} any
    | bb40 = {[%#soption9] false} any
    | bb36 = {[%#soption10] false} any
    | bb32 = {[%#soption11] false} any
    | bb28 = {[%#soption12] false} any
    | bb24 = {[%#soption13] false} any
    | bb20 = {[%#soption14] false} any
    | bb16 = {[%#soption15] false} any
    | bb12 = {[%#soption16] false} any
    | bb8 = {[%#soption17] false} any
    | bb4 = {[%#soption18] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : t_Option'0 = Any.any_l ()
    | & _17 : t_Option'0 = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _24 : t_Option'0 = Any.any_l ()
    | & _31 : bool = Any.any_l ()
    | & _33 : t_Option'0 = Any.any_l ()
    | & _35 : t_Option'0 = Any.any_l ()
    | & _40 : bool = Any.any_l ()
    | & _42 : t_Option'0 = Any.any_l ()
    | & _49 : bool = Any.any_l ()
    | & _51 : t_Option'0 = Any.any_l ()
    | & _53 : t_Option'0 = Any.any_l ()
    | & _58 : bool = Any.any_l ()
    | & _60 : t_Option'0 = Any.any_l ()
    | & _67 : bool = Any.any_l ()
    | & _69 : t_Option'0 = Any.any_l ()
    | & _71 : t_Option'0 = Any.any_l ()
    | & _76 : bool = Any.any_l ()
    | & _78 : t_Option'0 = Any.any_l ()
    | & _85 : bool = Any.any_l ()
    | & _87 : t_Option'0 = Any.any_l ()
    | & _89 : t_Option'0 = Any.any_l ()
    | & _94 : bool = Any.any_l ()
    | & _96 : t_Option'0 = Any.any_l ()
    | & _103 : bool = Any.any_l ()
    | & _105 : t_Option'0 = Any.any_l ()
    | & _107 : t_Option'0 = Any.any_l ()
    | & _111 : t_Option'0 = Any.any_l ()
    | & _112 : t_Option'0 = Any.any_l ()
    | & _113 : t_Option'0 = Any.any_l ()
    | & _114 : t_Option'0 = Any.any_l ()
    | & _115 : t_Option'0 = Any.any_l ()
    | & _116 : t_Option'0 = Any.any_l ()
    | & _117 : t_Option'0 = Any.any_l ()
    | & _118 : t_Option'0 = Any.any_l ()
    | & _119 : t_Option'0 = Any.any_l ()
    | & _120 : t_Option'0 = Any.any_l ()
    | & _121 : t_Option'0 = Any.any_l ()
    | & _122 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__and_then [#"option.rs" 129 0 129 17]
  let%span soption0 = "option.rs" 131 34 131 35
  let%span soption1 = "option.rs" 132 34 132 35
  let%span soption2 = "option.rs" 143 4 143 41
  let%span soption3 = "option.rs" 142 4 142 47
  let%span soption4 = "option.rs" 134 4 134 67
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 296 27 299 17
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 300 26 303 17
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption8 = "option.rs" 140 16 140 17
  let%span soption9 = "option.rs" 140 29 140 30
  let%span soption10 = "option.rs" 136 8 137 38
  let%span soption11 = "option.rs" 142 41 142 45
  let%span soption12 = "option.rs" 134 26 134 44
  let%span smodel13 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum15 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 134 26 134 44] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:t_Option'0))= bb0
    [ bb0 = {false} any ]
     [ return' (result:t_Option'0)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : Int32.t) =
    [%#soption12] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : Int32.t) (result : t_Option'0) =
    [%#soption12] let _2 = args in closure0'0'post'return' self _2 result
  
  let rec and_then'1 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:and_then requires] [%#soption5] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption6] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  
  let rec promoted2__and_then'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum15] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption14] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel13] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption7] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 135 15 138 6] (_1:()) (x:Int32.t) (return'  (ret:t_Option'0))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- x = ([%#soption8] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ]  ]
    
    | bb1 = s0
      [ s0 = Int32.add {x} {[%#soption9] (1 : Int32.t)} (fun (_ret':Int32.t) ->  [ &_6 <- _ret' ] s1)
      | s1 =  [ &res <- C_Some'0 _6 ] s2
      | s2 = bb3 ]
    
    | bb2 = s0 [ s0 =  [ &res <- C_None'0 ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &_0 <- res ] s1 | s1 = return' {_0} ]  ]
    )
    [ & _0 : t_Option'0 = Any.any_l ()
    | & x : Int32.t = x
    | & res : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : Int32.t = Any.any_l () ]
    
    [ return' (result:t_Option'0)-> {[@expl:closure ensures] [%#soption10] Int32.to_int x = 1
      /\ (exists y : Int32.t . result = C_Some'0 y /\ Int32.to_int y = Int32.to_int x + 1)
      \/ Int32.to_int x <> 1 /\ result = C_None'0}
      (! return' {result}) ]
  
  
  predicate precondition'1 (self : ()) (args : Int32.t) =
    let x = args in true
  
  predicate postcondition_once'1 (self : ()) (args : Int32.t) (result : t_Option'0) =
    [%#soption10] let x = args in Int32.to_int x = 1
    /\ (exists y : Int32.t . result = C_Some'0 y /\ Int32.to_int y = Int32.to_int x + 1)
    \/ Int32.to_int x <> 1 /\ result = C_None'0
  
  let rec and_then'2 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:and_then requires] [%#soption5] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'1 f t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption6] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> postcondition_once'1 f t result
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__and_then'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption11] (2 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted0__and_then'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec and_then'0[#"option.rs" 129 0 129 17] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some1 <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &some2 <- C_Some'0 ([%#soption1] (3 : Int32.t)) ] s3
      | s3 =  [ &_9 <- () ] s4
      | s4 = and_then'1 {none} {_9} (fun (_ret':t_Option'0) ->  [ &_7 <- _ret' ] s5)
      | s5 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted2__and_then'0 (fun (pr2:t_Option'0) ->  [ &_34 <- pr2 ] s1)
      | s1 = eq'0 {_7} {_34} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &clos <- () ] s1
      | s1 = and_then'2 {some1} {clos} (fun (_ret':t_Option'0) ->  [ &_17 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted1__and_then'0 (fun (pr1:t_Option'0) ->  [ &_33 <- pr1 ] s1)
      | s1 = eq'0 {_17} {_33} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb7) ] 
    | bb7 = s0 [ s0 = and_then'2 {some2} {clos} (fun (_ret':t_Option'0) ->  [ &_26 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = promoted0__and_then'0 (fun (pr0:t_Option'0) ->  [ &_32 <- pr0 ] s1)
      | s1 = eq'0 {_26} {_32} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_24 = false} (! bb12) | br1 -> {_24} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption2] false} any
    | bb8 = {[%#soption3] false} any
    | bb4 = {[%#soption4] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some1 : t_Option'0 = Any.any_l ()
    | & some2 : t_Option'0 = Any.any_l ()
    | & _5 : bool = Any.any_l ()
    | & _7 : t_Option'0 = Any.any_l ()
    | & _9 : () = Any.any_l ()
    | & clos : () = Any.any_l ()
    | & _15 : bool = Any.any_l ()
    | & _17 : t_Option'0 = Any.any_l ()
    | & _24 : bool = Any.any_l ()
    | & _26 : t_Option'0 = Any.any_l ()
    | & _32 : t_Option'0 = Any.any_l ()
    | & _33 : t_Option'0 = Any.any_l ()
    | & _34 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__filter [#"option.rs" 146 0 146 15]
  let%span soption0 = "option.rs" 148 33 148 34
  let%span soption1 = "option.rs" 152 4 152 45
  let%span soption2 = "option.rs" 151 4 151 51
  let%span soption3 = "option.rs" 150 4 150 46
  let%span soption4 = "../../creusot-contracts/src/std/option.rs" 313 27 316 17
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 317 26 323 17
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption7 = "option.rs" 151 34 151 35
  let%span soption8 = "option.rs" 151 45 151 49
  let%span soption9 = "option.rs" 152 34 152 35
  let%span soption10 = "option.rs" 150 24 150 27
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption12 = "option.rs" 151 24 151 27
  let%span soption13 = "option.rs" 152 24 152 27
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum15 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 150 24 150 27] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = {false} any ]
     [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : Int32.t) =
    [%#soption10] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : Int32.t) (result : bool) =
    [%#soption10] let _2 = args in closure0'0'post'return' self _2 result
  
  predicate resolve'0 (_1 : Int32.t) =
    true
  
  let rec filter'1 (self:t_Option'0) (predicate':()) (return'  (ret:t_Option'0))= {[@expl:filter requires] [%#soption4] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 predicate' t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption5] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> match result with
          | C_None'0 -> postcondition_once'0 predicate' t false /\ resolve'0 t
          | C_Some'0 r -> postcondition_once'0 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  
  let rec promoted2__filter'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum15] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption14] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel11] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption6] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 151 24 151 27] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- x = ([%#soption7] (1 : Int32.t)) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () | & x : Int32.t = x ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : Int32.t) =
    [%#soption12] let x = args in closure1'0'pre self x
  
  predicate postcondition_once'1 (self : ()) (args : Int32.t) (result : bool) =
    [%#soption12] let x = args in closure1'0'post'return' self x result
  
  let rec filter'2 (self:t_Option'0) (predicate':()) (return'  (ret:t_Option'0))= {[@expl:filter requires] [%#soption4] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'1 predicate' t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption5] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> match result with
          | C_None'0 -> postcondition_once'1 predicate' t false /\ resolve'0 t
          | C_Some'0 r -> postcondition_once'1 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__filter'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption8] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec closure2'0[#"option.rs" 152 24 152 27] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- x = ([%#soption9] (2 : Int32.t)) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () | & x : Int32.t = x ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'2 (self : ()) (args : Int32.t) =
    [%#soption13] let x = args in closure2'0'pre self x
  
  predicate postcondition_once'2 (self : ()) (args : Int32.t) (result : bool) =
    [%#soption13] let x = args in closure2'0'post'return' self x result
  
  let rec filter'3 (self:t_Option'0) (predicate':()) (return'  (ret:t_Option'0))= {[@expl:filter requires] [%#soption4] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'2 predicate' t
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption5] match self with
        | C_None'0 -> result = C_None'0
        | C_Some'0 t -> match result with
          | C_None'0 -> postcondition_once'2 predicate' t false /\ resolve'0 t
          | C_Some'0 r -> postcondition_once'2 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  
  let rec promoted0__filter'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec filter'0[#"option.rs" 146 0 146 15] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &_8 <- () ] s3
      | s3 = filter'1 {none} {_8} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted2__filter'0 (fun (pr2:t_Option'0) ->  [ &_32 <- pr2 ] s1)
      | s1 = eq'0 {_6} {_32} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- () ] s1
      | s1 = filter'2 {some} {_17} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted1__filter'0 (fun (pr1:t_Option'0) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'0 {_15} {_31} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_26 <- () ] s1
      | s1 = filter'3 {some} {_26} (fun (_ret':t_Option'0) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0
      [ s0 = promoted0__filter'0 (fun (pr0:t_Option'0) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'0 {_24} {_30} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption1] false} any
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : t_Option'0 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _24 : t_Option'0 = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _31 : t_Option'0 = Any.any_l ()
    | & _32 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__is_some_and [#"option.rs" 155 0 155 20]
  let%span soption0 = "option.rs" 157 34 157 35
  let%span soption1 = "option.rs" 158 34 158 35
  let%span soption2 = "option.rs" 161 4 161 43
  let%span soption3 = "option.rs" 162 4 162 40
  let%span soption4 = "option.rs" 160 4 160 42
  let%span soption5 = "option.rs" 160 39 160 40
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 49 27 52 17
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 53 26 56 17
  let%span soption8 = "option.rs" 161 40 161 41
  let%span soption9 = "option.rs" 162 34 162 38
  let%span soption10 = "option.rs" 160 30 160 33
  let%span soption11 = "option.rs" 161 31 161 34
  let%span soption12 = "option.rs" 162 30 162 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 160 30 160 33] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- x = ([%#soption5] (1 : Int32.t)) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () | & x : Int32.t = x ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : Int32.t) =
    [%#soption10] let x = args in closure0'0'pre self x
  
  predicate postcondition_once'0 (self : ()) (args : Int32.t) (result : bool) =
    [%#soption10] let x = args in closure0'0'post'return' self x result
  
  let rec is_some_and'1 (self:t_Option'0) (f:()) (return'  (ret:bool))= {[@expl:is_some_and requires] [%#soption6] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    any
    [ return' (result:bool)-> {[%#soption7] match self with
        | C_None'0 -> result = false
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 161 31 161 34] [@coma:extspec] (_1:()) (x:Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- x = ([%#soption8] (1 : Int32.t)) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () | & x : Int32.t = x ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : Int32.t) =
    [%#soption11] let x = args in closure1'0'pre self x
  
  predicate postcondition_once'1 (self : ()) (args : Int32.t) (result : bool) =
    [%#soption11] let x = args in closure1'0'post'return' self x result
  
  let rec is_some_and'2 (self:t_Option'0) (f:()) (return'  (ret:bool))= {[@expl:is_some_and requires] [%#soption6] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'1 f t
      end}
    any
    [ return' (result:bool)-> {[%#soption7] match self with
        | C_None'0 -> result = false
        | C_Some'0 t -> postcondition_once'1 f t result
        end}
      (! return' {result}) ]
  
  
  let rec closure2'0[#"option.rs" 162 30 162 33] [@coma:extspec] (_1:()) (_2:Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption9] true ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'2 (self : ()) (args : Int32.t) =
    [%#soption12] let _2 = args in closure2'0'pre self _2
  
  predicate postcondition_once'2 (self : ()) (args : Int32.t) (result : bool) =
    [%#soption12] let _2 = args in closure2'0'post'return' self _2 result
  
  let rec is_some_and'3 (self:t_Option'0) (f:()) (return'  (ret:bool))= {[@expl:is_some_and requires] [%#soption6] match self with
      | C_None'0 -> true
      | C_Some'0 t -> precondition'2 f t
      end}
    any
    [ return' (result:bool)-> {[%#soption7] match self with
        | C_None'0 -> result = false
        | C_Some'0 t -> postcondition_once'2 f t result
        end}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec is_some_and'0[#"option.rs" 155 0 155 20] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some1 <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &some2 <- C_Some'0 ([%#soption1] (2 : Int32.t)) ] s3
      | s3 =  [ &_7 <- () ] s4
      | s4 = is_some_and'1 {some1} {_7} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s5)
      | s5 = bb1 ]
    
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- () ] s1
      | s1 = is_some_and'2 {some2} {_12} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] 
    | bb5 = {[%#soption2] false} any
    | bb6 = s0
      [ s0 =  [ &_17 <- () ] s1
      | s1 = is_some_and'3 {none} {_17} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ] 
    | bb8 = {[%#soption3] false} any
    | bb9 = return' {_0}
    | bb3 = {[%#soption4] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some1 : t_Option'0 = Any.any_l ()
    | & some2 : t_Option'0 = Any.any_l ()
    | & _5 : bool = Any.any_l ()
    | & _7 : () = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _12 : () = Any.any_l ()
    | & _15 : bool = Any.any_l ()
    | & _17 : () = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__or_else [#"option.rs" 165 0 165 16]
  let%span soption0 = "option.rs" 167 33 167 34
  let%span soption1 = "option.rs" 171 4 171 49
  let%span soption2 = "option.rs" 170 4 170 42
  let%span soption3 = "option.rs" 169 4 169 48
  let%span soption4 = "option.rs" 169 33 169 34
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 343 27 343 62
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 344 26 347 17
  let%span soption7 = "option.rs" 169 45 169 46
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption9 = "option.rs" 171 46 171 47
  let%span soption10 = "option.rs" 169 25 169 27
  let%span smodel11 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption12 = "option.rs" 170 25 170 27
  let%span soption13 = "option.rs" 171 25 171 27
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum15 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec closure0'0[#"option.rs" 169 25 169 27] [@coma:extspec] (_1:()) (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- C_Some'0 ([%#soption4] (2 : Int32.t)) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () ]  [ return' (result:t_Option'0)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : ()) =
    [%#soption10] let () = args in closure0'0'pre self
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : t_Option'0) =
    [%#soption10] let () = args in closure0'0'post'return' self result
  
  let rec or_else'1 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:or_else requires] [%#soption5] self
    = C_None'0  -> precondition'0 f ()}
    any
    [ return' (result:t_Option'0)-> {[%#soption6] match self with
        | C_None'0 -> postcondition_once'0 f () result
        | C_Some'0 t -> result = C_Some'0 t
        end}
      (! return' {result}) ]
  
  
  let rec promoted2__or_else'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption7] (2 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum15] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption14] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel11] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption8] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 170 25 170 27] [@coma:extspec] (_1:()) (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- C_None'0 ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () ]  [ return' (result:t_Option'0)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : ()) =
    [%#soption12] let () = args in closure1'0'pre self
  
  predicate postcondition_once'1 (self : ()) (args : ()) (result : t_Option'0) =
    [%#soption12] let () = args in closure1'0'post'return' self result
  
  let rec or_else'2 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:or_else requires] [%#soption5] self
    = C_None'0  -> precondition'1 f ()}
    any
    [ return' (result:t_Option'0)-> {[%#soption6] match self with
        | C_None'0 -> postcondition_once'1 f () result
        | C_Some'0 t -> result = C_Some'0 t
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__or_else'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec closure2'0[#"option.rs" 171 25 171 27] [@coma:extspec] (_1:()) (return'  (ret:t_Option'0))= bb0
    [ bb0 = {false} any ]
     [ return' (result:t_Option'0)-> return' {result} ] 
  
  predicate precondition'2 (self : ()) (args : ()) =
    [%#soption13] let () = args in closure2'0'pre self
  
  predicate postcondition_once'2 (self : ()) (args : ()) (result : t_Option'0) =
    [%#soption13] let () = args in closure2'0'post'return' self result
  
  let rec or_else'3 (self:t_Option'0) (f:()) (return'  (ret:t_Option'0))= {[@expl:or_else requires] [%#soption5] self
    = C_None'0  -> precondition'2 f ()}
    any
    [ return' (result:t_Option'0)-> {[%#soption6] match self with
        | C_None'0 -> postcondition_once'2 f () result
        | C_Some'0 t -> result = C_Some'0 t
        end}
      (! return' {result}) ]
  
  
  let rec promoted0__or_else'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption9] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec or_else'0[#"option.rs" 165 0 165 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &_8 <- () ] s3
      | s3 = or_else'1 {none} {_8} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted2__or_else'0 (fun (pr2:t_Option'0) ->  [ &_32 <- pr2 ] s1)
      | s1 = eq'0 {_6} {_32} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_17 <- () ] s1
      | s1 = or_else'2 {none} {_17} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted1__or_else'0 (fun (pr1:t_Option'0) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'0 {_15} {_31} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_26 <- () ] s1
      | s1 = or_else'3 {some} {_26} (fun (_ret':t_Option'0) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0
      [ s0 = promoted0__or_else'0 (fun (pr0:t_Option'0) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'0 {_24} {_30} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption1] false} any
    | bb8 = {[%#soption2] false} any
    | bb4 = {[%#soption3] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : t_Option'0 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _24 : t_Option'0 = Any.any_l ()
    | & _26 : () = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _31 : t_Option'0 = Any.any_l ()
    | & _32 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__insert [#"option.rs" 174 0 174 15]
  let%span soption0 = "option.rs" 176 37 176 38
  let%span soption1 = "option.rs" 178 25 178 26
  let%span soption2 = "option.rs" 179 19 179 20
  let%span soption3 = "option.rs" 180 10 180 11
  let%span soption4 = "option.rs" 182 25 182 26
  let%span soption5 = "option.rs" 183 19 183 20
  let%span soption6 = "option.rs" 184 10 184 11
  let%span soption7 = "option.rs" 185 4 185 28
  let%span soption8 = "option.rs" 183 4 183 21
  let%span soption9 = "option.rs" 181 4 181 28
  let%span soption10 = "option.rs" 179 4 179 21
  let%span soption11 = "../../creusot-contracts/src/std/option.rs" 372 26 375 17
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 376 26 376 68
  let%span soption13 = "option.rs" 181 25 181 26
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption15 = "option.rs" 185 25 185 26
  let%span sresolve16 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel17 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption18 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum19 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  predicate resolve'1 (_1 : Int32.t) =
    true
  
  let rec insert'1 (self:MutBorrow.t t_Option'0) (value:Int32.t) (return'  (ret:MutBorrow.t Int32.t))= any
    [ return' (result:MutBorrow.t Int32.t)-> {[%#soption11] match self.current with
        | C_Some'0 t -> resolve'1 t
        | C_None'0 -> true
        end}
      {[%#soption12] result.current = value /\ self.final = C_Some'0 (result.final)}
      (! return' {result}) ]
  
  
  predicate resolve'2 (self : MutBorrow.t Int32.t) =
    [%#sresolve16] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t Int32.t) =
    resolve'2 _1
  
  let rec promoted1__insert'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption13] (3 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum19] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption18] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel17] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption14] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec promoted0__insert'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption15] (5 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec insert'0[#"option.rs" 174 0 174 15] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_4 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = insert'1 {_4} {[%#soption1] (2 : Int32.t)} (fun (_ret':MutBorrow.t Int32.t) ->  [ &i1 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_6 <- i1.current = ([%#soption2] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb2) ]  ]
    
    | bb2 = s0
      [ s0 =  [ &i1 <- { i1 with current = ([%#soption3] (3 : Int32.t)) } ] s1
      | s1 = -{resolve'0 i1}- s2
      | s2 = promoted1__insert'0 (fun (pr1:t_Option'0) ->  [ &_28 <- pr1 ] s3)
      | s3 = eq'0 {none} {_28} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s4)
      | s4 = bb4 ]
    
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] 
    | bb5 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_16 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = insert'1 {_16} {[%#soption4] (4 : Int32.t)} (fun (_ret':MutBorrow.t Int32.t) ->  [ &i2 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_18 <- i2.current = ([%#soption5] (4 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 =  [ &i2 <- { i2 with current = ([%#soption6] (5 : Int32.t)) } ] s1
      | s1 = -{resolve'0 i2}- s2
      | s2 = promoted0__insert'0 (fun (pr0:t_Option'0) ->  [ &_27 <- pr0 ] s3)
      | s3 = eq'0 {some} {_27} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s4)
      | s4 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = return' {_0}
    | bb12 = {[%#soption7] false} any
    | bb9 = s0 [ s0 = -{resolve'0 i2}- s1 | s1 = {[%#soption8] false} any ] 
    | bb6 = {[%#soption9] false} any
    | bb3 = s0 [ s0 = -{resolve'0 i1}- s1 | s1 = {[%#soption10] false} any ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & i1 : MutBorrow.t Int32.t = Any.any_l ()
    | & _4 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _6 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & i2 : MutBorrow.t Int32.t = Any.any_l ()
    | & _16 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _18 : bool = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _27 : t_Option'0 = Any.any_l ()
    | & _28 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__get_or_insert [#"option.rs" 188 0 188 22]
  let%span soption0 = "option.rs" 190 37 190 38
  let%span soption1 = "option.rs" 193 32 193 33
  let%span soption2 = "option.rs" 194 19 194 20
  let%span soption3 = "option.rs" 195 10 195 11
  let%span soption4 = "option.rs" 197 32 197 33
  let%span soption5 = "option.rs" 198 19 198 20
  let%span soption6 = "option.rs" 199 10 199 11
  let%span soption7 = "option.rs" 203 16 203 17
  let%span soption8 = "option.rs" 207 19 207 20
  let%span soption9 = "option.rs" 208 10 208 11
  let%span soption10 = "option.rs" 211 19 211 20
  let%span soption11 = "option.rs" 212 10 212 11
  let%span soption12 = "option.rs" 213 4 213 28
  let%span soption13 = "option.rs" 211 4 211 21
  let%span soption14 = "option.rs" 209 4 209 28
  let%span soption15 = "option.rs" 207 4 207 21
  let%span soption16 = "option.rs" 200 4 200 28
  let%span soption17 = "option.rs" 198 4 198 21
  let%span soption18 = "option.rs" 196 4 196 28
  let%span soption19 = "option.rs" 194 4 194 21
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 386 26 389 17
  let%span soption21 = "option.rs" 196 25 196 26
  let%span soption22 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption23 = "option.rs" 200 25 200 26
  let%span soption24 = "option.rs" 206 40 206 41
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 401 27 401 63
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 402 26 405 17
  let%span soption27 = "option.rs" 209 25 209 26
  let%span soption28 = "option.rs" 213 25 213 26
  let%span sresolve29 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel30 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption31 = "option.rs" 206 37 206 39
  let%span soption32 = "option.rs" 210 37 210 39
  let%span soption33 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum34 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  predicate resolve'1 (_1 : Int32.t) =
    true
  
  let rec get_or_insert'1 (self:MutBorrow.t t_Option'0) (value:Int32.t) (return'  (ret:MutBorrow.t Int32.t))= any
    [ return' (result:MutBorrow.t Int32.t)-> {[%#soption20] match self.current with
        | C_None'0 -> result.current = value /\ self.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self.current = C_Some'0 (result.current)
        /\ self.final = C_Some'0 (result.final) /\ resolve'1 value
        end}
      (! return' {result}) ]
  
  
  predicate resolve'2 (self : MutBorrow.t Int32.t) =
    [%#sresolve29] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t Int32.t) =
    resolve'2 _1
  
  let rec promoted3__get_or_insert'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption21] (3 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum34] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption33] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel30] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption22] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec promoted2__get_or_insert'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption23] (5 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec closure0'0[#"option.rs" 206 37 206 39] [@coma:extspec] (_1:()) (return'  (ret:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption24] (2 : Int32.t) ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : Int32.t = Any.any_l () ]  [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : ()) =
    [%#soption31] let () = args in closure0'0'pre self
  
  predicate postcondition_once'0 (self : ()) (args : ()) (result : Int32.t) =
    [%#soption31] let () = args in closure0'0'post'return' self result
  
  let rec get_or_insert_with'0 (self:MutBorrow.t t_Option'0) (f:()) (return'  (ret:MutBorrow.t Int32.t))= {[@expl:get_or_insert_with requires] [%#soption25] self.current
    = C_None'0  -> precondition'0 f ()}
    any
    [ return' (result:MutBorrow.t Int32.t)-> {[%#soption26] match self.current with
        | C_None'0 -> postcondition_once'0 f () result.current /\ self.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self.current = C_Some'0 (result.current) /\ self.final = C_Some'0 (result.final)
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__get_or_insert'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption27] (3 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec closure1'0[#"option.rs" 210 37 210 39] [@coma:extspec] (_1:()) (return'  (ret:Int32.t))= bb0
    [ bb0 = {false} any ]
     [ return' (result:Int32.t)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : ()) =
    [%#soption32] let () = args in closure1'0'pre self
  
  predicate postcondition_once'1 (self : ()) (args : ()) (result : Int32.t) =
    [%#soption32] let () = args in closure1'0'post'return' self result
  
  let rec get_or_insert_with'1 (self:MutBorrow.t t_Option'0) (f:()) (return'  (ret:MutBorrow.t Int32.t))= {[@expl:get_or_insert_with requires] [%#soption25] self.current
    = C_None'0  -> precondition'1 f ()}
    any
    [ return' (result:MutBorrow.t Int32.t)-> {[%#soption26] match self.current with
        | C_None'0 -> postcondition_once'1 f () result.current /\ self.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self.current = C_Some'0 (result.current) /\ self.final = C_Some'0 (result.final)
        end}
      (! return' {result}) ]
  
  
  let rec promoted0__get_or_insert'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption28] (5 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec get_or_insert'0[#"option.rs" 188 0 188 22] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_4 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = get_or_insert'1 {_4} {[%#soption1] (2 : Int32.t)} (fun (_ret':MutBorrow.t Int32.t) ->  [ &i1 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_6 <- i1.current = ([%#soption2] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb2) ]  ]
    
    | bb2 = s0
      [ s0 =  [ &i1 <- { i1 with current = ([%#soption3] (3 : Int32.t)) } ] s1
      | s1 = -{resolve'0 i1}- s2
      | s2 = promoted3__get_or_insert'0 (fun (pr3:t_Option'0) ->  [ &_58 <- pr3 ] s3)
      | s3 = eq'0 {none} {_58} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s4)
      | s4 = bb4 ]
    
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] 
    | bb5 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_16 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = get_or_insert'1 {_16} {[%#soption4] (4 : Int32.t)}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &i2 <- _ret' ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_18 <- i2.current = ([%#soption5] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb8) ]  ]
    
    | bb8 = s0
      [ s0 =  [ &i2 <- { i2 with current = ([%#soption6] (5 : Int32.t)) } ] s1
      | s1 = -{resolve'0 i2}- s2
      | s2 = promoted2__get_or_insert'0 (fun (pr2:t_Option'0) ->  [ &_57 <- pr2 ] s3)
      | s3 = eq'0 {some} {_57} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s4)
      | s4 = bb10 ]
    
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_27 <- C_None'0 ] s1
      | s1 =  [ &none <- _27 ] s2
      | s2 =  [ &_28 <- C_Some'0 ([%#soption7] (1 : Int32.t)) ] s3
      | s3 =  [ &some <- _28 ] s4
      | s4 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_30 <- _ret' ]  [ &none <- _ret'.final ] s5)
      | s5 =  [ &_31 <- () ] s6
      | s6 = get_or_insert_with'0 {_30} {_31} (fun (_ret':MutBorrow.t Int32.t) ->  [ &i11 <- _ret' ] s7)
      | s7 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_33 <- i11.current = ([%#soption8] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_33 = false} (! bb15) | br1 -> {_33} (! bb14) ]  ]
    
    | bb14 = s0
      [ s0 =  [ &i11 <- { i11 with current = ([%#soption9] (3 : Int32.t)) } ] s1
      | s1 = -{resolve'0 i11}- s2
      | s2 = promoted1__get_or_insert'0 (fun (pr1:t_Option'0) ->  [ &_56 <- pr1 ] s3)
      | s3 = eq'0 {none} {_56} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s4)
      | s4 = bb16 ]
    
    | bb16 = any [ br0 -> {_37 = false} (! bb18) | br1 -> {_37} (! bb17) ] 
    | bb17 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_43 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 =  [ &_44 <- () ] s2
      | s2 = get_or_insert_with'1 {_43} {_44} (fun (_ret':MutBorrow.t Int32.t) ->  [ &i21 <- _ret' ] s3)
      | s3 = bb19 ]
    
    | bb19 = s0
      [ s0 =  [ &_46 <- i21.current = ([%#soption10] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_46 = false} (! bb21) | br1 -> {_46} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 =  [ &i21 <- { i21 with current = ([%#soption11] (5 : Int32.t)) } ] s1
      | s1 = -{resolve'0 i21}- s2
      | s2 = promoted0__get_or_insert'0 (fun (pr0:t_Option'0) ->  [ &_55 <- pr0 ] s3)
      | s3 = eq'0 {some} {_55} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s4)
      | s4 = bb22 ]
    
    | bb22 = any [ br0 -> {_50 = false} (! bb24) | br1 -> {_50} (! bb23) ] 
    | bb23 = return' {_0}
    | bb24 = {[%#soption12] false} any
    | bb21 = s0 [ s0 = -{resolve'0 i21}- s1 | s1 = {[%#soption13] false} any ] 
    | bb18 = {[%#soption14] false} any
    | bb15 = s0 [ s0 = -{resolve'0 i11}- s1 | s1 = {[%#soption15] false} any ] 
    | bb12 = {[%#soption16] false} any
    | bb9 = s0 [ s0 = -{resolve'0 i2}- s1 | s1 = {[%#soption17] false} any ] 
    | bb6 = {[%#soption18] false} any
    | bb3 = s0 [ s0 = -{resolve'0 i1}- s1 | s1 = {[%#soption19] false} any ]  ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & i1 : MutBorrow.t Int32.t = Any.any_l ()
    | & _4 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _6 : bool = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & i2 : MutBorrow.t Int32.t = Any.any_l ()
    | & _16 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _18 : bool = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _27 : t_Option'0 = Any.any_l ()
    | & _28 : t_Option'0 = Any.any_l ()
    | & i11 : MutBorrow.t Int32.t = Any.any_l ()
    | & _30 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _31 : () = Any.any_l ()
    | & _33 : bool = Any.any_l ()
    | & _37 : bool = Any.any_l ()
    | & i21 : MutBorrow.t Int32.t = Any.any_l ()
    | & _43 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _44 : () = Any.any_l ()
    | & _46 : bool = Any.any_l ()
    | & _50 : bool = Any.any_l ()
    | & _55 : t_Option'0 = Any.any_l ()
    | & _56 : t_Option'0 = Any.any_l ()
    | & _57 : t_Option'0 = Any.any_l ()
    | & _58 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__take [#"option.rs" 216 0 216 13]
  let%span soption0 = "option.rs" 218 37 218 38
  let%span soption1 = "option.rs" 222 36 222 37
  let%span soption2 = "option.rs" 223 4 223 27
  let%span soption3 = "option.rs" 222 4 222 38
  let%span soption4 = "option.rs" 221 4 221 27
  let%span soption5 = "option.rs" 220 4 220 34
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 416 26 416 58
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption9 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  let rec take'1 (self:MutBorrow.t t_Option'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption6] result = self.current /\ self.final = C_None'0} (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption7] result = (self = C_None'0)} (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption8] self <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption9] C_Some'0 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec take'0[#"option.rs" 216 0 216 13] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 = take'1 {_7} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s4)
      | s4 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0 [ s0 = is_none'0 {none} (fun (_ret':bool) ->  [ &_10 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ] 
    | bb6 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_17 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = take'1 {_17} (fun (_ret':t_Option'0) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0 [ s0 = unwrap'0 {_16} (fun (_ret':Int32.t) ->  [ &_15 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 =  [ &_14 <- _15 = ([%#soption1] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb11) | br1 -> {_14} (! bb10) ]  ]
    
    | bb10 = s0 [ s0 = is_none'0 {some} (fun (_ret':bool) ->  [ &_20 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = any [ br0 -> {_20 = false} (! bb14) | br1 -> {_20} (! bb13) ] 
    | bb13 = return' {_0}
    | bb14 = {[%#soption2] false} any
    | bb11 = {[%#soption3] false} any
    | bb7 = {[%#soption4] false} any
    | bb4 = {[%#soption5] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _7 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & _14 : bool = Any.any_l ()
    | & _15 : Int32.t = Any.any_l ()
    | & _16 : t_Option'0 = Any.any_l ()
    | & _17 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _20 : bool = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__take_if [#"option.rs" 226 0 226 16]
  let%span soption0 = "option.rs" 228 37 228 38
  let%span soption1 = "option.rs" 240 4 240 25
  let%span soption2 = "option.rs" 233 4 239 5
  let%span soption3 = "option.rs" 232 4 232 28
  let%span soption4 = "option.rs" 231 4 231 46
  let%span soption5 = "option.rs" 230 4 230 47
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 421 27 424 17
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 425 26 434 17
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption9 = "option.rs" 231 35 231 36
  let%span soption10 = "option.rs" 232 25 232 26
  let%span soption11 = "option.rs" 235 28 235 29
  let%span soption12 = "option.rs" 236 17 236 18
  let%span soption13 = "option.rs" 238 19 238 20
  let%span soption14 = "option.rs" 230 25 230 28
  let%span smodel15 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption16 = "option.rs" 231 25 231 28
  let%span soption17 = "option.rs" 234 21 234 24
  let%span sresolve18 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span soption19 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum20 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  predicate resolve'1 (self : MutBorrow.t Int32.t) =
    [%#sresolve18] self.final = self.current
  
  predicate resolve'0 (_1 : MutBorrow.t Int32.t) =
    resolve'1 _1
  
  let rec closure0'0[#"option.rs" 230 25 230 28] [@coma:extspec] (_1:()) (_2:MutBorrow.t Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 = -{resolve'0 _2}- s1 | s1 = {false} any ]  ]
     [ & _2 : MutBorrow.t Int32.t = _2 ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate inv'0 (_1 : MutBorrow.t Int32.t)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t Int32.t [inv'0 x] . inv'0 x = true
  
  predicate precondition'0 (self : ()) (args : MutBorrow.t Int32.t) =
    [%#soption14] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : MutBorrow.t Int32.t) (result : bool) =
    [%#soption14] let _2 = args in closure0'0'post'return' self _2 result
  
  let rec take_if'1 (self:MutBorrow.t t_Option'0) (predicate':()) (return'  (ret:t_Option'0))= {[@expl:take_if requires] [%#soption6] match self.current with
      | C_None'0 -> true
      | C_Some'0 t -> forall b : MutBorrow.t Int32.t . inv'0 b /\ b.current = t  -> precondition'0 predicate' b
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption7] match self.current with
        | C_None'0 -> result = C_None'0 /\ self.final = C_None'0
        | C_Some'0 cur -> exists b : MutBorrow.t Int32.t, res : bool . inv'0 b
        /\ cur = b.current
        /\ postcondition_once'0 predicate' b res
        /\ (if res then
          self.final = C_None'0 /\ result = C_Some'0 (b.final)
        else
          self.final = C_Some'0 (b.final) /\ result = C_None'0
        )
        end}
      (! return' {result}) ]
  
  
  let rec promoted4__take_if'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum20] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'1 =
    [%#soption19] match self with
      | C_Some'0 t -> C_Some'1 (deep_model'2 t)
      | C_None'0 -> C_None'1
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'1 =
    [%#smodel15] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption8] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec closure1'0[#"option.rs" 231 25 231 28] [@coma:extspec] (_1:()) (x:MutBorrow.t Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 x}- s1 | s1 =  [ &_0 <- x.current = ([%#soption9] (2 : Int32.t)) ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : bool = Any.any_l () | & x : MutBorrow.t Int32.t = x ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : MutBorrow.t Int32.t) =
    [%#soption16] let x = args in closure1'0'pre self x
  
  predicate postcondition_once'1 (self : ()) (args : MutBorrow.t Int32.t) (result : bool) =
    [%#soption16] let x = args in closure1'0'post'return' self x result
  
  let rec take_if'2 (self:MutBorrow.t t_Option'0) (predicate':()) (return'  (ret:t_Option'0))= {[@expl:take_if requires] [%#soption6] match self.current with
      | C_None'0 -> true
      | C_Some'0 t -> forall b : MutBorrow.t Int32.t . inv'0 b /\ b.current = t  -> precondition'1 predicate' b
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption7] match self.current with
        | C_None'0 -> result = C_None'0 /\ self.final = C_None'0
        | C_Some'0 cur -> exists b : MutBorrow.t Int32.t, res : bool . inv'0 b
        /\ cur = b.current
        /\ postcondition_once'1 predicate' b res
        /\ (if res then
          self.final = C_None'0 /\ result = C_Some'0 (b.final)
        else
          self.final = C_Some'0 (b.final) /\ result = C_None'0
        )
        end}
      (! return' {result}) ]
  
  
  let rec promoted3__take_if'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted2__take_if'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption10] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec closure2'0[#"option.rs" 234 21 234 24] [@coma:extspec] (_1:()) (x:MutBorrow.t Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0
      [ s0 =  [ &res <- x.current = ([%#soption11] (1 : Int32.t)) ] s1
      | s1 =  [ &x <- { x with current = ([%#soption12] (3 : Int32.t)) } ] s2
      | s2 = -{resolve'0 x}- s3
      | s3 =  [ &_0 <- res ] s4
      | s4 = return' {_0} ]
     ]
     [ & _0 : bool = Any.any_l () | & x : MutBorrow.t Int32.t = x | & res : bool = Any.any_l () ] 
    [ return' (result:bool)-> return' {result} ]
  
  
  predicate precondition'2 (self : ()) (args : MutBorrow.t Int32.t) =
    [%#soption17] let x = args in closure2'0'pre self x
  
  predicate postcondition_once'2 (self : ()) (args : MutBorrow.t Int32.t) (result : bool) =
    [%#soption17] let x = args in closure2'0'post'return' self x result
  
  let rec take_if'3 (self:MutBorrow.t t_Option'0) (predicate':()) (return'  (ret:t_Option'0))= {[@expl:take_if requires] [%#soption6] match self.current with
      | C_None'0 -> true
      | C_Some'0 t -> forall b : MutBorrow.t Int32.t . inv'0 b /\ b.current = t  -> precondition'2 predicate' b
      end}
    any
    [ return' (result:t_Option'0)-> {[%#soption7] match self.current with
        | C_None'0 -> result = C_None'0 /\ self.final = C_None'0
        | C_Some'0 cur -> exists b : MutBorrow.t Int32.t, res : bool . inv'0 b
        /\ cur = b.current
        /\ postcondition_once'2 predicate' b res
        /\ (if res then
          self.final = C_None'0 /\ result = C_Some'0 (b.final)
        else
          self.final = C_Some'0 (b.final) /\ result = C_None'0
        )
        end}
      (! return' {result}) ]
  
  
  let rec promoted1__take_if'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption13] (3 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted0__take_if'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec take_if'0[#"option.rs" 226 0 226 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option'0> {none}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_7 <- _ret' ]  [ &none <- _ret'.final ] s3)
      | s3 =  [ &_8 <- () ] s4
      | s4 = take_if'1 {_7} {_8} (fun (_ret':t_Option'0) ->  [ &_6 <- _ret' ] s5)
      | s5 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted4__take_if'0 (fun (pr4:t_Option'0) ->  [ &_46 <- pr4 ] s1)
      | s1 = eq'0 {_6} {_46} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_16 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 =  [ &_17 <- () ] s2
      | s2 = take_if'2 {_16} {_17} (fun (_ret':t_Option'0) ->  [ &_15 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0
      [ s0 = promoted3__take_if'0 (fun (pr3:t_Option'0) ->  [ &_45 <- pr3 ] s1)
      | s1 = eq'0 {_15} {_45} (fun (_ret':bool) ->  [ &_13 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ] 
    | bb7 = s0
      [ s0 = promoted2__take_if'0 (fun (pr2:t_Option'0) ->  [ &_44 <- pr2 ] s1)
      | s1 = eq'0 {some} {_44} (fun (_ret':bool) ->  [ &_22 <- _ret' ] s2)
      | s2 = bb9 ]
    
    | bb9 = any [ br0 -> {_22 = false} (! bb11) | br1 -> {_22} (! bb10) ] 
    | bb10 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'0> {some}
          (fun (_ret':MutBorrow.t t_Option'0) ->  [ &_31 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 =  [ &_32 <- () ] s2
      | s2 = take_if'3 {_31} {_32} (fun (_ret':t_Option'0) ->  [ &_30 <- _ret' ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0
      [ s0 = promoted1__take_if'0 (fun (pr1:t_Option'0) ->  [ &_43 <- pr1 ] s1)
      | s1 = eq'0 {_30} {_43} (fun (_ret':bool) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb13 ]
    
    | bb13 = any [ br0 -> {_28 = false} (! bb15) | br1 -> {_28} (! bb14) ] 
    | bb14 = s0
      [ s0 = promoted0__take_if'0 (fun (pr0:t_Option'0) ->  [ &_42 <- pr0 ] s1)
      | s1 = eq'0 {some} {_42} (fun (_ret':bool) ->  [ &_37 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = any [ br0 -> {_37 = false} (! bb18) | br1 -> {_37} (! bb17) ] 
    | bb17 = return' {_0}
    | bb18 = {[%#soption1] false} any
    | bb15 = {[%#soption2] false} any
    | bb11 = {[%#soption3] false} any
    | bb8 = {[%#soption4] false} any
    | bb4 = {[%#soption5] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'0 = Any.any_l ()
    | & some : t_Option'0 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'0 = Any.any_l ()
    | & _7 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _8 : () = Any.any_l ()
    | & _13 : bool = Any.any_l ()
    | & _15 : t_Option'0 = Any.any_l ()
    | & _16 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _17 : () = Any.any_l ()
    | & _22 : bool = Any.any_l ()
    | & _28 : bool = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _31 : MutBorrow.t t_Option'0 = Any.any_l ()
    | & _32 : () = Any.any_l ()
    | & _37 : bool = Any.any_l ()
    | & _42 : t_Option'0 = Any.any_l ()
    | & _43 : t_Option'0 = Any.any_l ()
    | & _44 : t_Option'0 = Any.any_l ()
    | & _45 : t_Option'0 = Any.any_l ()
    | & _46 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__copied_cloned [#"option.rs" 243 0 243 22]
  let%span soption0 = "option.rs" 245 37 245 38
  let%span soption1 = "option.rs" 249 47 249 48
  let%span soption2 = "option.rs" 251 47 251 48
  let%span soption3 = "option.rs" 254 47 254 48
  let%span soption4 = "option.rs" 256 47 256 48
  let%span soption5 = "option.rs" 256 4 256 49
  let%span soption6 = "option.rs" 255 4 255 45
  let%span soption7 = "option.rs" 254 4 254 49
  let%span soption8 = "option.rs" 253 4 253 45
  let%span soption9 = "option.rs" 251 4 251 49
  let%span soption10 = "option.rs" 250 4 250 45
  let%span soption11 = "option.rs" 249 4 249 49
  let%span soption12 = "option.rs" 248 4 248 45
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 74 26 74 58
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 76 20 76 89
  let%span soption15 = "../../creusot-contracts/src/std/option.rs" 480 26 480 57
  let%span soption16 = "../../creusot-contracts/src/std/option.rs" 481 26 481 93
  let%span soption17 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span soption18 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption19 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  let%span soption20 = "../../creusot-contracts/src/std/option.rs" 86 26 86 75
  let%span soption21 = "../../creusot-contracts/src/std/option.rs" 88 20 89 100
  let%span soption22 = "../../creusot-contracts/src/std/option.rs" 505 26 505 57
  let%span soption23 = "../../creusot-contracts/src/std/option.rs" 507 20 508 93
  let%span soption24 = "../../creusot-contracts/src/std/option.rs" 491 26 491 57
  let%span soption25 = "../../creusot-contracts/src/std/option.rs" 492 26 492 93
  let%span soption26 = "../../creusot-contracts/src/std/option.rs" 519 26 519 57
  let%span soption27 = "../../creusot-contracts/src/std/option.rs" 521 20 522 93
  let%span sresolve28 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 Int32.t
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 Int32.t
  
  let rec as_ref'0 (self:t_Option'1) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption13] self = C_None'0  -> result = C_None'1}
      {[%#soption14] self = C_None'0 \/ (exists r : Int32.t . result = C_Some'1 r /\ self = C_Some'0 r)}
      (! return' {result}) ]
  
  
  let rec copied'0 (self:t_Option'0) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption15] self = C_None'1  -> result = C_None'0}
      {[%#soption16] self = C_None'1 \/ (exists t : Int32.t . self = C_Some'1 t /\ result = C_Some'0 t)}
      (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'1) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption17] result = (self = C_None'0)} (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'1) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption18] self <> C_None'0}
    any [ return' (result:Int32.t)-> {[%#soption19] C_Some'0 result = self} (! return' {result}) ] 
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (MutBorrow.t Int32.t)
  
  let rec as_mut'0 (self:MutBorrow.t t_Option'1) (return'  (ret:t_Option'2))= any
    [ return' (result:t_Option'2)-> {[%#soption20] self.current = C_None'0
       -> result = C_None'2 /\ self.final = C_None'0}
      {[%#soption21] self.current = C_None'0
      \/ (exists r : MutBorrow.t Int32.t . result = C_Some'2 r
      /\ self.current = C_Some'0 (r.current) /\ self.final = C_Some'0 (r.final))}
      (! return' {result}) ]
  
  
  predicate resolve'0 (self : MutBorrow.t Int32.t) =
    [%#sresolve28] self.final = self.current
  
  let rec copied'1 (self:t_Option'2) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption22] self = C_None'2  -> result = C_None'0}
      {[%#soption23] self = C_None'2
      \/ (exists t : MutBorrow.t Int32.t . self = C_Some'2 t /\ result = C_Some'0 (t.current) /\ resolve'0 t)}
      (! return' {result}) ]
  
  
  let rec cloned'0 (self:t_Option'0) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption24] self = C_None'1  -> result = C_None'0}
      {[%#soption25] self = C_None'1 \/ (exists t : Int32.t . self = C_Some'1 t /\ result = C_Some'0 t)}
      (! return' {result}) ]
  
  
  let rec cloned'1 (self:t_Option'2) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption26] self = C_None'2  -> result = C_None'0}
      {[%#soption27] self = C_None'2
      \/ (exists t : MutBorrow.t Int32.t . self = C_Some'2 t /\ result = C_Some'0 (t.current) /\ resolve'0 t)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec copied_cloned'0[#"option.rs" 243 0 243 22] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &some <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 = as_ref'0 {none} (fun (_ret':t_Option'0) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = copied'0 {_7} (fun (_ret':t_Option'1) ->  [ &_6 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = is_none'0 {_6} (fun (_ret':bool) ->  [ &_4 <- _ret' ] s1) | s1 = bb3 ] 
    | bb3 = any [ br0 -> {_4 = false} (! bb5) | br1 -> {_4} (! bb4) ] 
    | bb4 = s0 [ s0 = as_ref'0 {some} (fun (_ret':t_Option'0) ->  [ &_14 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = copied'0 {_14} (fun (_ret':t_Option'1) ->  [ &_13 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 = unwrap'0 {_13} (fun (_ret':Int32.t) ->  [ &_12 <- _ret' ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_11 <- _12 = ([%#soption1] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_11 = false} (! bb10) | br1 -> {_11} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'1> {none}
          (fun (_ret':MutBorrow.t t_Option'1) ->  [ &_22 <- _ret' ]  [ &none <- _ret'.final ] s1)
      | s1 = as_mut'0 {_22} (fun (_ret':t_Option'2) ->  [ &_21 <- _ret' ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = copied'1 {_21} (fun (_ret':t_Option'1) ->  [ &_20 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 = is_none'0 {_20} (fun (_ret':bool) ->  [ &_18 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_18 = false} (! bb15) | br1 -> {_18} (! bb14) ] 
    | bb14 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'1> {some}
          (fun (_ret':MutBorrow.t t_Option'1) ->  [ &_29 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'0 {_29} (fun (_ret':t_Option'2) ->  [ &_28 <- _ret' ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = copied'1 {_28} (fun (_ret':t_Option'1) ->  [ &_27 <- _ret' ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 = unwrap'0 {_27} (fun (_ret':Int32.t) ->  [ &_26 <- _ret' ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 =  [ &_25 <- _26 = ([%#soption2] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_25 = false} (! bb20) | br1 -> {_25} (! bb19) ]  ]
    
    | bb19 = s0 [ s0 = as_ref'0 {none} (fun (_ret':t_Option'0) ->  [ &_35 <- _ret' ] s1) | s1 = bb21 ] 
    | bb21 = s0 [ s0 = cloned'0 {_35} (fun (_ret':t_Option'1) ->  [ &_34 <- _ret' ] s1) | s1 = bb22 ] 
    | bb22 = s0 [ s0 = is_none'0 {_34} (fun (_ret':bool) ->  [ &_32 <- _ret' ] s1) | s1 = bb23 ] 
    | bb23 = any [ br0 -> {_32 = false} (! bb25) | br1 -> {_32} (! bb24) ] 
    | bb24 = s0 [ s0 = as_ref'0 {some} (fun (_ret':t_Option'0) ->  [ &_42 <- _ret' ] s1) | s1 = bb26 ] 
    | bb26 = s0 [ s0 = cloned'0 {_42} (fun (_ret':t_Option'1) ->  [ &_41 <- _ret' ] s1) | s1 = bb27 ] 
    | bb27 = s0 [ s0 = unwrap'0 {_41} (fun (_ret':Int32.t) ->  [ &_40 <- _ret' ] s1) | s1 = bb28 ] 
    | bb28 = s0
      [ s0 =  [ &_39 <- _40 = ([%#soption3] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_39 = false} (! bb30) | br1 -> {_39} (! bb29) ]  ]
    
    | bb29 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'1> {none}
          (fun (_ret':MutBorrow.t t_Option'1) ->  [ &_50 <- _ret' ]  [ &none <- _ret'.final ] s1)
      | s1 = as_mut'0 {_50} (fun (_ret':t_Option'2) ->  [ &_49 <- _ret' ] s2)
      | s2 = bb31 ]
    
    | bb31 = s0 [ s0 = cloned'1 {_49} (fun (_ret':t_Option'1) ->  [ &_48 <- _ret' ] s1) | s1 = bb32 ] 
    | bb32 = s0 [ s0 = is_none'0 {_48} (fun (_ret':bool) ->  [ &_46 <- _ret' ] s1) | s1 = bb33 ] 
    | bb33 = any [ br0 -> {_46 = false} (! bb35) | br1 -> {_46} (! bb34) ] 
    | bb34 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option'1> {some}
          (fun (_ret':MutBorrow.t t_Option'1) ->  [ &_57 <- _ret' ]  [ &some <- _ret'.final ] s1)
      | s1 = as_mut'0 {_57} (fun (_ret':t_Option'2) ->  [ &_56 <- _ret' ] s2)
      | s2 = bb36 ]
    
    | bb36 = s0 [ s0 = cloned'1 {_56} (fun (_ret':t_Option'1) ->  [ &_55 <- _ret' ] s1) | s1 = bb37 ] 
    | bb37 = s0 [ s0 = unwrap'0 {_55} (fun (_ret':Int32.t) ->  [ &_54 <- _ret' ] s1) | s1 = bb38 ] 
    | bb38 = s0
      [ s0 =  [ &_53 <- _54 = ([%#soption4] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_53 = false} (! bb40) | br1 -> {_53} (! bb39) ]  ]
    
    | bb39 = return' {_0}
    | bb40 = {[%#soption5] false} any
    | bb35 = {[%#soption6] false} any
    | bb30 = {[%#soption7] false} any
    | bb25 = {[%#soption8] false} any
    | bb20 = {[%#soption9] false} any
    | bb15 = {[%#soption10] false} any
    | bb10 = {[%#soption11] false} any
    | bb5 = {[%#soption12] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'1 = Any.any_l ()
    | & some : t_Option'1 = Any.any_l ()
    | & _4 : bool = Any.any_l ()
    | & _6 : t_Option'1 = Any.any_l ()
    | & _7 : t_Option'0 = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & _12 : Int32.t = Any.any_l ()
    | & _13 : t_Option'1 = Any.any_l ()
    | & _14 : t_Option'0 = Any.any_l ()
    | & _18 : bool = Any.any_l ()
    | & _20 : t_Option'1 = Any.any_l ()
    | & _21 : t_Option'2 = Any.any_l ()
    | & _22 : MutBorrow.t t_Option'1 = Any.any_l ()
    | & _25 : bool = Any.any_l ()
    | & _26 : Int32.t = Any.any_l ()
    | & _27 : t_Option'1 = Any.any_l ()
    | & _28 : t_Option'2 = Any.any_l ()
    | & _29 : MutBorrow.t t_Option'1 = Any.any_l ()
    | & _32 : bool = Any.any_l ()
    | & _34 : t_Option'1 = Any.any_l ()
    | & _35 : t_Option'0 = Any.any_l ()
    | & _39 : bool = Any.any_l ()
    | & _40 : Int32.t = Any.any_l ()
    | & _41 : t_Option'1 = Any.any_l ()
    | & _42 : t_Option'0 = Any.any_l ()
    | & _46 : bool = Any.any_l ()
    | & _48 : t_Option'1 = Any.any_l ()
    | & _49 : t_Option'2 = Any.any_l ()
    | & _50 : MutBorrow.t t_Option'1 = Any.any_l ()
    | & _53 : bool = Any.any_l ()
    | & _54 : Int32.t = Any.any_l ()
    | & _55 : t_Option'1 = Any.any_l ()
    | & _56 : t_Option'2 = Any.any_l ()
    | & _57 : MutBorrow.t t_Option'1 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__zip_unzip [#"option.rs" 259 0 259 18]
  let%span soption0 = "option.rs" 262 37 262 38
  let%span soption1 = "option.rs" 263 39 263 43
  let%span soption2 = "option.rs" 271 49 271 50
  let%span soption3 = "option.rs" 271 52 271 56
  let%span soption4 = "option.rs" 278 4 278 39
  let%span soption5 = "option.rs" 277 4 277 36
  let%span soption6 = "option.rs" 276 4 276 33
  let%span soption7 = "option.rs" 275 4 275 33
  let%span soption8 = "option.rs" 268 4 268 55
  let%span soption9 = "option.rs" 267 4 267 44
  let%span soption10 = "option.rs" 266 4 266 44
  let%span soption11 = "option.rs" 265 4 265 44
  let%span soption12 = "../../creusot-contracts/src/std/option.rs" 451 26 455 17
  let%span soption13 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption14 = "option.rs" 268 45 268 46
  let%span soption15 = "option.rs" 268 48 268 52
  let%span soption16 = "../../creusot-contracts/src/std/option.rs" 466 26 469 17
  let%span soption17 = "option.rs" 277 33 277 34
  let%span soption18 = "option.rs" 278 33 278 37
  let%span sresolve19 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span smodel20 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption21 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span stuples22 = "../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span snum23 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel24 = "../../creusot-contracts/src/model.rs" 82 8 82 12
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 Int32.t
  
  type t_Option'2  =
    | C_None'1
    | C_Some'1 bool
  
  type tuple'0  =
    { _0'0: Int32.t; _1'0: bool }
  
  type t_Option'0  =
    | C_None'2
    | C_Some'2 tuple'0
  
  type tuple'1  =
    { _0'1: t_Option'1; _1'1: t_Option'2 }
  
  predicate resolve'2 (_1 : bool) =
    true
  
  predicate resolve'0 (self : t_Option'2) =
    [%#sresolve19] match self with
      | C_Some'1 x -> resolve'2 x
      | C_None'1 -> true
      end
  
  predicate resolve'3 (_1 : Int32.t) =
    true
  
  predicate resolve'1 (self : t_Option'1) =
    [%#sresolve19] match self with
      | C_Some'0 x -> resolve'3 x
      | C_None'0 -> true
      end
  
  let rec zip'0 (self:t_Option'1) (other:t_Option'2) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption12] match { _0'1 = self; _1'1 = other } with
        | {_0'1 = C_None'0} -> result = C_None'2 /\ resolve'0 other
        | {_1'1 = C_None'1} -> result = C_None'2 /\ resolve'1 self
        | {_0'1 = C_Some'0 t ; _1'1 = C_Some'1 u} -> result = C_Some'2 { _0'0 = t; _1'0 = u }
        end}
      (! return' {result}) ]
  
  
  let rec promoted7__zip_unzip'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'2 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type tuple'2  =
    { _0'2: int; _1'2: bool }
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 tuple'2
  
  function deep_model'7 (self : Int32.t) : int =
    [%#snum23] Int32.to_int self
  
  function deep_model'8 (self : bool) : bool =
    [%#smodel24] self
  
  function deep_model'6 (self : tuple'0) : tuple'2 =
    [%#stuples22] { _0'2 = deep_model'7 self._0'0; _1'2 = deep_model'8 self._1'0 }
  
  function deep_model'3 (self : t_Option'0) : t_Option'3 =
    [%#soption21] match self with
      | C_Some'2 t -> C_Some'3 (deep_model'6 t)
      | C_None'2 -> C_None'3
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'3 =
    [%#smodel20] deep_model'3 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption13] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec promoted6__zip_unzip'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'2 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted5__zip_unzip'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'2 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec promoted4__zip_unzip'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_2 <- { _0'0 = ([%#soption14] (1 : Int32.t)); _1'0 = ([%#soption15] true) } ] s1
      | s1 =  [ &_1 <- C_Some'2 _2 ] s2
      | s2 =  [ &_0 <- _1 ] s3
      | s3 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () | & _2 : tuple'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec unzip'0 (self:t_Option'0) (return'  (ret:tuple'1))= any
    [ return' (result:tuple'1)-> {[%#soption16] match self with
        | C_None'2 -> result = { _0'1 = C_None'0; _1'1 = C_None'1 }
        | C_Some'2 {_0'0 = t ; _1'0 = u} -> result = { _0'1 = C_Some'0 t; _1'1 = C_Some'1 u }
        end}
      (! return' {result}) ]
  
  
  let rec promoted3__zip_unzip'0 (return'  (ret:t_Option'1))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'0 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'1 = Any.any_l () | & _1 : t_Option'1 = Any.any_l () ] 
    [ return' (result:t_Option'1)-> return' {result} ]
  
  
  type t_Option'4  =
    | C_None'4
    | C_Some'4 int
  
  function deep_model'4 (self : t_Option'1) : t_Option'4 =
    [%#soption21] match self with
      | C_Some'0 t -> C_Some'4 (deep_model'7 t)
      | C_None'0 -> C_None'4
      end
  
  function deep_model'1 (self : t_Option'1) : t_Option'4 =
    [%#smodel20] deep_model'4 self
  
  let rec eq'1 (self:t_Option'1) (other:t_Option'1) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption13] result = (deep_model'1 self = deep_model'1 other)} (! return' {result}) ]
  
  
  let rec promoted2__zip_unzip'0 (return'  (ret:t_Option'2))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'1 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'2 = Any.any_l () | & _1 : t_Option'2 = Any.any_l () ] 
    [ return' (result:t_Option'2)-> return' {result} ]
  
  
  function deep_model'5 (self : t_Option'2) : t_Option'2 =
    [%#soption21] match self with
      | C_Some'1 t -> C_Some'1 (deep_model'8 t)
      | C_None'1 -> C_None'1
      end
  
  function deep_model'2 (self : t_Option'2) : t_Option'2 =
    [%#smodel20] deep_model'5 self
  
  let rec eq'2 (self:t_Option'2) (other:t_Option'2) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption13] result = (deep_model'2 self = deep_model'2 other)} (! return' {result}) ]
  
  
  let rec promoted1__zip_unzip'0 (return'  (ret:t_Option'1))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'0 ([%#soption17] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'1 = Any.any_l () | & _1 : t_Option'1 = Any.any_l () ] 
    [ return' (result:t_Option'1)-> return' {result} ]
  
  
  let rec promoted0__zip_unzip'0 (return'  (ret:t_Option'2))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_Some'1 ([%#soption18] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'2 = Any.any_l () | & _1 : t_Option'2 = Any.any_l () ] 
    [ return' (result:t_Option'2)-> return' {result} ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec zip_unzip'0[#"option.rs" 259 0 259 18] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none_int <- C_None'0 ] s1
      | s1 =  [ &none_bool <- C_None'1 ] s2
      | s2 =  [ &some_int <- C_Some'0 ([%#soption0] (1 : Int32.t)) ] s3
      | s3 =  [ &some_bool <- C_Some'1 ([%#soption1] true) ] s4
      | s4 = zip'0 {none_int} {none_bool} (fun (_ret':t_Option'0) ->  [ &_8 <- _ret' ] s5)
      | s5 = bb1 ]
    
    | bb1 = s0
      [ s0 = promoted7__zip_unzip'0 (fun (pr7:t_Option'0) ->  [ &_80 <- pr7 ] s1)
      | s1 = eq'0 {_8} {_80} (fun (_ret':bool) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb2 ]
    
    | bb2 = any [ br0 -> {_6 = false} (! bb4) | br1 -> {_6} (! bb3) ] 
    | bb3 = s0 [ s0 = zip'0 {none_int} {some_bool} (fun (_ret':t_Option'0) ->  [ &_17 <- _ret' ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = promoted6__zip_unzip'0 (fun (pr6:t_Option'0) ->  [ &_79 <- pr6 ] s1)
      | s1 = eq'0 {_17} {_79} (fun (_ret':bool) ->  [ &_15 <- _ret' ] s2)
      | s2 = bb6 ]
    
    | bb6 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb7) ] 
    | bb7 = s0 [ s0 = zip'0 {some_int} {none_bool} (fun (_ret':t_Option'0) ->  [ &_26 <- _ret' ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = promoted5__zip_unzip'0 (fun (pr5:t_Option'0) ->  [ &_78 <- pr5 ] s1)
      | s1 = eq'0 {_26} {_78} (fun (_ret':bool) ->  [ &_24 <- _ret' ] s2)
      | s2 = bb10 ]
    
    | bb10 = any [ br0 -> {_24 = false} (! bb12) | br1 -> {_24} (! bb11) ] 
    | bb11 = s0 [ s0 = zip'0 {some_int} {some_bool} (fun (_ret':t_Option'0) ->  [ &_35 <- _ret' ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 = promoted4__zip_unzip'0 (fun (pr4:t_Option'0) ->  [ &_77 <- pr4 ] s1)
      | s1 = eq'0 {_35} {_77} (fun (_ret':bool) ->  [ &_33 <- _ret' ] s2)
      | s2 = bb14 ]
    
    | bb14 = any [ br0 -> {_33 = false} (! bb16) | br1 -> {_33} (! bb15) ] 
    | bb15 = s0
      [ s0 =  [ &none_zipped <- C_None'2 ] s1
      | s1 =  [ &_44 <- { _0'0 = ([%#soption2] (1 : Int32.t)); _1'0 = ([%#soption3] true) } ] s2
      | s2 =  [ &some_zipped <- C_Some'2 _44 ] s3
      | s3 = unzip'0 {none_zipped} (fun (_ret':tuple'1) ->  [ &none_unzip <- _ret' ] s4)
      | s4 = bb17 ]
    
    | bb17 = s0 [ s0 = unzip'0 {some_zipped} (fun (_ret':tuple'1) ->  [ &some_unzip <- _ret' ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 = promoted3__zip_unzip'0 (fun (pr3:t_Option'1) ->  [ &_76 <- pr3 ] s1)
      | s1 = eq'1 {none_unzip._0'1} {_76} (fun (_ret':bool) ->  [ &_50 <- _ret' ] s2)
      | s2 = bb19 ]
    
    | bb19 = any [ br0 -> {_50 = false} (! bb21) | br1 -> {_50} (! bb20) ] 
    | bb20 = s0
      [ s0 = promoted2__zip_unzip'0 (fun (pr2:t_Option'2) ->  [ &_75 <- pr2 ] s1)
      | s1 = eq'2 {none_unzip._1'1} {_75} (fun (_ret':bool) ->  [ &_56 <- _ret' ] s2)
      | s2 = bb22 ]
    
    | bb22 = any [ br0 -> {_56 = false} (! bb24) | br1 -> {_56} (! bb23) ] 
    | bb23 = s0
      [ s0 = promoted1__zip_unzip'0 (fun (pr1:t_Option'1) ->  [ &_74 <- pr1 ] s1)
      | s1 = eq'1 {some_unzip._0'1} {_74} (fun (_ret':bool) ->  [ &_62 <- _ret' ] s2)
      | s2 = bb25 ]
    
    | bb25 = any [ br0 -> {_62 = false} (! bb27) | br1 -> {_62} (! bb26) ] 
    | bb26 = s0
      [ s0 = promoted0__zip_unzip'0 (fun (pr0:t_Option'2) ->  [ &_73 <- pr0 ] s1)
      | s1 = eq'2 {some_unzip._1'1} {_73} (fun (_ret':bool) ->  [ &_68 <- _ret' ] s2)
      | s2 = bb28 ]
    
    | bb28 = any [ br0 -> {_68 = false} (! bb30) | br1 -> {_68} (! bb29) ] 
    | bb29 = return' {_0}
    | bb30 = {[%#soption4] false} any
    | bb27 = {[%#soption5] false} any
    | bb24 = {[%#soption6] false} any
    | bb21 = {[%#soption7] false} any
    | bb16 = {[%#soption8] false} any
    | bb12 = {[%#soption9] false} any
    | bb8 = {[%#soption10] false} any
    | bb4 = {[%#soption11] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none_int : t_Option'1 = Any.any_l ()
    | & none_bool : t_Option'2 = Any.any_l ()
    | & some_int : t_Option'1 = Any.any_l ()
    | & some_bool : t_Option'2 = Any.any_l ()
    | & _6 : bool = Any.any_l ()
    | & _8 : t_Option'0 = Any.any_l ()
    | & _15 : bool = Any.any_l ()
    | & _17 : t_Option'0 = Any.any_l ()
    | & _24 : bool = Any.any_l ()
    | & _26 : t_Option'0 = Any.any_l ()
    | & _33 : bool = Any.any_l ()
    | & _35 : t_Option'0 = Any.any_l ()
    | & none_zipped : t_Option'0 = Any.any_l ()
    | & some_zipped : t_Option'0 = Any.any_l ()
    | & _44 : tuple'0 = Any.any_l ()
    | & none_unzip : tuple'1 = Any.any_l ()
    | & some_unzip : tuple'1 = Any.any_l ()
    | & _50 : bool = Any.any_l ()
    | & _56 : bool = Any.any_l ()
    | & _62 : bool = Any.any_l ()
    | & _68 : bool = Any.any_l ()
    | & _73 : t_Option'2 = Any.any_l ()
    | & _74 : t_Option'1 = Any.any_l ()
    | & _75 : t_Option'2 = Any.any_l ()
    | & _76 : t_Option'1 = Any.any_l ()
    | & _77 : t_Option'0 = Any.any_l ()
    | & _78 : t_Option'0 = Any.any_l ()
    | & _79 : t_Option'0 = Any.any_l ()
    | & _80 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__transpose [#"option.rs" 281 0 281 18]
  let%span soption0 = "option.rs" 283 53 283 54
  let%span soption1 = "option.rs" 284 55 284 59
  let%span soption2 = "option.rs" 288 49 288 53
  let%span soption3 = "option.rs" 288 4 288 54
  let%span soption4 = "option.rs" 287 4 287 52
  let%span soption5 = "option.rs" 286 4 286 46
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 536 26 540 17
  let%span sresult7 = "../../creusot-contracts/src/std/result.rs" 53 27 53 53
  let%span sresult8 = "../../creusot-contracts/src/std/result.rs" 54 26 54 44
  let%span soption9 = "../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption10 = "option.rs" 287 49 287 50
  let%span sresult11 = "../../creusot-contracts/src/std/result.rs" 67 27 67 54
  let%span sresult12 = "../../creusot-contracts/src/std/result.rs" 68 26 68 45
  let%span smodel13 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span soption14 = "../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span snum15 = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Result'1  =
    | C_Ok'0 Int32.t
    | C_Err'0 bool
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_Result'1
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 Int32.t
  
  type t_Result'0  =
    | C_Ok'1 t_Option'0
    | C_Err'1 bool
  
  let rec transpose'1 (self:t_Option'1) (return'  (ret:t_Result'0))= any
    [ return' (result:t_Result'0)-> {[%#soption6] match self with
        | C_None'0 -> result = C_Ok'1 (C_None'1)
        | C_Some'0 (C_Ok'0 ok) -> result = C_Ok'1 (C_Some'1 ok)
        | C_Some'0 (C_Err'0 err) -> result = C_Err'1 err
        end}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Result'0) (return'  (ret:t_Option'0))= {[@expl:unwrap requires] [%#sresult7] exists t : t_Option'0 . self
    = C_Ok'1 t}
    any [ return' (result:t_Option'0)-> {[%#sresult8] C_Ok'1 result = self} (! return' {result}) ] 
  
  let rec promoted1__transpose'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_None'1 ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 int
  
  function deep_model'2 (self : Int32.t) : int =
    [%#snum15] Int32.to_int self
  
  function deep_model'1 (self : t_Option'0) : t_Option'2 =
    [%#soption14] match self with
      | C_Some'1 t -> C_Some'2 (deep_model'2 t)
      | C_None'1 -> C_None'2
      end
  
  function deep_model'0 (self : t_Option'0) : t_Option'2 =
    [%#smodel13] deep_model'1 self
  
  let rec eq'0 (self:t_Option'0) (other:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption9] result = (deep_model'0 self = deep_model'0 other)} (! return' {result}) ]
  
  
  let rec promoted0__transpose'0 (return'  (ret:t_Option'0))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some'1 ([%#soption10] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]
     ]
     [ & _0 : t_Option'0 = Any.any_l () | & _1 : t_Option'0 = Any.any_l () ] 
    [ return' (result:t_Option'0)-> return' {result} ]
  
  
  let rec unwrap_err'0 (self:t_Result'0) (return'  (ret:bool))= {[@expl:unwrap_err requires] [%#sresult11] exists e : bool . self
    = C_Err'1 e}
    any [ return' (result:bool)-> {[%#sresult12] C_Err'1 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec transpose'0[#"option.rs" 281 0 281 18] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &none <- C_None'0 ] s1
      | s1 =  [ &_3 <- C_Ok'0 ([%#soption0] (1 : Int32.t)) ] s2
      | s2 =  [ &some_ok <- C_Some'0 _3 ] s3
      | s3 =  [ &_5 <- C_Err'0 ([%#soption1] true) ] s4
      | s4 =  [ &some_err <- C_Some'0 _5 ] s5
      | s5 = transpose'1 {none} (fun (_ret':t_Result'0) ->  [ &_10 <- _ret' ] s6)
      | s6 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap'0 {_10} (fun (_ret':t_Option'0) ->  [ &_9 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = promoted1__transpose'0 (fun (pr1:t_Option'0) ->  [ &_31 <- pr1 ] s1)
      | s1 = eq'0 {_9} {_31} (fun (_ret':bool) ->  [ &_7 <- _ret' ] s2)
      | s2 = bb3 ]
    
    | bb3 = any [ br0 -> {_7 = false} (! bb5) | br1 -> {_7} (! bb4) ] 
    | bb4 = s0 [ s0 = transpose'1 {some_ok} (fun (_ret':t_Result'0) ->  [ &_19 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = unwrap'0 {_19} (fun (_ret':t_Option'0) ->  [ &_18 <- _ret' ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = promoted0__transpose'0 (fun (pr0:t_Option'0) ->  [ &_30 <- pr0 ] s1)
      | s1 = eq'0 {_18} {_30} (fun (_ret':bool) ->  [ &_16 <- _ret' ] s2)
      | s2 = bb8 ]
    
    | bb8 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ] 
    | bb9 = s0 [ s0 = transpose'1 {some_err} (fun (_ret':t_Result'0) ->  [ &_27 <- _ret' ] s1) | s1 = bb11 ] 
    | bb11 = s0 [ s0 = unwrap_err'0 {_27} (fun (_ret':bool) ->  [ &_26 <- _ret' ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 =  [ &_25 <- _26 ] s1 | s1 = any [ br0 -> {_25 = false} (! bb14) | br1 -> {_25} (! bb13) ]  ] 
    | bb13 = return' {_0}
    | bb14 = {[%#soption3] false} any
    | bb10 = {[%#soption4] false} any
    | bb5 = {[%#soption5] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & none : t_Option'1 = Any.any_l ()
    | & some_ok : t_Option'1 = Any.any_l ()
    | & _3 : t_Result'1 = Any.any_l ()
    | & some_err : t_Option'1 = Any.any_l ()
    | & _5 : t_Result'1 = Any.any_l ()
    | & _7 : bool = Any.any_l ()
    | & _9 : t_Option'0 = Any.any_l ()
    | & _10 : t_Result'0 = Any.any_l ()
    | & _16 : bool = Any.any_l ()
    | & _18 : t_Option'0 = Any.any_l ()
    | & _19 : t_Result'0 = Any.any_l ()
    | & _25 : bool = Any.any_l ()
    | & _26 : bool = Any.any_l ()
    | & _27 : t_Result'0 = Any.any_l ()
    | & _30 : t_Option'0 = Any.any_l ()
    | & _31 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__flatten [#"option.rs" 291 0 291 16]
  let%span soption0 = "option.rs" 296 45 296 46
  let%span soption1 = "option.rs" 297 38 297 39
  let%span soption2 = "option.rs" 297 4 297 40
  let%span soption3 = "option.rs" 295 4 295 36
  let%span soption4 = "option.rs" 293 4 293 36
  let%span soption5 = "../../creusot-contracts/src/std/option.rs" 552 26 552 57
  let%span soption6 = "../../creusot-contracts/src/std/option.rs" 553 26 553 62
  let%span soption7 = "../../creusot-contracts/src/std/option.rs" 65 26 65 51
  let%span soption8 = "../../creusot-contracts/src/std/option.rs" 136 27 136 39
  let%span soption9 = "../../creusot-contracts/src/std/option.rs" 137 26 137 46
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option'0  =
    | C_None'1
    | C_Some'1 Int32.t
  
  type t_Option'1  =
    | C_None'0
    | C_Some'0 t_Option'0
  
  let rec flatten'1 (self:t_Option'1) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption5] self = C_None'0  -> result = C_None'1}
      {[%#soption6] self = C_None'0 \/ self = C_Some'0 result}
      (! return' {result}) ]
  
  
  let rec is_none'0 (self:t_Option'0) (return'  (ret:bool))= any
    [ return' (result:bool)-> {[%#soption7] result = (self = C_None'1)} (! return' {result}) ]
  
  
  let rec unwrap'0 (self:t_Option'0) (return'  (ret:Int32.t))= {[@expl:unwrap requires] [%#soption8] self <> C_None'1}
    any [ return' (result:Int32.t)-> {[%#soption9] C_Some'1 result = self} (! return' {result}) ] 
  
  meta "compute_max_steps" 1000000
  
  let rec flatten'0[#"option.rs" 291 0 291 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &opt <- C_None'0 ] s1
      | s1 = flatten'1 {opt} (fun (_ret':t_Option'0) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none'0 {_5} (fun (_ret':bool) ->  [ &_3 <- _ret' ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = s0
      [ s0 =  [ &_9 <- C_None'1 ] s1
      | s1 =  [ &opt1 <- C_Some'0 _9 ] s2
      | s2 = flatten'1 {opt1} (fun (_ret':t_Option'0) ->  [ &_13 <- _ret' ] s3)
      | s3 = bb5 ]
    
    | bb5 = s0 [ s0 = is_none'0 {_13} (fun (_ret':bool) ->  [ &_11 <- _ret' ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_11 = false} (! bb8) | br1 -> {_11} (! bb7) ] 
    | bb7 = s0
      [ s0 =  [ &_17 <- C_Some'1 ([%#soption0] (1 : Int32.t)) ] s1
      | s1 =  [ &opt2 <- C_Some'0 _17 ] s2
      | s2 = flatten'1 {opt2} (fun (_ret':t_Option'0) ->  [ &_21 <- _ret' ] s3)
      | s3 = bb9 ]
    
    | bb9 = s0 [ s0 = unwrap'0 {_21} (fun (_ret':Int32.t) ->  [ &_20 <- _ret' ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_19 <- _20 = ([%#soption1] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_19 = false} (! bb12) | br1 -> {_19} (! bb11) ]  ]
    
    | bb11 = return' {_0}
    | bb12 = {[%#soption2] false} any
    | bb8 = {[%#soption3] false} any
    | bb4 = {[%#soption4] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & opt : t_Option'1 = Any.any_l ()
    | & _3 : bool = Any.any_l ()
    | & _5 : t_Option'0 = Any.any_l ()
    | & opt1 : t_Option'1 = Any.any_l ()
    | & _9 : t_Option'0 = Any.any_l ()
    | & _11 : bool = Any.any_l ()
    | & _13 : t_Option'0 = Any.any_l ()
    | & opt2 : t_Option'1 = Any.any_l ()
    | & _17 : t_Option'0 = Any.any_l ()
    | & _19 : bool = Any.any_l ()
    | & _20 : Int32.t = Any.any_l ()
    | & _21 : t_Option'0 = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module M_option__resolve [#"option.rs" 300 0 300 16]
  let%span soption0 = "option.rs" 302 16 302 17
  let%span soption1 = "option.rs" 305 17 305 18
  let%span soption2 = "option.rs" 308 16 308 17
  let%span soption3 = "option.rs" 310 25 310 26
  let%span soption4 = "option.rs" 311 17 311 18
  let%span soption5 = "option.rs" 312 16 312 17
  let%span soption6 = "option.rs" 313 16 313 17
  let%span soption7 = "option.rs" 316 17 316 18
  let%span soption8 = "option.rs" 316 27 316 28
  let%span soption9 = "option.rs" 319 16 319 17
  let%span soption10 = "option.rs" 322 17 322 18
  let%span soption11 = "option.rs" 324 16 324 17
  let%span soption12 = "option.rs" 325 16 325 17
  let%span soption13 = "option.rs" 329 17 329 18
  let%span soption14 = "option.rs" 329 27 329 28
  let%span soption15 = "option.rs" 332 16 332 17
  let%span soption16 = "option.rs" 333 16 333 17
  let%span soption17 = "option.rs" 336 12 336 13
  let%span soption18 = "option.rs" 337 17 337 18
  let%span soption19 = "option.rs" 337 27 337 28
  let%span soption20 = "option.rs" 340 16 340 17
  let%span soption21 = "option.rs" 341 16 341 17
  let%span soption22 = "option.rs" 344 12 344 13
  let%span soption23 = "option.rs" 345 17 345 18
  let%span soption24 = "option.rs" 345 27 345 28
  let%span soption25 = "option.rs" 348 16 348 17
  let%span soption26 = "option.rs" 351 17 351 18
  let%span soption27 = "option.rs" 354 16 354 17
  let%span soption28 = "option.rs" 357 17 357 18
  let%span soption29 = "option.rs" 360 17 360 18
  let%span soption30 = "option.rs" 360 4 360 19
  let%span soption31 = "option.rs" 357 4 357 19
  let%span soption32 = "option.rs" 351 4 351 19
  let%span soption33 = "option.rs" 345 4 345 29
  let%span soption34 = "option.rs" 337 4 337 29
  let%span soption35 = "option.rs" 329 4 329 29
  let%span soption36 = "option.rs" 322 4 322 19
  let%span soption37 = "option.rs" 316 4 316 29
  let%span soption38 = "option.rs" 311 4 311 19
  let%span soption39 = "option.rs" 305 4 305 19
  let%span soption40 = "option.rs" 304 4 304 38
  let%span soption41 = "option.rs" 304 32 304 36
  let%span soption42 = "../../creusot-contracts/src/std/option.rs" 49 27 52 17
  let%span soption43 = "../../creusot-contracts/src/std/option.rs" 53 26 56 17
  let%span soption44 = "../../creusot-contracts/src/std/option.rs" 287 26 287 75
  let%span soption45 = "../../creusot-contracts/src/std/option.rs" 288 26 288 76
  let%span soption46 = "../../creusot-contracts/src/std/option.rs" 334 26 334 57
  let%span soption47 = "../../creusot-contracts/src/std/option.rs" 335 26 335 76
  let%span soption48 = "option.rs" 321 27 321 32
  let%span soption49 = "../../creusot-contracts/src/std/option.rs" 313 27 316 17
  let%span soption50 = "../../creusot-contracts/src/std/option.rs" 317 26 323 17
  let%span soption51 = "../../creusot-contracts/src/std/option.rs" 358 26 363 17
  let%span soption52 = "../../creusot-contracts/src/std/option.rs" 372 26 375 17
  let%span soption53 = "../../creusot-contracts/src/std/option.rs" 376 26 376 68
  let%span soption54 = "../../creusot-contracts/src/std/option.rs" 386 26 389 17
  let%span soption55 = "../../creusot-contracts/src/std/option.rs" 451 26 455 17
  let%span soption56 = "../../creusot-contracts/src/std/option.rs" 505 26 505 57
  let%span soption57 = "../../creusot-contracts/src/std/option.rs" 507 20 508 93
  let%span soption58 = "../../creusot-contracts/src/std/option.rs" 519 26 519 57
  let%span soption59 = "../../creusot-contracts/src/std/option.rs" 521 20 522 93
  let%span soption60 = "option.rs" 304 28 304 31
  let%span sresolve61 = "../../creusot-contracts/src/resolve.rs" 82 8 85 9
  let%span soption62 = "option.rs" 321 23 321 26
  let%span sresolve63 = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span sresolve64 = "../../creusot-contracts/src/resolve.rs" 40 8 40 44
  
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option'1  =
    | C_None'1
    | C_Some'0 (MutBorrow.t Int32.t)
  
  predicate resolve'7 (self : MutBorrow.t Int32.t) =
    [%#sresolve63] self.final = self.current
  
  predicate resolve'2 (_1 : MutBorrow.t Int32.t) =
    resolve'7 _1
  
  let rec closure1'0[#"option.rs" 304 28 304 31] [@coma:extspec] (_1:()) (_2:MutBorrow.t Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 = -{resolve'2 _2}- s1 | s1 =  [ &_0 <- [%#soption41] true ] s2 | s2 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () | & _2 : MutBorrow.t Int32.t = _2 ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'0 (self : ()) (args : MutBorrow.t Int32.t) =
    [%#soption60] let _2 = args in closure1'0'pre self _2
  
  predicate postcondition_once'0 (self : ()) (args : MutBorrow.t Int32.t) (result : bool) =
    [%#soption60] let _2 = args in closure1'0'post'return' self _2 result
  
  let rec is_some_and'0 (self:t_Option'1) (f:()) (return'  (ret:bool))= {[@expl:is_some_and requires] [%#soption42] match self with
      | C_None'1 -> true
      | C_Some'0 t -> precondition'0 f t
      end}
    any
    [ return' (result:bool)-> {[%#soption43] match self with
        | C_None'1 -> result = false
        | C_Some'0 t -> postcondition_once'0 f t result
        end}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'1 Int32.t
  
  predicate resolve'10 (_1 : Int32.t) =
    true
  
  predicate resolve'5 (self : t_Option'0) =
    [%#sresolve61] match self with
      | C_Some'1 x -> resolve'10 x
      | C_None'0 -> true
      end
  
  predicate resolve'6 (self : t_Option'1) =
    [%#sresolve61] match self with
      | C_Some'0 x -> resolve'2 x
      | C_None'1 -> true
      end
  
  let rec and'0 (self:t_Option'1) (optb:t_Option'0) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption44] self = C_None'1  -> result = C_None'0 /\ resolve'5 optb}
      {[%#soption45] self = C_None'1 \/ result = optb /\ resolve'6 self}
      (! return' {result}) ]
  
  
  let rec or'0 (self:t_Option'1) (optb:t_Option'1) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption46] self = C_None'1  -> result = optb}
      {[%#soption47] self = C_None'1 \/ result = self /\ resolve'6 optb}
      (! return' {result}) ]
  
  
  predicate resolve'1 (_1 : t_Option'1) =
    resolve'6 _1
  
  let rec closure0'0[#"option.rs" 321 23 321 26] [@coma:extspec] (_1:()) (_2:MutBorrow.t Int32.t) (return'  (ret:bool))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#soption48] false ] s1 | s1 = return' {_0} ]  ]
     [ & _0 : bool = Any.any_l () ]  [ return' (result:bool)-> return' {result} ] 
  
  predicate precondition'1 (self : ()) (args : MutBorrow.t Int32.t) =
    [%#soption62] let _2 = args in closure0'0'pre self _2
  
  predicate postcondition_once'1 (self : ()) (args : MutBorrow.t Int32.t) (result : bool) =
    [%#soption62] let _2 = args in closure0'0'post'return' self _2 result
  
  let rec filter'0 (self:t_Option'1) (predicate':()) (return'  (ret:t_Option'1))= {[@expl:filter requires] [%#soption49] match self with
      | C_None'1 -> true
      | C_Some'0 t -> precondition'1 predicate' t
      end}
    any
    [ return' (result:t_Option'1)-> {[%#soption50] match self with
        | C_None'1 -> result = C_None'1
        | C_Some'0 t -> match result with
          | C_None'1 -> postcondition_once'1 predicate' t false /\ resolve'2 t
          | C_Some'0 r -> postcondition_once'1 predicate' t true /\ r = t
          end
        end}
      (! return' {result}) ]
  
  
  type tuple'0  =
    { _0'0: t_Option'1; _1'0: t_Option'1 }
  
  let rec xor'0 (self:t_Option'1) (optb:t_Option'1) (return'  (ret:t_Option'1))= any
    [ return' (result:t_Option'1)-> {[%#soption51] match { _0'0 = self; _1'0 = optb } with
        | {_0'0 = C_None'1 ; _1'0 = C_None'1} -> result = C_None'1
        | {_0'0 = C_Some'0 t1 ; _1'0 = C_Some'0 t2} -> result = C_None'1 /\ resolve'2 t1 /\ resolve'2 t2
        | {_0'0 = C_Some'0 t ; _1'0 = C_None'1} -> result = C_Some'0 t
        | {_0'0 = C_None'1 ; _1'0 = C_Some'0 t} -> result = C_Some'0 t
        end}
      (! return' {result}) ]
  
  
  let rec insert'0 (self:MutBorrow.t t_Option'1) (value:MutBorrow.t Int32.t) (return'  (ret:MutBorrow.t (MutBorrow.t Int32.t)))= any
    [ return' (result:MutBorrow.t (MutBorrow.t Int32.t))-> {[%#soption52] match self.current with
        | C_Some'0 t -> resolve'2 t
        | C_None'1 -> true
        end}
      {[%#soption53] result.current = value /\ self.final = C_Some'0 (result.final)}
      (! return' {result}) ]
  
  
  predicate resolve'8 (self : MutBorrow.t (MutBorrow.t Int32.t)) =
    [%#sresolve63] self.final = self.current
  
  predicate resolve'3 (_1 : MutBorrow.t (MutBorrow.t Int32.t)) =
    resolve'8 _1
  
  let rec get_or_insert'0 (self:MutBorrow.t t_Option'1) (value:MutBorrow.t Int32.t) (return'  (ret:MutBorrow.t (MutBorrow.t Int32.t)))= any
    [ return' (result:MutBorrow.t (MutBorrow.t Int32.t))-> {[%#soption54] match self.current with
        | C_None'1 -> result.current = value /\ self.final = C_Some'0 (result.final)
        | C_Some'0 _ -> self.current = C_Some'0 (result.current)
        /\ self.final = C_Some'0 (result.final) /\ resolve'2 value
        end}
      (! return' {result}) ]
  
  
  type tuple'2  =
    { _0'2: MutBorrow.t Int32.t; _1'2: Int32.t }
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 tuple'2
  
  type tuple'1  =
    { _0'1: t_Option'1; _1'1: t_Option'0 }
  
  let rec zip'0 (self:t_Option'1) (other:t_Option'0) (return'  (ret:t_Option'2))= any
    [ return' (result:t_Option'2)-> {[%#soption55] match { _0'1 = self; _1'1 = other } with
        | {_0'1 = C_None'1} -> result = C_None'2 /\ resolve'5 other
        | {_1'1 = C_None'0} -> result = C_None'2 /\ resolve'6 self
        | {_0'1 = C_Some'0 t ; _1'1 = C_Some'1 u} -> result = C_Some'2 { _0'2 = t; _1'2 = u }
        end}
      (! return' {result}) ]
  
  
  predicate resolve'12 (self : tuple'2) =
    [%#sresolve64] resolve'2 self._0'2 /\ resolve'10 self._1'2
  
  predicate resolve'11 (_1 : tuple'2) =
    resolve'12 _1
  
  predicate resolve'9 (self : t_Option'2) =
    [%#sresolve61] match self with
      | C_Some'2 x -> resolve'11 x
      | C_None'2 -> true
      end
  
  predicate resolve'4 (_1 : t_Option'2) =
    resolve'9 _1
  
  let rec copied'0 (self:t_Option'1) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption56] self = C_None'1  -> result = C_None'0}
      {[%#soption57] self = C_None'1
      \/ (exists t : MutBorrow.t Int32.t . self = C_Some'0 t /\ result = C_Some'1 (t.current) /\ resolve'7 t)}
      (! return' {result}) ]
  
  
  let rec cloned'0 (self:t_Option'1) (return'  (ret:t_Option'0))= any
    [ return' (result:t_Option'0)-> {[%#soption58] self = C_None'1  -> result = C_None'0}
      {[%#soption59] self = C_None'1
      \/ (exists t : MutBorrow.t Int32.t . self = C_Some'0 t /\ result = C_Some'1 (t.current) /\ resolve'7 t)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec resolve'0[#"option.rs" 300 0 300 16] (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &x <- [%#soption0] (1 : Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_3 <- _ret' ]  [ &x <- _ret'.final ] s2)
      | s2 =  [ &opt <- C_Some'0 _3 ] s3
      | s3 =  [ &_7 <- () ] s4
      | s4 = is_some_and'0 {opt} {_7} (fun (_ret':bool) ->  [ &_5 <- _ret' ] s5)
      | s5 = bb1 ]
    
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0
      [ s0 =  [ &_10 <- x = ([%#soption1] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_10 = false} (! bb5) | br1 -> {_10} (! bb4) ]  ]
    
    | bb4 = s0
      [ s0 =  [ &x1 <- [%#soption2] (1 : Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x1}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_15 <- _ret' ]  [ &x1 <- _ret'.final ] s2)
      | s2 =  [ &opt1 <- C_Some'0 _15 ] s3
      | s3 =  [ &_18 <- C_Some'1 ([%#soption3] (2 : Int32.t)) ] s4
      | s4 = and'0 {opt1} {_18} (fun (_ret':t_Option'0) ->  [ &_16 <- _ret' ] s5)
      | s5 = bb6 ]
    
    | bb6 = s0
      [ s0 =  [ &_20 <- x1 = ([%#soption4] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb8) | br1 -> {_20} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 =  [ &x2 <- [%#soption5] (1 : Int32.t) ] s1
      | s1 =  [ &y <- [%#soption6] (2 : Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x2}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_26 <- _ret' ]  [ &x2 <- _ret'.final ] s3)
      | s3 =  [ &opt2 <- C_Some'0 _26 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_29 <- _ret' ]  [ &y <- _ret'.final ] s5)
      | s5 =  [ &_28 <- C_Some'0 _29 ] s6
      | s6 = or'0 {_28} {opt2} (fun (_ret':t_Option'1) ->  [ &_27 <- _ret' ] s7)
      | s7 = bb9 ]
    
    | bb9 = s0
      [ s0 = -{resolve'1 _27}- s1
      | s1 =  [ &_32 <- x2 = ([%#soption7] (1 : Int32.t)) ] s2
      | s2 = any [ br0 -> {_32 = false} (! bb13) | br1 -> {_32} (! bb10) ]  ]
    
    | bb10 = s0
      [ s0 =  [ &_34 <- y = ([%#soption8] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_34 = false} (! bb12) | br1 -> {_34} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 =  [ &x3 <- [%#soption9] (1 : Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x3}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_39 <- _ret' ]  [ &x3 <- _ret'.final ] s2)
      | s2 =  [ &opt3 <- C_Some'0 _39 ] s3
      | s3 =  [ &_42 <- () ] s4
      | s4 = filter'0 {opt3} {_42} (fun (_ret':t_Option'1) ->  [ &_40 <- _ret' ] s5)
      | s5 = bb15 ]
    
    | bb15 = s0
      [ s0 = -{resolve'1 _40}- s1
      | s1 =  [ &_44 <- x3 = ([%#soption10] (1 : Int32.t)) ] s2
      | s2 = any [ br0 -> {_44 = false} (! bb17) | br1 -> {_44} (! bb16) ]  ]
    
    | bb16 = s0
      [ s0 =  [ &x4 <- [%#soption11] (1 : Int32.t) ] s1
      | s1 =  [ &y1 <- [%#soption12] (2 : Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x4}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_50 <- _ret' ]  [ &x4 <- _ret'.final ] s3)
      | s3 =  [ &optx <- C_Some'0 _50 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y1}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_52 <- _ret' ]  [ &y1 <- _ret'.final ] s5)
      | s5 =  [ &opty <- C_Some'0 _52 ] s6
      | s6 = xor'0 {optx} {opty} (fun (_ret':t_Option'1) ->  [ &_53 <- _ret' ] s7)
      | s7 = bb18 ]
    
    | bb18 = s0
      [ s0 = -{resolve'1 _53}- s1
      | s1 =  [ &_57 <- x4 = ([%#soption13] (1 : Int32.t)) ] s2
      | s2 = any [ br0 -> {_57 = false} (! bb22) | br1 -> {_57} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 =  [ &_59 <- y1 = ([%#soption14] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_59 = false} (! bb21) | br1 -> {_59} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 =  [ &x5 <- [%#soption15] (1 : Int32.t) ] s1
      | s1 =  [ &y2 <- [%#soption16] (2 : Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x5}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_65 <- _ret' ]  [ &x5 <- _ret'.final ] s3)
      | s3 =  [ &opt4 <- C_Some'0 _65 ] s4
      | s4 = MutBorrow.borrow_mut <t_Option'1> {opt4}
          (fun (_ret':MutBorrow.t t_Option'1) ->  [ &_67 <- _ret' ]  [ &opt4 <- _ret'.final ] s5)
      | s5 = MutBorrow.borrow_mut <Int32.t> {y2}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_69 <- _ret' ]  [ &y2 <- _ret'.final ] s6)
      | s6 = MutBorrow.borrow_final <Int32.t> {_69.current} {MutBorrow.get_id _69}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_68 <- _ret' ]  [ &_69 <- { _69 with current = _ret'.final } ] s7)
      | s7 = insert'0 {_67} {_68} (fun (_ret':MutBorrow.t (MutBorrow.t Int32.t)) ->  [ &bor <- _ret' ] s8)
      | s8 = bb24 ]
    
    | bb24 = s0
      [ s0 = -{resolve'2 _69}- s1
      | s1 =  [ &bor <- { bor with current = { bor.current with current = ([%#soption17] (3 : Int32.t)) } } ] s2
      | s2 = -{resolve'3 bor}- s3
      | s3 = -{resolve'1 opt4}- s4
      | s4 =  [ &_71 <- x5 = ([%#soption18] (1 : Int32.t)) ] s5
      | s5 = any [ br0 -> {_71 = false} (! bb28) | br1 -> {_71} (! bb25) ]  ]
    
    | bb25 = s0
      [ s0 =  [ &_73 <- y2 = ([%#soption19] (3 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_73 = false} (! bb27) | br1 -> {_73} (! bb26) ]  ]
    
    | bb26 = s0
      [ s0 =  [ &x6 <- [%#soption20] (1 : Int32.t) ] s1
      | s1 =  [ &y3 <- [%#soption21] (2 : Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x6}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_79 <- _ret' ]  [ &x6 <- _ret'.final ] s3)
      | s3 =  [ &opt5 <- C_Some'0 _79 ] s4
      | s4 = MutBorrow.borrow_mut <t_Option'1> {opt5}
          (fun (_ret':MutBorrow.t t_Option'1) ->  [ &_81 <- _ret' ]  [ &opt5 <- _ret'.final ] s5)
      | s5 = MutBorrow.borrow_mut <Int32.t> {y3}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_83 <- _ret' ]  [ &y3 <- _ret'.final ] s6)
      | s6 = MutBorrow.borrow_final <Int32.t> {_83.current} {MutBorrow.get_id _83}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_82 <- _ret' ]  [ &_83 <- { _83 with current = _ret'.final } ] s7)
      | s7 = get_or_insert'0 {_81} {_82} (fun (_ret':MutBorrow.t (MutBorrow.t Int32.t)) ->  [ &bor1 <- _ret' ] s8)
      | s8 = bb30 ]
    
    | bb30 = s0
      [ s0 = -{resolve'2 _83}- s1
      | s1 =  [ &bor1 <- { bor1 with current = { bor1.current with current = ([%#soption22] (3 : Int32.t)) } } ] s2
      | s2 = -{resolve'3 bor1}- s3
      | s3 = -{resolve'1 opt5}- s4
      | s4 =  [ &_85 <- x6 = ([%#soption23] (3 : Int32.t)) ] s5
      | s5 = any [ br0 -> {_85 = false} (! bb34) | br1 -> {_85} (! bb31) ]  ]
    
    | bb31 = s0
      [ s0 =  [ &_87 <- y3 = ([%#soption24] (2 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_87 = false} (! bb33) | br1 -> {_87} (! bb32) ]  ]
    
    | bb32 = s0
      [ s0 =  [ &x7 <- [%#soption25] (1 : Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x7}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_92 <- _ret' ]  [ &x7 <- _ret'.final ] s2)
      | s2 =  [ &opt6 <- C_Some'0 _92 ] s3
      | s3 =  [ &_95 <- C_None'0 ] s4
      | s4 = zip'0 {opt6} {_95} (fun (_ret':t_Option'2) ->  [ &_93 <- _ret' ] s5)
      | s5 = bb36 ]
    
    | bb36 = s0
      [ s0 = -{resolve'4 _93}- s1
      | s1 =  [ &_97 <- x7 = ([%#soption26] (1 : Int32.t)) ] s2
      | s2 = any [ br0 -> {_97 = false} (! bb38) | br1 -> {_97} (! bb37) ]  ]
    
    | bb37 = s0
      [ s0 =  [ &x8 <- [%#soption27] (1 : Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x8}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_102 <- _ret' ]  [ &x8 <- _ret'.final ] s2)
      | s2 =  [ &opt7 <- C_Some'0 _102 ] s3
      | s3 = copied'0 {opt7} (fun (_ret':t_Option'0) ->  [ &_103 <- _ret' ] s4)
      | s4 = bb39 ]
    
    | bb39 = s0
      [ s0 =  [ &_106 <- x8 = ([%#soption28] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_106 = false} (! bb41) | br1 -> {_106} (! bb40) ]  ]
    
    | bb40 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x8}
          (fun (_ret':MutBorrow.t Int32.t) ->  [ &_110 <- _ret' ]  [ &x8 <- _ret'.final ] s1)
      | s1 =  [ &opt8 <- C_Some'0 _110 ] s2
      | s2 = cloned'0 {opt8} (fun (_ret':t_Option'0) ->  [ &_111 <- _ret' ] s3)
      | s3 = bb42 ]
    
    | bb42 = s0
      [ s0 =  [ &_114 <- x8 = ([%#soption29] (1 : Int32.t)) ] s1
      | s1 = any [ br0 -> {_114 = false} (! bb44) | br1 -> {_114} (! bb43) ]  ]
    
    | bb43 = return' {_0}
    | bb44 = {[%#soption30] false} any
    | bb41 = {[%#soption31] false} any
    | bb38 = {[%#soption32] false} any
    | bb33 = bb35
    | bb34 = bb35
    | bb35 = {[%#soption33] false} any
    | bb27 = bb29
    | bb28 = bb29
    | bb29 = {[%#soption34] false} any
    | bb21 = bb23
    | bb22 = bb23
    | bb23 = {[%#soption35] false} any
    | bb17 = {[%#soption36] false} any
    | bb12 = bb14
    | bb13 = bb14
    | bb14 = {[%#soption37] false} any
    | bb8 = {[%#soption38] false} any
    | bb5 = {[%#soption39] false} any
    | bb3 = {[%#soption40] false} any ]
    )
    [ & _0 : () = Any.any_l ()
    | & x : Int32.t = Any.any_l ()
    | & opt : t_Option'1 = Any.any_l ()
    | & _3 : MutBorrow.t Int32.t = Any.any_l ()
    | & _5 : bool = Any.any_l ()
    | & _7 : () = Any.any_l ()
    | & _10 : bool = Any.any_l ()
    | & x1 : Int32.t = Any.any_l ()
    | & opt1 : t_Option'1 = Any.any_l ()
    | & _15 : MutBorrow.t Int32.t = Any.any_l ()
    | & _16 : t_Option'0 = Any.any_l ()
    | & _18 : t_Option'0 = Any.any_l ()
    | & _20 : bool = Any.any_l ()
    | & x2 : Int32.t = Any.any_l ()
    | & y : Int32.t = Any.any_l ()
    | & opt2 : t_Option'1 = Any.any_l ()
    | & _26 : MutBorrow.t Int32.t = Any.any_l ()
    | & _27 : t_Option'1 = Any.any_l ()
    | & _28 : t_Option'1 = Any.any_l ()
    | & _29 : MutBorrow.t Int32.t = Any.any_l ()
    | & _32 : bool = Any.any_l ()
    | & _34 : bool = Any.any_l ()
    | & x3 : Int32.t = Any.any_l ()
    | & opt3 : t_Option'1 = Any.any_l ()
    | & _39 : MutBorrow.t Int32.t = Any.any_l ()
    | & _40 : t_Option'1 = Any.any_l ()
    | & _42 : () = Any.any_l ()
    | & _44 : bool = Any.any_l ()
    | & x4 : Int32.t = Any.any_l ()
    | & y1 : Int32.t = Any.any_l ()
    | & optx : t_Option'1 = Any.any_l ()
    | & _50 : MutBorrow.t Int32.t = Any.any_l ()
    | & opty : t_Option'1 = Any.any_l ()
    | & _52 : MutBorrow.t Int32.t = Any.any_l ()
    | & _53 : t_Option'1 = Any.any_l ()
    | & _57 : bool = Any.any_l ()
    | & _59 : bool = Any.any_l ()
    | & x5 : Int32.t = Any.any_l ()
    | & y2 : Int32.t = Any.any_l ()
    | & opt4 : t_Option'1 = Any.any_l ()
    | & _65 : MutBorrow.t Int32.t = Any.any_l ()
    | & bor : MutBorrow.t (MutBorrow.t Int32.t) = Any.any_l ()
    | & _67 : MutBorrow.t t_Option'1 = Any.any_l ()
    | & _68 : MutBorrow.t Int32.t = Any.any_l ()
    | & _69 : MutBorrow.t Int32.t = Any.any_l ()
    | & _71 : bool = Any.any_l ()
    | & _73 : bool = Any.any_l ()
    | & x6 : Int32.t = Any.any_l ()
    | & y3 : Int32.t = Any.any_l ()
    | & opt5 : t_Option'1 = Any.any_l ()
    | & _79 : MutBorrow.t Int32.t = Any.any_l ()
    | & bor1 : MutBorrow.t (MutBorrow.t Int32.t) = Any.any_l ()
    | & _81 : MutBorrow.t t_Option'1 = Any.any_l ()
    | & _82 : MutBorrow.t Int32.t = Any.any_l ()
    | & _83 : MutBorrow.t Int32.t = Any.any_l ()
    | & _85 : bool = Any.any_l ()
    | & _87 : bool = Any.any_l ()
    | & x7 : Int32.t = Any.any_l ()
    | & opt6 : t_Option'1 = Any.any_l ()
    | & _92 : MutBorrow.t Int32.t = Any.any_l ()
    | & _93 : t_Option'2 = Any.any_l ()
    | & _95 : t_Option'0 = Any.any_l ()
    | & _97 : bool = Any.any_l ()
    | & x8 : Int32.t = Any.any_l ()
    | & opt7 : t_Option'1 = Any.any_l ()
    | & _102 : MutBorrow.t Int32.t = Any.any_l ()
    | & _103 : t_Option'0 = Any.any_l ()
    | & _106 : bool = Any.any_l ()
    | & opt8 : t_Option'1 = Any.any_l ()
    | & _110 : MutBorrow.t Int32.t = Any.any_l ()
    | & _111 : t_Option'0 = Any.any_l ()
    | & _114 : bool = Any.any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
