//! Type invariants

use crate::*;

/// A user-defined _type invariant_.
///
/// Type invariants are additional pre- and postconditions added to each program functions.
///
/// # Example
///
/// ```rust
/// # use creusot_contracts::*;
/// struct SumTo10 {
///     a: i32,
///     b: i32,
/// }
/// // The type invariant constrains the set of valid `SumTo10`s to
/// // only allow values where the sum of both fields is equal to 10.
/// impl Invariant for SumTo10 {
///     #[predicate]
///     #[open]
///     fn invariant(self) -> bool {
///         pearlite! {
///             self.a@ + self.b@ == 10
///         }
///     }
/// }
///
/// // #[requires(inv(x))]     // generated by Creusot
/// // #[ensures(inv(result))] // generated by Creusot
/// fn invariant_holds(mut x: SumTo10) -> SumTo10 {
///     assert!(x.a + x.b == 10); // We are given the invariant when entering the function
///     x.a = 5; // we can break it locally!
///     x.b = 5; // but it must be restored eventually
///     x
/// }
/// ```
///
/// # Structural invariants
///
/// A type automatically inherits the invariants of its fields.
///
/// Examples:
/// - `x: (T, U)` -> `inv(x.0) && inv(x.1)`
/// - `x: &T` -> `inv(*x)`
/// - `x: Vec<T>` -> `forall<i: Int> 0 <= i && i < x@.len() ==> inv(x@[i])`
///
/// This does not prevent the type to additionnaly implement the `Invariant` trait.
///
/// ## Mutable borrows
///
/// For mutable borrows, the invariant is the conjunction of the invariants of the current
/// and final values: `x: &mut T` -> `inv(*x) && inv(^x)`.
///
/// # Logical functions
///
/// Invariant pre- and postconditions are not added to logical functions:
/// ```
/// # use creusot_contracts::*;
/// # struct SumTo10 { a: i32, b: i32 }
/// # impl Invariant for SumTo10 {
/// # #[predicate] #[open] fn invariant(self) -> bool { pearlite!{self.a@ + self.b@ == 10} }
/// # }
/// #[logic]
/// #[ensures(x.a@ + x.b@ == 10)]
/// fn not_provable(x: SumTo10) {}
/// ```
pub trait Invariant {
    #[predicate(prophetic)]
    #[rustc_diagnostic_item = "creusot_invariant_user"]
    fn invariant(self) -> bool;
}

#[cfg(feature = "nightly")]
impl Invariant for ! {
    #[predicate(prophetic)]
    #[open]
    #[creusot::trusted_ignore_structural_inv]
    fn invariant(self) -> bool {
        false
    }
}

impl<T: ?Sized> Invariant for &T {
    #[predicate(prophetic)]
    #[open]
    #[creusot::trusted_ignore_structural_inv]
    #[creusot::trusted_is_tyinv_trivial_if_param_trivial]
    fn invariant(self) -> bool {
        inv(*self)
    }
}

impl<T: ?Sized> Invariant for &mut T {
    #[predicate(prophetic)]
    #[open]
    #[creusot::trusted_ignore_structural_inv]
    #[creusot::trusted_is_tyinv_trivial_if_param_trivial]
    fn invariant(self) -> bool {
        pearlite! { inv(*self) && inv(^self) }
    }
}

/// Whether the invariant of a value holds
///
/// This function is functionnaly equivalent to [`Invariant::invariant`], except that it
/// can be called on any type (even if it does not implement [`Invariant`]).
#[predicate(prophetic)]
#[trusted]
#[rustc_diagnostic_item = "creusot_invariant_internal"]
pub fn inv<T: ?Sized>(_: T) -> bool {
    true
}

#[cfg(not(creusot))]
pub fn inv<T: ?Sized>(_: &T) -> bool {
    panic!()
}
