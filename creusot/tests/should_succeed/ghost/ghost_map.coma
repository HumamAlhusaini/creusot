
module T_creusot_contracts__ghost__GhostBox [#"../../../../creusot-contracts/src/ghost.rs" 27 0 27 22]
  type t_GhostBox 't =
    | C_GhostBox 't
  
  let rec t_GhostBox < 't > (input:t_GhostBox 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_GhostBox field_0 = input} (! ret {field_0}) ]
    
  
  function t_GhostBox__0 (self : t_GhostBox 't) : 't =
    match self with
      | C_GhostBox a -> a
      end
end
module T_creusot_contracts__logic__fmap__FMap [#"../../../../creusot-contracts/src/logic/fmap.rs" 25 0 25 29]
  type t_FMap 'k 'v
end
module T_core__option__Option
  type t_Option 't =
    | C_None
    | C_Some 't
  
  let rec v_None < 't > (input:t_Option 't) (ret  )= any
    [ good -> {C_None  = input} (! ret) | bad -> {C_None  <> input} (! {false} any) ]
    
  
  let rec v_Some < 't > (input:t_Option 't) (ret  (field_0:'t))= any
    [ good (field_0:'t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : 't [C_Some field_0 : t_Option 't] . C_Some field_0 <> input} (! {false} any) ]
    
end
module M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z_Type [#"ghost_map.rs" 6 4 48 5]
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  use prelude.prelude.Borrow
  
  type m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z  =
    | M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z (borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)))
  
  let rec m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z (input:m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) (ret  (map:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))))= any
    [ good (map:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)))-> {M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z map
      = input}
      (! ret {map}) ]
    
end
module M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z [#"ghost_map.rs" 6 4 48 5]
  let%span sghost_map0 = "ghost_map.rs" 7 8 7 54
  let%span sghost_map1 = "ghost_map.rs" 8 25 8 26
  let%span sghost_map2 = "ghost_map.rs" 8 28 8 30
  let%span sghost_map3 = "ghost_map.rs" 10 22 10 47
  let%span sghost_map4 = "ghost_map.rs" 11 22 11 34
  let%span sghost_map5 = "ghost_map.rs" 12 28 12 29
  let%span sghost_map6 = "ghost_map.rs" 12 31 12 32
  let%span sghost_map7 = "ghost_map.rs" 12 34 12 35
  let%span sghost_map8 = "ghost_map.rs" 14 17 14 19
  let%span sghost_map9 = "ghost_map.rs" 16 22 16 47
  let%span sghost_map10 = "ghost_map.rs" 18 45 18 46
  let%span sghost_map11 = "ghost_map.rs" 18 48 18 50
  let%span sghost_map12 = "ghost_map.rs" 19 45 19 46
  let%span sghost_map13 = "ghost_map.rs" 19 48 19 51
  let%span sghost_map14 = "ghost_map.rs" 21 22 21 43
  let%span sghost_map15 = "ghost_map.rs" 22 22 22 50
  let%span sghost_map16 = "ghost_map.rs" 23 22 23 34
  let%span sghost_map17 = "ghost_map.rs" 24 22 24 48
  let%span sghost_map18 = "ghost_map.rs" 25 22 25 47
  let%span sghost_map19 = "ghost_map.rs" 30 22 30 42
  let%span sghost_map20 = "ghost_map.rs" 31 22 31 49
  let%span sghost_map21 = "ghost_map.rs" 32 22 32 42
  let%span sghost_map22 = "ghost_map.rs" 33 22 33 43
  let%span sghost_map23 = "ghost_map.rs" 38 22 38 31
  let%span sghost_map24 = "ghost_map.rs" 39 22 39 32
  let%span sghost_map25 = "ghost_map.rs" 40 22 40 32
  let%span sghost_map26 = "ghost_map.rs" 45 22 45 42
  let%span sghost_map27 = "ghost_map.rs" 46 22 46 34
  let%span sghost_map28 = "ghost_map.rs" 47 22 47 34
  let%span span29 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span30 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span31 = "../../../../creusot-contracts/src/ghost.rs" 146 15 146 16
  let%span span32 = "../../../../creusot-contracts/src/ghost.rs" 144 14 144 28
  let%span span33 = "../../../../creusot-contracts/src/ghost.rs" 146 4 146 28
  let%span span34 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span35 = "../../../../creusot-contracts/src/util.rs" 25 11 25 16
  let%span span36 = "../../../../creusot-contracts/src/util.rs" 26 10 26 15
  let%span span37 = "../../../../creusot-contracts/src/util.rs" 27 10 27 11
  let%span span38 = "../../../../creusot-contracts/src/util.rs" 34 11 34 21
  let%span span39 = "../../../../creusot-contracts/src/util.rs" 35 10 35 28
  let%span span40 = "../../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span span41 = "../../../../creusot-contracts/src/logic/fmap.rs" 75 8 75 26
  let%span span42 = "../../../../creusot-contracts/src/logic/fmap.rs" 82 8 82 27
  let%span span43 = "../../../../creusot-contracts/src/logic/fmap.rs" 99 8 99 27
  let%span span44 = "../../../../creusot-contracts/src/logic/fmap.rs" 264 28 264 31
  let%span span45 = "../../../../creusot-contracts/src/logic/fmap.rs" 256 4 263 11
  let%span span46 = "../../../../creusot-contracts/src/logic/fmap.rs" 264 4 264 50
  let%span span47 = "../../../../creusot-contracts/src/logic/fmap.rs" 235 33 235 36
  let%span span48 = "../../../../creusot-contracts/src/logic/fmap.rs" 234 14 234 33
  let%span span49 = "../../../../creusot-contracts/src/logic/fmap.rs" 32 14 32 25
  let%span span50 = "../../../../creusot-contracts/src/logic/fmap.rs" 65 14 65 55
  let%span span51 = "../../../../creusot-contracts/src/logic/fmap.rs" 66 14 66 84
  let%span span52 = "../../../../creusot-contracts/src/logic/fmap.rs" 374 35 374 38
  let%span span53 = "../../../../creusot-contracts/src/logic/fmap.rs" 369 14 369 40
  let%span span54 = "../../../../creusot-contracts/src/logic/fmap.rs" 370 14 373 9
  let%span span55 = "../../../../creusot-contracts/src/logic/fmap.rs" 374 4 376 17
  let%span span56 = "../../../../creusot-contracts/src/logic/fmap.rs" 297 30 297 33
  let%span span57 = "../../../../creusot-contracts/src/logic/fmap.rs" 286 4 294 11
  let%span span58 = "../../../../creusot-contracts/src/logic/fmap.rs" 295 4 295 75
  let%span span59 = "../../../../creusot-contracts/src/logic/fmap.rs" 296 14 296 44
  let%span span60 = "../../../../creusot-contracts/src/logic/fmap.rs" 297 4 297 56
  let%span span61 = "../../../../creusot-contracts/src/logic/fmap.rs" 92 9 92 31
  let%span span62 = "../../../../creusot-contracts/src/logic/fmap.rs" 214 14 214 34
  let%span span63 = "../../../../creusot-contracts/src/ghost.rs" 51 14 51 18
  let%span span64 = "../../../../creusot-contracts/src/ghost.rs" 50 14 50 35
  let%span span65 = "../../../../creusot-contracts/src/ghost.rs" 51 4 51 36
  let%span span66 = "../../../../creusot-contracts/src/util.rs" 15 14 15 30
  let%span span67 = "../../../../creusot-contracts/src/logic/fmap.rs" 55 14 55 71
  let%span span68 = "../../../../creusot-contracts/src/logic/fmap.rs" 56 4 56 63
  let%span span69 = "../../../../creusot-contracts/src/logic/fmap.rs" 57 4 57 68
  let%span span70 = "../../../../creusot-contracts/src/logic/fmap.rs" 328 35 328 38
  let%span span71 = "../../../../creusot-contracts/src/logic/fmap.rs" 328 43 328 48
  let%span span72 = "../../../../creusot-contracts/src/logic/fmap.rs" 322 14 322 46
  let%span span73 = "../../../../creusot-contracts/src/logic/fmap.rs" 323 4 327 11
  let%span span74 = "../../../../creusot-contracts/src/logic/fmap.rs" 328 4 330 17
  let%span span75 = "../../../../creusot-contracts/src/ghost.rs" 66 22 66 26
  let%span span76 = "../../../../creusot-contracts/src/ghost.rs" 65 14 65 36
  let%span span77 = "../../../../creusot-contracts/src/ghost.rs" 66 4 66 48
  let%span span78 = "../../../../creusot-contracts/src/ghost.rs" 179 14 179 31
  
  use prelude.prelude.Int32
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  predicate inv'12 (_1 : FMap'0.t_FMap int32 int32)
  
  axiom inv_axiom'12 [@rewrite] : forall x : FMap'0.t_FMap int32 int32 [inv'12 x] . inv'12 x = true
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'11 (_1 : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))
  
  axiom inv_axiom'11 [@rewrite] : forall x : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) [inv'11 x] . inv'11 x
  = true
  
  predicate inv'10 (_1 : GhostBox'0.t_GhostBox ())
  
  axiom inv_axiom'10 [@rewrite] : forall x : GhostBox'0.t_GhostBox () [inv'10 x] . inv'10 x = true
  
  predicate inv'9 (_1 : ())
  
  axiom inv_axiom'9 [@rewrite] : forall x : () [inv'9 x] . inv'9 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'8 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Option'0.t_Option int32 [inv'8 x] . inv'8 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'7 (_1 : Option'0.t_Option (borrowed int32))
  
  axiom inv_axiom'7 [@rewrite] : forall x : Option'0.t_Option (borrowed int32) [inv'7 x] . inv'7 x = true
  
  predicate inv'2 (_1 : int32)
  
  predicate invariant'6 (self : int32) =
    [%#span29] inv'2 self
  
  predicate inv'6 (_1 : int32)
  
  axiom inv_axiom'6 [@rewrite] : forall x : int32 [inv'6 x] . inv'6 x = true
  
  predicate invariant'5 (self : FMap'0.t_FMap int32 int32) =
    [%#span29] inv'12 self
  
  predicate inv'5 (_1 : FMap'0.t_FMap int32 int32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : FMap'0.t_FMap int32 int32 [inv'5 x] . inv'5 x = true
  
  predicate invariant'4 (self : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) =
    [%#span29] inv'11 self
  
  predicate inv'4 (_1 : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))
  
  axiom inv_axiom'4 [@rewrite] : forall x : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) [inv'4 x] . inv'4 x = true
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  axiom inv_axiom'2 [@rewrite] : forall x : int32 [inv'2 x] . inv'2 x = true
  
  predicate invariant'1 (self : borrowed (FMap'0.t_FMap int32 int32)) =
    [%#span30] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'1 (_1 : borrowed (FMap'0.t_FMap int32 int32))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (FMap'0.t_FMap int32 int32) [inv'1 x] . inv'1 x = true
  
  predicate invariant'0 (self : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) =
    [%#span30] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'0 (_1 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) [inv'0 x] . inv'0 x
  = true
  
  use prelude.prelude.Intrinsic
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  let rec new'0 (x:()) (return'  (ret:GhostBox'0.t_GhostBox ()))= {[@expl:precondition] [%#span31] inv'9 x}
    any
    [ return' (result:GhostBox'0.t_GhostBox ())-> {[%#span33] inv'10 result}
      {[%#span32] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 result = x}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) =
    [%#span34] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) =
    resolve'7 _1
  
  use prelude.prelude.Int
  
  use M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z_Type as Closure'0
  
  function field_0'0 [#"ghost_map.rs" 6 4 48 5] (self : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))
    
   =
    let Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z a = self in a
  
  predicate resolve'5 [#"ghost_map.rs" 6 4 48 5] (_1 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) =
    resolve'6 (field_0'0 _1)
  
  predicate resolve'2 (_1 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) =
    resolve'5 _1
  
  function unreachable'0 (_1 : ()) : int32
  
  axiom unreachable'0_spec : forall _1 : () . ([%#span35] false)  -> ([%#span36] false)
  
  function unwrap'0 (op : Option'0.t_Option int32) : int32
  
  axiom unwrap'0_spec : forall op : Option'0.t_Option int32 . ([%#span38] op <> Option'0.C_None)
   -> ([%#span39] Option'0.C_Some (unwrap'0 op) = op)
  
  use map.Map
  
  use map.Map
  
  function mk'0 (_m : Map.map int32 (Option'0.t_Option int32)) : FMap'0.t_FMap int32 int32
  
  function view'0 (self : FMap'0.t_FMap int32 int32) : Map.map int32 (Option'0.t_Option int32)
  
  axiom view'0_spec : forall self : FMap'0.t_FMap int32 int32 . [%#span40] mk'0 (view'0 self) = self
  
  function get'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : Option'0.t_Option int32 =
    [%#span41] Map.get (view'0 self) k
  
  function lookup_unsized'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : int32 =
    [%#span42] unwrap'0 (get'0 self k)
  
  function contains'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : bool =
    [%#span43] get'0 self k <> Option'0.C_None
  
  let rec get_ghost'0 (self:FMap'0.t_FMap int32 int32) (key:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] [%#span44] inv'6 key}
    any
    [ return' (result:Option'0.t_Option int32)-> {[%#span46] inv'8 result}
      {[%#span45] if contains'0 self key then
        match result with
          | Option'0.C_None -> false
          | Option'0.C_Some r -> lookup_unsized'0 self key = r
          end
      else
        result = Option'0.C_None
      }
      (! return' {result}) ]
    
  
  let rec contains_ghost'0 (self:FMap'0.t_FMap int32 int32) (key:int32) (return'  (ret:bool))= {[@expl:precondition] [%#span47] inv'6 key}
    any [ return' (result:bool)-> {[%#span48] contains'0 self key} (! return' {result}) ] 
  
  function len'0 (self : FMap'0.t_FMap int32 int32) : int
  
  axiom len'0_spec : forall self : FMap'0.t_FMap int32 int32 . [%#span49] len'0 self >= 0
  
  use map.Map
  
  function remove'0 (self : FMap'0.t_FMap int32 int32) (k : int32) : FMap'0.t_FMap int32 int32
  
  axiom remove'0_spec : forall self : FMap'0.t_FMap int32 int32, k : int32 . ([%#span51] len'0 (remove'0 self k)
  = (if contains'0 self k then len'0 self - 1 else len'0 self))
  && ([%#span50] view'0 (remove'0 self k) = Map.set (view'0 self) k (Option'0.C_None))
  
  let rec remove_ghost'0 (self:borrowed (FMap'0.t_FMap int32 int32)) (key:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] [%#span52] inv'6 key}
    any
    [ return' (result:Option'0.t_Option int32)-> {[%#span55] inv'3 result}
      {[%#span54] match get'0 self.current key with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some v -> result = Option'0.C_Some v
        end}
      {[%#span53] self.final = remove'0 self.current key}
      (! return' {result}) ]
    
  
  predicate resolve'4 (self : borrowed int32) =
    [%#span34] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed int32) =
    resolve'4 _1
  
  let rec get_mut'0 (self:borrowed (FMap'0.t_FMap int32 int32)) (key:int32) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] [%#span56] inv'6 key}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {[%#span60] inv'7 result}
      {[%#span59] len'0 self.current = len'0 self.final}
      {[%#span58] forall k : int32 . k <> key  -> get'0 self.current k = get'0 self.final k}
      {[%#span57] if contains'0 self.current key then
        match result with
          | Option'0.C_None -> false
          | Option'0.C_Some r -> lookup_unsized'0 self.current key = r.current
          /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = Option'0.C_None
      }
      (! return' {result}) ]
    
  
  function lookup'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : int32 =
    [%#span61] lookup_unsized'0 self k
  
  let rec len_ghost'0 (self:FMap'0.t_FMap int32 int32) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#span62] result = len'0 self} (! return' {result}) ]
    
  
  let rec deref'0 (self:GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) (return'  (ret:FMap'0.t_FMap int32 int32))= {[@expl:precondition] [%#span63] inv'4 self}
    any
    [ return' (result:FMap'0.t_FMap int32 int32)-> {[%#span65] inv'5 result}
      {[%#span64] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self = result}
      (! return' {result}) ]
    
  
  predicate resolve'3 (self : borrowed (FMap'0.t_FMap int32 int32)) =
    [%#span34] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (FMap'0.t_FMap int32 int32)) =
    resolve'3 _1
  
  function make_sized'0 (self : int32) : int32
  
  axiom make_sized'0_spec : forall self : int32 . [%#span66] make_sized'0 self = self
  
  function insert'0 (self : FMap'0.t_FMap int32 int32) (k : int32) (v : int32) : FMap'0.t_FMap int32 int32
  
  axiom insert'0_spec : forall self : FMap'0.t_FMap int32 int32, k : int32, v : int32 . ([%#span69] not contains'0 self k
   -> len'0 (insert'0 self k v) = len'0 self + 1)
  && ([%#span68] contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self)
  && ([%#span67] view'0 (insert'0 self k v) = Map.set (view'0 self) k (Option'0.C_Some (make_sized'0 v)))
  
  let rec insert_ghost'0 (self:borrowed (FMap'0.t_FMap int32 int32)) (key:int32) (value:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] [%#span71] inv'2 value}
    {[@expl:precondition] [%#span70] inv'2 key}
    any
    [ return' (result:Option'0.t_Option int32)-> {[%#span74] inv'3 result}
      {[%#span73] if contains'0 self.current key then
        result = Option'0.C_Some (lookup'0 self.current key)
      else
        result = Option'0.C_None
      }
      {[%#span72] self.final = insert'0 self.current key value}
      (! return' {result}) ]
    
  
  let rec deref_mut'0 (self:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) (return'  (ret:borrowed (FMap'0.t_FMap int32 int32)))= {[@expl:precondition] [%#span75] inv'0 self}
    any
    [ return' (result:borrowed (FMap'0.t_FMap int32 int32))-> {[%#span77] inv'1 result}
      {[%#span76] result
      = Borrow.borrow_logic (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.current) (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.final) (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
  
  function inner_logic'0 (self : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) : FMap'0.t_FMap int32 int32
  
  axiom inner_logic'0_spec : forall self : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) . [%#span78] inner_logic'0 self
  = T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self
  
  meta "compute_max_steps" 1000000
  
  let rec m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z (_1:Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) (return'  (ret:GhostBox'0.t_GhostBox ()))= bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map0] forall k : int32 . not contains'0 (inner_logic'0 (field_0'0 _1).current) k}
        s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_8 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_8} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_6 <- _ret' ] 
             [ &_7 <- { _7 with current = _ret'.final ; } ] 
            s1)
      | s1 = insert_ghost'0 {_6} {[%#sghost_map1] (1 : int32)} {[%#sghost_map2] (21 : int32)}
          (fun (_ret':Option'0.t_Option int32) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = -{resolve'0 _7}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_11 <- _ret' ] s2))
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 = len_ghost'0 {_11} (fun (_ret':int) ->  [ &length1 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map3] lookup'0 (inner_logic'0 (field_0'0 _1).current) (1 : int32)
        = (21 : int32)}
        s1
      | s1 = {[@expl:assertion] [%#sghost_map4] length1 = 1} s2
      | s2 =  [ &_20 <- (([%#sghost_map5] (1 : int32)), ([%#sghost_map6] (2 : int32)), ([%#sghost_map7] (3 : int32))) ] 
        s3
      | s3 =  [ &x1 <- let (r'0, _, _) = _20 in r'0 ] s4
      | s4 =  [ &x2 <- let (_, r'1, _) = _20 in r'1 ] s5
      | s5 =  [ &x3 <- let (_, _, r'2) = _20 in r'2 ] s6
      | s6 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'3:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'3.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_25 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'3 with current = _ret'.final ; }) ]
                
                s7))
      | s7 = deref_mut'0 {_25} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_24 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_24.current} {Borrow.get_id _24}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_23 <- _ret' ] 
             [ &_24 <- { _24 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_27 <- x1 ] s2
      | s2 = get_mut'0 {_23} {_27} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = any
      [ br0 -> {_22 = Option'0.C_None } (! bb9) | br1 (a:borrowed int32)-> {_22 = Option'0.C_Some a} (! bb7) ]
      
    | bb9 = s0
      [ s0 = -{match _22 with
          | Option'0.C_Some x'0 -> resolve'1 x'0
          | _ -> true
          end}-
        s1
      | s1 = -{resolve'0 _24}- s2
      | s2 = bb10 ]
      
    | bb7 = bb8
    | bb8 = s0
      [ s0 = Option'0.v_Some <borrowed int32> {_22} (fun (r0'0:borrowed int32) ->  [ &x <- r0'0 ] s1)
      | s1 =  [ &x <- { x with current = ([%#sghost_map8] (42 : int32)) ; } ] s2
      | s2 = -{resolve'1 x}- s3
      | s3 = -{resolve'0 _24}- s4
      | s4 = bb10 ]
      
    | bb10 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map9] lookup'0 (inner_logic'0 (field_0'0 _1).current) (1 : int32)
        = (42 : int32)}
        s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_35 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_35} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_34 <- _ret' ] s3)
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_33 <- _ret' ] 
             [ &_34 <- { _34 with current = _ret'.final ; } ] 
            s1)
      | s1 = insert_ghost'0 {_33} {[%#sghost_map10] (2 : int32)} {[%#sghost_map11] (50 : int32)}
          (fun (_ret':Option'0.t_Option int32) ->  [ &inserted_none <- _ret' ] s2)
      | s2 = bb12 ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 _34}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_39 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_39} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_38 <- _ret' ] s3)
      | s3 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_38.current} {Borrow.get_id _38}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_37 <- _ret' ] 
             [ &_38 <- { _38 with current = _ret'.final ; } ] 
            s1)
      | s1 = insert_ghost'0 {_37} {[%#sghost_map12] (2 : int32)} {[%#sghost_map13] (100 : int32)}
          (fun (_ret':Option'0.t_Option int32) ->  [ &inserted_some <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 = -{resolve'0 _38}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_42 <- _ret' ] s2))
      | s2 = bb15 ]
      
    | bb15 = s0 [ s0 = len_ghost'0 {_42} (fun (_ret':int) ->  [ &length2 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map14] inserted_none = Option'0.C_None} s1
      | s1 = {[@expl:assertion] [%#sghost_map15] inserted_some = Option'0.C_Some (50 : int32)} s2
      | s2 = {[@expl:assertion] [%#sghost_map16] length2 = 2} s3
      | s3 = {[@expl:assertion] [%#sghost_map17] lookup'0 (inner_logic'0 (field_0'0 _1).current) (2 : int32)
        = (100 : int32)}
        s4
      | s4 = {[@expl:assertion] [%#sghost_map18] lookup'0 (inner_logic'0 (field_0'0 _1).current) (1 : int32)
        = (42 : int32)}
        s5
      | s5 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_57 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s6))
      | s6 = deref_mut'0 {_57} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_56 <- _ret' ] s7)
      | s7 = bb17 ]
      
    | bb17 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_56.current} {Borrow.get_id _56}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_55 <- _ret' ] 
             [ &_56 <- { _56 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_59 <- x3 ] s2
      | s2 = remove_ghost'0 {_55} {_59} (fun (_ret':Option'0.t_Option int32) ->  [ &remove_none1 <- _ret' ] s3)
      | s3 = bb18 ]
      
    | bb18 = s0
      [ s0 = -{resolve'0 _56}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_63 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_63} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_62 <- _ret' ] s3)
      | s3 = bb19 ]
      
    | bb19 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_62.current} {Borrow.get_id _62}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_61 <- _ret' ] 
             [ &_62 <- { _62 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_65 <- x2 ] s2
      | s2 = remove_ghost'0 {_61} {_65} (fun (_ret':Option'0.t_Option int32) ->  [ &remove_some <- _ret' ] s3)
      | s3 = bb20 ]
      
    | bb20 = s0
      [ s0 = -{resolve'0 _62}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_final <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current} {Borrow.get_id r'0}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_69 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_69} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_68 <- _ret' ] s3)
      | s3 = bb21 ]
      
    | bb21 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_68.current} {Borrow.get_id _68}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_67 <- _ret' ] 
             [ &_68 <- { _68 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_71 <- x2 ] s2
      | s2 = remove_ghost'0 {_67} {_71} (fun (_ret':Option'0.t_Option int32) ->  [ &remove_none2 <- _ret' ] s3)
      | s3 = bb22 ]
      
    | bb22 = s0
      [ s0 = -{resolve'0 _68}- s1
      | s1 = {[@expl:assertion] [%#sghost_map19] remove_none1 = Option'0.C_None} s2
      | s2 = {[@expl:assertion] [%#sghost_map20] remove_some = Option'0.C_Some (100 : int32)} s3
      | s3 = {[@expl:assertion] [%#sghost_map21] remove_none2 = Option'0.C_None} s4
      | s4 = {[@expl:assertion] [%#sghost_map22] get'0 (inner_logic'0 (field_0'0 _1).current) (2 : int32)
        = Option'0.C_None}
        s5
      | s5 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_82 <- _ret' ] s6))
      | s6 = bb23 ]
      
    | bb23 = s0
      [ s0 =  [ &_85 <- x1 ] s1
      | s1 = contains_ghost'0 {_82} {_85} (fun (_ret':bool) ->  [ &contains1 <- _ret' ] s2)
      | s2 = bb24 ]
      
    | bb24 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_88 <- _ret' ] s1))
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 =  [ &_91 <- x2 ] s1
      | s1 = contains_ghost'0 {_88} {_91} (fun (_ret':bool) ->  [ &contains2 <- _ret' ] s2)
      | s2 = bb26 ]
      
    | bb26 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_94 <- _ret' ] s1))
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &_97 <- x3 ] s1
      | s1 = contains_ghost'0 {_94} {_97} (fun (_ret':bool) ->  [ &contains3 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map23] contains1} s1
      | s1 = {[@expl:assertion] [%#sghost_map24] not contains2} s2
      | s2 = {[@expl:assertion] [%#sghost_map25] not contains3} s3
      | s3 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_106 <- _ret' ] s4))
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &_109 <- x1 ] s1
      | s1 = get_ghost'0 {_106} {_109} (fun (_ret':Option'0.t_Option int32) ->  [ &get1 <- _ret' ] s2)
      | s2 = bb30 ]
      
    | bb30 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_112 <- _ret' ] s1))
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 =  [ &_115 <- x2 ] s1
      | s1 = get_ghost'0 {_112} {_115} (fun (_ret':Option'0.t_Option int32) ->  [ &get2 <- _ret' ] s2)
      | s2 = bb32 ]
      
    | bb32 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_118 <- _ret' ] s1))
      | s1 = bb33 ]
      
    | bb33 = s0
      [ s0 =  [ &_121 <- x3 ] s1
      | s1 = get_ghost'0 {_118} {_121} (fun (_ret':Option'0.t_Option int32) ->  [ &get3 <- _ret' ] s2)
      | s2 = bb34 ]
      
    | bb34 = s0
      [ s0 = -{resolve'2 _1}- s1
      | s1 = {[@expl:assertion] [%#sghost_map26] get1 = Option'0.C_Some (42 : int32)} s2
      | s2 = {[@expl:assertion] [%#sghost_map27] get2 = Option'0.C_None} s3
      | s3 = {[@expl:assertion] [%#sghost_map28] get3 = Option'0.C_None} s4
      | s4 = new'0 {_2} (fun (_ret':GhostBox'0.t_GhostBox ()) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb35 ]
      
    | bb35 = return' {_0} ]
    
    [ & _0 : GhostBox'0.t_GhostBox () = any_l ()
    | & _1 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z = _1
    | & _2 : () = any_l ()
    | & _5 : Option'0.t_Option int32 = any_l ()
    | & _6 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _7 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _8 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & length1 : int = any_l ()
    | & _11 : FMap'0.t_FMap int32 int32 = any_l ()
    | & x1 : int32 = any_l ()
    | & x2 : int32 = any_l ()
    | & x3 : int32 = any_l ()
    | & _20 : (int32, int32, int32) = any_l ()
    | & _22 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _23 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _24 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _25 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _27 : int32 = any_l ()
    | & x : borrowed int32 = any_l ()
    | & inserted_none : Option'0.t_Option int32 = any_l ()
    | & _33 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _34 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _35 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & inserted_some : Option'0.t_Option int32 = any_l ()
    | & _37 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _38 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _39 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & length2 : int = any_l ()
    | & _42 : FMap'0.t_FMap int32 int32 = any_l ()
    | & remove_none1 : Option'0.t_Option int32 = any_l ()
    | & _55 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _56 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _57 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _59 : int32 = any_l ()
    | & remove_some : Option'0.t_Option int32 = any_l ()
    | & _61 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _62 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _63 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _65 : int32 = any_l ()
    | & remove_none2 : Option'0.t_Option int32 = any_l ()
    | & _67 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _68 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _69 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _71 : int32 = any_l ()
    | & contains1 : bool = any_l ()
    | & _82 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _85 : int32 = any_l ()
    | & contains2 : bool = any_l ()
    | & _88 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _91 : int32 = any_l ()
    | & contains3 : bool = any_l ()
    | & _94 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _97 : int32 = any_l ()
    | & get1 : Option'0.t_Option int32 = any_l ()
    | & _106 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _109 : int32 = any_l ()
    | & get2 : Option'0.t_Option int32 = any_l ()
    | & _112 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _115 : int32 = any_l ()
    | & get3 : Option'0.t_Option int32 = any_l ()
    | & _118 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _121 : int32 = any_l () ]
     [ return' (result:GhostBox'0.t_GhostBox ())-> return' {result} ] 
end
module M_ghost_map__ghost_map [#"ghost_map.rs" 4 0 4 18]
  let%span sghost_map0 = "ghost_map.rs" 5 18 5 41
  let%span span1 = "../../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span2 = "../../../../creusot-contracts/src/invariant.rs" 34 20 34 44
  let%span span3 = "../../../../creusot-contracts/src/ghost.rs" 146 15 146 16
  let%span span4 = "../../../../creusot-contracts/src/ghost.rs" 144 14 144 28
  let%span span5 = "../../../../creusot-contracts/src/ghost.rs" 146 4 146 28
  let%span span6 = "../../../../creusot-contracts/src/resolve.rs" 41 20 41 34
  let%span span7 = "../../../../creusot-contracts/src/util.rs" 25 11 25 16
  let%span span8 = "../../../../creusot-contracts/src/util.rs" 26 10 26 15
  let%span span9 = "../../../../creusot-contracts/src/util.rs" 27 10 27 11
  let%span span10 = "../../../../creusot-contracts/src/util.rs" 34 11 34 21
  let%span span11 = "../../../../creusot-contracts/src/util.rs" 35 10 35 28
  let%span span12 = "../../../../creusot-contracts/src/logic/fmap.rs" 47 14 47 38
  let%span span13 = "../../../../creusot-contracts/src/logic/fmap.rs" 75 8 75 26
  let%span span14 = "../../../../creusot-contracts/src/logic/fmap.rs" 82 8 82 27
  let%span span15 = "../../../../creusot-contracts/src/logic/fmap.rs" 99 8 99 27
  let%span span16 = "../../../../creusot-contracts/src/logic/fmap.rs" 264 28 264 31
  let%span span17 = "../../../../creusot-contracts/src/logic/fmap.rs" 256 4 263 11
  let%span span18 = "../../../../creusot-contracts/src/logic/fmap.rs" 264 4 264 50
  let%span span19 = "../../../../creusot-contracts/src/logic/fmap.rs" 235 33 235 36
  let%span span20 = "../../../../creusot-contracts/src/logic/fmap.rs" 234 14 234 33
  let%span span21 = "../../../../creusot-contracts/src/logic/fmap.rs" 32 14 32 25
  let%span span22 = "../../../../creusot-contracts/src/logic/fmap.rs" 65 14 65 55
  let%span span23 = "../../../../creusot-contracts/src/logic/fmap.rs" 66 14 66 84
  let%span span24 = "../../../../creusot-contracts/src/logic/fmap.rs" 374 35 374 38
  let%span span25 = "../../../../creusot-contracts/src/logic/fmap.rs" 369 14 369 40
  let%span span26 = "../../../../creusot-contracts/src/logic/fmap.rs" 370 14 373 9
  let%span span27 = "../../../../creusot-contracts/src/logic/fmap.rs" 374 4 376 17
  let%span span28 = "../../../../creusot-contracts/src/logic/fmap.rs" 297 30 297 33
  let%span span29 = "../../../../creusot-contracts/src/logic/fmap.rs" 286 4 294 11
  let%span span30 = "../../../../creusot-contracts/src/logic/fmap.rs" 295 4 295 75
  let%span span31 = "../../../../creusot-contracts/src/logic/fmap.rs" 296 14 296 44
  let%span span32 = "../../../../creusot-contracts/src/logic/fmap.rs" 297 4 297 56
  let%span span33 = "../../../../creusot-contracts/src/logic/fmap.rs" 92 9 92 31
  let%span span34 = "../../../../creusot-contracts/src/logic/fmap.rs" 214 14 214 34
  let%span span35 = "../../../../creusot-contracts/src/ghost.rs" 51 14 51 18
  let%span span36 = "../../../../creusot-contracts/src/ghost.rs" 50 14 50 35
  let%span span37 = "../../../../creusot-contracts/src/ghost.rs" 51 4 51 36
  let%span span38 = "../../../../creusot-contracts/src/util.rs" 15 14 15 30
  let%span span39 = "../../../../creusot-contracts/src/logic/fmap.rs" 55 14 55 71
  let%span span40 = "../../../../creusot-contracts/src/logic/fmap.rs" 56 4 56 63
  let%span span41 = "../../../../creusot-contracts/src/logic/fmap.rs" 57 4 57 68
  let%span span42 = "../../../../creusot-contracts/src/logic/fmap.rs" 328 35 328 38
  let%span span43 = "../../../../creusot-contracts/src/logic/fmap.rs" 328 43 328 48
  let%span span44 = "../../../../creusot-contracts/src/logic/fmap.rs" 322 14 322 46
  let%span span45 = "../../../../creusot-contracts/src/logic/fmap.rs" 323 4 327 11
  let%span span46 = "../../../../creusot-contracts/src/logic/fmap.rs" 328 4 330 17
  let%span span47 = "../../../../creusot-contracts/src/ghost.rs" 66 22 66 26
  let%span span48 = "../../../../creusot-contracts/src/ghost.rs" 65 14 65 36
  let%span span49 = "../../../../creusot-contracts/src/ghost.rs" 66 4 66 48
  let%span span50 = "../../../../creusot-contracts/src/ghost.rs" 179 14 179 31
  let%span span51 = "ghost_map.rs" 7 8 7 54
  let%span span52 = "ghost_map.rs" 8 25 8 26
  let%span span53 = "ghost_map.rs" 8 28 8 30
  let%span span54 = "ghost_map.rs" 10 22 10 47
  let%span span55 = "ghost_map.rs" 11 22 11 34
  let%span span56 = "ghost_map.rs" 12 28 12 29
  let%span span57 = "ghost_map.rs" 12 31 12 32
  let%span span58 = "ghost_map.rs" 12 34 12 35
  let%span span59 = "ghost_map.rs" 14 17 14 19
  let%span span60 = "ghost_map.rs" 16 22 16 47
  let%span span61 = "ghost_map.rs" 18 45 18 46
  let%span span62 = "ghost_map.rs" 18 48 18 50
  let%span span63 = "ghost_map.rs" 19 45 19 46
  let%span span64 = "ghost_map.rs" 19 48 19 51
  let%span span65 = "ghost_map.rs" 21 22 21 43
  let%span span66 = "ghost_map.rs" 22 22 22 50
  let%span span67 = "ghost_map.rs" 23 22 23 34
  let%span span68 = "ghost_map.rs" 24 22 24 48
  let%span span69 = "ghost_map.rs" 25 22 25 47
  let%span span70 = "ghost_map.rs" 30 22 30 42
  let%span span71 = "ghost_map.rs" 31 22 31 49
  let%span span72 = "ghost_map.rs" 32 22 32 42
  let%span span73 = "ghost_map.rs" 33 22 33 43
  let%span span74 = "ghost_map.rs" 38 22 38 31
  let%span span75 = "ghost_map.rs" 39 22 39 32
  let%span span76 = "ghost_map.rs" 40 22 40 32
  let%span span77 = "ghost_map.rs" 45 22 45 42
  let%span span78 = "ghost_map.rs" 46 22 46 34
  let%span span79 = "ghost_map.rs" 47 22 47 34
  let%span span80 = "../../../../creusot-contracts/src/logic/fmap.rs" 175 4 175 40
  let%span span81 = "../../../../creusot-contracts/src/logic/fmap.rs" 176 4 176 69
  let%span span82 = "../../../../creusot-contracts/src/logic/fmap.rs" 178 8 178 35
  let%span span83 = "../../../../creusot-contracts/src/logic/fmap.rs" 105 14 105 31
  let%span span84 = "../../../../creusot-contracts/src/logic/fmap.rs" 106 14 106 49
  let%span span85 = "../../../../creusot-contracts/src/logic/fmap.rs" 114 8 114 34
  let%span span86 = "../../../../creusot-contracts/src/logic/fmap.rs" 187 14 187 31
  
  use prelude.prelude.Int32
  
  use T_creusot_contracts__logic__fmap__FMap as FMap'0
  
  predicate inv'12 (_1 : FMap'0.t_FMap int32 int32)
  
  axiom inv_axiom'12 [@rewrite] : forall x : FMap'0.t_FMap int32 int32 [inv'12 x] . inv'12 x = true
  
  use T_creusot_contracts__ghost__GhostBox as GhostBox'0
  
  predicate inv'11 (_1 : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))
  
  axiom inv_axiom'11 [@rewrite] : forall x : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) [inv'11 x] . inv'11 x
  = true
  
  predicate inv'10 (_1 : GhostBox'0.t_GhostBox ())
  
  axiom inv_axiom'10 [@rewrite] : forall x : GhostBox'0.t_GhostBox () [inv'10 x] . inv'10 x = true
  
  predicate inv'9 (_1 : ())
  
  axiom inv_axiom'9 [@rewrite] : forall x : () [inv'9 x] . inv'9 x = true
  
  use T_core__option__Option as Option'0
  
  predicate inv'8 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'8 [@rewrite] : forall x : Option'0.t_Option int32 [inv'8 x] . inv'8 x = true
  
  use prelude.prelude.Borrow
  
  predicate inv'7 (_1 : Option'0.t_Option (borrowed int32))
  
  axiom inv_axiom'7 [@rewrite] : forall x : Option'0.t_Option (borrowed int32) [inv'7 x] . inv'7 x = true
  
  predicate inv'2 (_1 : int32)
  
  predicate invariant'6 (self : int32) =
    [%#span1] inv'2 self
  
  predicate inv'6 (_1 : int32)
  
  axiom inv_axiom'6 [@rewrite] : forall x : int32 [inv'6 x] . inv'6 x = true
  
  predicate invariant'5 (self : FMap'0.t_FMap int32 int32) =
    [%#span1] inv'12 self
  
  predicate inv'5 (_1 : FMap'0.t_FMap int32 int32)
  
  axiom inv_axiom'5 [@rewrite] : forall x : FMap'0.t_FMap int32 int32 [inv'5 x] . inv'5 x = true
  
  predicate invariant'4 (self : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) =
    [%#span1] inv'11 self
  
  predicate inv'4 (_1 : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))
  
  axiom inv_axiom'4 [@rewrite] : forall x : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) [inv'4 x] . inv'4 x = true
  
  predicate inv'3 (_1 : Option'0.t_Option int32)
  
  axiom inv_axiom'3 [@rewrite] : forall x : Option'0.t_Option int32 [inv'3 x] . inv'3 x = true
  
  axiom inv_axiom'2 [@rewrite] : forall x : int32 [inv'2 x] . inv'2 x = true
  
  predicate invariant'1 (self : borrowed (FMap'0.t_FMap int32 int32)) =
    [%#span2] inv'12 self.current /\ inv'12 self.final
  
  predicate inv'1 (_1 : borrowed (FMap'0.t_FMap int32 int32))
  
  axiom inv_axiom'1 [@rewrite] : forall x : borrowed (FMap'0.t_FMap int32 int32) [inv'1 x] . inv'1 x = true
  
  predicate invariant'0 (self : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) =
    [%#span2] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'0 (_1 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)))
  
  axiom inv_axiom'0 [@rewrite] : forall x : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) [inv'0 x] . inv'0 x
  = true
  
  use prelude.prelude.Intrinsic
  
  use T_creusot_contracts__ghost__GhostBox as T_creusot_contracts__ghost__GhostBox
  
  let rec new'1 (x:()) (return'  (ret:GhostBox'0.t_GhostBox ()))= {[@expl:precondition] [%#span3] inv'9 x}
    any
    [ return' (result:GhostBox'0.t_GhostBox ())-> {[%#span5] inv'10 result}
      {[%#span4] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 result = x}
      (! return' {result}) ]
    
  
  predicate resolve'7 (self : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) =
    [%#span6] self.final = self.current
  
  predicate resolve'6 (_1 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) =
    resolve'7 _1
  
  use prelude.prelude.Int
  
  use M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z_Type as Closure'0
  
  function field_0'0 [#"ghost_map.rs" 6 4 48 5] (self : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))
    
   =
    let Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z a = self in a
  
  predicate resolve'5 [#"ghost_map.rs" 6 4 48 5] (_1 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) =
    resolve'6 (field_0'0 _1)
  
  predicate resolve'2 (_1 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) =
    resolve'5 _1
  
  function unreachable'0 (_1 : ()) : int32
  
  axiom unreachable'0_spec : forall _1 : () . ([%#span7] false)  -> ([%#span8] false)
  
  function unwrap'0 (op : Option'0.t_Option int32) : int32
  
  axiom unwrap'0_spec : forall op : Option'0.t_Option int32 . ([%#span10] op <> Option'0.C_None)
   -> ([%#span11] Option'0.C_Some (unwrap'0 op) = op)
  
  use map.Map
  
  use map.Map
  
  function mk'0 (_m : Map.map int32 (Option'0.t_Option int32)) : FMap'0.t_FMap int32 int32
  
  function view'0 (self : FMap'0.t_FMap int32 int32) : Map.map int32 (Option'0.t_Option int32)
  
  axiom view'0_spec : forall self : FMap'0.t_FMap int32 int32 . [%#span12] mk'0 (view'0 self) = self
  
  function get'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : Option'0.t_Option int32 =
    [%#span13] Map.get (view'0 self) k
  
  function lookup_unsized'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : int32 =
    [%#span14] unwrap'0 (get'0 self k)
  
  function contains'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : bool =
    [%#span15] get'0 self k <> Option'0.C_None
  
  let rec get_ghost'0 (self:FMap'0.t_FMap int32 int32) (key:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] [%#span16] inv'6 key}
    any
    [ return' (result:Option'0.t_Option int32)-> {[%#span18] inv'8 result}
      {[%#span17] if contains'0 self key then
        match result with
          | Option'0.C_None -> false
          | Option'0.C_Some r -> lookup_unsized'0 self key = r
          end
      else
        result = Option'0.C_None
      }
      (! return' {result}) ]
    
  
  let rec contains_ghost'0 (self:FMap'0.t_FMap int32 int32) (key:int32) (return'  (ret:bool))= {[@expl:precondition] [%#span19] inv'6 key}
    any [ return' (result:bool)-> {[%#span20] contains'0 self key} (! return' {result}) ] 
  
  function len'0 (self : FMap'0.t_FMap int32 int32) : int
  
  axiom len'0_spec : forall self : FMap'0.t_FMap int32 int32 . [%#span21] len'0 self >= 0
  
  use map.Map
  
  function remove'0 (self : FMap'0.t_FMap int32 int32) (k : int32) : FMap'0.t_FMap int32 int32
  
  axiom remove'0_spec : forall self : FMap'0.t_FMap int32 int32, k : int32 . ([%#span23] len'0 (remove'0 self k)
  = (if contains'0 self k then len'0 self - 1 else len'0 self))
  && ([%#span22] view'0 (remove'0 self k) = Map.set (view'0 self) k (Option'0.C_None))
  
  let rec remove_ghost'0 (self:borrowed (FMap'0.t_FMap int32 int32)) (key:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] [%#span24] inv'6 key}
    any
    [ return' (result:Option'0.t_Option int32)-> {[%#span27] inv'3 result}
      {[%#span26] match get'0 self.current key with
        | Option'0.C_None -> result = Option'0.C_None
        | Option'0.C_Some v -> result = Option'0.C_Some v
        end}
      {[%#span25] self.final = remove'0 self.current key}
      (! return' {result}) ]
    
  
  predicate resolve'4 (self : borrowed int32) =
    [%#span6] self.final = self.current
  
  predicate resolve'1 (_1 : borrowed int32) =
    resolve'4 _1
  
  let rec get_mut'0 (self:borrowed (FMap'0.t_FMap int32 int32)) (key:int32) (return'  (ret:Option'0.t_Option (borrowed int32)))= {[@expl:precondition] [%#span28] inv'6 key}
    any
    [ return' (result:Option'0.t_Option (borrowed int32))-> {[%#span32] inv'7 result}
      {[%#span31] len'0 self.current = len'0 self.final}
      {[%#span30] forall k : int32 . k <> key  -> get'0 self.current k = get'0 self.final k}
      {[%#span29] if contains'0 self.current key then
        match result with
          | Option'0.C_None -> false
          | Option'0.C_Some r -> lookup_unsized'0 self.current key = r.current
          /\ lookup_unsized'0 self.final key = r.final
          end
      else
        result = Option'0.C_None
      }
      (! return' {result}) ]
    
  
  function lookup'0 [@inline:trivial] (self : FMap'0.t_FMap int32 int32) (k : int32) : int32 =
    [%#span33] lookup_unsized'0 self k
  
  let rec len_ghost'0 (self:FMap'0.t_FMap int32 int32) (return'  (ret:int))= any
    [ return' (result:int)-> {[%#span34] result = len'0 self} (! return' {result}) ]
    
  
  let rec deref'0 (self:GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) (return'  (ret:FMap'0.t_FMap int32 int32))= {[@expl:precondition] [%#span35] inv'4 self}
    any
    [ return' (result:FMap'0.t_FMap int32 int32)-> {[%#span37] inv'5 result}
      {[%#span36] T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self = result}
      (! return' {result}) ]
    
  
  predicate resolve'3 (self : borrowed (FMap'0.t_FMap int32 int32)) =
    [%#span6] self.final = self.current
  
  predicate resolve'0 (_1 : borrowed (FMap'0.t_FMap int32 int32)) =
    resolve'3 _1
  
  function make_sized'0 (self : int32) : int32
  
  axiom make_sized'0_spec : forall self : int32 . [%#span38] make_sized'0 self = self
  
  function insert'0 (self : FMap'0.t_FMap int32 int32) (k : int32) (v : int32) : FMap'0.t_FMap int32 int32
  
  axiom insert'0_spec : forall self : FMap'0.t_FMap int32 int32, k : int32, v : int32 . ([%#span41] not contains'0 self k
   -> len'0 (insert'0 self k v) = len'0 self + 1)
  && ([%#span40] contains'0 self k  -> len'0 (insert'0 self k v) = len'0 self)
  && ([%#span39] view'0 (insert'0 self k v) = Map.set (view'0 self) k (Option'0.C_Some (make_sized'0 v)))
  
  let rec insert_ghost'0 (self:borrowed (FMap'0.t_FMap int32 int32)) (key:int32) (value:int32) (return'  (ret:Option'0.t_Option int32))= {[@expl:precondition] [%#span43] inv'2 value}
    {[@expl:precondition] [%#span42] inv'2 key}
    any
    [ return' (result:Option'0.t_Option int32)-> {[%#span46] inv'3 result}
      {[%#span45] if contains'0 self.current key then
        result = Option'0.C_Some (lookup'0 self.current key)
      else
        result = Option'0.C_None
      }
      {[%#span44] self.final = insert'0 self.current key value}
      (! return' {result}) ]
    
  
  let rec deref_mut'0 (self:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) (return'  (ret:borrowed (FMap'0.t_FMap int32 int32)))= {[@expl:precondition] [%#span47] inv'0 self}
    any
    [ return' (result:borrowed (FMap'0.t_FMap int32 int32))-> {[%#span49] inv'1 result}
      {[%#span48] result
      = Borrow.borrow_logic (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.current) (T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self.final) (Borrow.inherit_id (Borrow.get_id self) 1)}
      (! return' {result}) ]
    
  
  function inner_logic'0 (self : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) : FMap'0.t_FMap int32 int32
  
  axiom inner_logic'0_spec : forall self : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) . [%#span50] inner_logic'0 self
  = T_creusot_contracts__ghost__GhostBox.t_GhostBox__0 self
  
  let rec closure0'0 (_1:Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z) (return'  (ret:GhostBox'0.t_GhostBox ()))= bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#span51] forall k : int32 . not contains'0 (inner_logic'0 (field_0'0 _1).current) k}
        s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_8 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_8} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_7.current} {Borrow.get_id _7}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_6 <- _ret' ] 
             [ &_7 <- { _7 with current = _ret'.final ; } ] 
            s1)
      | s1 = insert_ghost'0 {_6} {[%#span52] (1 : int32)} {[%#span53] (21 : int32)}
          (fun (_ret':Option'0.t_Option int32) ->  [ &_5 <- _ret' ] s2)
      | s2 = bb2 ]
      
    | bb2 = s0
      [ s0 = -{resolve'0 _7}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_11 <- _ret' ] s2))
      | s2 = bb3 ]
      
    | bb3 = s0 [ s0 = len_ghost'0 {_11} (fun (_ret':int) ->  [ &length1 <- _ret' ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:assertion] [%#span54] lookup'0 (inner_logic'0 (field_0'0 _1).current) (1 : int32) = (21 : int32)}
        s1
      | s1 = {[@expl:assertion] [%#span55] length1 = 1} s2
      | s2 =  [ &_20 <- (([%#span56] (1 : int32)), ([%#span57] (2 : int32)), ([%#span58] (3 : int32))) ] s3
      | s3 =  [ &x1 <- let (r'0, _, _) = _20 in r'0 ] s4
      | s4 =  [ &x2 <- let (_, r'1, _) = _20 in r'1 ] s5
      | s5 =  [ &x3 <- let (_, _, r'2) = _20 in r'2 ] s6
      | s6 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'3:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'3.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_25 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'3 with current = _ret'.final ; }) ]
                
                s7))
      | s7 = deref_mut'0 {_25} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_24 <- _ret' ] s8)
      | s8 = bb5 ]
      
    | bb5 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_24.current} {Borrow.get_id _24}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_23 <- _ret' ] 
             [ &_24 <- { _24 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_27 <- x1 ] s2
      | s2 = get_mut'0 {_23} {_27} (fun (_ret':Option'0.t_Option (borrowed int32)) ->  [ &_22 <- _ret' ] s3)
      | s3 = bb6 ]
      
    | bb6 = any
      [ br0 -> {_22 = Option'0.C_None } (! bb9) | br1 (a:borrowed int32)-> {_22 = Option'0.C_Some a} (! bb7) ]
      
    | bb9 = s0
      [ s0 = -{match _22 with
          | Option'0.C_Some x'0 -> resolve'1 x'0
          | _ -> true
          end}-
        s1
      | s1 = -{resolve'0 _24}- s2
      | s2 = bb10 ]
      
    | bb7 = bb8
    | bb8 = s0
      [ s0 = Option'0.v_Some <borrowed int32> {_22} (fun (r0'0:borrowed int32) ->  [ &x <- r0'0 ] s1)
      | s1 =  [ &x <- { x with current = ([%#span59] (42 : int32)) ; } ] s2
      | s2 = -{resolve'1 x}- s3
      | s3 = -{resolve'0 _24}- s4
      | s4 = bb10 ]
      
    | bb10 = s0
      [ s0 = {[@expl:assertion] [%#span60] lookup'0 (inner_logic'0 (field_0'0 _1).current) (1 : int32) = (42 : int32)}
        s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_35 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_35} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_34 <- _ret' ] s3)
      | s3 = bb11 ]
      
    | bb11 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_34.current} {Borrow.get_id _34}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_33 <- _ret' ] 
             [ &_34 <- { _34 with current = _ret'.final ; } ] 
            s1)
      | s1 = insert_ghost'0 {_33} {[%#span61] (2 : int32)} {[%#span62] (50 : int32)}
          (fun (_ret':Option'0.t_Option int32) ->  [ &inserted_none <- _ret' ] s2)
      | s2 = bb12 ]
      
    | bb12 = s0
      [ s0 = -{resolve'0 _34}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_39 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_39} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_38 <- _ret' ] s3)
      | s3 = bb13 ]
      
    | bb13 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_38.current} {Borrow.get_id _38}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_37 <- _ret' ] 
             [ &_38 <- { _38 with current = _ret'.final ; } ] 
            s1)
      | s1 = insert_ghost'0 {_37} {[%#span63] (2 : int32)} {[%#span64] (100 : int32)}
          (fun (_ret':Option'0.t_Option int32) ->  [ &inserted_some <- _ret' ] s2)
      | s2 = bb14 ]
      
    | bb14 = s0
      [ s0 = -{resolve'0 _38}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_42 <- _ret' ] s2))
      | s2 = bb15 ]
      
    | bb15 = s0 [ s0 = len_ghost'0 {_42} (fun (_ret':int) ->  [ &length2 <- _ret' ] s1) | s1 = bb16 ] 
    | bb16 = s0
      [ s0 = {[@expl:assertion] [%#span65] inserted_none = Option'0.C_None} s1
      | s1 = {[@expl:assertion] [%#span66] inserted_some = Option'0.C_Some (50 : int32)} s2
      | s2 = {[@expl:assertion] [%#span67] length2 = 2} s3
      | s3 = {[@expl:assertion] [%#span68] lookup'0 (inner_logic'0 (field_0'0 _1).current) (2 : int32) = (100 : int32)}
        s4
      | s4 = {[@expl:assertion] [%#span69] lookup'0 (inner_logic'0 (field_0'0 _1).current) (1 : int32) = (42 : int32)}
        s5
      | s5 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_57 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s6))
      | s6 = deref_mut'0 {_57} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_56 <- _ret' ] s7)
      | s7 = bb17 ]
      
    | bb17 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_56.current} {Borrow.get_id _56}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_55 <- _ret' ] 
             [ &_56 <- { _56 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_59 <- x3 ] s2
      | s2 = remove_ghost'0 {_55} {_59} (fun (_ret':Option'0.t_Option int32) ->  [ &remove_none1 <- _ret' ] s3)
      | s3 = bb18 ]
      
    | bb18 = s0
      [ s0 = -{resolve'0 _56}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_63 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_63} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_62 <- _ret' ] s3)
      | s3 = bb19 ]
      
    | bb19 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_62.current} {Borrow.get_id _62}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_61 <- _ret' ] 
             [ &_62 <- { _62 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_65 <- x2 ] s2
      | s2 = remove_ghost'0 {_61} {_65} (fun (_ret':Option'0.t_Option int32) ->  [ &remove_some <- _ret' ] s3)
      | s3 = bb20 ]
      
    | bb20 = s0
      [ s0 = -{resolve'0 _62}- s1
      | s1 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            Borrow.borrow_final <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {r'0.current} {Borrow.get_id r'0}
              (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
                 [ &_69 <- _ret' ] 
                
                [ &_1 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z ({ r'0 with current = _ret'.final ; }) ]
                
                s2))
      | s2 = deref_mut'0 {_69} (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->  [ &_68 <- _ret' ] s3)
      | s3 = bb21 ]
      
    | bb21 = s0
      [ s0 = Borrow.borrow_final <FMap'0.t_FMap int32 int32> {_68.current} {Borrow.get_id _68}
          (fun (_ret':borrowed (FMap'0.t_FMap int32 int32)) ->
             [ &_67 <- _ret' ] 
             [ &_68 <- { _68 with current = _ret'.final ; } ] 
            s1)
      | s1 =  [ &_71 <- x2 ] s2
      | s2 = remove_ghost'0 {_67} {_71} (fun (_ret':Option'0.t_Option int32) ->  [ &remove_none2 <- _ret' ] s3)
      | s3 = bb22 ]
      
    | bb22 = s0
      [ s0 = -{resolve'0 _68}- s1
      | s1 = {[@expl:assertion] [%#span70] remove_none1 = Option'0.C_None} s2
      | s2 = {[@expl:assertion] [%#span71] remove_some = Option'0.C_Some (100 : int32)} s3
      | s3 = {[@expl:assertion] [%#span72] remove_none2 = Option'0.C_None} s4
      | s4 = {[@expl:assertion] [%#span73] get'0 (inner_logic'0 (field_0'0 _1).current) (2 : int32) = Option'0.C_None}
        s5
      | s5 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_82 <- _ret' ] s6))
      | s6 = bb23 ]
      
    | bb23 = s0
      [ s0 =  [ &_85 <- x1 ] s1
      | s1 = contains_ghost'0 {_82} {_85} (fun (_ret':bool) ->  [ &contains1 <- _ret' ] s2)
      | s2 = bb24 ]
      
    | bb24 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_88 <- _ret' ] s1))
      | s1 = bb25 ]
      
    | bb25 = s0
      [ s0 =  [ &_91 <- x2 ] s1
      | s1 = contains_ghost'0 {_88} {_91} (fun (_ret':bool) ->  [ &contains2 <- _ret' ] s2)
      | s2 = bb26 ]
      
    | bb26 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_94 <- _ret' ] s1))
      | s1 = bb27 ]
      
    | bb27 = s0
      [ s0 =  [ &_97 <- x3 ] s1
      | s1 = contains_ghost'0 {_94} {_97} (fun (_ret':bool) ->  [ &contains3 <- _ret' ] s2)
      | s2 = bb28 ]
      
    | bb28 = s0
      [ s0 = {[@expl:assertion] [%#span74] contains1} s1
      | s1 = {[@expl:assertion] [%#span75] not contains2} s2
      | s2 = {[@expl:assertion] [%#span76] not contains3} s3
      | s3 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_106 <- _ret' ] s4))
      | s4 = bb29 ]
      
    | bb29 = s0
      [ s0 =  [ &_109 <- x1 ] s1
      | s1 = get_ghost'0 {_106} {_109} (fun (_ret':Option'0.t_Option int32) ->  [ &get1 <- _ret' ] s2)
      | s2 = bb30 ]
      
    | bb30 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_112 <- _ret' ] s1))
      | s1 = bb31 ]
      
    | bb31 = s0
      [ s0 =  [ &_115 <- x2 ] s1
      | s1 = get_ghost'0 {_112} {_115} (fun (_ret':Option'0.t_Option int32) ->  [ &get2 <- _ret' ] s2)
      | s2 = bb32 ]
      
    | bb32 = s0
      [ s0 = Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z {_1}
          (fun (r'0:borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
            deref'0 {r'0.current} (fun (_ret':FMap'0.t_FMap int32 int32) ->  [ &_118 <- _ret' ] s1))
      | s1 = bb33 ]
      
    | bb33 = s0
      [ s0 =  [ &_121 <- x3 ] s1
      | s1 = get_ghost'0 {_118} {_121} (fun (_ret':Option'0.t_Option int32) ->  [ &get3 <- _ret' ] s2)
      | s2 = bb34 ]
      
    | bb34 = s0
      [ s0 = -{resolve'2 _1}- s1
      | s1 = {[@expl:assertion] [%#span77] get1 = Option'0.C_Some (42 : int32)} s2
      | s2 = {[@expl:assertion] [%#span78] get2 = Option'0.C_None} s3
      | s3 = {[@expl:assertion] [%#span79] get3 = Option'0.C_None} s4
      | s4 = new'1 {_2} (fun (_ret':GhostBox'0.t_GhostBox ()) ->  [ &_0 <- _ret' ] s5)
      | s5 = bb35 ]
      
    | bb35 = return' {_0} ]
    
    [ & _0 : GhostBox'0.t_GhostBox () = any_l ()
    | & _1 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z = _1
    | & _2 : () = any_l ()
    | & _5 : Option'0.t_Option int32 = any_l ()
    | & _6 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _7 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _8 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & length1 : int = any_l ()
    | & _11 : FMap'0.t_FMap int32 int32 = any_l ()
    | & x1 : int32 = any_l ()
    | & x2 : int32 = any_l ()
    | & x3 : int32 = any_l ()
    | & _20 : (int32, int32, int32) = any_l ()
    | & _22 : Option'0.t_Option (borrowed int32) = any_l ()
    | & _23 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _24 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _25 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _27 : int32 = any_l ()
    | & x : borrowed int32 = any_l ()
    | & inserted_none : Option'0.t_Option int32 = any_l ()
    | & _33 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _34 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _35 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & inserted_some : Option'0.t_Option int32 = any_l ()
    | & _37 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _38 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _39 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & length2 : int = any_l ()
    | & _42 : FMap'0.t_FMap int32 int32 = any_l ()
    | & remove_none1 : Option'0.t_Option int32 = any_l ()
    | & _55 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _56 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _57 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _59 : int32 = any_l ()
    | & remove_some : Option'0.t_Option int32 = any_l ()
    | & _61 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _62 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _63 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _65 : int32 = any_l ()
    | & remove_none2 : Option'0.t_Option int32 = any_l ()
    | & _67 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _68 : borrowed (FMap'0.t_FMap int32 int32) = any_l ()
    | & _69 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _71 : int32 = any_l ()
    | & contains1 : bool = any_l ()
    | & _82 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _85 : int32 = any_l ()
    | & contains2 : bool = any_l ()
    | & _88 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _91 : int32 = any_l ()
    | & contains3 : bool = any_l ()
    | & _94 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _97 : int32 = any_l ()
    | & get1 : Option'0.t_Option int32 = any_l ()
    | & _106 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _109 : int32 = any_l ()
    | & get2 : Option'0.t_Option int32 = any_l ()
    | & _112 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _115 : int32 = any_l ()
    | & get3 : Option'0.t_Option int32 = any_l ()
    | & _118 : FMap'0.t_FMap int32 int32 = any_l ()
    | & _121 : int32 = any_l () ]
     [ return' (result:GhostBox'0.t_GhostBox ())-> return' {result} ] 
  
  function ext_eq'0 (self : FMap'0.t_FMap int32 int32) (other : FMap'0.t_FMap int32 int32) : bool =
    [%#span82] view'0 self = view'0 other
  
  axiom ext_eq'0_spec : forall self : FMap'0.t_FMap int32 int32, other : FMap'0.t_FMap int32 int32 . ([%#span81] (forall k : int32 . get'0 self k
  = get'0 other k)  -> ext_eq'0 self other)
  && ([%#span80] ext_eq'0 self other  -> self = other)
  
  use map.Const
  
  function empty'0 (_1 : ()) : FMap'0.t_FMap int32 int32
  
  axiom empty'0_spec : forall _1 : () . ([%#span84] view'0 (empty'0 _1) = Const.const (Option'0.C_None))
  && ([%#span83] len'0 (empty'0 _1) = 0)
  
  function is_empty'0 (self : FMap'0.t_FMap int32 int32) : bool =
    [%#span85] ext_eq'0 self (empty'0 ())
  
  let rec new'0 (_1:()) (return'  (ret:GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)))= any
    [ return' (result:GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))-> {[%#span86] is_empty'0 (inner_logic'0 result)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec ghost_map (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 = new'0 {[%#sghost_map0] ()}
          (fun (_ret':GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) ->  [ &map <- _ret' ] s1)
      | s1 = bb1 ]
      
    | bb1 = s0
      [ s0 = Borrow.borrow_mut <GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)> {map}
          (fun (_ret':borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32))) ->
             [ &_4 <- _ret' ] 
             [ &map <- _ret'.final ] 
            s1)
      | s1 =  [ &_3 <- Closure'0.M_ghost_map__ghost_map__qy123zclosureqy35z0qy125z _4 ] s2
      | s2 = closure0'0 {_3} (fun (_ret':GhostBox'0.t_GhostBox ()) ->  [ &_2 <- _ret' ] s3)
      | s3 = bb2 ]
      
    | bb2 = bb3
    | bb3 = bb4
    | bb4 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & map : GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32) = any_l ()
    | & _2 : GhostBox'0.t_GhostBox () = any_l ()
    | & _3 : Closure'0.m_ghost_map__ghost_map__qy123zclosureqy35z0qy125z = any_l ()
    | & _4 : borrowed (GhostBox'0.t_GhostBox (FMap'0.t_FMap int32 int32)) = any_l ()
    | & _5 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
