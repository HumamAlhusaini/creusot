module M_trigger2__resolve_seq [#"trigger2.rs" 6 0 6 43]
  let%span strigger20 = "trigger2.rs" 5 10 5 34
  let%span svec1 = "../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span strigger22 = "trigger2.rs" 8 8 9 32
  let%span suint_macros3 = "../../../../../../.rustup/toolchains/nightly-2025-01-31-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs" 49 8 49 27
  let%span svec4 = "../../../creusot-contracts/src/std/vec.rs" 49 20 49 83
  let%span sindex5 = "../../../creusot-contracts/src/logic/ops/index.rs" 27 8 27 31
  let%span sresolve6 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.UIntSize
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: usize }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  constant v_MAX'0 : usize = [%#suint_macros3] (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 (self : t_Vec'0) : Seq.seq (borrowed t_T'0)
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec1] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : borrowed t_T'0 =
    [%#sindex5] Seq.get (view'0 self) ix
  
  predicate resolve'3 (self : borrowed t_T'0) =
    [%#sresolve6] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed t_T'0) =
    resolve'3 _1
  
  predicate resolve'1 (self : t_Vec'0) =
    [%#svec4] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'2 (index_logic'0 self i)
  
  predicate resolve'0 (_1 : t_Vec'0) =
    resolve'1 _1
  
  constant seq  : t_Vec'0
  
  predicate resolve_seq'0 [#"trigger2.rs" 6 0 6 43] (seq : t_Vec'0)
  
  goal vc_resolve_seq'0 : [%#strigger20] resolve'0 seq
   -> ([%#strigger22] forall i : int [Seq.get (view'0 seq) i] . 0 <= i /\ i < Seq.length (view'0 seq)
   -> (Seq.get (view'0 seq) i).current = (Seq.get (view'0 seq) i).final)
end
module M_trigger2__resolve_seq2 [#"trigger2.rs" 16 0 16 48]
  let%span strigger20 = "trigger2.rs" 14 10 14 34
  let%span strigger21 = "trigger2.rs" 5 10 5 34
  let%span strigger22 = "trigger2.rs" 17 4 17 20
  let%span strigger23 = "trigger2.rs" 8 8 9 32
  let%span svec4 = "../../../creusot-contracts/src/std/vec.rs" 49 20 49 83
  let%span svec5 = "../../../creusot-contracts/src/std/vec.rs" 18 14 18 41
  let%span sindex6 = "../../../creusot-contracts/src/logic/ops/index.rs" 27 8 27 31
  let%span suint_macros7 = "../../../../../../.rustup/toolchains/nightly-2025-01-31-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs" 49 8 49 27
  let%span sresolve8 = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use prelude.prelude.Borrow
  
  use prelude.prelude.Opaque
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: opaque_ptr }
  
  type t_Unique'0  =
    { t_Unique__pointer'0: t_NonNull'0; t_Unique__qy95zmarker'0: () }
  
  use prelude.prelude.UIntSize
  
  type t_UsizeNoHighBit'0  =
    { t_UsizeNoHighBit__0'0: usize }
  
  type t_RawVecInner'0  =
    { t_RawVecInner__ptr'0: t_Unique'0; t_RawVecInner__cap'0: t_UsizeNoHighBit'0; t_RawVecInner__alloc'0: () }
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner'0; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: usize }
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  constant v_MAX'0 : usize = [%#suint_macros7] (18446744073709551615 : usize)
  
  use prelude.prelude.UIntSize
  
  type t_T'0
  
  use seq.Seq
  
  function view'0 (self : t_Vec'0) : Seq.seq (borrowed t_T'0)
  
  axiom view'0_spec : forall self : t_Vec'0 . [%#svec5] Seq.length (view'0 self) <= UIntSize.to_int (v_MAX'0 : usize)
  
  use seq.Seq
  
  function index_logic'0 [@inline:trivial] (self : t_Vec'0) (ix : int) : borrowed t_T'0 =
    [%#sindex6] Seq.get (view'0 self) ix
  
  predicate resolve'3 (self : borrowed t_T'0) =
    [%#sresolve8] self.final = self.current
  
  predicate resolve'2 (_1 : borrowed t_T'0) =
    resolve'3 _1
  
  predicate resolve'1 (self : t_Vec'0) =
    [%#svec4] forall i : int . 0 <= i /\ i < Seq.length (view'0 self)  -> resolve'2 (index_logic'0 self i)
  
  predicate resolve'0 (_1 : t_Vec'0) =
    resolve'1 _1
  
  predicate resolve_seq'0 [#"trigger2.rs" 6 0 6 43] (seq : t_Vec'0) =
    [%#strigger23] forall i : int [Seq.get (view'0 seq) i] . 0 <= i /\ i < Seq.length (view'0 seq)
     -> (Seq.get (view'0 seq) i).current = (Seq.get (view'0 seq) i).final
  
  axiom resolve_seq'0_spec : forall seq : t_Vec'0 . [%#strigger21] resolve'0 seq  -> resolve_seq'0 seq
  
  constant seq  : t_Vec'0
  
  predicate resolve_seq2'0 [#"trigger2.rs" 16 0 16 48] (seq : t_Vec'0)
  
  goal vc_resolve_seq2'0 : ([%#strigger21] resolve'0 seq  -> resolve_seq'0 seq)
   -> ([%#strigger20] resolve'0 seq  -> resolve_seq'0 seq)
end
